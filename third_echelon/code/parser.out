Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> start
Rule 1     start -> multiple_statements
Rule 2     multiple_statements -> multiple_statements statement
Rule 3     multiple_statements -> statement
Rule 4     statement -> open
Rule 5     statement -> closed
Rule 6     open -> IF condition statement
Rule 7     open -> IF condition closed ELSE open
Rule 8     open -> WHILE condition open
Rule 9     open -> for for_condition open
Rule 10    for -> FOR
Rule 11    closed -> simple
Rule 12    closed -> block
Rule 13    closed -> IF condition closed ELSE closed
Rule 14    closed -> WHILE condition closed
Rule 15    closed -> for for_condition closed
Rule 16    condition -> L_PAREN expr R_PAREN
Rule 17    for_condition -> L_PAREN simple simple expr R_PAREN
Rule 18    for_condition -> L_PAREN simple simple R_PAREN
Rule 19    multi_declaration -> multi_declaration ID COMMA
Rule 20    multi_declaration -> multi_declaration MULTIPLY ID COMMA
Rule 21    multi_declaration -> multi_declaration ID ASSIGN expr COMMA
Rule 22    multi_declaration -> multi_declaration MULTIPLY ID ASSIGN expr COMMA
Rule 23    multi_declaration -> ID COMMA
Rule 24    multi_declaration -> ID ASSIGN expr COMMA
Rule 25    multi_declaration -> MULTIPLY ID COMMA
Rule 26    multi_declaration -> MULTIPLY ID ASSIGN expr COMMA
Rule 27    stop -> ID SEMICOLON
Rule 28    stop -> MULTIPLY ID SEMICOLON
Rule 29    stop -> ID ASSIGN expr SEMICOLON
Rule 30    stop -> MULTIPLY ID ASSIGN expr SEMICOLON
Rule 31    arrayindex -> L_SQBRACE index R_SQBRACE
Rule 32    narrayindex -> narrayindex arrayindex
Rule 33    narrayindex -> arrayindex
Rule 34    declaration -> TYPE ID SEMICOLON
Rule 35    declaration -> TYPE MULTIPLY ID SEMICOLON
Rule 36    declaration -> TYPE ID ASSIGN expr SEMICOLON
Rule 37    declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON
Rule 38    declaration -> TYPE multi_declaration stop
Rule 39    declaration -> TYPE ID narrayindex SEMICOLON
Rule 40    declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON
Rule 41    init -> expr COMMA init
Rule 42    init -> expr
Rule 43    init_list -> L_FLOWBRACE init_list R_FLOWBRACE COMMA init_list
Rule 44    init_list -> L_FLOWBRACE init R_FLOWBRACE COMMA init_list
Rule 45    init_list -> L_FLOWBRACE init R_FLOWBRACE
Rule 46    init_list -> L_FLOWBRACE init_list R_FLOWBRACE
Rule 47    index -> expr
Rule 48    index -> empty
Rule 49    block -> left_flower multiple_statements right_flower
Rule 50    block -> left_flower right_flower
Rule 51    left_flower -> L_FLOWBRACE
Rule 52    right_flower -> R_FLOWBRACE
Rule 53    simple -> expr SEMICOLON
Rule 54    simple -> header
Rule 55    simple -> declaration
Rule 56    simple -> SEMICOLON
Rule 57    simple -> function
Rule 58    simple -> RETURN expr SEMICOLON
Rule 59    simple -> RETURN SEMICOLON
Rule 60    header -> HASH INCLUDE STRING
Rule 61    header -> HASH INCLUDE HEADER_FILE
Rule 62    empty -> <empty>
Rule 63    function_call -> ID L_PAREN call_params R_PAREN
Rule 64    call_params -> empty
Rule 65    call_params -> yes_call_params end_call_params
Rule 66    call_params -> end_call_params
Rule 67    yes_call_params -> yes_call_params expr COMMA
Rule 68    yes_call_params -> expr COMMA
Rule 69    end_call_params -> expr
Rule 70    yes_dec_params -> yes_dec_params TYPE expr COMMA
Rule 71    yes_dec_params -> yes_dec_params TYPE COMMA
Rule 72    yes_dec_params -> yes_dec_params TYPE MULTIPLY COMMA
Rule 73    yes_dec_params -> TYPE expr COMMA
Rule 74    yes_dec_params -> TYPE COMMA
Rule 75    yes_dec_params -> TYPE MULTIPLY COMMA
Rule 76    end_dec_params -> TYPE expr
Rule 77    end_dec_params -> TYPE
Rule 78    end_dec_params -> TYPE MULTIPLY
Rule 79    dec_params -> empty
Rule 80    dec_params -> yes_dec_params end_dec_params
Rule 81    dec_params -> end_dec_params
Rule 82    function -> TYPE ID L_PAREN dec_params R_PAREN function_2
Rule 83    function_2 -> SEMICOLON
Rule 84    function_2 -> block
Rule 85    expr -> expr assignment exprOR
Rule 86    expr -> exprOR
Rule 87    assignment -> ASSIGN
Rule 88    assignment -> PLUS_ASSIGN
Rule 89    assignment -> MINUS_ASSIGN
Rule 90    assignment -> MUL_ASSIGN
Rule 91    assignment -> DIV_ASSIGN
Rule 92    assignment -> AND_ASSIGN
Rule 93    assignment -> OR_ASSIGN
Rule 94    assignment -> XOR_ASSIGN
Rule 95    assignment -> MOD_ASSIGN
Rule 96    assignment -> L_SHIFT_ASSIGN
Rule 97    assignment -> R_SHIFT_ASSIGN
Rule 98    exprOR -> exprOR OR exprAND
Rule 99    exprOR -> exprAND
Rule 100   exprAND -> exprAND AND exprBITOR
Rule 101   exprAND -> exprBITOR
Rule 102   exprBITOR -> exprBITOR BIT_OR exprBITXOR
Rule 103   exprBITOR -> exprBITXOR
Rule 104   exprBITXOR -> exprBITXOR BIT_XOR exprBITAND
Rule 105   exprBITXOR -> exprBITAND
Rule 106   exprBITAND -> exprBITAND BIT_AND exprEQ
Rule 107   exprBITAND -> exprEQ
Rule 108   exprEQ -> exprEQ EQ exprRELOP
Rule 109   exprEQ -> exprEQ NE exprRELOP
Rule 110   exprEQ -> exprRELOP
Rule 111   exprRELOP -> exprRELOP relop exprSHIFT
Rule 112   exprRELOP -> exprSHIFT
Rule 113   relop -> LE
Rule 114   relop -> LT
Rule 115   relop -> GE
Rule 116   relop -> GT
Rule 117   exprSHIFT -> exprSHIFT L_SHIFT exprOP
Rule 118   exprSHIFT -> exprSHIFT R_SHIFT exprOP
Rule 119   exprSHIFT -> exprOP
Rule 120   exprOP -> exprOP PLUS term
Rule 121   exprOP -> exprOP MINUS term
Rule 122   exprOP -> term
Rule 123   term -> term MULTIPLY factor
Rule 124   term -> term DIVIDE factor
Rule 125   term -> term MOD factor
Rule 126   term -> factor
Rule 127   factor -> NOT factor
Rule 128   factor -> PLUS factor
Rule 129   factor -> MINUS factor
Rule 130   factor -> PLUS_PLUS factor
Rule 131   factor -> MINUS_MINUS factor
Rule 132   factor -> cast brace
Rule 133   factor -> brace
Rule 134   cast -> L_PAREN TYPE R_PAREN
Rule 135   cast -> L_PAREN TYPE MULTIPLY R_PAREN
Rule 136   brace -> L_PAREN expr R_PAREN
Rule 137   brace -> brace PLUS_PLUS
Rule 138   brace -> brace MINUS_MINUS
Rule 139   brace -> NUM
Rule 140   brace -> STRING
Rule 141   brace -> MULTIPLY ID
Rule 142   brace -> BIT_AND ID
Rule 143   brace -> ID
Rule 144   brace -> CHAR
Rule 145   brace -> function_call
Rule 146   brace -> ID narrayindex
Rule 147   NUM -> INT_NUM
Rule 148   NUM -> FLOAT_NUM

Terminals, with rules where they appear

AND                  : 100
AND_ASSIGN           : 92
ASSIGN               : 21 22 24 26 29 30 36 37 40 87
BIT_AND              : 106 142
BIT_OR               : 102
BIT_XOR              : 104
CHAR                 : 144
COMMA                : 19 20 21 22 23 24 25 26 41 43 44 67 68 70 71 72 73 74 75
DIVIDE               : 124
DIV_ASSIGN           : 91
ELSE                 : 7 13
EQ                   : 108
FLOAT_NUM            : 148
FOR                  : 10
GE                   : 115
GT                   : 116
HASH                 : 60 61
HEADER_FILE          : 61
ID                   : 19 20 21 22 23 24 25 26 27 28 29 30 34 35 36 37 39 40 63 82 141 142 143 146
IF                   : 6 7 13
INCLUDE              : 60 61
INT_NUM              : 147
LE                   : 113
LT                   : 114
L_FLOWBRACE          : 43 44 45 46 51
L_PAREN              : 16 17 18 63 82 134 135 136
L_SHIFT              : 117
L_SHIFT_ASSIGN       : 96
L_SQBRACE            : 31
MINUS                : 121 129
MINUS_ASSIGN         : 89
MINUS_MINUS          : 131 138
MOD                  : 125
MOD_ASSIGN           : 95
MULTIPLY             : 20 22 25 26 28 30 35 37 72 75 78 123 135 141
MUL_ASSIGN           : 90
NE                   : 109
NOT                  : 127
OR                   : 98
OR_ASSIGN            : 93
PLUS                 : 120 128
PLUS_ASSIGN          : 88
PLUS_PLUS            : 130 137
RETURN               : 58 59
R_FLOWBRACE          : 43 44 45 46 52
R_PAREN              : 16 17 18 63 82 134 135 136
R_SHIFT              : 118
R_SHIFT_ASSIGN       : 97
R_SQBRACE            : 31
SEMICOLON            : 27 28 29 30 34 35 36 37 39 40 53 56 58 59 83
STRING               : 60 140
TYPE                 : 34 35 36 37 38 39 40 70 71 72 73 74 75 76 77 78 82 134 135
WHILE                : 8 14
XOR_ASSIGN           : 94
error                : 

Nonterminals, with rules where they appear

NUM                  : 139
arrayindex           : 32 33
assignment           : 85
block                : 12 84
brace                : 132 133 137 138
call_params          : 63
cast                 : 132
closed               : 5 7 13 13 14 15
condition            : 6 7 8 13 14
dec_params           : 82
declaration          : 55
empty                : 48 64 79
end_call_params      : 65 66
end_dec_params       : 80 81
expr                 : 16 17 21 22 24 26 29 30 36 37 41 42 47 53 58 67 68 69 70 73 76 85 136
exprAND              : 98 99 100
exprBITAND           : 104 105 106
exprBITOR            : 100 101 102
exprBITXOR           : 102 103 104
exprEQ               : 106 107 108 109
exprOP               : 117 118 119 120 121
exprOR               : 85 86 98
exprRELOP            : 108 109 110 111
exprSHIFT            : 111 112 117 118
factor               : 123 124 125 126 127 128 129 130 131
for                  : 9 15
for_condition        : 9 15
function             : 57
function_2           : 82
function_call        : 145
header               : 54
index                : 31
init                 : 41 44 45
init_list            : 40 43 43 44 46
left_flower          : 49 50
multi_declaration    : 19 20 21 22 38
multiple_statements  : 1 2 49
narrayindex          : 32 39 40 146
open                 : 4 7 8 9
relop                : 111
right_flower         : 49 50
simple               : 11 17 17 18 18
start                : 0
statement            : 2 3 6
stop                 : 38
term                 : 120 121 122 123 124 125
yes_call_params      : 65 67
yes_dec_params       : 70 71 72 80

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . multiple_statements
    (2) multiple_statements -> . multiple_statements statement
    (3) multiple_statements -> . statement
    (4) statement -> . open
    (5) statement -> . closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) open -> . for for_condition open
    (11) closed -> . simple
    (12) closed -> . block
    (13) closed -> . IF condition closed ELSE closed
    (14) closed -> . WHILE condition closed
    (15) closed -> . for for_condition closed
    (10) for -> . FOR
    (53) simple -> . expr SEMICOLON
    (54) simple -> . header
    (55) simple -> . declaration
    (56) simple -> . SEMICOLON
    (57) simple -> . function
    (58) simple -> . RETURN expr SEMICOLON
    (59) simple -> . RETURN SEMICOLON
    (49) block -> . left_flower multiple_statements right_flower
    (50) block -> . left_flower right_flower
    (85) expr -> . expr assignment exprOR
    (86) expr -> . exprOR
    (60) header -> . HASH INCLUDE STRING
    (61) header -> . HASH INCLUDE HEADER_FILE
    (34) declaration -> . TYPE ID SEMICOLON
    (35) declaration -> . TYPE MULTIPLY ID SEMICOLON
    (36) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (37) declaration -> . TYPE MULTIPLY ID ASSIGN expr SEMICOLON
    (38) declaration -> . TYPE multi_declaration stop
    (39) declaration -> . TYPE ID narrayindex SEMICOLON
    (40) declaration -> . TYPE ID narrayindex ASSIGN init_list SEMICOLON
    (82) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (51) left_flower -> . L_FLOWBRACE
    (98) exprOR -> . exprOR OR exprAND
    (99) exprOR -> . exprAND
    (100) exprAND -> . exprAND AND exprBITOR
    (101) exprAND -> . exprBITOR
    (102) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (103) exprBITOR -> . exprBITXOR
    (104) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (105) exprBITXOR -> . exprBITAND
    (106) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (107) exprBITAND -> . exprEQ
    (108) exprEQ -> . exprEQ EQ exprRELOP
    (109) exprEQ -> . exprEQ NE exprRELOP
    (110) exprEQ -> . exprRELOP
    (111) exprRELOP -> . exprRELOP relop exprSHIFT
    (112) exprRELOP -> . exprSHIFT
    (117) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (118) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (119) exprSHIFT -> . exprOP
    (120) exprOP -> . exprOP PLUS term
    (121) exprOP -> . exprOP MINUS term
    (122) exprOP -> . term
    (123) term -> . term MULTIPLY factor
    (124) term -> . term DIVIDE factor
    (125) term -> . term MOD factor
    (126) term -> . factor
    (127) factor -> . NOT factor
    (128) factor -> . PLUS factor
    (129) factor -> . MINUS factor
    (130) factor -> . PLUS_PLUS factor
    (131) factor -> . MINUS_MINUS factor
    (132) factor -> . cast brace
    (133) factor -> . brace
    (134) cast -> . L_PAREN TYPE R_PAREN
    (135) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (136) brace -> . L_PAREN expr R_PAREN
    (137) brace -> . brace PLUS_PLUS
    (138) brace -> . brace MINUS_MINUS
    (139) brace -> . NUM
    (140) brace -> . STRING
    (141) brace -> . MULTIPLY ID
    (142) brace -> . BIT_AND ID
    (143) brace -> . ID
    (144) brace -> . CHAR
    (145) brace -> . function_call
    (146) brace -> . ID narrayindex
    (147) NUM -> . INT_NUM
    (148) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    IF              shift and go to state 6
    WHILE           shift and go to state 7
    FOR             shift and go to state 11
    SEMICOLON       shift and go to state 13
    RETURN          shift and go to state 17
    HASH            shift and go to state 20
    TYPE            shift and go to state 22
    L_FLOWBRACE     shift and go to state 26
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    start                          shift and go to state 1
    multiple_statements            shift and go to state 2
    statement                      shift and go to state 3
    open                           shift and go to state 4
    closed                         shift and go to state 5
    for                            shift and go to state 8
    simple                         shift and go to state 9
    block                          shift and go to state 10
    expr                           shift and go to state 12
    header                         shift and go to state 14
    declaration                    shift and go to state 15
    function                       shift and go to state 16
    left_flower                    shift and go to state 18
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 1

    (0) S' -> start .



state 2

    (1) start -> multiple_statements .
    (2) multiple_statements -> multiple_statements . statement
    (4) statement -> . open
    (5) statement -> . closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) open -> . for for_condition open
    (11) closed -> . simple
    (12) closed -> . block
    (13) closed -> . IF condition closed ELSE closed
    (14) closed -> . WHILE condition closed
    (15) closed -> . for for_condition closed
    (10) for -> . FOR
    (53) simple -> . expr SEMICOLON
    (54) simple -> . header
    (55) simple -> . declaration
    (56) simple -> . SEMICOLON
    (57) simple -> . function
    (58) simple -> . RETURN expr SEMICOLON
    (59) simple -> . RETURN SEMICOLON
    (49) block -> . left_flower multiple_statements right_flower
    (50) block -> . left_flower right_flower
    (85) expr -> . expr assignment exprOR
    (86) expr -> . exprOR
    (60) header -> . HASH INCLUDE STRING
    (61) header -> . HASH INCLUDE HEADER_FILE
    (34) declaration -> . TYPE ID SEMICOLON
    (35) declaration -> . TYPE MULTIPLY ID SEMICOLON
    (36) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (37) declaration -> . TYPE MULTIPLY ID ASSIGN expr SEMICOLON
    (38) declaration -> . TYPE multi_declaration stop
    (39) declaration -> . TYPE ID narrayindex SEMICOLON
    (40) declaration -> . TYPE ID narrayindex ASSIGN init_list SEMICOLON
    (82) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (51) left_flower -> . L_FLOWBRACE
    (98) exprOR -> . exprOR OR exprAND
    (99) exprOR -> . exprAND
    (100) exprAND -> . exprAND AND exprBITOR
    (101) exprAND -> . exprBITOR
    (102) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (103) exprBITOR -> . exprBITXOR
    (104) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (105) exprBITXOR -> . exprBITAND
    (106) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (107) exprBITAND -> . exprEQ
    (108) exprEQ -> . exprEQ EQ exprRELOP
    (109) exprEQ -> . exprEQ NE exprRELOP
    (110) exprEQ -> . exprRELOP
    (111) exprRELOP -> . exprRELOP relop exprSHIFT
    (112) exprRELOP -> . exprSHIFT
    (117) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (118) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (119) exprSHIFT -> . exprOP
    (120) exprOP -> . exprOP PLUS term
    (121) exprOP -> . exprOP MINUS term
    (122) exprOP -> . term
    (123) term -> . term MULTIPLY factor
    (124) term -> . term DIVIDE factor
    (125) term -> . term MOD factor
    (126) term -> . factor
    (127) factor -> . NOT factor
    (128) factor -> . PLUS factor
    (129) factor -> . MINUS factor
    (130) factor -> . PLUS_PLUS factor
    (131) factor -> . MINUS_MINUS factor
    (132) factor -> . cast brace
    (133) factor -> . brace
    (134) cast -> . L_PAREN TYPE R_PAREN
    (135) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (136) brace -> . L_PAREN expr R_PAREN
    (137) brace -> . brace PLUS_PLUS
    (138) brace -> . brace MINUS_MINUS
    (139) brace -> . NUM
    (140) brace -> . STRING
    (141) brace -> . MULTIPLY ID
    (142) brace -> . BIT_AND ID
    (143) brace -> . ID
    (144) brace -> . CHAR
    (145) brace -> . function_call
    (146) brace -> . ID narrayindex
    (147) NUM -> . INT_NUM
    (148) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    $end            reduce using rule 1 (start -> multiple_statements .)
    IF              shift and go to state 6
    WHILE           shift and go to state 7
    FOR             shift and go to state 11
    SEMICOLON       shift and go to state 13
    RETURN          shift and go to state 17
    HASH            shift and go to state 20
    TYPE            shift and go to state 22
    L_FLOWBRACE     shift and go to state 26
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    statement                      shift and go to state 50
    open                           shift and go to state 4
    closed                         shift and go to state 5
    for                            shift and go to state 8
    simple                         shift and go to state 9
    block                          shift and go to state 10
    expr                           shift and go to state 12
    header                         shift and go to state 14
    declaration                    shift and go to state 15
    function                       shift and go to state 16
    left_flower                    shift and go to state 18
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 3

    (3) multiple_statements -> statement .

    IF              reduce using rule 3 (multiple_statements -> statement .)
    WHILE           reduce using rule 3 (multiple_statements -> statement .)
    FOR             reduce using rule 3 (multiple_statements -> statement .)
    SEMICOLON       reduce using rule 3 (multiple_statements -> statement .)
    RETURN          reduce using rule 3 (multiple_statements -> statement .)
    HASH            reduce using rule 3 (multiple_statements -> statement .)
    TYPE            reduce using rule 3 (multiple_statements -> statement .)
    L_FLOWBRACE     reduce using rule 3 (multiple_statements -> statement .)
    NOT             reduce using rule 3 (multiple_statements -> statement .)
    PLUS            reduce using rule 3 (multiple_statements -> statement .)
    MINUS           reduce using rule 3 (multiple_statements -> statement .)
    PLUS_PLUS       reduce using rule 3 (multiple_statements -> statement .)
    MINUS_MINUS     reduce using rule 3 (multiple_statements -> statement .)
    L_PAREN         reduce using rule 3 (multiple_statements -> statement .)
    STRING          reduce using rule 3 (multiple_statements -> statement .)
    MULTIPLY        reduce using rule 3 (multiple_statements -> statement .)
    BIT_AND         reduce using rule 3 (multiple_statements -> statement .)
    ID              reduce using rule 3 (multiple_statements -> statement .)
    CHAR            reduce using rule 3 (multiple_statements -> statement .)
    INT_NUM         reduce using rule 3 (multiple_statements -> statement .)
    FLOAT_NUM       reduce using rule 3 (multiple_statements -> statement .)
    $end            reduce using rule 3 (multiple_statements -> statement .)
    R_FLOWBRACE     reduce using rule 3 (multiple_statements -> statement .)


state 4

    (4) statement -> open .

    IF              reduce using rule 4 (statement -> open .)
    WHILE           reduce using rule 4 (statement -> open .)
    FOR             reduce using rule 4 (statement -> open .)
    SEMICOLON       reduce using rule 4 (statement -> open .)
    RETURN          reduce using rule 4 (statement -> open .)
    HASH            reduce using rule 4 (statement -> open .)
    TYPE            reduce using rule 4 (statement -> open .)
    L_FLOWBRACE     reduce using rule 4 (statement -> open .)
    NOT             reduce using rule 4 (statement -> open .)
    PLUS            reduce using rule 4 (statement -> open .)
    MINUS           reduce using rule 4 (statement -> open .)
    PLUS_PLUS       reduce using rule 4 (statement -> open .)
    MINUS_MINUS     reduce using rule 4 (statement -> open .)
    L_PAREN         reduce using rule 4 (statement -> open .)
    STRING          reduce using rule 4 (statement -> open .)
    MULTIPLY        reduce using rule 4 (statement -> open .)
    BIT_AND         reduce using rule 4 (statement -> open .)
    ID              reduce using rule 4 (statement -> open .)
    CHAR            reduce using rule 4 (statement -> open .)
    INT_NUM         reduce using rule 4 (statement -> open .)
    FLOAT_NUM       reduce using rule 4 (statement -> open .)
    $end            reduce using rule 4 (statement -> open .)
    R_FLOWBRACE     reduce using rule 4 (statement -> open .)


state 5

    (5) statement -> closed .

    IF              reduce using rule 5 (statement -> closed .)
    WHILE           reduce using rule 5 (statement -> closed .)
    FOR             reduce using rule 5 (statement -> closed .)
    SEMICOLON       reduce using rule 5 (statement -> closed .)
    RETURN          reduce using rule 5 (statement -> closed .)
    HASH            reduce using rule 5 (statement -> closed .)
    TYPE            reduce using rule 5 (statement -> closed .)
    L_FLOWBRACE     reduce using rule 5 (statement -> closed .)
    NOT             reduce using rule 5 (statement -> closed .)
    PLUS            reduce using rule 5 (statement -> closed .)
    MINUS           reduce using rule 5 (statement -> closed .)
    PLUS_PLUS       reduce using rule 5 (statement -> closed .)
    MINUS_MINUS     reduce using rule 5 (statement -> closed .)
    L_PAREN         reduce using rule 5 (statement -> closed .)
    STRING          reduce using rule 5 (statement -> closed .)
    MULTIPLY        reduce using rule 5 (statement -> closed .)
    BIT_AND         reduce using rule 5 (statement -> closed .)
    ID              reduce using rule 5 (statement -> closed .)
    CHAR            reduce using rule 5 (statement -> closed .)
    INT_NUM         reduce using rule 5 (statement -> closed .)
    FLOAT_NUM       reduce using rule 5 (statement -> closed .)
    $end            reduce using rule 5 (statement -> closed .)
    R_FLOWBRACE     reduce using rule 5 (statement -> closed .)


state 6

    (6) open -> IF . condition statement
    (7) open -> IF . condition closed ELSE open
    (13) closed -> IF . condition closed ELSE closed
    (16) condition -> . L_PAREN expr R_PAREN

    L_PAREN         shift and go to state 52

    condition                      shift and go to state 51

state 7

    (8) open -> WHILE . condition open
    (14) closed -> WHILE . condition closed
    (16) condition -> . L_PAREN expr R_PAREN

    L_PAREN         shift and go to state 52

    condition                      shift and go to state 53

state 8

    (9) open -> for . for_condition open
    (15) closed -> for . for_condition closed
    (17) for_condition -> . L_PAREN simple simple expr R_PAREN
    (18) for_condition -> . L_PAREN simple simple R_PAREN

    L_PAREN         shift and go to state 55

    for_condition                  shift and go to state 54

state 9

    (11) closed -> simple .

    IF              reduce using rule 11 (closed -> simple .)
    WHILE           reduce using rule 11 (closed -> simple .)
    FOR             reduce using rule 11 (closed -> simple .)
    SEMICOLON       reduce using rule 11 (closed -> simple .)
    RETURN          reduce using rule 11 (closed -> simple .)
    HASH            reduce using rule 11 (closed -> simple .)
    TYPE            reduce using rule 11 (closed -> simple .)
    L_FLOWBRACE     reduce using rule 11 (closed -> simple .)
    NOT             reduce using rule 11 (closed -> simple .)
    PLUS            reduce using rule 11 (closed -> simple .)
    MINUS           reduce using rule 11 (closed -> simple .)
    PLUS_PLUS       reduce using rule 11 (closed -> simple .)
    MINUS_MINUS     reduce using rule 11 (closed -> simple .)
    L_PAREN         reduce using rule 11 (closed -> simple .)
    STRING          reduce using rule 11 (closed -> simple .)
    MULTIPLY        reduce using rule 11 (closed -> simple .)
    BIT_AND         reduce using rule 11 (closed -> simple .)
    ID              reduce using rule 11 (closed -> simple .)
    CHAR            reduce using rule 11 (closed -> simple .)
    INT_NUM         reduce using rule 11 (closed -> simple .)
    FLOAT_NUM       reduce using rule 11 (closed -> simple .)
    $end            reduce using rule 11 (closed -> simple .)
    R_FLOWBRACE     reduce using rule 11 (closed -> simple .)
    ELSE            reduce using rule 11 (closed -> simple .)


state 10

    (12) closed -> block .

    IF              reduce using rule 12 (closed -> block .)
    WHILE           reduce using rule 12 (closed -> block .)
    FOR             reduce using rule 12 (closed -> block .)
    SEMICOLON       reduce using rule 12 (closed -> block .)
    RETURN          reduce using rule 12 (closed -> block .)
    HASH            reduce using rule 12 (closed -> block .)
    TYPE            reduce using rule 12 (closed -> block .)
    L_FLOWBRACE     reduce using rule 12 (closed -> block .)
    NOT             reduce using rule 12 (closed -> block .)
    PLUS            reduce using rule 12 (closed -> block .)
    MINUS           reduce using rule 12 (closed -> block .)
    PLUS_PLUS       reduce using rule 12 (closed -> block .)
    MINUS_MINUS     reduce using rule 12 (closed -> block .)
    L_PAREN         reduce using rule 12 (closed -> block .)
    STRING          reduce using rule 12 (closed -> block .)
    MULTIPLY        reduce using rule 12 (closed -> block .)
    BIT_AND         reduce using rule 12 (closed -> block .)
    ID              reduce using rule 12 (closed -> block .)
    CHAR            reduce using rule 12 (closed -> block .)
    INT_NUM         reduce using rule 12 (closed -> block .)
    FLOAT_NUM       reduce using rule 12 (closed -> block .)
    $end            reduce using rule 12 (closed -> block .)
    R_FLOWBRACE     reduce using rule 12 (closed -> block .)
    ELSE            reduce using rule 12 (closed -> block .)


state 11

    (10) for -> FOR .

    L_PAREN         reduce using rule 10 (for -> FOR .)


state 12

    (53) simple -> expr . SEMICOLON
    (85) expr -> expr . assignment exprOR
    (87) assignment -> . ASSIGN
    (88) assignment -> . PLUS_ASSIGN
    (89) assignment -> . MINUS_ASSIGN
    (90) assignment -> . MUL_ASSIGN
    (91) assignment -> . DIV_ASSIGN
    (92) assignment -> . AND_ASSIGN
    (93) assignment -> . OR_ASSIGN
    (94) assignment -> . XOR_ASSIGN
    (95) assignment -> . MOD_ASSIGN
    (96) assignment -> . L_SHIFT_ASSIGN
    (97) assignment -> . R_SHIFT_ASSIGN

    SEMICOLON       shift and go to state 56
    ASSIGN          shift and go to state 58
    PLUS_ASSIGN     shift and go to state 59
    MINUS_ASSIGN    shift and go to state 60
    MUL_ASSIGN      shift and go to state 61
    DIV_ASSIGN      shift and go to state 62
    AND_ASSIGN      shift and go to state 63
    OR_ASSIGN       shift and go to state 64
    XOR_ASSIGN      shift and go to state 65
    MOD_ASSIGN      shift and go to state 66
    L_SHIFT_ASSIGN  shift and go to state 67
    R_SHIFT_ASSIGN  shift and go to state 68

    assignment                     shift and go to state 57

state 13

    (56) simple -> SEMICOLON .

    IF              reduce using rule 56 (simple -> SEMICOLON .)
    WHILE           reduce using rule 56 (simple -> SEMICOLON .)
    FOR             reduce using rule 56 (simple -> SEMICOLON .)
    SEMICOLON       reduce using rule 56 (simple -> SEMICOLON .)
    RETURN          reduce using rule 56 (simple -> SEMICOLON .)
    HASH            reduce using rule 56 (simple -> SEMICOLON .)
    TYPE            reduce using rule 56 (simple -> SEMICOLON .)
    L_FLOWBRACE     reduce using rule 56 (simple -> SEMICOLON .)
    NOT             reduce using rule 56 (simple -> SEMICOLON .)
    PLUS            reduce using rule 56 (simple -> SEMICOLON .)
    MINUS           reduce using rule 56 (simple -> SEMICOLON .)
    PLUS_PLUS       reduce using rule 56 (simple -> SEMICOLON .)
    MINUS_MINUS     reduce using rule 56 (simple -> SEMICOLON .)
    L_PAREN         reduce using rule 56 (simple -> SEMICOLON .)
    STRING          reduce using rule 56 (simple -> SEMICOLON .)
    MULTIPLY        reduce using rule 56 (simple -> SEMICOLON .)
    BIT_AND         reduce using rule 56 (simple -> SEMICOLON .)
    ID              reduce using rule 56 (simple -> SEMICOLON .)
    CHAR            reduce using rule 56 (simple -> SEMICOLON .)
    INT_NUM         reduce using rule 56 (simple -> SEMICOLON .)
    FLOAT_NUM       reduce using rule 56 (simple -> SEMICOLON .)
    $end            reduce using rule 56 (simple -> SEMICOLON .)
    R_FLOWBRACE     reduce using rule 56 (simple -> SEMICOLON .)
    ELSE            reduce using rule 56 (simple -> SEMICOLON .)
    R_PAREN         reduce using rule 56 (simple -> SEMICOLON .)


state 14

    (54) simple -> header .

    IF              reduce using rule 54 (simple -> header .)
    WHILE           reduce using rule 54 (simple -> header .)
    FOR             reduce using rule 54 (simple -> header .)
    SEMICOLON       reduce using rule 54 (simple -> header .)
    RETURN          reduce using rule 54 (simple -> header .)
    HASH            reduce using rule 54 (simple -> header .)
    TYPE            reduce using rule 54 (simple -> header .)
    L_FLOWBRACE     reduce using rule 54 (simple -> header .)
    NOT             reduce using rule 54 (simple -> header .)
    PLUS            reduce using rule 54 (simple -> header .)
    MINUS           reduce using rule 54 (simple -> header .)
    PLUS_PLUS       reduce using rule 54 (simple -> header .)
    MINUS_MINUS     reduce using rule 54 (simple -> header .)
    L_PAREN         reduce using rule 54 (simple -> header .)
    STRING          reduce using rule 54 (simple -> header .)
    MULTIPLY        reduce using rule 54 (simple -> header .)
    BIT_AND         reduce using rule 54 (simple -> header .)
    ID              reduce using rule 54 (simple -> header .)
    CHAR            reduce using rule 54 (simple -> header .)
    INT_NUM         reduce using rule 54 (simple -> header .)
    FLOAT_NUM       reduce using rule 54 (simple -> header .)
    $end            reduce using rule 54 (simple -> header .)
    R_FLOWBRACE     reduce using rule 54 (simple -> header .)
    ELSE            reduce using rule 54 (simple -> header .)
    R_PAREN         reduce using rule 54 (simple -> header .)


state 15

    (55) simple -> declaration .

    IF              reduce using rule 55 (simple -> declaration .)
    WHILE           reduce using rule 55 (simple -> declaration .)
    FOR             reduce using rule 55 (simple -> declaration .)
    SEMICOLON       reduce using rule 55 (simple -> declaration .)
    RETURN          reduce using rule 55 (simple -> declaration .)
    HASH            reduce using rule 55 (simple -> declaration .)
    TYPE            reduce using rule 55 (simple -> declaration .)
    L_FLOWBRACE     reduce using rule 55 (simple -> declaration .)
    NOT             reduce using rule 55 (simple -> declaration .)
    PLUS            reduce using rule 55 (simple -> declaration .)
    MINUS           reduce using rule 55 (simple -> declaration .)
    PLUS_PLUS       reduce using rule 55 (simple -> declaration .)
    MINUS_MINUS     reduce using rule 55 (simple -> declaration .)
    L_PAREN         reduce using rule 55 (simple -> declaration .)
    STRING          reduce using rule 55 (simple -> declaration .)
    MULTIPLY        reduce using rule 55 (simple -> declaration .)
    BIT_AND         reduce using rule 55 (simple -> declaration .)
    ID              reduce using rule 55 (simple -> declaration .)
    CHAR            reduce using rule 55 (simple -> declaration .)
    INT_NUM         reduce using rule 55 (simple -> declaration .)
    FLOAT_NUM       reduce using rule 55 (simple -> declaration .)
    $end            reduce using rule 55 (simple -> declaration .)
    R_FLOWBRACE     reduce using rule 55 (simple -> declaration .)
    ELSE            reduce using rule 55 (simple -> declaration .)
    R_PAREN         reduce using rule 55 (simple -> declaration .)


state 16

    (57) simple -> function .

    IF              reduce using rule 57 (simple -> function .)
    WHILE           reduce using rule 57 (simple -> function .)
    FOR             reduce using rule 57 (simple -> function .)
    SEMICOLON       reduce using rule 57 (simple -> function .)
    RETURN          reduce using rule 57 (simple -> function .)
    HASH            reduce using rule 57 (simple -> function .)
    TYPE            reduce using rule 57 (simple -> function .)
    L_FLOWBRACE     reduce using rule 57 (simple -> function .)
    NOT             reduce using rule 57 (simple -> function .)
    PLUS            reduce using rule 57 (simple -> function .)
    MINUS           reduce using rule 57 (simple -> function .)
    PLUS_PLUS       reduce using rule 57 (simple -> function .)
    MINUS_MINUS     reduce using rule 57 (simple -> function .)
    L_PAREN         reduce using rule 57 (simple -> function .)
    STRING          reduce using rule 57 (simple -> function .)
    MULTIPLY        reduce using rule 57 (simple -> function .)
    BIT_AND         reduce using rule 57 (simple -> function .)
    ID              reduce using rule 57 (simple -> function .)
    CHAR            reduce using rule 57 (simple -> function .)
    INT_NUM         reduce using rule 57 (simple -> function .)
    FLOAT_NUM       reduce using rule 57 (simple -> function .)
    $end            reduce using rule 57 (simple -> function .)
    R_FLOWBRACE     reduce using rule 57 (simple -> function .)
    ELSE            reduce using rule 57 (simple -> function .)
    R_PAREN         reduce using rule 57 (simple -> function .)


state 17

    (58) simple -> RETURN . expr SEMICOLON
    (59) simple -> RETURN . SEMICOLON
    (85) expr -> . expr assignment exprOR
    (86) expr -> . exprOR
    (98) exprOR -> . exprOR OR exprAND
    (99) exprOR -> . exprAND
    (100) exprAND -> . exprAND AND exprBITOR
    (101) exprAND -> . exprBITOR
    (102) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (103) exprBITOR -> . exprBITXOR
    (104) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (105) exprBITXOR -> . exprBITAND
    (106) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (107) exprBITAND -> . exprEQ
    (108) exprEQ -> . exprEQ EQ exprRELOP
    (109) exprEQ -> . exprEQ NE exprRELOP
    (110) exprEQ -> . exprRELOP
    (111) exprRELOP -> . exprRELOP relop exprSHIFT
    (112) exprRELOP -> . exprSHIFT
    (117) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (118) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (119) exprSHIFT -> . exprOP
    (120) exprOP -> . exprOP PLUS term
    (121) exprOP -> . exprOP MINUS term
    (122) exprOP -> . term
    (123) term -> . term MULTIPLY factor
    (124) term -> . term DIVIDE factor
    (125) term -> . term MOD factor
    (126) term -> . factor
    (127) factor -> . NOT factor
    (128) factor -> . PLUS factor
    (129) factor -> . MINUS factor
    (130) factor -> . PLUS_PLUS factor
    (131) factor -> . MINUS_MINUS factor
    (132) factor -> . cast brace
    (133) factor -> . brace
    (134) cast -> . L_PAREN TYPE R_PAREN
    (135) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (136) brace -> . L_PAREN expr R_PAREN
    (137) brace -> . brace PLUS_PLUS
    (138) brace -> . brace MINUS_MINUS
    (139) brace -> . NUM
    (140) brace -> . STRING
    (141) brace -> . MULTIPLY ID
    (142) brace -> . BIT_AND ID
    (143) brace -> . ID
    (144) brace -> . CHAR
    (145) brace -> . function_call
    (146) brace -> . ID narrayindex
    (147) NUM -> . INT_NUM
    (148) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    SEMICOLON       shift and go to state 70
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    expr                           shift and go to state 69
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 18

    (49) block -> left_flower . multiple_statements right_flower
    (50) block -> left_flower . right_flower
    (2) multiple_statements -> . multiple_statements statement
    (3) multiple_statements -> . statement
    (52) right_flower -> . R_FLOWBRACE
    (4) statement -> . open
    (5) statement -> . closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) open -> . for for_condition open
    (11) closed -> . simple
    (12) closed -> . block
    (13) closed -> . IF condition closed ELSE closed
    (14) closed -> . WHILE condition closed
    (15) closed -> . for for_condition closed
    (10) for -> . FOR
    (53) simple -> . expr SEMICOLON
    (54) simple -> . header
    (55) simple -> . declaration
    (56) simple -> . SEMICOLON
    (57) simple -> . function
    (58) simple -> . RETURN expr SEMICOLON
    (59) simple -> . RETURN SEMICOLON
    (49) block -> . left_flower multiple_statements right_flower
    (50) block -> . left_flower right_flower
    (85) expr -> . expr assignment exprOR
    (86) expr -> . exprOR
    (60) header -> . HASH INCLUDE STRING
    (61) header -> . HASH INCLUDE HEADER_FILE
    (34) declaration -> . TYPE ID SEMICOLON
    (35) declaration -> . TYPE MULTIPLY ID SEMICOLON
    (36) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (37) declaration -> . TYPE MULTIPLY ID ASSIGN expr SEMICOLON
    (38) declaration -> . TYPE multi_declaration stop
    (39) declaration -> . TYPE ID narrayindex SEMICOLON
    (40) declaration -> . TYPE ID narrayindex ASSIGN init_list SEMICOLON
    (82) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (51) left_flower -> . L_FLOWBRACE
    (98) exprOR -> . exprOR OR exprAND
    (99) exprOR -> . exprAND
    (100) exprAND -> . exprAND AND exprBITOR
    (101) exprAND -> . exprBITOR
    (102) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (103) exprBITOR -> . exprBITXOR
    (104) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (105) exprBITXOR -> . exprBITAND
    (106) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (107) exprBITAND -> . exprEQ
    (108) exprEQ -> . exprEQ EQ exprRELOP
    (109) exprEQ -> . exprEQ NE exprRELOP
    (110) exprEQ -> . exprRELOP
    (111) exprRELOP -> . exprRELOP relop exprSHIFT
    (112) exprRELOP -> . exprSHIFT
    (117) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (118) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (119) exprSHIFT -> . exprOP
    (120) exprOP -> . exprOP PLUS term
    (121) exprOP -> . exprOP MINUS term
    (122) exprOP -> . term
    (123) term -> . term MULTIPLY factor
    (124) term -> . term DIVIDE factor
    (125) term -> . term MOD factor
    (126) term -> . factor
    (127) factor -> . NOT factor
    (128) factor -> . PLUS factor
    (129) factor -> . MINUS factor
    (130) factor -> . PLUS_PLUS factor
    (131) factor -> . MINUS_MINUS factor
    (132) factor -> . cast brace
    (133) factor -> . brace
    (134) cast -> . L_PAREN TYPE R_PAREN
    (135) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (136) brace -> . L_PAREN expr R_PAREN
    (137) brace -> . brace PLUS_PLUS
    (138) brace -> . brace MINUS_MINUS
    (139) brace -> . NUM
    (140) brace -> . STRING
    (141) brace -> . MULTIPLY ID
    (142) brace -> . BIT_AND ID
    (143) brace -> . ID
    (144) brace -> . CHAR
    (145) brace -> . function_call
    (146) brace -> . ID narrayindex
    (147) NUM -> . INT_NUM
    (148) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    R_FLOWBRACE     shift and go to state 73
    IF              shift and go to state 6
    WHILE           shift and go to state 7
    FOR             shift and go to state 11
    SEMICOLON       shift and go to state 13
    RETURN          shift and go to state 17
    HASH            shift and go to state 20
    TYPE            shift and go to state 22
    L_FLOWBRACE     shift and go to state 26
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    left_flower                    shift and go to state 18
    multiple_statements            shift and go to state 71
    right_flower                   shift and go to state 72
    statement                      shift and go to state 3
    open                           shift and go to state 4
    closed                         shift and go to state 5
    for                            shift and go to state 8
    simple                         shift and go to state 9
    block                          shift and go to state 10
    expr                           shift and go to state 12
    header                         shift and go to state 14
    declaration                    shift and go to state 15
    function                       shift and go to state 16
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 19

    (86) expr -> exprOR .
    (98) exprOR -> exprOR . OR exprAND

    SEMICOLON       reduce using rule 86 (expr -> exprOR .)
    ASSIGN          reduce using rule 86 (expr -> exprOR .)
    PLUS_ASSIGN     reduce using rule 86 (expr -> exprOR .)
    MINUS_ASSIGN    reduce using rule 86 (expr -> exprOR .)
    MUL_ASSIGN      reduce using rule 86 (expr -> exprOR .)
    DIV_ASSIGN      reduce using rule 86 (expr -> exprOR .)
    AND_ASSIGN      reduce using rule 86 (expr -> exprOR .)
    OR_ASSIGN       reduce using rule 86 (expr -> exprOR .)
    XOR_ASSIGN      reduce using rule 86 (expr -> exprOR .)
    MOD_ASSIGN      reduce using rule 86 (expr -> exprOR .)
    L_SHIFT_ASSIGN  reduce using rule 86 (expr -> exprOR .)
    R_SHIFT_ASSIGN  reduce using rule 86 (expr -> exprOR .)
    R_PAREN         reduce using rule 86 (expr -> exprOR .)
    COMMA           reduce using rule 86 (expr -> exprOR .)
    R_SQBRACE       reduce using rule 86 (expr -> exprOR .)
    R_FLOWBRACE     reduce using rule 86 (expr -> exprOR .)
    OR              shift and go to state 74


state 20

    (60) header -> HASH . INCLUDE STRING
    (61) header -> HASH . INCLUDE HEADER_FILE

    INCLUDE         shift and go to state 75


state 21

    (140) brace -> STRING .

    PLUS_PLUS       reduce using rule 140 (brace -> STRING .)
    MINUS_MINUS     reduce using rule 140 (brace -> STRING .)
    MULTIPLY        reduce using rule 140 (brace -> STRING .)
    DIVIDE          reduce using rule 140 (brace -> STRING .)
    MOD             reduce using rule 140 (brace -> STRING .)
    PLUS            reduce using rule 140 (brace -> STRING .)
    MINUS           reduce using rule 140 (brace -> STRING .)
    L_SHIFT         reduce using rule 140 (brace -> STRING .)
    R_SHIFT         reduce using rule 140 (brace -> STRING .)
    LE              reduce using rule 140 (brace -> STRING .)
    LT              reduce using rule 140 (brace -> STRING .)
    GE              reduce using rule 140 (brace -> STRING .)
    GT              reduce using rule 140 (brace -> STRING .)
    EQ              reduce using rule 140 (brace -> STRING .)
    NE              reduce using rule 140 (brace -> STRING .)
    BIT_AND         reduce using rule 140 (brace -> STRING .)
    BIT_XOR         reduce using rule 140 (brace -> STRING .)
    BIT_OR          reduce using rule 140 (brace -> STRING .)
    AND             reduce using rule 140 (brace -> STRING .)
    OR              reduce using rule 140 (brace -> STRING .)
    SEMICOLON       reduce using rule 140 (brace -> STRING .)
    ASSIGN          reduce using rule 140 (brace -> STRING .)
    PLUS_ASSIGN     reduce using rule 140 (brace -> STRING .)
    MINUS_ASSIGN    reduce using rule 140 (brace -> STRING .)
    MUL_ASSIGN      reduce using rule 140 (brace -> STRING .)
    DIV_ASSIGN      reduce using rule 140 (brace -> STRING .)
    AND_ASSIGN      reduce using rule 140 (brace -> STRING .)
    OR_ASSIGN       reduce using rule 140 (brace -> STRING .)
    XOR_ASSIGN      reduce using rule 140 (brace -> STRING .)
    MOD_ASSIGN      reduce using rule 140 (brace -> STRING .)
    L_SHIFT_ASSIGN  reduce using rule 140 (brace -> STRING .)
    R_SHIFT_ASSIGN  reduce using rule 140 (brace -> STRING .)
    R_PAREN         reduce using rule 140 (brace -> STRING .)
    COMMA           reduce using rule 140 (brace -> STRING .)
    R_SQBRACE       reduce using rule 140 (brace -> STRING .)
    R_FLOWBRACE     reduce using rule 140 (brace -> STRING .)


state 22

    (34) declaration -> TYPE . ID SEMICOLON
    (35) declaration -> TYPE . MULTIPLY ID SEMICOLON
    (36) declaration -> TYPE . ID ASSIGN expr SEMICOLON
    (37) declaration -> TYPE . MULTIPLY ID ASSIGN expr SEMICOLON
    (38) declaration -> TYPE . multi_declaration stop
    (39) declaration -> TYPE . ID narrayindex SEMICOLON
    (40) declaration -> TYPE . ID narrayindex ASSIGN init_list SEMICOLON
    (82) function -> TYPE . ID L_PAREN dec_params R_PAREN function_2
    (19) multi_declaration -> . multi_declaration ID COMMA
    (20) multi_declaration -> . multi_declaration MULTIPLY ID COMMA
    (21) multi_declaration -> . multi_declaration ID ASSIGN expr COMMA
    (22) multi_declaration -> . multi_declaration MULTIPLY ID ASSIGN expr COMMA
    (23) multi_declaration -> . ID COMMA
    (24) multi_declaration -> . ID ASSIGN expr COMMA
    (25) multi_declaration -> . MULTIPLY ID COMMA
    (26) multi_declaration -> . MULTIPLY ID ASSIGN expr COMMA

    ID              shift and go to state 76
    MULTIPLY        shift and go to state 77

    multi_declaration              shift and go to state 78

state 23

    (143) brace -> ID .
    (146) brace -> ID . narrayindex
    (63) function_call -> ID . L_PAREN call_params R_PAREN
    (32) narrayindex -> . narrayindex arrayindex
    (33) narrayindex -> . arrayindex
    (31) arrayindex -> . L_SQBRACE index R_SQBRACE

    PLUS_PLUS       reduce using rule 143 (brace -> ID .)
    MINUS_MINUS     reduce using rule 143 (brace -> ID .)
    MULTIPLY        reduce using rule 143 (brace -> ID .)
    DIVIDE          reduce using rule 143 (brace -> ID .)
    MOD             reduce using rule 143 (brace -> ID .)
    PLUS            reduce using rule 143 (brace -> ID .)
    MINUS           reduce using rule 143 (brace -> ID .)
    L_SHIFT         reduce using rule 143 (brace -> ID .)
    R_SHIFT         reduce using rule 143 (brace -> ID .)
    LE              reduce using rule 143 (brace -> ID .)
    LT              reduce using rule 143 (brace -> ID .)
    GE              reduce using rule 143 (brace -> ID .)
    GT              reduce using rule 143 (brace -> ID .)
    EQ              reduce using rule 143 (brace -> ID .)
    NE              reduce using rule 143 (brace -> ID .)
    BIT_AND         reduce using rule 143 (brace -> ID .)
    BIT_XOR         reduce using rule 143 (brace -> ID .)
    BIT_OR          reduce using rule 143 (brace -> ID .)
    AND             reduce using rule 143 (brace -> ID .)
    OR              reduce using rule 143 (brace -> ID .)
    SEMICOLON       reduce using rule 143 (brace -> ID .)
    ASSIGN          reduce using rule 143 (brace -> ID .)
    PLUS_ASSIGN     reduce using rule 143 (brace -> ID .)
    MINUS_ASSIGN    reduce using rule 143 (brace -> ID .)
    MUL_ASSIGN      reduce using rule 143 (brace -> ID .)
    DIV_ASSIGN      reduce using rule 143 (brace -> ID .)
    AND_ASSIGN      reduce using rule 143 (brace -> ID .)
    OR_ASSIGN       reduce using rule 143 (brace -> ID .)
    XOR_ASSIGN      reduce using rule 143 (brace -> ID .)
    MOD_ASSIGN      reduce using rule 143 (brace -> ID .)
    L_SHIFT_ASSIGN  reduce using rule 143 (brace -> ID .)
    R_SHIFT_ASSIGN  reduce using rule 143 (brace -> ID .)
    R_PAREN         reduce using rule 143 (brace -> ID .)
    COMMA           reduce using rule 143 (brace -> ID .)
    R_SQBRACE       reduce using rule 143 (brace -> ID .)
    R_FLOWBRACE     reduce using rule 143 (brace -> ID .)
    L_PAREN         shift and go to state 80
    L_SQBRACE       shift and go to state 82

    narrayindex                    shift and go to state 79
    arrayindex                     shift and go to state 81

state 24

    (141) brace -> MULTIPLY . ID

    ID              shift and go to state 83


state 25

    (134) cast -> L_PAREN . TYPE R_PAREN
    (135) cast -> L_PAREN . TYPE MULTIPLY R_PAREN
    (136) brace -> L_PAREN . expr R_PAREN
    (85) expr -> . expr assignment exprOR
    (86) expr -> . exprOR
    (98) exprOR -> . exprOR OR exprAND
    (99) exprOR -> . exprAND
    (100) exprAND -> . exprAND AND exprBITOR
    (101) exprAND -> . exprBITOR
    (102) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (103) exprBITOR -> . exprBITXOR
    (104) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (105) exprBITXOR -> . exprBITAND
    (106) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (107) exprBITAND -> . exprEQ
    (108) exprEQ -> . exprEQ EQ exprRELOP
    (109) exprEQ -> . exprEQ NE exprRELOP
    (110) exprEQ -> . exprRELOP
    (111) exprRELOP -> . exprRELOP relop exprSHIFT
    (112) exprRELOP -> . exprSHIFT
    (117) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (118) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (119) exprSHIFT -> . exprOP
    (120) exprOP -> . exprOP PLUS term
    (121) exprOP -> . exprOP MINUS term
    (122) exprOP -> . term
    (123) term -> . term MULTIPLY factor
    (124) term -> . term DIVIDE factor
    (125) term -> . term MOD factor
    (126) term -> . factor
    (127) factor -> . NOT factor
    (128) factor -> . PLUS factor
    (129) factor -> . MINUS factor
    (130) factor -> . PLUS_PLUS factor
    (131) factor -> . MINUS_MINUS factor
    (132) factor -> . cast brace
    (133) factor -> . brace
    (134) cast -> . L_PAREN TYPE R_PAREN
    (135) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (136) brace -> . L_PAREN expr R_PAREN
    (137) brace -> . brace PLUS_PLUS
    (138) brace -> . brace MINUS_MINUS
    (139) brace -> . NUM
    (140) brace -> . STRING
    (141) brace -> . MULTIPLY ID
    (142) brace -> . BIT_AND ID
    (143) brace -> . ID
    (144) brace -> . CHAR
    (145) brace -> . function_call
    (146) brace -> . ID narrayindex
    (147) NUM -> . INT_NUM
    (148) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    TYPE            shift and go to state 84
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    expr                           shift and go to state 85
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 26

    (51) left_flower -> L_FLOWBRACE .

    R_FLOWBRACE     reduce using rule 51 (left_flower -> L_FLOWBRACE .)
    IF              reduce using rule 51 (left_flower -> L_FLOWBRACE .)
    WHILE           reduce using rule 51 (left_flower -> L_FLOWBRACE .)
    FOR             reduce using rule 51 (left_flower -> L_FLOWBRACE .)
    SEMICOLON       reduce using rule 51 (left_flower -> L_FLOWBRACE .)
    RETURN          reduce using rule 51 (left_flower -> L_FLOWBRACE .)
    HASH            reduce using rule 51 (left_flower -> L_FLOWBRACE .)
    TYPE            reduce using rule 51 (left_flower -> L_FLOWBRACE .)
    L_FLOWBRACE     reduce using rule 51 (left_flower -> L_FLOWBRACE .)
    NOT             reduce using rule 51 (left_flower -> L_FLOWBRACE .)
    PLUS            reduce using rule 51 (left_flower -> L_FLOWBRACE .)
    MINUS           reduce using rule 51 (left_flower -> L_FLOWBRACE .)
    PLUS_PLUS       reduce using rule 51 (left_flower -> L_FLOWBRACE .)
    MINUS_MINUS     reduce using rule 51 (left_flower -> L_FLOWBRACE .)
    L_PAREN         reduce using rule 51 (left_flower -> L_FLOWBRACE .)
    STRING          reduce using rule 51 (left_flower -> L_FLOWBRACE .)
    MULTIPLY        reduce using rule 51 (left_flower -> L_FLOWBRACE .)
    BIT_AND         reduce using rule 51 (left_flower -> L_FLOWBRACE .)
    ID              reduce using rule 51 (left_flower -> L_FLOWBRACE .)
    CHAR            reduce using rule 51 (left_flower -> L_FLOWBRACE .)
    INT_NUM         reduce using rule 51 (left_flower -> L_FLOWBRACE .)
    FLOAT_NUM       reduce using rule 51 (left_flower -> L_FLOWBRACE .)


state 27

    (99) exprOR -> exprAND .
    (100) exprAND -> exprAND . AND exprBITOR

    OR              reduce using rule 99 (exprOR -> exprAND .)
    SEMICOLON       reduce using rule 99 (exprOR -> exprAND .)
    ASSIGN          reduce using rule 99 (exprOR -> exprAND .)
    PLUS_ASSIGN     reduce using rule 99 (exprOR -> exprAND .)
    MINUS_ASSIGN    reduce using rule 99 (exprOR -> exprAND .)
    MUL_ASSIGN      reduce using rule 99 (exprOR -> exprAND .)
    DIV_ASSIGN      reduce using rule 99 (exprOR -> exprAND .)
    AND_ASSIGN      reduce using rule 99 (exprOR -> exprAND .)
    OR_ASSIGN       reduce using rule 99 (exprOR -> exprAND .)
    XOR_ASSIGN      reduce using rule 99 (exprOR -> exprAND .)
    MOD_ASSIGN      reduce using rule 99 (exprOR -> exprAND .)
    L_SHIFT_ASSIGN  reduce using rule 99 (exprOR -> exprAND .)
    R_SHIFT_ASSIGN  reduce using rule 99 (exprOR -> exprAND .)
    R_PAREN         reduce using rule 99 (exprOR -> exprAND .)
    COMMA           reduce using rule 99 (exprOR -> exprAND .)
    R_SQBRACE       reduce using rule 99 (exprOR -> exprAND .)
    R_FLOWBRACE     reduce using rule 99 (exprOR -> exprAND .)
    AND             shift and go to state 86


state 28

    (101) exprAND -> exprBITOR .
    (102) exprBITOR -> exprBITOR . BIT_OR exprBITXOR

    AND             reduce using rule 101 (exprAND -> exprBITOR .)
    OR              reduce using rule 101 (exprAND -> exprBITOR .)
    SEMICOLON       reduce using rule 101 (exprAND -> exprBITOR .)
    ASSIGN          reduce using rule 101 (exprAND -> exprBITOR .)
    PLUS_ASSIGN     reduce using rule 101 (exprAND -> exprBITOR .)
    MINUS_ASSIGN    reduce using rule 101 (exprAND -> exprBITOR .)
    MUL_ASSIGN      reduce using rule 101 (exprAND -> exprBITOR .)
    DIV_ASSIGN      reduce using rule 101 (exprAND -> exprBITOR .)
    AND_ASSIGN      reduce using rule 101 (exprAND -> exprBITOR .)
    OR_ASSIGN       reduce using rule 101 (exprAND -> exprBITOR .)
    XOR_ASSIGN      reduce using rule 101 (exprAND -> exprBITOR .)
    MOD_ASSIGN      reduce using rule 101 (exprAND -> exprBITOR .)
    L_SHIFT_ASSIGN  reduce using rule 101 (exprAND -> exprBITOR .)
    R_SHIFT_ASSIGN  reduce using rule 101 (exprAND -> exprBITOR .)
    R_PAREN         reduce using rule 101 (exprAND -> exprBITOR .)
    COMMA           reduce using rule 101 (exprAND -> exprBITOR .)
    R_SQBRACE       reduce using rule 101 (exprAND -> exprBITOR .)
    R_FLOWBRACE     reduce using rule 101 (exprAND -> exprBITOR .)
    BIT_OR          shift and go to state 87


state 29

    (103) exprBITOR -> exprBITXOR .
    (104) exprBITXOR -> exprBITXOR . BIT_XOR exprBITAND

    BIT_OR          reduce using rule 103 (exprBITOR -> exprBITXOR .)
    AND             reduce using rule 103 (exprBITOR -> exprBITXOR .)
    OR              reduce using rule 103 (exprBITOR -> exprBITXOR .)
    SEMICOLON       reduce using rule 103 (exprBITOR -> exprBITXOR .)
    ASSIGN          reduce using rule 103 (exprBITOR -> exprBITXOR .)
    PLUS_ASSIGN     reduce using rule 103 (exprBITOR -> exprBITXOR .)
    MINUS_ASSIGN    reduce using rule 103 (exprBITOR -> exprBITXOR .)
    MUL_ASSIGN      reduce using rule 103 (exprBITOR -> exprBITXOR .)
    DIV_ASSIGN      reduce using rule 103 (exprBITOR -> exprBITXOR .)
    AND_ASSIGN      reduce using rule 103 (exprBITOR -> exprBITXOR .)
    OR_ASSIGN       reduce using rule 103 (exprBITOR -> exprBITXOR .)
    XOR_ASSIGN      reduce using rule 103 (exprBITOR -> exprBITXOR .)
    MOD_ASSIGN      reduce using rule 103 (exprBITOR -> exprBITXOR .)
    L_SHIFT_ASSIGN  reduce using rule 103 (exprBITOR -> exprBITXOR .)
    R_SHIFT_ASSIGN  reduce using rule 103 (exprBITOR -> exprBITXOR .)
    R_PAREN         reduce using rule 103 (exprBITOR -> exprBITXOR .)
    COMMA           reduce using rule 103 (exprBITOR -> exprBITXOR .)
    R_SQBRACE       reduce using rule 103 (exprBITOR -> exprBITXOR .)
    R_FLOWBRACE     reduce using rule 103 (exprBITOR -> exprBITXOR .)
    BIT_XOR         shift and go to state 88


state 30

    (105) exprBITXOR -> exprBITAND .
    (106) exprBITAND -> exprBITAND . BIT_AND exprEQ

    BIT_XOR         reduce using rule 105 (exprBITXOR -> exprBITAND .)
    BIT_OR          reduce using rule 105 (exprBITXOR -> exprBITAND .)
    AND             reduce using rule 105 (exprBITXOR -> exprBITAND .)
    OR              reduce using rule 105 (exprBITXOR -> exprBITAND .)
    SEMICOLON       reduce using rule 105 (exprBITXOR -> exprBITAND .)
    ASSIGN          reduce using rule 105 (exprBITXOR -> exprBITAND .)
    PLUS_ASSIGN     reduce using rule 105 (exprBITXOR -> exprBITAND .)
    MINUS_ASSIGN    reduce using rule 105 (exprBITXOR -> exprBITAND .)
    MUL_ASSIGN      reduce using rule 105 (exprBITXOR -> exprBITAND .)
    DIV_ASSIGN      reduce using rule 105 (exprBITXOR -> exprBITAND .)
    AND_ASSIGN      reduce using rule 105 (exprBITXOR -> exprBITAND .)
    OR_ASSIGN       reduce using rule 105 (exprBITXOR -> exprBITAND .)
    XOR_ASSIGN      reduce using rule 105 (exprBITXOR -> exprBITAND .)
    MOD_ASSIGN      reduce using rule 105 (exprBITXOR -> exprBITAND .)
    L_SHIFT_ASSIGN  reduce using rule 105 (exprBITXOR -> exprBITAND .)
    R_SHIFT_ASSIGN  reduce using rule 105 (exprBITXOR -> exprBITAND .)
    R_PAREN         reduce using rule 105 (exprBITXOR -> exprBITAND .)
    COMMA           reduce using rule 105 (exprBITXOR -> exprBITAND .)
    R_SQBRACE       reduce using rule 105 (exprBITXOR -> exprBITAND .)
    R_FLOWBRACE     reduce using rule 105 (exprBITXOR -> exprBITAND .)
    BIT_AND         shift and go to state 89


state 31

    (142) brace -> BIT_AND . ID

    ID              shift and go to state 90


state 32

    (107) exprBITAND -> exprEQ .
    (108) exprEQ -> exprEQ . EQ exprRELOP
    (109) exprEQ -> exprEQ . NE exprRELOP

    BIT_AND         reduce using rule 107 (exprBITAND -> exprEQ .)
    BIT_XOR         reduce using rule 107 (exprBITAND -> exprEQ .)
    BIT_OR          reduce using rule 107 (exprBITAND -> exprEQ .)
    AND             reduce using rule 107 (exprBITAND -> exprEQ .)
    OR              reduce using rule 107 (exprBITAND -> exprEQ .)
    SEMICOLON       reduce using rule 107 (exprBITAND -> exprEQ .)
    ASSIGN          reduce using rule 107 (exprBITAND -> exprEQ .)
    PLUS_ASSIGN     reduce using rule 107 (exprBITAND -> exprEQ .)
    MINUS_ASSIGN    reduce using rule 107 (exprBITAND -> exprEQ .)
    MUL_ASSIGN      reduce using rule 107 (exprBITAND -> exprEQ .)
    DIV_ASSIGN      reduce using rule 107 (exprBITAND -> exprEQ .)
    AND_ASSIGN      reduce using rule 107 (exprBITAND -> exprEQ .)
    OR_ASSIGN       reduce using rule 107 (exprBITAND -> exprEQ .)
    XOR_ASSIGN      reduce using rule 107 (exprBITAND -> exprEQ .)
    MOD_ASSIGN      reduce using rule 107 (exprBITAND -> exprEQ .)
    L_SHIFT_ASSIGN  reduce using rule 107 (exprBITAND -> exprEQ .)
    R_SHIFT_ASSIGN  reduce using rule 107 (exprBITAND -> exprEQ .)
    R_PAREN         reduce using rule 107 (exprBITAND -> exprEQ .)
    COMMA           reduce using rule 107 (exprBITAND -> exprEQ .)
    R_SQBRACE       reduce using rule 107 (exprBITAND -> exprEQ .)
    R_FLOWBRACE     reduce using rule 107 (exprBITAND -> exprEQ .)
    EQ              shift and go to state 91
    NE              shift and go to state 92


state 33

    (110) exprEQ -> exprRELOP .
    (111) exprRELOP -> exprRELOP . relop exprSHIFT
    (113) relop -> . LE
    (114) relop -> . LT
    (115) relop -> . GE
    (116) relop -> . GT

    EQ              reduce using rule 110 (exprEQ -> exprRELOP .)
    NE              reduce using rule 110 (exprEQ -> exprRELOP .)
    BIT_AND         reduce using rule 110 (exprEQ -> exprRELOP .)
    BIT_XOR         reduce using rule 110 (exprEQ -> exprRELOP .)
    BIT_OR          reduce using rule 110 (exprEQ -> exprRELOP .)
    AND             reduce using rule 110 (exprEQ -> exprRELOP .)
    OR              reduce using rule 110 (exprEQ -> exprRELOP .)
    SEMICOLON       reduce using rule 110 (exprEQ -> exprRELOP .)
    ASSIGN          reduce using rule 110 (exprEQ -> exprRELOP .)
    PLUS_ASSIGN     reduce using rule 110 (exprEQ -> exprRELOP .)
    MINUS_ASSIGN    reduce using rule 110 (exprEQ -> exprRELOP .)
    MUL_ASSIGN      reduce using rule 110 (exprEQ -> exprRELOP .)
    DIV_ASSIGN      reduce using rule 110 (exprEQ -> exprRELOP .)
    AND_ASSIGN      reduce using rule 110 (exprEQ -> exprRELOP .)
    OR_ASSIGN       reduce using rule 110 (exprEQ -> exprRELOP .)
    XOR_ASSIGN      reduce using rule 110 (exprEQ -> exprRELOP .)
    MOD_ASSIGN      reduce using rule 110 (exprEQ -> exprRELOP .)
    L_SHIFT_ASSIGN  reduce using rule 110 (exprEQ -> exprRELOP .)
    R_SHIFT_ASSIGN  reduce using rule 110 (exprEQ -> exprRELOP .)
    R_PAREN         reduce using rule 110 (exprEQ -> exprRELOP .)
    COMMA           reduce using rule 110 (exprEQ -> exprRELOP .)
    R_SQBRACE       reduce using rule 110 (exprEQ -> exprRELOP .)
    R_FLOWBRACE     reduce using rule 110 (exprEQ -> exprRELOP .)
    LE              shift and go to state 94
    LT              shift and go to state 95
    GE              shift and go to state 96
    GT              shift and go to state 97

    relop                          shift and go to state 93

state 34

    (112) exprRELOP -> exprSHIFT .
    (117) exprSHIFT -> exprSHIFT . L_SHIFT exprOP
    (118) exprSHIFT -> exprSHIFT . R_SHIFT exprOP

    LE              reduce using rule 112 (exprRELOP -> exprSHIFT .)
    LT              reduce using rule 112 (exprRELOP -> exprSHIFT .)
    GE              reduce using rule 112 (exprRELOP -> exprSHIFT .)
    GT              reduce using rule 112 (exprRELOP -> exprSHIFT .)
    EQ              reduce using rule 112 (exprRELOP -> exprSHIFT .)
    NE              reduce using rule 112 (exprRELOP -> exprSHIFT .)
    BIT_AND         reduce using rule 112 (exprRELOP -> exprSHIFT .)
    BIT_XOR         reduce using rule 112 (exprRELOP -> exprSHIFT .)
    BIT_OR          reduce using rule 112 (exprRELOP -> exprSHIFT .)
    AND             reduce using rule 112 (exprRELOP -> exprSHIFT .)
    OR              reduce using rule 112 (exprRELOP -> exprSHIFT .)
    SEMICOLON       reduce using rule 112 (exprRELOP -> exprSHIFT .)
    ASSIGN          reduce using rule 112 (exprRELOP -> exprSHIFT .)
    PLUS_ASSIGN     reduce using rule 112 (exprRELOP -> exprSHIFT .)
    MINUS_ASSIGN    reduce using rule 112 (exprRELOP -> exprSHIFT .)
    MUL_ASSIGN      reduce using rule 112 (exprRELOP -> exprSHIFT .)
    DIV_ASSIGN      reduce using rule 112 (exprRELOP -> exprSHIFT .)
    AND_ASSIGN      reduce using rule 112 (exprRELOP -> exprSHIFT .)
    OR_ASSIGN       reduce using rule 112 (exprRELOP -> exprSHIFT .)
    XOR_ASSIGN      reduce using rule 112 (exprRELOP -> exprSHIFT .)
    MOD_ASSIGN      reduce using rule 112 (exprRELOP -> exprSHIFT .)
    L_SHIFT_ASSIGN  reduce using rule 112 (exprRELOP -> exprSHIFT .)
    R_SHIFT_ASSIGN  reduce using rule 112 (exprRELOP -> exprSHIFT .)
    R_PAREN         reduce using rule 112 (exprRELOP -> exprSHIFT .)
    COMMA           reduce using rule 112 (exprRELOP -> exprSHIFT .)
    R_SQBRACE       reduce using rule 112 (exprRELOP -> exprSHIFT .)
    R_FLOWBRACE     reduce using rule 112 (exprRELOP -> exprSHIFT .)
    L_SHIFT         shift and go to state 98
    R_SHIFT         shift and go to state 99


state 35

    (119) exprSHIFT -> exprOP .
    (120) exprOP -> exprOP . PLUS term
    (121) exprOP -> exprOP . MINUS term

    L_SHIFT         reduce using rule 119 (exprSHIFT -> exprOP .)
    R_SHIFT         reduce using rule 119 (exprSHIFT -> exprOP .)
    LE              reduce using rule 119 (exprSHIFT -> exprOP .)
    LT              reduce using rule 119 (exprSHIFT -> exprOP .)
    GE              reduce using rule 119 (exprSHIFT -> exprOP .)
    GT              reduce using rule 119 (exprSHIFT -> exprOP .)
    EQ              reduce using rule 119 (exprSHIFT -> exprOP .)
    NE              reduce using rule 119 (exprSHIFT -> exprOP .)
    BIT_AND         reduce using rule 119 (exprSHIFT -> exprOP .)
    BIT_XOR         reduce using rule 119 (exprSHIFT -> exprOP .)
    BIT_OR          reduce using rule 119 (exprSHIFT -> exprOP .)
    AND             reduce using rule 119 (exprSHIFT -> exprOP .)
    OR              reduce using rule 119 (exprSHIFT -> exprOP .)
    SEMICOLON       reduce using rule 119 (exprSHIFT -> exprOP .)
    ASSIGN          reduce using rule 119 (exprSHIFT -> exprOP .)
    PLUS_ASSIGN     reduce using rule 119 (exprSHIFT -> exprOP .)
    MINUS_ASSIGN    reduce using rule 119 (exprSHIFT -> exprOP .)
    MUL_ASSIGN      reduce using rule 119 (exprSHIFT -> exprOP .)
    DIV_ASSIGN      reduce using rule 119 (exprSHIFT -> exprOP .)
    AND_ASSIGN      reduce using rule 119 (exprSHIFT -> exprOP .)
    OR_ASSIGN       reduce using rule 119 (exprSHIFT -> exprOP .)
    XOR_ASSIGN      reduce using rule 119 (exprSHIFT -> exprOP .)
    MOD_ASSIGN      reduce using rule 119 (exprSHIFT -> exprOP .)
    L_SHIFT_ASSIGN  reduce using rule 119 (exprSHIFT -> exprOP .)
    R_SHIFT_ASSIGN  reduce using rule 119 (exprSHIFT -> exprOP .)
    R_PAREN         reduce using rule 119 (exprSHIFT -> exprOP .)
    COMMA           reduce using rule 119 (exprSHIFT -> exprOP .)
    R_SQBRACE       reduce using rule 119 (exprSHIFT -> exprOP .)
    R_FLOWBRACE     reduce using rule 119 (exprSHIFT -> exprOP .)
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101


state 36

    (128) factor -> PLUS . factor
    (127) factor -> . NOT factor
    (128) factor -> . PLUS factor
    (129) factor -> . MINUS factor
    (130) factor -> . PLUS_PLUS factor
    (131) factor -> . MINUS_MINUS factor
    (132) factor -> . cast brace
    (133) factor -> . brace
    (134) cast -> . L_PAREN TYPE R_PAREN
    (135) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (136) brace -> . L_PAREN expr R_PAREN
    (137) brace -> . brace PLUS_PLUS
    (138) brace -> . brace MINUS_MINUS
    (139) brace -> . NUM
    (140) brace -> . STRING
    (141) brace -> . MULTIPLY ID
    (142) brace -> . BIT_AND ID
    (143) brace -> . ID
    (144) brace -> . CHAR
    (145) brace -> . function_call
    (146) brace -> . ID narrayindex
    (147) NUM -> . INT_NUM
    (148) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    factor                         shift and go to state 102
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 37

    (122) exprOP -> term .
    (123) term -> term . MULTIPLY factor
    (124) term -> term . DIVIDE factor
    (125) term -> term . MOD factor

    PLUS            reduce using rule 122 (exprOP -> term .)
    MINUS           reduce using rule 122 (exprOP -> term .)
    L_SHIFT         reduce using rule 122 (exprOP -> term .)
    R_SHIFT         reduce using rule 122 (exprOP -> term .)
    LE              reduce using rule 122 (exprOP -> term .)
    LT              reduce using rule 122 (exprOP -> term .)
    GE              reduce using rule 122 (exprOP -> term .)
    GT              reduce using rule 122 (exprOP -> term .)
    EQ              reduce using rule 122 (exprOP -> term .)
    NE              reduce using rule 122 (exprOP -> term .)
    BIT_AND         reduce using rule 122 (exprOP -> term .)
    BIT_XOR         reduce using rule 122 (exprOP -> term .)
    BIT_OR          reduce using rule 122 (exprOP -> term .)
    AND             reduce using rule 122 (exprOP -> term .)
    OR              reduce using rule 122 (exprOP -> term .)
    SEMICOLON       reduce using rule 122 (exprOP -> term .)
    ASSIGN          reduce using rule 122 (exprOP -> term .)
    PLUS_ASSIGN     reduce using rule 122 (exprOP -> term .)
    MINUS_ASSIGN    reduce using rule 122 (exprOP -> term .)
    MUL_ASSIGN      reduce using rule 122 (exprOP -> term .)
    DIV_ASSIGN      reduce using rule 122 (exprOP -> term .)
    AND_ASSIGN      reduce using rule 122 (exprOP -> term .)
    OR_ASSIGN       reduce using rule 122 (exprOP -> term .)
    XOR_ASSIGN      reduce using rule 122 (exprOP -> term .)
    MOD_ASSIGN      reduce using rule 122 (exprOP -> term .)
    L_SHIFT_ASSIGN  reduce using rule 122 (exprOP -> term .)
    R_SHIFT_ASSIGN  reduce using rule 122 (exprOP -> term .)
    R_PAREN         reduce using rule 122 (exprOP -> term .)
    COMMA           reduce using rule 122 (exprOP -> term .)
    R_SQBRACE       reduce using rule 122 (exprOP -> term .)
    R_FLOWBRACE     reduce using rule 122 (exprOP -> term .)
    MULTIPLY        shift and go to state 103
    DIVIDE          shift and go to state 104
    MOD             shift and go to state 105


state 38

    (129) factor -> MINUS . factor
    (127) factor -> . NOT factor
    (128) factor -> . PLUS factor
    (129) factor -> . MINUS factor
    (130) factor -> . PLUS_PLUS factor
    (131) factor -> . MINUS_MINUS factor
    (132) factor -> . cast brace
    (133) factor -> . brace
    (134) cast -> . L_PAREN TYPE R_PAREN
    (135) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (136) brace -> . L_PAREN expr R_PAREN
    (137) brace -> . brace PLUS_PLUS
    (138) brace -> . brace MINUS_MINUS
    (139) brace -> . NUM
    (140) brace -> . STRING
    (141) brace -> . MULTIPLY ID
    (142) brace -> . BIT_AND ID
    (143) brace -> . ID
    (144) brace -> . CHAR
    (145) brace -> . function_call
    (146) brace -> . ID narrayindex
    (147) NUM -> . INT_NUM
    (148) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    factor                         shift and go to state 106
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 39

    (126) term -> factor .

    MULTIPLY        reduce using rule 126 (term -> factor .)
    DIVIDE          reduce using rule 126 (term -> factor .)
    MOD             reduce using rule 126 (term -> factor .)
    PLUS            reduce using rule 126 (term -> factor .)
    MINUS           reduce using rule 126 (term -> factor .)
    L_SHIFT         reduce using rule 126 (term -> factor .)
    R_SHIFT         reduce using rule 126 (term -> factor .)
    LE              reduce using rule 126 (term -> factor .)
    LT              reduce using rule 126 (term -> factor .)
    GE              reduce using rule 126 (term -> factor .)
    GT              reduce using rule 126 (term -> factor .)
    EQ              reduce using rule 126 (term -> factor .)
    NE              reduce using rule 126 (term -> factor .)
    BIT_AND         reduce using rule 126 (term -> factor .)
    BIT_XOR         reduce using rule 126 (term -> factor .)
    BIT_OR          reduce using rule 126 (term -> factor .)
    AND             reduce using rule 126 (term -> factor .)
    OR              reduce using rule 126 (term -> factor .)
    SEMICOLON       reduce using rule 126 (term -> factor .)
    ASSIGN          reduce using rule 126 (term -> factor .)
    PLUS_ASSIGN     reduce using rule 126 (term -> factor .)
    MINUS_ASSIGN    reduce using rule 126 (term -> factor .)
    MUL_ASSIGN      reduce using rule 126 (term -> factor .)
    DIV_ASSIGN      reduce using rule 126 (term -> factor .)
    AND_ASSIGN      reduce using rule 126 (term -> factor .)
    OR_ASSIGN       reduce using rule 126 (term -> factor .)
    XOR_ASSIGN      reduce using rule 126 (term -> factor .)
    MOD_ASSIGN      reduce using rule 126 (term -> factor .)
    L_SHIFT_ASSIGN  reduce using rule 126 (term -> factor .)
    R_SHIFT_ASSIGN  reduce using rule 126 (term -> factor .)
    R_PAREN         reduce using rule 126 (term -> factor .)
    COMMA           reduce using rule 126 (term -> factor .)
    R_SQBRACE       reduce using rule 126 (term -> factor .)
    R_FLOWBRACE     reduce using rule 126 (term -> factor .)


state 40

    (127) factor -> NOT . factor
    (127) factor -> . NOT factor
    (128) factor -> . PLUS factor
    (129) factor -> . MINUS factor
    (130) factor -> . PLUS_PLUS factor
    (131) factor -> . MINUS_MINUS factor
    (132) factor -> . cast brace
    (133) factor -> . brace
    (134) cast -> . L_PAREN TYPE R_PAREN
    (135) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (136) brace -> . L_PAREN expr R_PAREN
    (137) brace -> . brace PLUS_PLUS
    (138) brace -> . brace MINUS_MINUS
    (139) brace -> . NUM
    (140) brace -> . STRING
    (141) brace -> . MULTIPLY ID
    (142) brace -> . BIT_AND ID
    (143) brace -> . ID
    (144) brace -> . CHAR
    (145) brace -> . function_call
    (146) brace -> . ID narrayindex
    (147) NUM -> . INT_NUM
    (148) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    factor                         shift and go to state 107
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 41

    (130) factor -> PLUS_PLUS . factor
    (127) factor -> . NOT factor
    (128) factor -> . PLUS factor
    (129) factor -> . MINUS factor
    (130) factor -> . PLUS_PLUS factor
    (131) factor -> . MINUS_MINUS factor
    (132) factor -> . cast brace
    (133) factor -> . brace
    (134) cast -> . L_PAREN TYPE R_PAREN
    (135) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (136) brace -> . L_PAREN expr R_PAREN
    (137) brace -> . brace PLUS_PLUS
    (138) brace -> . brace MINUS_MINUS
    (139) brace -> . NUM
    (140) brace -> . STRING
    (141) brace -> . MULTIPLY ID
    (142) brace -> . BIT_AND ID
    (143) brace -> . ID
    (144) brace -> . CHAR
    (145) brace -> . function_call
    (146) brace -> . ID narrayindex
    (147) NUM -> . INT_NUM
    (148) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    factor                         shift and go to state 108
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 42

    (131) factor -> MINUS_MINUS . factor
    (127) factor -> . NOT factor
    (128) factor -> . PLUS factor
    (129) factor -> . MINUS factor
    (130) factor -> . PLUS_PLUS factor
    (131) factor -> . MINUS_MINUS factor
    (132) factor -> . cast brace
    (133) factor -> . brace
    (134) cast -> . L_PAREN TYPE R_PAREN
    (135) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (136) brace -> . L_PAREN expr R_PAREN
    (137) brace -> . brace PLUS_PLUS
    (138) brace -> . brace MINUS_MINUS
    (139) brace -> . NUM
    (140) brace -> . STRING
    (141) brace -> . MULTIPLY ID
    (142) brace -> . BIT_AND ID
    (143) brace -> . ID
    (144) brace -> . CHAR
    (145) brace -> . function_call
    (146) brace -> . ID narrayindex
    (147) NUM -> . INT_NUM
    (148) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    factor                         shift and go to state 109
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 43

    (132) factor -> cast . brace
    (136) brace -> . L_PAREN expr R_PAREN
    (137) brace -> . brace PLUS_PLUS
    (138) brace -> . brace MINUS_MINUS
    (139) brace -> . NUM
    (140) brace -> . STRING
    (141) brace -> . MULTIPLY ID
    (142) brace -> . BIT_AND ID
    (143) brace -> . ID
    (144) brace -> . CHAR
    (145) brace -> . function_call
    (146) brace -> . ID narrayindex
    (147) NUM -> . INT_NUM
    (148) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    L_PAREN         shift and go to state 111
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    brace                          shift and go to state 110
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 44

    (133) factor -> brace .
    (137) brace -> brace . PLUS_PLUS
    (138) brace -> brace . MINUS_MINUS

    MULTIPLY        reduce using rule 133 (factor -> brace .)
    DIVIDE          reduce using rule 133 (factor -> brace .)
    MOD             reduce using rule 133 (factor -> brace .)
    PLUS            reduce using rule 133 (factor -> brace .)
    MINUS           reduce using rule 133 (factor -> brace .)
    L_SHIFT         reduce using rule 133 (factor -> brace .)
    R_SHIFT         reduce using rule 133 (factor -> brace .)
    LE              reduce using rule 133 (factor -> brace .)
    LT              reduce using rule 133 (factor -> brace .)
    GE              reduce using rule 133 (factor -> brace .)
    GT              reduce using rule 133 (factor -> brace .)
    EQ              reduce using rule 133 (factor -> brace .)
    NE              reduce using rule 133 (factor -> brace .)
    BIT_AND         reduce using rule 133 (factor -> brace .)
    BIT_XOR         reduce using rule 133 (factor -> brace .)
    BIT_OR          reduce using rule 133 (factor -> brace .)
    AND             reduce using rule 133 (factor -> brace .)
    OR              reduce using rule 133 (factor -> brace .)
    SEMICOLON       reduce using rule 133 (factor -> brace .)
    ASSIGN          reduce using rule 133 (factor -> brace .)
    PLUS_ASSIGN     reduce using rule 133 (factor -> brace .)
    MINUS_ASSIGN    reduce using rule 133 (factor -> brace .)
    MUL_ASSIGN      reduce using rule 133 (factor -> brace .)
    DIV_ASSIGN      reduce using rule 133 (factor -> brace .)
    AND_ASSIGN      reduce using rule 133 (factor -> brace .)
    OR_ASSIGN       reduce using rule 133 (factor -> brace .)
    XOR_ASSIGN      reduce using rule 133 (factor -> brace .)
    MOD_ASSIGN      reduce using rule 133 (factor -> brace .)
    L_SHIFT_ASSIGN  reduce using rule 133 (factor -> brace .)
    R_SHIFT_ASSIGN  reduce using rule 133 (factor -> brace .)
    R_PAREN         reduce using rule 133 (factor -> brace .)
    COMMA           reduce using rule 133 (factor -> brace .)
    R_SQBRACE       reduce using rule 133 (factor -> brace .)
    R_FLOWBRACE     reduce using rule 133 (factor -> brace .)
    PLUS_PLUS       shift and go to state 112
    MINUS_MINUS     shift and go to state 113


state 45

    (139) brace -> NUM .

    PLUS_PLUS       reduce using rule 139 (brace -> NUM .)
    MINUS_MINUS     reduce using rule 139 (brace -> NUM .)
    MULTIPLY        reduce using rule 139 (brace -> NUM .)
    DIVIDE          reduce using rule 139 (brace -> NUM .)
    MOD             reduce using rule 139 (brace -> NUM .)
    PLUS            reduce using rule 139 (brace -> NUM .)
    MINUS           reduce using rule 139 (brace -> NUM .)
    L_SHIFT         reduce using rule 139 (brace -> NUM .)
    R_SHIFT         reduce using rule 139 (brace -> NUM .)
    LE              reduce using rule 139 (brace -> NUM .)
    LT              reduce using rule 139 (brace -> NUM .)
    GE              reduce using rule 139 (brace -> NUM .)
    GT              reduce using rule 139 (brace -> NUM .)
    EQ              reduce using rule 139 (brace -> NUM .)
    NE              reduce using rule 139 (brace -> NUM .)
    BIT_AND         reduce using rule 139 (brace -> NUM .)
    BIT_XOR         reduce using rule 139 (brace -> NUM .)
    BIT_OR          reduce using rule 139 (brace -> NUM .)
    AND             reduce using rule 139 (brace -> NUM .)
    OR              reduce using rule 139 (brace -> NUM .)
    SEMICOLON       reduce using rule 139 (brace -> NUM .)
    ASSIGN          reduce using rule 139 (brace -> NUM .)
    PLUS_ASSIGN     reduce using rule 139 (brace -> NUM .)
    MINUS_ASSIGN    reduce using rule 139 (brace -> NUM .)
    MUL_ASSIGN      reduce using rule 139 (brace -> NUM .)
    DIV_ASSIGN      reduce using rule 139 (brace -> NUM .)
    AND_ASSIGN      reduce using rule 139 (brace -> NUM .)
    OR_ASSIGN       reduce using rule 139 (brace -> NUM .)
    XOR_ASSIGN      reduce using rule 139 (brace -> NUM .)
    MOD_ASSIGN      reduce using rule 139 (brace -> NUM .)
    L_SHIFT_ASSIGN  reduce using rule 139 (brace -> NUM .)
    R_SHIFT_ASSIGN  reduce using rule 139 (brace -> NUM .)
    R_PAREN         reduce using rule 139 (brace -> NUM .)
    COMMA           reduce using rule 139 (brace -> NUM .)
    R_SQBRACE       reduce using rule 139 (brace -> NUM .)
    R_FLOWBRACE     reduce using rule 139 (brace -> NUM .)


state 46

    (144) brace -> CHAR .

    PLUS_PLUS       reduce using rule 144 (brace -> CHAR .)
    MINUS_MINUS     reduce using rule 144 (brace -> CHAR .)
    MULTIPLY        reduce using rule 144 (brace -> CHAR .)
    DIVIDE          reduce using rule 144 (brace -> CHAR .)
    MOD             reduce using rule 144 (brace -> CHAR .)
    PLUS            reduce using rule 144 (brace -> CHAR .)
    MINUS           reduce using rule 144 (brace -> CHAR .)
    L_SHIFT         reduce using rule 144 (brace -> CHAR .)
    R_SHIFT         reduce using rule 144 (brace -> CHAR .)
    LE              reduce using rule 144 (brace -> CHAR .)
    LT              reduce using rule 144 (brace -> CHAR .)
    GE              reduce using rule 144 (brace -> CHAR .)
    GT              reduce using rule 144 (brace -> CHAR .)
    EQ              reduce using rule 144 (brace -> CHAR .)
    NE              reduce using rule 144 (brace -> CHAR .)
    BIT_AND         reduce using rule 144 (brace -> CHAR .)
    BIT_XOR         reduce using rule 144 (brace -> CHAR .)
    BIT_OR          reduce using rule 144 (brace -> CHAR .)
    AND             reduce using rule 144 (brace -> CHAR .)
    OR              reduce using rule 144 (brace -> CHAR .)
    SEMICOLON       reduce using rule 144 (brace -> CHAR .)
    ASSIGN          reduce using rule 144 (brace -> CHAR .)
    PLUS_ASSIGN     reduce using rule 144 (brace -> CHAR .)
    MINUS_ASSIGN    reduce using rule 144 (brace -> CHAR .)
    MUL_ASSIGN      reduce using rule 144 (brace -> CHAR .)
    DIV_ASSIGN      reduce using rule 144 (brace -> CHAR .)
    AND_ASSIGN      reduce using rule 144 (brace -> CHAR .)
    OR_ASSIGN       reduce using rule 144 (brace -> CHAR .)
    XOR_ASSIGN      reduce using rule 144 (brace -> CHAR .)
    MOD_ASSIGN      reduce using rule 144 (brace -> CHAR .)
    L_SHIFT_ASSIGN  reduce using rule 144 (brace -> CHAR .)
    R_SHIFT_ASSIGN  reduce using rule 144 (brace -> CHAR .)
    R_PAREN         reduce using rule 144 (brace -> CHAR .)
    COMMA           reduce using rule 144 (brace -> CHAR .)
    R_SQBRACE       reduce using rule 144 (brace -> CHAR .)
    R_FLOWBRACE     reduce using rule 144 (brace -> CHAR .)


state 47

    (145) brace -> function_call .

    PLUS_PLUS       reduce using rule 145 (brace -> function_call .)
    MINUS_MINUS     reduce using rule 145 (brace -> function_call .)
    MULTIPLY        reduce using rule 145 (brace -> function_call .)
    DIVIDE          reduce using rule 145 (brace -> function_call .)
    MOD             reduce using rule 145 (brace -> function_call .)
    PLUS            reduce using rule 145 (brace -> function_call .)
    MINUS           reduce using rule 145 (brace -> function_call .)
    L_SHIFT         reduce using rule 145 (brace -> function_call .)
    R_SHIFT         reduce using rule 145 (brace -> function_call .)
    LE              reduce using rule 145 (brace -> function_call .)
    LT              reduce using rule 145 (brace -> function_call .)
    GE              reduce using rule 145 (brace -> function_call .)
    GT              reduce using rule 145 (brace -> function_call .)
    EQ              reduce using rule 145 (brace -> function_call .)
    NE              reduce using rule 145 (brace -> function_call .)
    BIT_AND         reduce using rule 145 (brace -> function_call .)
    BIT_XOR         reduce using rule 145 (brace -> function_call .)
    BIT_OR          reduce using rule 145 (brace -> function_call .)
    AND             reduce using rule 145 (brace -> function_call .)
    OR              reduce using rule 145 (brace -> function_call .)
    SEMICOLON       reduce using rule 145 (brace -> function_call .)
    ASSIGN          reduce using rule 145 (brace -> function_call .)
    PLUS_ASSIGN     reduce using rule 145 (brace -> function_call .)
    MINUS_ASSIGN    reduce using rule 145 (brace -> function_call .)
    MUL_ASSIGN      reduce using rule 145 (brace -> function_call .)
    DIV_ASSIGN      reduce using rule 145 (brace -> function_call .)
    AND_ASSIGN      reduce using rule 145 (brace -> function_call .)
    OR_ASSIGN       reduce using rule 145 (brace -> function_call .)
    XOR_ASSIGN      reduce using rule 145 (brace -> function_call .)
    MOD_ASSIGN      reduce using rule 145 (brace -> function_call .)
    L_SHIFT_ASSIGN  reduce using rule 145 (brace -> function_call .)
    R_SHIFT_ASSIGN  reduce using rule 145 (brace -> function_call .)
    R_PAREN         reduce using rule 145 (brace -> function_call .)
    COMMA           reduce using rule 145 (brace -> function_call .)
    R_SQBRACE       reduce using rule 145 (brace -> function_call .)
    R_FLOWBRACE     reduce using rule 145 (brace -> function_call .)


state 48

    (147) NUM -> INT_NUM .

    PLUS_PLUS       reduce using rule 147 (NUM -> INT_NUM .)
    MINUS_MINUS     reduce using rule 147 (NUM -> INT_NUM .)
    MULTIPLY        reduce using rule 147 (NUM -> INT_NUM .)
    DIVIDE          reduce using rule 147 (NUM -> INT_NUM .)
    MOD             reduce using rule 147 (NUM -> INT_NUM .)
    PLUS            reduce using rule 147 (NUM -> INT_NUM .)
    MINUS           reduce using rule 147 (NUM -> INT_NUM .)
    L_SHIFT         reduce using rule 147 (NUM -> INT_NUM .)
    R_SHIFT         reduce using rule 147 (NUM -> INT_NUM .)
    LE              reduce using rule 147 (NUM -> INT_NUM .)
    LT              reduce using rule 147 (NUM -> INT_NUM .)
    GE              reduce using rule 147 (NUM -> INT_NUM .)
    GT              reduce using rule 147 (NUM -> INT_NUM .)
    EQ              reduce using rule 147 (NUM -> INT_NUM .)
    NE              reduce using rule 147 (NUM -> INT_NUM .)
    BIT_AND         reduce using rule 147 (NUM -> INT_NUM .)
    BIT_XOR         reduce using rule 147 (NUM -> INT_NUM .)
    BIT_OR          reduce using rule 147 (NUM -> INT_NUM .)
    AND             reduce using rule 147 (NUM -> INT_NUM .)
    OR              reduce using rule 147 (NUM -> INT_NUM .)
    SEMICOLON       reduce using rule 147 (NUM -> INT_NUM .)
    ASSIGN          reduce using rule 147 (NUM -> INT_NUM .)
    PLUS_ASSIGN     reduce using rule 147 (NUM -> INT_NUM .)
    MINUS_ASSIGN    reduce using rule 147 (NUM -> INT_NUM .)
    MUL_ASSIGN      reduce using rule 147 (NUM -> INT_NUM .)
    DIV_ASSIGN      reduce using rule 147 (NUM -> INT_NUM .)
    AND_ASSIGN      reduce using rule 147 (NUM -> INT_NUM .)
    OR_ASSIGN       reduce using rule 147 (NUM -> INT_NUM .)
    XOR_ASSIGN      reduce using rule 147 (NUM -> INT_NUM .)
    MOD_ASSIGN      reduce using rule 147 (NUM -> INT_NUM .)
    L_SHIFT_ASSIGN  reduce using rule 147 (NUM -> INT_NUM .)
    R_SHIFT_ASSIGN  reduce using rule 147 (NUM -> INT_NUM .)
    R_PAREN         reduce using rule 147 (NUM -> INT_NUM .)
    COMMA           reduce using rule 147 (NUM -> INT_NUM .)
    R_SQBRACE       reduce using rule 147 (NUM -> INT_NUM .)
    R_FLOWBRACE     reduce using rule 147 (NUM -> INT_NUM .)


state 49

    (148) NUM -> FLOAT_NUM .

    PLUS_PLUS       reduce using rule 148 (NUM -> FLOAT_NUM .)
    MINUS_MINUS     reduce using rule 148 (NUM -> FLOAT_NUM .)
    MULTIPLY        reduce using rule 148 (NUM -> FLOAT_NUM .)
    DIVIDE          reduce using rule 148 (NUM -> FLOAT_NUM .)
    MOD             reduce using rule 148 (NUM -> FLOAT_NUM .)
    PLUS            reduce using rule 148 (NUM -> FLOAT_NUM .)
    MINUS           reduce using rule 148 (NUM -> FLOAT_NUM .)
    L_SHIFT         reduce using rule 148 (NUM -> FLOAT_NUM .)
    R_SHIFT         reduce using rule 148 (NUM -> FLOAT_NUM .)
    LE              reduce using rule 148 (NUM -> FLOAT_NUM .)
    LT              reduce using rule 148 (NUM -> FLOAT_NUM .)
    GE              reduce using rule 148 (NUM -> FLOAT_NUM .)
    GT              reduce using rule 148 (NUM -> FLOAT_NUM .)
    EQ              reduce using rule 148 (NUM -> FLOAT_NUM .)
    NE              reduce using rule 148 (NUM -> FLOAT_NUM .)
    BIT_AND         reduce using rule 148 (NUM -> FLOAT_NUM .)
    BIT_XOR         reduce using rule 148 (NUM -> FLOAT_NUM .)
    BIT_OR          reduce using rule 148 (NUM -> FLOAT_NUM .)
    AND             reduce using rule 148 (NUM -> FLOAT_NUM .)
    OR              reduce using rule 148 (NUM -> FLOAT_NUM .)
    SEMICOLON       reduce using rule 148 (NUM -> FLOAT_NUM .)
    ASSIGN          reduce using rule 148 (NUM -> FLOAT_NUM .)
    PLUS_ASSIGN     reduce using rule 148 (NUM -> FLOAT_NUM .)
    MINUS_ASSIGN    reduce using rule 148 (NUM -> FLOAT_NUM .)
    MUL_ASSIGN      reduce using rule 148 (NUM -> FLOAT_NUM .)
    DIV_ASSIGN      reduce using rule 148 (NUM -> FLOAT_NUM .)
    AND_ASSIGN      reduce using rule 148 (NUM -> FLOAT_NUM .)
    OR_ASSIGN       reduce using rule 148 (NUM -> FLOAT_NUM .)
    XOR_ASSIGN      reduce using rule 148 (NUM -> FLOAT_NUM .)
    MOD_ASSIGN      reduce using rule 148 (NUM -> FLOAT_NUM .)
    L_SHIFT_ASSIGN  reduce using rule 148 (NUM -> FLOAT_NUM .)
    R_SHIFT_ASSIGN  reduce using rule 148 (NUM -> FLOAT_NUM .)
    R_PAREN         reduce using rule 148 (NUM -> FLOAT_NUM .)
    COMMA           reduce using rule 148 (NUM -> FLOAT_NUM .)
    R_SQBRACE       reduce using rule 148 (NUM -> FLOAT_NUM .)
    R_FLOWBRACE     reduce using rule 148 (NUM -> FLOAT_NUM .)


state 50

    (2) multiple_statements -> multiple_statements statement .

    IF              reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    WHILE           reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    FOR             reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    SEMICOLON       reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    RETURN          reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    HASH            reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    TYPE            reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    L_FLOWBRACE     reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    NOT             reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    PLUS            reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    MINUS           reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    PLUS_PLUS       reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    MINUS_MINUS     reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    L_PAREN         reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    STRING          reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    MULTIPLY        reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    BIT_AND         reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    ID              reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    CHAR            reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    INT_NUM         reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    FLOAT_NUM       reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    $end            reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    R_FLOWBRACE     reduce using rule 2 (multiple_statements -> multiple_statements statement .)


state 51

    (6) open -> IF condition . statement
    (7) open -> IF condition . closed ELSE open
    (13) closed -> IF condition . closed ELSE closed
    (4) statement -> . open
    (5) statement -> . closed
    (11) closed -> . simple
    (12) closed -> . block
    (13) closed -> . IF condition closed ELSE closed
    (14) closed -> . WHILE condition closed
    (15) closed -> . for for_condition closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) open -> . for for_condition open
    (53) simple -> . expr SEMICOLON
    (54) simple -> . header
    (55) simple -> . declaration
    (56) simple -> . SEMICOLON
    (57) simple -> . function
    (58) simple -> . RETURN expr SEMICOLON
    (59) simple -> . RETURN SEMICOLON
    (49) block -> . left_flower multiple_statements right_flower
    (50) block -> . left_flower right_flower
    (10) for -> . FOR
    (85) expr -> . expr assignment exprOR
    (86) expr -> . exprOR
    (60) header -> . HASH INCLUDE STRING
    (61) header -> . HASH INCLUDE HEADER_FILE
    (34) declaration -> . TYPE ID SEMICOLON
    (35) declaration -> . TYPE MULTIPLY ID SEMICOLON
    (36) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (37) declaration -> . TYPE MULTIPLY ID ASSIGN expr SEMICOLON
    (38) declaration -> . TYPE multi_declaration stop
    (39) declaration -> . TYPE ID narrayindex SEMICOLON
    (40) declaration -> . TYPE ID narrayindex ASSIGN init_list SEMICOLON
    (82) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (51) left_flower -> . L_FLOWBRACE
    (98) exprOR -> . exprOR OR exprAND
    (99) exprOR -> . exprAND
    (100) exprAND -> . exprAND AND exprBITOR
    (101) exprAND -> . exprBITOR
    (102) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (103) exprBITOR -> . exprBITXOR
    (104) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (105) exprBITXOR -> . exprBITAND
    (106) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (107) exprBITAND -> . exprEQ
    (108) exprEQ -> . exprEQ EQ exprRELOP
    (109) exprEQ -> . exprEQ NE exprRELOP
    (110) exprEQ -> . exprRELOP
    (111) exprRELOP -> . exprRELOP relop exprSHIFT
    (112) exprRELOP -> . exprSHIFT
    (117) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (118) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (119) exprSHIFT -> . exprOP
    (120) exprOP -> . exprOP PLUS term
    (121) exprOP -> . exprOP MINUS term
    (122) exprOP -> . term
    (123) term -> . term MULTIPLY factor
    (124) term -> . term DIVIDE factor
    (125) term -> . term MOD factor
    (126) term -> . factor
    (127) factor -> . NOT factor
    (128) factor -> . PLUS factor
    (129) factor -> . MINUS factor
    (130) factor -> . PLUS_PLUS factor
    (131) factor -> . MINUS_MINUS factor
    (132) factor -> . cast brace
    (133) factor -> . brace
    (134) cast -> . L_PAREN TYPE R_PAREN
    (135) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (136) brace -> . L_PAREN expr R_PAREN
    (137) brace -> . brace PLUS_PLUS
    (138) brace -> . brace MINUS_MINUS
    (139) brace -> . NUM
    (140) brace -> . STRING
    (141) brace -> . MULTIPLY ID
    (142) brace -> . BIT_AND ID
    (143) brace -> . ID
    (144) brace -> . CHAR
    (145) brace -> . function_call
    (146) brace -> . ID narrayindex
    (147) NUM -> . INT_NUM
    (148) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    IF              shift and go to state 114
    WHILE           shift and go to state 117
    SEMICOLON       shift and go to state 13
    RETURN          shift and go to state 17
    FOR             shift and go to state 11
    HASH            shift and go to state 20
    TYPE            shift and go to state 22
    L_FLOWBRACE     shift and go to state 26
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    statement                      shift and go to state 115
    closed                         shift and go to state 116
    open                           shift and go to state 4
    simple                         shift and go to state 9
    block                          shift and go to state 10
    for                            shift and go to state 118
    expr                           shift and go to state 12
    header                         shift and go to state 14
    declaration                    shift and go to state 15
    function                       shift and go to state 16
    left_flower                    shift and go to state 18
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 52

    (16) condition -> L_PAREN . expr R_PAREN
    (85) expr -> . expr assignment exprOR
    (86) expr -> . exprOR
    (98) exprOR -> . exprOR OR exprAND
    (99) exprOR -> . exprAND
    (100) exprAND -> . exprAND AND exprBITOR
    (101) exprAND -> . exprBITOR
    (102) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (103) exprBITOR -> . exprBITXOR
    (104) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (105) exprBITXOR -> . exprBITAND
    (106) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (107) exprBITAND -> . exprEQ
    (108) exprEQ -> . exprEQ EQ exprRELOP
    (109) exprEQ -> . exprEQ NE exprRELOP
    (110) exprEQ -> . exprRELOP
    (111) exprRELOP -> . exprRELOP relop exprSHIFT
    (112) exprRELOP -> . exprSHIFT
    (117) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (118) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (119) exprSHIFT -> . exprOP
    (120) exprOP -> . exprOP PLUS term
    (121) exprOP -> . exprOP MINUS term
    (122) exprOP -> . term
    (123) term -> . term MULTIPLY factor
    (124) term -> . term DIVIDE factor
    (125) term -> . term MOD factor
    (126) term -> . factor
    (127) factor -> . NOT factor
    (128) factor -> . PLUS factor
    (129) factor -> . MINUS factor
    (130) factor -> . PLUS_PLUS factor
    (131) factor -> . MINUS_MINUS factor
    (132) factor -> . cast brace
    (133) factor -> . brace
    (134) cast -> . L_PAREN TYPE R_PAREN
    (135) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (136) brace -> . L_PAREN expr R_PAREN
    (137) brace -> . brace PLUS_PLUS
    (138) brace -> . brace MINUS_MINUS
    (139) brace -> . NUM
    (140) brace -> . STRING
    (141) brace -> . MULTIPLY ID
    (142) brace -> . BIT_AND ID
    (143) brace -> . ID
    (144) brace -> . CHAR
    (145) brace -> . function_call
    (146) brace -> . ID narrayindex
    (147) NUM -> . INT_NUM
    (148) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    expr                           shift and go to state 119
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 53

    (8) open -> WHILE condition . open
    (14) closed -> WHILE condition . closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) open -> . for for_condition open
    (11) closed -> . simple
    (12) closed -> . block
    (13) closed -> . IF condition closed ELSE closed
    (14) closed -> . WHILE condition closed
    (15) closed -> . for for_condition closed
    (10) for -> . FOR
    (53) simple -> . expr SEMICOLON
    (54) simple -> . header
    (55) simple -> . declaration
    (56) simple -> . SEMICOLON
    (57) simple -> . function
    (58) simple -> . RETURN expr SEMICOLON
    (59) simple -> . RETURN SEMICOLON
    (49) block -> . left_flower multiple_statements right_flower
    (50) block -> . left_flower right_flower
    (85) expr -> . expr assignment exprOR
    (86) expr -> . exprOR
    (60) header -> . HASH INCLUDE STRING
    (61) header -> . HASH INCLUDE HEADER_FILE
    (34) declaration -> . TYPE ID SEMICOLON
    (35) declaration -> . TYPE MULTIPLY ID SEMICOLON
    (36) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (37) declaration -> . TYPE MULTIPLY ID ASSIGN expr SEMICOLON
    (38) declaration -> . TYPE multi_declaration stop
    (39) declaration -> . TYPE ID narrayindex SEMICOLON
    (40) declaration -> . TYPE ID narrayindex ASSIGN init_list SEMICOLON
    (82) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (51) left_flower -> . L_FLOWBRACE
    (98) exprOR -> . exprOR OR exprAND
    (99) exprOR -> . exprAND
    (100) exprAND -> . exprAND AND exprBITOR
    (101) exprAND -> . exprBITOR
    (102) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (103) exprBITOR -> . exprBITXOR
    (104) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (105) exprBITXOR -> . exprBITAND
    (106) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (107) exprBITAND -> . exprEQ
    (108) exprEQ -> . exprEQ EQ exprRELOP
    (109) exprEQ -> . exprEQ NE exprRELOP
    (110) exprEQ -> . exprRELOP
    (111) exprRELOP -> . exprRELOP relop exprSHIFT
    (112) exprRELOP -> . exprSHIFT
    (117) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (118) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (119) exprSHIFT -> . exprOP
    (120) exprOP -> . exprOP PLUS term
    (121) exprOP -> . exprOP MINUS term
    (122) exprOP -> . term
    (123) term -> . term MULTIPLY factor
    (124) term -> . term DIVIDE factor
    (125) term -> . term MOD factor
    (126) term -> . factor
    (127) factor -> . NOT factor
    (128) factor -> . PLUS factor
    (129) factor -> . MINUS factor
    (130) factor -> . PLUS_PLUS factor
    (131) factor -> . MINUS_MINUS factor
    (132) factor -> . cast brace
    (133) factor -> . brace
    (134) cast -> . L_PAREN TYPE R_PAREN
    (135) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (136) brace -> . L_PAREN expr R_PAREN
    (137) brace -> . brace PLUS_PLUS
    (138) brace -> . brace MINUS_MINUS
    (139) brace -> . NUM
    (140) brace -> . STRING
    (141) brace -> . MULTIPLY ID
    (142) brace -> . BIT_AND ID
    (143) brace -> . ID
    (144) brace -> . CHAR
    (145) brace -> . function_call
    (146) brace -> . ID narrayindex
    (147) NUM -> . INT_NUM
    (148) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    IF              shift and go to state 6
    WHILE           shift and go to state 7
    FOR             shift and go to state 11
    SEMICOLON       shift and go to state 13
    RETURN          shift and go to state 17
    HASH            shift and go to state 20
    TYPE            shift and go to state 22
    L_FLOWBRACE     shift and go to state 26
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    open                           shift and go to state 120
    closed                         shift and go to state 121
    for                            shift and go to state 8
    simple                         shift and go to state 9
    block                          shift and go to state 10
    expr                           shift and go to state 12
    header                         shift and go to state 14
    declaration                    shift and go to state 15
    function                       shift and go to state 16
    left_flower                    shift and go to state 18
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 54

    (9) open -> for for_condition . open
    (15) closed -> for for_condition . closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) open -> . for for_condition open
    (11) closed -> . simple
    (12) closed -> . block
    (13) closed -> . IF condition closed ELSE closed
    (14) closed -> . WHILE condition closed
    (15) closed -> . for for_condition closed
    (10) for -> . FOR
    (53) simple -> . expr SEMICOLON
    (54) simple -> . header
    (55) simple -> . declaration
    (56) simple -> . SEMICOLON
    (57) simple -> . function
    (58) simple -> . RETURN expr SEMICOLON
    (59) simple -> . RETURN SEMICOLON
    (49) block -> . left_flower multiple_statements right_flower
    (50) block -> . left_flower right_flower
    (85) expr -> . expr assignment exprOR
    (86) expr -> . exprOR
    (60) header -> . HASH INCLUDE STRING
    (61) header -> . HASH INCLUDE HEADER_FILE
    (34) declaration -> . TYPE ID SEMICOLON
    (35) declaration -> . TYPE MULTIPLY ID SEMICOLON
    (36) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (37) declaration -> . TYPE MULTIPLY ID ASSIGN expr SEMICOLON
    (38) declaration -> . TYPE multi_declaration stop
    (39) declaration -> . TYPE ID narrayindex SEMICOLON
    (40) declaration -> . TYPE ID narrayindex ASSIGN init_list SEMICOLON
    (82) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (51) left_flower -> . L_FLOWBRACE
    (98) exprOR -> . exprOR OR exprAND
    (99) exprOR -> . exprAND
    (100) exprAND -> . exprAND AND exprBITOR
    (101) exprAND -> . exprBITOR
    (102) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (103) exprBITOR -> . exprBITXOR
    (104) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (105) exprBITXOR -> . exprBITAND
    (106) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (107) exprBITAND -> . exprEQ
    (108) exprEQ -> . exprEQ EQ exprRELOP
    (109) exprEQ -> . exprEQ NE exprRELOP
    (110) exprEQ -> . exprRELOP
    (111) exprRELOP -> . exprRELOP relop exprSHIFT
    (112) exprRELOP -> . exprSHIFT
    (117) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (118) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (119) exprSHIFT -> . exprOP
    (120) exprOP -> . exprOP PLUS term
    (121) exprOP -> . exprOP MINUS term
    (122) exprOP -> . term
    (123) term -> . term MULTIPLY factor
    (124) term -> . term DIVIDE factor
    (125) term -> . term MOD factor
    (126) term -> . factor
    (127) factor -> . NOT factor
    (128) factor -> . PLUS factor
    (129) factor -> . MINUS factor
    (130) factor -> . PLUS_PLUS factor
    (131) factor -> . MINUS_MINUS factor
    (132) factor -> . cast brace
    (133) factor -> . brace
    (134) cast -> . L_PAREN TYPE R_PAREN
    (135) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (136) brace -> . L_PAREN expr R_PAREN
    (137) brace -> . brace PLUS_PLUS
    (138) brace -> . brace MINUS_MINUS
    (139) brace -> . NUM
    (140) brace -> . STRING
    (141) brace -> . MULTIPLY ID
    (142) brace -> . BIT_AND ID
    (143) brace -> . ID
    (144) brace -> . CHAR
    (145) brace -> . function_call
    (146) brace -> . ID narrayindex
    (147) NUM -> . INT_NUM
    (148) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    IF              shift and go to state 6
    WHILE           shift and go to state 7
    FOR             shift and go to state 11
    SEMICOLON       shift and go to state 13
    RETURN          shift and go to state 17
    HASH            shift and go to state 20
    TYPE            shift and go to state 22
    L_FLOWBRACE     shift and go to state 26
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    for                            shift and go to state 8
    open                           shift and go to state 122
    closed                         shift and go to state 123
    simple                         shift and go to state 9
    block                          shift and go to state 10
    expr                           shift and go to state 12
    header                         shift and go to state 14
    declaration                    shift and go to state 15
    function                       shift and go to state 16
    left_flower                    shift and go to state 18
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 55

    (17) for_condition -> L_PAREN . simple simple expr R_PAREN
    (18) for_condition -> L_PAREN . simple simple R_PAREN
    (53) simple -> . expr SEMICOLON
    (54) simple -> . header
    (55) simple -> . declaration
    (56) simple -> . SEMICOLON
    (57) simple -> . function
    (58) simple -> . RETURN expr SEMICOLON
    (59) simple -> . RETURN SEMICOLON
    (85) expr -> . expr assignment exprOR
    (86) expr -> . exprOR
    (60) header -> . HASH INCLUDE STRING
    (61) header -> . HASH INCLUDE HEADER_FILE
    (34) declaration -> . TYPE ID SEMICOLON
    (35) declaration -> . TYPE MULTIPLY ID SEMICOLON
    (36) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (37) declaration -> . TYPE MULTIPLY ID ASSIGN expr SEMICOLON
    (38) declaration -> . TYPE multi_declaration stop
    (39) declaration -> . TYPE ID narrayindex SEMICOLON
    (40) declaration -> . TYPE ID narrayindex ASSIGN init_list SEMICOLON
    (82) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (98) exprOR -> . exprOR OR exprAND
    (99) exprOR -> . exprAND
    (100) exprAND -> . exprAND AND exprBITOR
    (101) exprAND -> . exprBITOR
    (102) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (103) exprBITOR -> . exprBITXOR
    (104) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (105) exprBITXOR -> . exprBITAND
    (106) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (107) exprBITAND -> . exprEQ
    (108) exprEQ -> . exprEQ EQ exprRELOP
    (109) exprEQ -> . exprEQ NE exprRELOP
    (110) exprEQ -> . exprRELOP
    (111) exprRELOP -> . exprRELOP relop exprSHIFT
    (112) exprRELOP -> . exprSHIFT
    (117) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (118) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (119) exprSHIFT -> . exprOP
    (120) exprOP -> . exprOP PLUS term
    (121) exprOP -> . exprOP MINUS term
    (122) exprOP -> . term
    (123) term -> . term MULTIPLY factor
    (124) term -> . term DIVIDE factor
    (125) term -> . term MOD factor
    (126) term -> . factor
    (127) factor -> . NOT factor
    (128) factor -> . PLUS factor
    (129) factor -> . MINUS factor
    (130) factor -> . PLUS_PLUS factor
    (131) factor -> . MINUS_MINUS factor
    (132) factor -> . cast brace
    (133) factor -> . brace
    (134) cast -> . L_PAREN TYPE R_PAREN
    (135) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (136) brace -> . L_PAREN expr R_PAREN
    (137) brace -> . brace PLUS_PLUS
    (138) brace -> . brace MINUS_MINUS
    (139) brace -> . NUM
    (140) brace -> . STRING
    (141) brace -> . MULTIPLY ID
    (142) brace -> . BIT_AND ID
    (143) brace -> . ID
    (144) brace -> . CHAR
    (145) brace -> . function_call
    (146) brace -> . ID narrayindex
    (147) NUM -> . INT_NUM
    (148) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    SEMICOLON       shift and go to state 13
    RETURN          shift and go to state 17
    HASH            shift and go to state 20
    TYPE            shift and go to state 22
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    simple                         shift and go to state 124
    expr                           shift and go to state 12
    header                         shift and go to state 14
    declaration                    shift and go to state 15
    function                       shift and go to state 16
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 56

    (53) simple -> expr SEMICOLON .

    IF              reduce using rule 53 (simple -> expr SEMICOLON .)
    WHILE           reduce using rule 53 (simple -> expr SEMICOLON .)
    FOR             reduce using rule 53 (simple -> expr SEMICOLON .)
    SEMICOLON       reduce using rule 53 (simple -> expr SEMICOLON .)
    RETURN          reduce using rule 53 (simple -> expr SEMICOLON .)
    HASH            reduce using rule 53 (simple -> expr SEMICOLON .)
    TYPE            reduce using rule 53 (simple -> expr SEMICOLON .)
    L_FLOWBRACE     reduce using rule 53 (simple -> expr SEMICOLON .)
    NOT             reduce using rule 53 (simple -> expr SEMICOLON .)
    PLUS            reduce using rule 53 (simple -> expr SEMICOLON .)
    MINUS           reduce using rule 53 (simple -> expr SEMICOLON .)
    PLUS_PLUS       reduce using rule 53 (simple -> expr SEMICOLON .)
    MINUS_MINUS     reduce using rule 53 (simple -> expr SEMICOLON .)
    L_PAREN         reduce using rule 53 (simple -> expr SEMICOLON .)
    STRING          reduce using rule 53 (simple -> expr SEMICOLON .)
    MULTIPLY        reduce using rule 53 (simple -> expr SEMICOLON .)
    BIT_AND         reduce using rule 53 (simple -> expr SEMICOLON .)
    ID              reduce using rule 53 (simple -> expr SEMICOLON .)
    CHAR            reduce using rule 53 (simple -> expr SEMICOLON .)
    INT_NUM         reduce using rule 53 (simple -> expr SEMICOLON .)
    FLOAT_NUM       reduce using rule 53 (simple -> expr SEMICOLON .)
    $end            reduce using rule 53 (simple -> expr SEMICOLON .)
    R_FLOWBRACE     reduce using rule 53 (simple -> expr SEMICOLON .)
    ELSE            reduce using rule 53 (simple -> expr SEMICOLON .)
    R_PAREN         reduce using rule 53 (simple -> expr SEMICOLON .)


state 57

    (85) expr -> expr assignment . exprOR
    (98) exprOR -> . exprOR OR exprAND
    (99) exprOR -> . exprAND
    (100) exprAND -> . exprAND AND exprBITOR
    (101) exprAND -> . exprBITOR
    (102) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (103) exprBITOR -> . exprBITXOR
    (104) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (105) exprBITXOR -> . exprBITAND
    (106) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (107) exprBITAND -> . exprEQ
    (108) exprEQ -> . exprEQ EQ exprRELOP
    (109) exprEQ -> . exprEQ NE exprRELOP
    (110) exprEQ -> . exprRELOP
    (111) exprRELOP -> . exprRELOP relop exprSHIFT
    (112) exprRELOP -> . exprSHIFT
    (117) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (118) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (119) exprSHIFT -> . exprOP
    (120) exprOP -> . exprOP PLUS term
    (121) exprOP -> . exprOP MINUS term
    (122) exprOP -> . term
    (123) term -> . term MULTIPLY factor
    (124) term -> . term DIVIDE factor
    (125) term -> . term MOD factor
    (126) term -> . factor
    (127) factor -> . NOT factor
    (128) factor -> . PLUS factor
    (129) factor -> . MINUS factor
    (130) factor -> . PLUS_PLUS factor
    (131) factor -> . MINUS_MINUS factor
    (132) factor -> . cast brace
    (133) factor -> . brace
    (134) cast -> . L_PAREN TYPE R_PAREN
    (135) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (136) brace -> . L_PAREN expr R_PAREN
    (137) brace -> . brace PLUS_PLUS
    (138) brace -> . brace MINUS_MINUS
    (139) brace -> . NUM
    (140) brace -> . STRING
    (141) brace -> . MULTIPLY ID
    (142) brace -> . BIT_AND ID
    (143) brace -> . ID
    (144) brace -> . CHAR
    (145) brace -> . function_call
    (146) brace -> . ID narrayindex
    (147) NUM -> . INT_NUM
    (148) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    exprOR                         shift and go to state 125
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 58

    (87) assignment -> ASSIGN .

    NOT             reduce using rule 87 (assignment -> ASSIGN .)
    PLUS            reduce using rule 87 (assignment -> ASSIGN .)
    MINUS           reduce using rule 87 (assignment -> ASSIGN .)
    PLUS_PLUS       reduce using rule 87 (assignment -> ASSIGN .)
    MINUS_MINUS     reduce using rule 87 (assignment -> ASSIGN .)
    L_PAREN         reduce using rule 87 (assignment -> ASSIGN .)
    STRING          reduce using rule 87 (assignment -> ASSIGN .)
    MULTIPLY        reduce using rule 87 (assignment -> ASSIGN .)
    BIT_AND         reduce using rule 87 (assignment -> ASSIGN .)
    ID              reduce using rule 87 (assignment -> ASSIGN .)
    CHAR            reduce using rule 87 (assignment -> ASSIGN .)
    INT_NUM         reduce using rule 87 (assignment -> ASSIGN .)
    FLOAT_NUM       reduce using rule 87 (assignment -> ASSIGN .)


state 59

    (88) assignment -> PLUS_ASSIGN .

    NOT             reduce using rule 88 (assignment -> PLUS_ASSIGN .)
    PLUS            reduce using rule 88 (assignment -> PLUS_ASSIGN .)
    MINUS           reduce using rule 88 (assignment -> PLUS_ASSIGN .)
    PLUS_PLUS       reduce using rule 88 (assignment -> PLUS_ASSIGN .)
    MINUS_MINUS     reduce using rule 88 (assignment -> PLUS_ASSIGN .)
    L_PAREN         reduce using rule 88 (assignment -> PLUS_ASSIGN .)
    STRING          reduce using rule 88 (assignment -> PLUS_ASSIGN .)
    MULTIPLY        reduce using rule 88 (assignment -> PLUS_ASSIGN .)
    BIT_AND         reduce using rule 88 (assignment -> PLUS_ASSIGN .)
    ID              reduce using rule 88 (assignment -> PLUS_ASSIGN .)
    CHAR            reduce using rule 88 (assignment -> PLUS_ASSIGN .)
    INT_NUM         reduce using rule 88 (assignment -> PLUS_ASSIGN .)
    FLOAT_NUM       reduce using rule 88 (assignment -> PLUS_ASSIGN .)


state 60

    (89) assignment -> MINUS_ASSIGN .

    NOT             reduce using rule 89 (assignment -> MINUS_ASSIGN .)
    PLUS            reduce using rule 89 (assignment -> MINUS_ASSIGN .)
    MINUS           reduce using rule 89 (assignment -> MINUS_ASSIGN .)
    PLUS_PLUS       reduce using rule 89 (assignment -> MINUS_ASSIGN .)
    MINUS_MINUS     reduce using rule 89 (assignment -> MINUS_ASSIGN .)
    L_PAREN         reduce using rule 89 (assignment -> MINUS_ASSIGN .)
    STRING          reduce using rule 89 (assignment -> MINUS_ASSIGN .)
    MULTIPLY        reduce using rule 89 (assignment -> MINUS_ASSIGN .)
    BIT_AND         reduce using rule 89 (assignment -> MINUS_ASSIGN .)
    ID              reduce using rule 89 (assignment -> MINUS_ASSIGN .)
    CHAR            reduce using rule 89 (assignment -> MINUS_ASSIGN .)
    INT_NUM         reduce using rule 89 (assignment -> MINUS_ASSIGN .)
    FLOAT_NUM       reduce using rule 89 (assignment -> MINUS_ASSIGN .)


state 61

    (90) assignment -> MUL_ASSIGN .

    NOT             reduce using rule 90 (assignment -> MUL_ASSIGN .)
    PLUS            reduce using rule 90 (assignment -> MUL_ASSIGN .)
    MINUS           reduce using rule 90 (assignment -> MUL_ASSIGN .)
    PLUS_PLUS       reduce using rule 90 (assignment -> MUL_ASSIGN .)
    MINUS_MINUS     reduce using rule 90 (assignment -> MUL_ASSIGN .)
    L_PAREN         reduce using rule 90 (assignment -> MUL_ASSIGN .)
    STRING          reduce using rule 90 (assignment -> MUL_ASSIGN .)
    MULTIPLY        reduce using rule 90 (assignment -> MUL_ASSIGN .)
    BIT_AND         reduce using rule 90 (assignment -> MUL_ASSIGN .)
    ID              reduce using rule 90 (assignment -> MUL_ASSIGN .)
    CHAR            reduce using rule 90 (assignment -> MUL_ASSIGN .)
    INT_NUM         reduce using rule 90 (assignment -> MUL_ASSIGN .)
    FLOAT_NUM       reduce using rule 90 (assignment -> MUL_ASSIGN .)


state 62

    (91) assignment -> DIV_ASSIGN .

    NOT             reduce using rule 91 (assignment -> DIV_ASSIGN .)
    PLUS            reduce using rule 91 (assignment -> DIV_ASSIGN .)
    MINUS           reduce using rule 91 (assignment -> DIV_ASSIGN .)
    PLUS_PLUS       reduce using rule 91 (assignment -> DIV_ASSIGN .)
    MINUS_MINUS     reduce using rule 91 (assignment -> DIV_ASSIGN .)
    L_PAREN         reduce using rule 91 (assignment -> DIV_ASSIGN .)
    STRING          reduce using rule 91 (assignment -> DIV_ASSIGN .)
    MULTIPLY        reduce using rule 91 (assignment -> DIV_ASSIGN .)
    BIT_AND         reduce using rule 91 (assignment -> DIV_ASSIGN .)
    ID              reduce using rule 91 (assignment -> DIV_ASSIGN .)
    CHAR            reduce using rule 91 (assignment -> DIV_ASSIGN .)
    INT_NUM         reduce using rule 91 (assignment -> DIV_ASSIGN .)
    FLOAT_NUM       reduce using rule 91 (assignment -> DIV_ASSIGN .)


state 63

    (92) assignment -> AND_ASSIGN .

    NOT             reduce using rule 92 (assignment -> AND_ASSIGN .)
    PLUS            reduce using rule 92 (assignment -> AND_ASSIGN .)
    MINUS           reduce using rule 92 (assignment -> AND_ASSIGN .)
    PLUS_PLUS       reduce using rule 92 (assignment -> AND_ASSIGN .)
    MINUS_MINUS     reduce using rule 92 (assignment -> AND_ASSIGN .)
    L_PAREN         reduce using rule 92 (assignment -> AND_ASSIGN .)
    STRING          reduce using rule 92 (assignment -> AND_ASSIGN .)
    MULTIPLY        reduce using rule 92 (assignment -> AND_ASSIGN .)
    BIT_AND         reduce using rule 92 (assignment -> AND_ASSIGN .)
    ID              reduce using rule 92 (assignment -> AND_ASSIGN .)
    CHAR            reduce using rule 92 (assignment -> AND_ASSIGN .)
    INT_NUM         reduce using rule 92 (assignment -> AND_ASSIGN .)
    FLOAT_NUM       reduce using rule 92 (assignment -> AND_ASSIGN .)


state 64

    (93) assignment -> OR_ASSIGN .

    NOT             reduce using rule 93 (assignment -> OR_ASSIGN .)
    PLUS            reduce using rule 93 (assignment -> OR_ASSIGN .)
    MINUS           reduce using rule 93 (assignment -> OR_ASSIGN .)
    PLUS_PLUS       reduce using rule 93 (assignment -> OR_ASSIGN .)
    MINUS_MINUS     reduce using rule 93 (assignment -> OR_ASSIGN .)
    L_PAREN         reduce using rule 93 (assignment -> OR_ASSIGN .)
    STRING          reduce using rule 93 (assignment -> OR_ASSIGN .)
    MULTIPLY        reduce using rule 93 (assignment -> OR_ASSIGN .)
    BIT_AND         reduce using rule 93 (assignment -> OR_ASSIGN .)
    ID              reduce using rule 93 (assignment -> OR_ASSIGN .)
    CHAR            reduce using rule 93 (assignment -> OR_ASSIGN .)
    INT_NUM         reduce using rule 93 (assignment -> OR_ASSIGN .)
    FLOAT_NUM       reduce using rule 93 (assignment -> OR_ASSIGN .)


state 65

    (94) assignment -> XOR_ASSIGN .

    NOT             reduce using rule 94 (assignment -> XOR_ASSIGN .)
    PLUS            reduce using rule 94 (assignment -> XOR_ASSIGN .)
    MINUS           reduce using rule 94 (assignment -> XOR_ASSIGN .)
    PLUS_PLUS       reduce using rule 94 (assignment -> XOR_ASSIGN .)
    MINUS_MINUS     reduce using rule 94 (assignment -> XOR_ASSIGN .)
    L_PAREN         reduce using rule 94 (assignment -> XOR_ASSIGN .)
    STRING          reduce using rule 94 (assignment -> XOR_ASSIGN .)
    MULTIPLY        reduce using rule 94 (assignment -> XOR_ASSIGN .)
    BIT_AND         reduce using rule 94 (assignment -> XOR_ASSIGN .)
    ID              reduce using rule 94 (assignment -> XOR_ASSIGN .)
    CHAR            reduce using rule 94 (assignment -> XOR_ASSIGN .)
    INT_NUM         reduce using rule 94 (assignment -> XOR_ASSIGN .)
    FLOAT_NUM       reduce using rule 94 (assignment -> XOR_ASSIGN .)


state 66

    (95) assignment -> MOD_ASSIGN .

    NOT             reduce using rule 95 (assignment -> MOD_ASSIGN .)
    PLUS            reduce using rule 95 (assignment -> MOD_ASSIGN .)
    MINUS           reduce using rule 95 (assignment -> MOD_ASSIGN .)
    PLUS_PLUS       reduce using rule 95 (assignment -> MOD_ASSIGN .)
    MINUS_MINUS     reduce using rule 95 (assignment -> MOD_ASSIGN .)
    L_PAREN         reduce using rule 95 (assignment -> MOD_ASSIGN .)
    STRING          reduce using rule 95 (assignment -> MOD_ASSIGN .)
    MULTIPLY        reduce using rule 95 (assignment -> MOD_ASSIGN .)
    BIT_AND         reduce using rule 95 (assignment -> MOD_ASSIGN .)
    ID              reduce using rule 95 (assignment -> MOD_ASSIGN .)
    CHAR            reduce using rule 95 (assignment -> MOD_ASSIGN .)
    INT_NUM         reduce using rule 95 (assignment -> MOD_ASSIGN .)
    FLOAT_NUM       reduce using rule 95 (assignment -> MOD_ASSIGN .)


state 67

    (96) assignment -> L_SHIFT_ASSIGN .

    NOT             reduce using rule 96 (assignment -> L_SHIFT_ASSIGN .)
    PLUS            reduce using rule 96 (assignment -> L_SHIFT_ASSIGN .)
    MINUS           reduce using rule 96 (assignment -> L_SHIFT_ASSIGN .)
    PLUS_PLUS       reduce using rule 96 (assignment -> L_SHIFT_ASSIGN .)
    MINUS_MINUS     reduce using rule 96 (assignment -> L_SHIFT_ASSIGN .)
    L_PAREN         reduce using rule 96 (assignment -> L_SHIFT_ASSIGN .)
    STRING          reduce using rule 96 (assignment -> L_SHIFT_ASSIGN .)
    MULTIPLY        reduce using rule 96 (assignment -> L_SHIFT_ASSIGN .)
    BIT_AND         reduce using rule 96 (assignment -> L_SHIFT_ASSIGN .)
    ID              reduce using rule 96 (assignment -> L_SHIFT_ASSIGN .)
    CHAR            reduce using rule 96 (assignment -> L_SHIFT_ASSIGN .)
    INT_NUM         reduce using rule 96 (assignment -> L_SHIFT_ASSIGN .)
    FLOAT_NUM       reduce using rule 96 (assignment -> L_SHIFT_ASSIGN .)


state 68

    (97) assignment -> R_SHIFT_ASSIGN .

    NOT             reduce using rule 97 (assignment -> R_SHIFT_ASSIGN .)
    PLUS            reduce using rule 97 (assignment -> R_SHIFT_ASSIGN .)
    MINUS           reduce using rule 97 (assignment -> R_SHIFT_ASSIGN .)
    PLUS_PLUS       reduce using rule 97 (assignment -> R_SHIFT_ASSIGN .)
    MINUS_MINUS     reduce using rule 97 (assignment -> R_SHIFT_ASSIGN .)
    L_PAREN         reduce using rule 97 (assignment -> R_SHIFT_ASSIGN .)
    STRING          reduce using rule 97 (assignment -> R_SHIFT_ASSIGN .)
    MULTIPLY        reduce using rule 97 (assignment -> R_SHIFT_ASSIGN .)
    BIT_AND         reduce using rule 97 (assignment -> R_SHIFT_ASSIGN .)
    ID              reduce using rule 97 (assignment -> R_SHIFT_ASSIGN .)
    CHAR            reduce using rule 97 (assignment -> R_SHIFT_ASSIGN .)
    INT_NUM         reduce using rule 97 (assignment -> R_SHIFT_ASSIGN .)
    FLOAT_NUM       reduce using rule 97 (assignment -> R_SHIFT_ASSIGN .)


state 69

    (58) simple -> RETURN expr . SEMICOLON
    (85) expr -> expr . assignment exprOR
    (87) assignment -> . ASSIGN
    (88) assignment -> . PLUS_ASSIGN
    (89) assignment -> . MINUS_ASSIGN
    (90) assignment -> . MUL_ASSIGN
    (91) assignment -> . DIV_ASSIGN
    (92) assignment -> . AND_ASSIGN
    (93) assignment -> . OR_ASSIGN
    (94) assignment -> . XOR_ASSIGN
    (95) assignment -> . MOD_ASSIGN
    (96) assignment -> . L_SHIFT_ASSIGN
    (97) assignment -> . R_SHIFT_ASSIGN

    SEMICOLON       shift and go to state 126
    ASSIGN          shift and go to state 58
    PLUS_ASSIGN     shift and go to state 59
    MINUS_ASSIGN    shift and go to state 60
    MUL_ASSIGN      shift and go to state 61
    DIV_ASSIGN      shift and go to state 62
    AND_ASSIGN      shift and go to state 63
    OR_ASSIGN       shift and go to state 64
    XOR_ASSIGN      shift and go to state 65
    MOD_ASSIGN      shift and go to state 66
    L_SHIFT_ASSIGN  shift and go to state 67
    R_SHIFT_ASSIGN  shift and go to state 68

    assignment                     shift and go to state 57

state 70

    (59) simple -> RETURN SEMICOLON .

    IF              reduce using rule 59 (simple -> RETURN SEMICOLON .)
    WHILE           reduce using rule 59 (simple -> RETURN SEMICOLON .)
    FOR             reduce using rule 59 (simple -> RETURN SEMICOLON .)
    SEMICOLON       reduce using rule 59 (simple -> RETURN SEMICOLON .)
    RETURN          reduce using rule 59 (simple -> RETURN SEMICOLON .)
    HASH            reduce using rule 59 (simple -> RETURN SEMICOLON .)
    TYPE            reduce using rule 59 (simple -> RETURN SEMICOLON .)
    L_FLOWBRACE     reduce using rule 59 (simple -> RETURN SEMICOLON .)
    NOT             reduce using rule 59 (simple -> RETURN SEMICOLON .)
    PLUS            reduce using rule 59 (simple -> RETURN SEMICOLON .)
    MINUS           reduce using rule 59 (simple -> RETURN SEMICOLON .)
    PLUS_PLUS       reduce using rule 59 (simple -> RETURN SEMICOLON .)
    MINUS_MINUS     reduce using rule 59 (simple -> RETURN SEMICOLON .)
    L_PAREN         reduce using rule 59 (simple -> RETURN SEMICOLON .)
    STRING          reduce using rule 59 (simple -> RETURN SEMICOLON .)
    MULTIPLY        reduce using rule 59 (simple -> RETURN SEMICOLON .)
    BIT_AND         reduce using rule 59 (simple -> RETURN SEMICOLON .)
    ID              reduce using rule 59 (simple -> RETURN SEMICOLON .)
    CHAR            reduce using rule 59 (simple -> RETURN SEMICOLON .)
    INT_NUM         reduce using rule 59 (simple -> RETURN SEMICOLON .)
    FLOAT_NUM       reduce using rule 59 (simple -> RETURN SEMICOLON .)
    $end            reduce using rule 59 (simple -> RETURN SEMICOLON .)
    R_FLOWBRACE     reduce using rule 59 (simple -> RETURN SEMICOLON .)
    ELSE            reduce using rule 59 (simple -> RETURN SEMICOLON .)
    R_PAREN         reduce using rule 59 (simple -> RETURN SEMICOLON .)


state 71

    (49) block -> left_flower multiple_statements . right_flower
    (2) multiple_statements -> multiple_statements . statement
    (52) right_flower -> . R_FLOWBRACE
    (4) statement -> . open
    (5) statement -> . closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) open -> . for for_condition open
    (11) closed -> . simple
    (12) closed -> . block
    (13) closed -> . IF condition closed ELSE closed
    (14) closed -> . WHILE condition closed
    (15) closed -> . for for_condition closed
    (10) for -> . FOR
    (53) simple -> . expr SEMICOLON
    (54) simple -> . header
    (55) simple -> . declaration
    (56) simple -> . SEMICOLON
    (57) simple -> . function
    (58) simple -> . RETURN expr SEMICOLON
    (59) simple -> . RETURN SEMICOLON
    (49) block -> . left_flower multiple_statements right_flower
    (50) block -> . left_flower right_flower
    (85) expr -> . expr assignment exprOR
    (86) expr -> . exprOR
    (60) header -> . HASH INCLUDE STRING
    (61) header -> . HASH INCLUDE HEADER_FILE
    (34) declaration -> . TYPE ID SEMICOLON
    (35) declaration -> . TYPE MULTIPLY ID SEMICOLON
    (36) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (37) declaration -> . TYPE MULTIPLY ID ASSIGN expr SEMICOLON
    (38) declaration -> . TYPE multi_declaration stop
    (39) declaration -> . TYPE ID narrayindex SEMICOLON
    (40) declaration -> . TYPE ID narrayindex ASSIGN init_list SEMICOLON
    (82) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (51) left_flower -> . L_FLOWBRACE
    (98) exprOR -> . exprOR OR exprAND
    (99) exprOR -> . exprAND
    (100) exprAND -> . exprAND AND exprBITOR
    (101) exprAND -> . exprBITOR
    (102) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (103) exprBITOR -> . exprBITXOR
    (104) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (105) exprBITXOR -> . exprBITAND
    (106) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (107) exprBITAND -> . exprEQ
    (108) exprEQ -> . exprEQ EQ exprRELOP
    (109) exprEQ -> . exprEQ NE exprRELOP
    (110) exprEQ -> . exprRELOP
    (111) exprRELOP -> . exprRELOP relop exprSHIFT
    (112) exprRELOP -> . exprSHIFT
    (117) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (118) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (119) exprSHIFT -> . exprOP
    (120) exprOP -> . exprOP PLUS term
    (121) exprOP -> . exprOP MINUS term
    (122) exprOP -> . term
    (123) term -> . term MULTIPLY factor
    (124) term -> . term DIVIDE factor
    (125) term -> . term MOD factor
    (126) term -> . factor
    (127) factor -> . NOT factor
    (128) factor -> . PLUS factor
    (129) factor -> . MINUS factor
    (130) factor -> . PLUS_PLUS factor
    (131) factor -> . MINUS_MINUS factor
    (132) factor -> . cast brace
    (133) factor -> . brace
    (134) cast -> . L_PAREN TYPE R_PAREN
    (135) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (136) brace -> . L_PAREN expr R_PAREN
    (137) brace -> . brace PLUS_PLUS
    (138) brace -> . brace MINUS_MINUS
    (139) brace -> . NUM
    (140) brace -> . STRING
    (141) brace -> . MULTIPLY ID
    (142) brace -> . BIT_AND ID
    (143) brace -> . ID
    (144) brace -> . CHAR
    (145) brace -> . function_call
    (146) brace -> . ID narrayindex
    (147) NUM -> . INT_NUM
    (148) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    R_FLOWBRACE     shift and go to state 73
    IF              shift and go to state 6
    WHILE           shift and go to state 7
    FOR             shift and go to state 11
    SEMICOLON       shift and go to state 13
    RETURN          shift and go to state 17
    HASH            shift and go to state 20
    TYPE            shift and go to state 22
    L_FLOWBRACE     shift and go to state 26
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    left_flower                    shift and go to state 18
    right_flower                   shift and go to state 127
    statement                      shift and go to state 50
    open                           shift and go to state 4
    closed                         shift and go to state 5
    for                            shift and go to state 8
    simple                         shift and go to state 9
    block                          shift and go to state 10
    expr                           shift and go to state 12
    header                         shift and go to state 14
    declaration                    shift and go to state 15
    function                       shift and go to state 16
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 72

    (50) block -> left_flower right_flower .

    IF              reduce using rule 50 (block -> left_flower right_flower .)
    WHILE           reduce using rule 50 (block -> left_flower right_flower .)
    FOR             reduce using rule 50 (block -> left_flower right_flower .)
    SEMICOLON       reduce using rule 50 (block -> left_flower right_flower .)
    RETURN          reduce using rule 50 (block -> left_flower right_flower .)
    HASH            reduce using rule 50 (block -> left_flower right_flower .)
    TYPE            reduce using rule 50 (block -> left_flower right_flower .)
    L_FLOWBRACE     reduce using rule 50 (block -> left_flower right_flower .)
    NOT             reduce using rule 50 (block -> left_flower right_flower .)
    PLUS            reduce using rule 50 (block -> left_flower right_flower .)
    MINUS           reduce using rule 50 (block -> left_flower right_flower .)
    PLUS_PLUS       reduce using rule 50 (block -> left_flower right_flower .)
    MINUS_MINUS     reduce using rule 50 (block -> left_flower right_flower .)
    L_PAREN         reduce using rule 50 (block -> left_flower right_flower .)
    STRING          reduce using rule 50 (block -> left_flower right_flower .)
    MULTIPLY        reduce using rule 50 (block -> left_flower right_flower .)
    BIT_AND         reduce using rule 50 (block -> left_flower right_flower .)
    ID              reduce using rule 50 (block -> left_flower right_flower .)
    CHAR            reduce using rule 50 (block -> left_flower right_flower .)
    INT_NUM         reduce using rule 50 (block -> left_flower right_flower .)
    FLOAT_NUM       reduce using rule 50 (block -> left_flower right_flower .)
    $end            reduce using rule 50 (block -> left_flower right_flower .)
    R_FLOWBRACE     reduce using rule 50 (block -> left_flower right_flower .)
    ELSE            reduce using rule 50 (block -> left_flower right_flower .)
    R_PAREN         reduce using rule 50 (block -> left_flower right_flower .)


state 73

    (52) right_flower -> R_FLOWBRACE .

    IF              reduce using rule 52 (right_flower -> R_FLOWBRACE .)
    WHILE           reduce using rule 52 (right_flower -> R_FLOWBRACE .)
    FOR             reduce using rule 52 (right_flower -> R_FLOWBRACE .)
    SEMICOLON       reduce using rule 52 (right_flower -> R_FLOWBRACE .)
    RETURN          reduce using rule 52 (right_flower -> R_FLOWBRACE .)
    HASH            reduce using rule 52 (right_flower -> R_FLOWBRACE .)
    TYPE            reduce using rule 52 (right_flower -> R_FLOWBRACE .)
    L_FLOWBRACE     reduce using rule 52 (right_flower -> R_FLOWBRACE .)
    NOT             reduce using rule 52 (right_flower -> R_FLOWBRACE .)
    PLUS            reduce using rule 52 (right_flower -> R_FLOWBRACE .)
    MINUS           reduce using rule 52 (right_flower -> R_FLOWBRACE .)
    PLUS_PLUS       reduce using rule 52 (right_flower -> R_FLOWBRACE .)
    MINUS_MINUS     reduce using rule 52 (right_flower -> R_FLOWBRACE .)
    L_PAREN         reduce using rule 52 (right_flower -> R_FLOWBRACE .)
    STRING          reduce using rule 52 (right_flower -> R_FLOWBRACE .)
    MULTIPLY        reduce using rule 52 (right_flower -> R_FLOWBRACE .)
    BIT_AND         reduce using rule 52 (right_flower -> R_FLOWBRACE .)
    ID              reduce using rule 52 (right_flower -> R_FLOWBRACE .)
    CHAR            reduce using rule 52 (right_flower -> R_FLOWBRACE .)
    INT_NUM         reduce using rule 52 (right_flower -> R_FLOWBRACE .)
    FLOAT_NUM       reduce using rule 52 (right_flower -> R_FLOWBRACE .)
    $end            reduce using rule 52 (right_flower -> R_FLOWBRACE .)
    R_FLOWBRACE     reduce using rule 52 (right_flower -> R_FLOWBRACE .)
    ELSE            reduce using rule 52 (right_flower -> R_FLOWBRACE .)
    R_PAREN         reduce using rule 52 (right_flower -> R_FLOWBRACE .)


state 74

    (98) exprOR -> exprOR OR . exprAND
    (100) exprAND -> . exprAND AND exprBITOR
    (101) exprAND -> . exprBITOR
    (102) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (103) exprBITOR -> . exprBITXOR
    (104) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (105) exprBITXOR -> . exprBITAND
    (106) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (107) exprBITAND -> . exprEQ
    (108) exprEQ -> . exprEQ EQ exprRELOP
    (109) exprEQ -> . exprEQ NE exprRELOP
    (110) exprEQ -> . exprRELOP
    (111) exprRELOP -> . exprRELOP relop exprSHIFT
    (112) exprRELOP -> . exprSHIFT
    (117) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (118) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (119) exprSHIFT -> . exprOP
    (120) exprOP -> . exprOP PLUS term
    (121) exprOP -> . exprOP MINUS term
    (122) exprOP -> . term
    (123) term -> . term MULTIPLY factor
    (124) term -> . term DIVIDE factor
    (125) term -> . term MOD factor
    (126) term -> . factor
    (127) factor -> . NOT factor
    (128) factor -> . PLUS factor
    (129) factor -> . MINUS factor
    (130) factor -> . PLUS_PLUS factor
    (131) factor -> . MINUS_MINUS factor
    (132) factor -> . cast brace
    (133) factor -> . brace
    (134) cast -> . L_PAREN TYPE R_PAREN
    (135) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (136) brace -> . L_PAREN expr R_PAREN
    (137) brace -> . brace PLUS_PLUS
    (138) brace -> . brace MINUS_MINUS
    (139) brace -> . NUM
    (140) brace -> . STRING
    (141) brace -> . MULTIPLY ID
    (142) brace -> . BIT_AND ID
    (143) brace -> . ID
    (144) brace -> . CHAR
    (145) brace -> . function_call
    (146) brace -> . ID narrayindex
    (147) NUM -> . INT_NUM
    (148) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    exprAND                        shift and go to state 128
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 75

    (60) header -> HASH INCLUDE . STRING
    (61) header -> HASH INCLUDE . HEADER_FILE

    STRING          shift and go to state 129
    HEADER_FILE     shift and go to state 130


state 76

    (34) declaration -> TYPE ID . SEMICOLON
    (36) declaration -> TYPE ID . ASSIGN expr SEMICOLON
    (39) declaration -> TYPE ID . narrayindex SEMICOLON
    (40) declaration -> TYPE ID . narrayindex ASSIGN init_list SEMICOLON
    (82) function -> TYPE ID . L_PAREN dec_params R_PAREN function_2
    (23) multi_declaration -> ID . COMMA
    (24) multi_declaration -> ID . ASSIGN expr COMMA
    (32) narrayindex -> . narrayindex arrayindex
    (33) narrayindex -> . arrayindex
    (31) arrayindex -> . L_SQBRACE index R_SQBRACE

    SEMICOLON       shift and go to state 131
    ASSIGN          shift and go to state 132
    L_PAREN         shift and go to state 134
    COMMA           shift and go to state 135
    L_SQBRACE       shift and go to state 82

    narrayindex                    shift and go to state 133
    arrayindex                     shift and go to state 81

state 77

    (35) declaration -> TYPE MULTIPLY . ID SEMICOLON
    (37) declaration -> TYPE MULTIPLY . ID ASSIGN expr SEMICOLON
    (25) multi_declaration -> MULTIPLY . ID COMMA
    (26) multi_declaration -> MULTIPLY . ID ASSIGN expr COMMA

    ID              shift and go to state 136


state 78

    (38) declaration -> TYPE multi_declaration . stop
    (19) multi_declaration -> multi_declaration . ID COMMA
    (20) multi_declaration -> multi_declaration . MULTIPLY ID COMMA
    (21) multi_declaration -> multi_declaration . ID ASSIGN expr COMMA
    (22) multi_declaration -> multi_declaration . MULTIPLY ID ASSIGN expr COMMA
    (27) stop -> . ID SEMICOLON
    (28) stop -> . MULTIPLY ID SEMICOLON
    (29) stop -> . ID ASSIGN expr SEMICOLON
    (30) stop -> . MULTIPLY ID ASSIGN expr SEMICOLON

    ID              shift and go to state 138
    MULTIPLY        shift and go to state 139

    stop                           shift and go to state 137

state 79

    (146) brace -> ID narrayindex .
    (32) narrayindex -> narrayindex . arrayindex
    (31) arrayindex -> . L_SQBRACE index R_SQBRACE

    PLUS_PLUS       reduce using rule 146 (brace -> ID narrayindex .)
    MINUS_MINUS     reduce using rule 146 (brace -> ID narrayindex .)
    MULTIPLY        reduce using rule 146 (brace -> ID narrayindex .)
    DIVIDE          reduce using rule 146 (brace -> ID narrayindex .)
    MOD             reduce using rule 146 (brace -> ID narrayindex .)
    PLUS            reduce using rule 146 (brace -> ID narrayindex .)
    MINUS           reduce using rule 146 (brace -> ID narrayindex .)
    L_SHIFT         reduce using rule 146 (brace -> ID narrayindex .)
    R_SHIFT         reduce using rule 146 (brace -> ID narrayindex .)
    LE              reduce using rule 146 (brace -> ID narrayindex .)
    LT              reduce using rule 146 (brace -> ID narrayindex .)
    GE              reduce using rule 146 (brace -> ID narrayindex .)
    GT              reduce using rule 146 (brace -> ID narrayindex .)
    EQ              reduce using rule 146 (brace -> ID narrayindex .)
    NE              reduce using rule 146 (brace -> ID narrayindex .)
    BIT_AND         reduce using rule 146 (brace -> ID narrayindex .)
    BIT_XOR         reduce using rule 146 (brace -> ID narrayindex .)
    BIT_OR          reduce using rule 146 (brace -> ID narrayindex .)
    AND             reduce using rule 146 (brace -> ID narrayindex .)
    OR              reduce using rule 146 (brace -> ID narrayindex .)
    SEMICOLON       reduce using rule 146 (brace -> ID narrayindex .)
    ASSIGN          reduce using rule 146 (brace -> ID narrayindex .)
    PLUS_ASSIGN     reduce using rule 146 (brace -> ID narrayindex .)
    MINUS_ASSIGN    reduce using rule 146 (brace -> ID narrayindex .)
    MUL_ASSIGN      reduce using rule 146 (brace -> ID narrayindex .)
    DIV_ASSIGN      reduce using rule 146 (brace -> ID narrayindex .)
    AND_ASSIGN      reduce using rule 146 (brace -> ID narrayindex .)
    OR_ASSIGN       reduce using rule 146 (brace -> ID narrayindex .)
    XOR_ASSIGN      reduce using rule 146 (brace -> ID narrayindex .)
    MOD_ASSIGN      reduce using rule 146 (brace -> ID narrayindex .)
    L_SHIFT_ASSIGN  reduce using rule 146 (brace -> ID narrayindex .)
    R_SHIFT_ASSIGN  reduce using rule 146 (brace -> ID narrayindex .)
    R_PAREN         reduce using rule 146 (brace -> ID narrayindex .)
    COMMA           reduce using rule 146 (brace -> ID narrayindex .)
    R_SQBRACE       reduce using rule 146 (brace -> ID narrayindex .)
    R_FLOWBRACE     reduce using rule 146 (brace -> ID narrayindex .)
    L_SQBRACE       shift and go to state 82

    arrayindex                     shift and go to state 140

state 80

    (63) function_call -> ID L_PAREN . call_params R_PAREN
    (64) call_params -> . empty
    (65) call_params -> . yes_call_params end_call_params
    (66) call_params -> . end_call_params
    (62) empty -> .
    (67) yes_call_params -> . yes_call_params expr COMMA
    (68) yes_call_params -> . expr COMMA
    (69) end_call_params -> . expr
    (85) expr -> . expr assignment exprOR
    (86) expr -> . exprOR
    (98) exprOR -> . exprOR OR exprAND
    (99) exprOR -> . exprAND
    (100) exprAND -> . exprAND AND exprBITOR
    (101) exprAND -> . exprBITOR
    (102) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (103) exprBITOR -> . exprBITXOR
    (104) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (105) exprBITXOR -> . exprBITAND
    (106) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (107) exprBITAND -> . exprEQ
    (108) exprEQ -> . exprEQ EQ exprRELOP
    (109) exprEQ -> . exprEQ NE exprRELOP
    (110) exprEQ -> . exprRELOP
    (111) exprRELOP -> . exprRELOP relop exprSHIFT
    (112) exprRELOP -> . exprSHIFT
    (117) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (118) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (119) exprSHIFT -> . exprOP
    (120) exprOP -> . exprOP PLUS term
    (121) exprOP -> . exprOP MINUS term
    (122) exprOP -> . term
    (123) term -> . term MULTIPLY factor
    (124) term -> . term DIVIDE factor
    (125) term -> . term MOD factor
    (126) term -> . factor
    (127) factor -> . NOT factor
    (128) factor -> . PLUS factor
    (129) factor -> . MINUS factor
    (130) factor -> . PLUS_PLUS factor
    (131) factor -> . MINUS_MINUS factor
    (132) factor -> . cast brace
    (133) factor -> . brace
    (134) cast -> . L_PAREN TYPE R_PAREN
    (135) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (136) brace -> . L_PAREN expr R_PAREN
    (137) brace -> . brace PLUS_PLUS
    (138) brace -> . brace MINUS_MINUS
    (139) brace -> . NUM
    (140) brace -> . STRING
    (141) brace -> . MULTIPLY ID
    (142) brace -> . BIT_AND ID
    (143) brace -> . ID
    (144) brace -> . CHAR
    (145) brace -> . function_call
    (146) brace -> . ID narrayindex
    (147) NUM -> . INT_NUM
    (148) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    R_PAREN         reduce using rule 62 (empty -> .)
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    call_params                    shift and go to state 141
    empty                          shift and go to state 142
    yes_call_params                shift and go to state 143
    end_call_params                shift and go to state 144
    expr                           shift and go to state 145
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 81

    (33) narrayindex -> arrayindex .

    L_SQBRACE       reduce using rule 33 (narrayindex -> arrayindex .)
    PLUS_PLUS       reduce using rule 33 (narrayindex -> arrayindex .)
    MINUS_MINUS     reduce using rule 33 (narrayindex -> arrayindex .)
    MULTIPLY        reduce using rule 33 (narrayindex -> arrayindex .)
    DIVIDE          reduce using rule 33 (narrayindex -> arrayindex .)
    MOD             reduce using rule 33 (narrayindex -> arrayindex .)
    PLUS            reduce using rule 33 (narrayindex -> arrayindex .)
    MINUS           reduce using rule 33 (narrayindex -> arrayindex .)
    L_SHIFT         reduce using rule 33 (narrayindex -> arrayindex .)
    R_SHIFT         reduce using rule 33 (narrayindex -> arrayindex .)
    LE              reduce using rule 33 (narrayindex -> arrayindex .)
    LT              reduce using rule 33 (narrayindex -> arrayindex .)
    GE              reduce using rule 33 (narrayindex -> arrayindex .)
    GT              reduce using rule 33 (narrayindex -> arrayindex .)
    EQ              reduce using rule 33 (narrayindex -> arrayindex .)
    NE              reduce using rule 33 (narrayindex -> arrayindex .)
    BIT_AND         reduce using rule 33 (narrayindex -> arrayindex .)
    BIT_XOR         reduce using rule 33 (narrayindex -> arrayindex .)
    BIT_OR          reduce using rule 33 (narrayindex -> arrayindex .)
    AND             reduce using rule 33 (narrayindex -> arrayindex .)
    OR              reduce using rule 33 (narrayindex -> arrayindex .)
    SEMICOLON       reduce using rule 33 (narrayindex -> arrayindex .)
    ASSIGN          reduce using rule 33 (narrayindex -> arrayindex .)
    PLUS_ASSIGN     reduce using rule 33 (narrayindex -> arrayindex .)
    MINUS_ASSIGN    reduce using rule 33 (narrayindex -> arrayindex .)
    MUL_ASSIGN      reduce using rule 33 (narrayindex -> arrayindex .)
    DIV_ASSIGN      reduce using rule 33 (narrayindex -> arrayindex .)
    AND_ASSIGN      reduce using rule 33 (narrayindex -> arrayindex .)
    OR_ASSIGN       reduce using rule 33 (narrayindex -> arrayindex .)
    XOR_ASSIGN      reduce using rule 33 (narrayindex -> arrayindex .)
    MOD_ASSIGN      reduce using rule 33 (narrayindex -> arrayindex .)
    L_SHIFT_ASSIGN  reduce using rule 33 (narrayindex -> arrayindex .)
    R_SHIFT_ASSIGN  reduce using rule 33 (narrayindex -> arrayindex .)
    R_PAREN         reduce using rule 33 (narrayindex -> arrayindex .)
    COMMA           reduce using rule 33 (narrayindex -> arrayindex .)
    R_SQBRACE       reduce using rule 33 (narrayindex -> arrayindex .)
    R_FLOWBRACE     reduce using rule 33 (narrayindex -> arrayindex .)


state 82

    (31) arrayindex -> L_SQBRACE . index R_SQBRACE
    (47) index -> . expr
    (48) index -> . empty
    (85) expr -> . expr assignment exprOR
    (86) expr -> . exprOR
    (62) empty -> .
    (98) exprOR -> . exprOR OR exprAND
    (99) exprOR -> . exprAND
    (100) exprAND -> . exprAND AND exprBITOR
    (101) exprAND -> . exprBITOR
    (102) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (103) exprBITOR -> . exprBITXOR
    (104) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (105) exprBITXOR -> . exprBITAND
    (106) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (107) exprBITAND -> . exprEQ
    (108) exprEQ -> . exprEQ EQ exprRELOP
    (109) exprEQ -> . exprEQ NE exprRELOP
    (110) exprEQ -> . exprRELOP
    (111) exprRELOP -> . exprRELOP relop exprSHIFT
    (112) exprRELOP -> . exprSHIFT
    (117) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (118) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (119) exprSHIFT -> . exprOP
    (120) exprOP -> . exprOP PLUS term
    (121) exprOP -> . exprOP MINUS term
    (122) exprOP -> . term
    (123) term -> . term MULTIPLY factor
    (124) term -> . term DIVIDE factor
    (125) term -> . term MOD factor
    (126) term -> . factor
    (127) factor -> . NOT factor
    (128) factor -> . PLUS factor
    (129) factor -> . MINUS factor
    (130) factor -> . PLUS_PLUS factor
    (131) factor -> . MINUS_MINUS factor
    (132) factor -> . cast brace
    (133) factor -> . brace
    (134) cast -> . L_PAREN TYPE R_PAREN
    (135) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (136) brace -> . L_PAREN expr R_PAREN
    (137) brace -> . brace PLUS_PLUS
    (138) brace -> . brace MINUS_MINUS
    (139) brace -> . NUM
    (140) brace -> . STRING
    (141) brace -> . MULTIPLY ID
    (142) brace -> . BIT_AND ID
    (143) brace -> . ID
    (144) brace -> . CHAR
    (145) brace -> . function_call
    (146) brace -> . ID narrayindex
    (147) NUM -> . INT_NUM
    (148) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    R_SQBRACE       reduce using rule 62 (empty -> .)
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    index                          shift and go to state 146
    expr                           shift and go to state 147
    empty                          shift and go to state 148
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 83

    (141) brace -> MULTIPLY ID .

    PLUS_PLUS       reduce using rule 141 (brace -> MULTIPLY ID .)
    MINUS_MINUS     reduce using rule 141 (brace -> MULTIPLY ID .)
    MULTIPLY        reduce using rule 141 (brace -> MULTIPLY ID .)
    DIVIDE          reduce using rule 141 (brace -> MULTIPLY ID .)
    MOD             reduce using rule 141 (brace -> MULTIPLY ID .)
    PLUS            reduce using rule 141 (brace -> MULTIPLY ID .)
    MINUS           reduce using rule 141 (brace -> MULTIPLY ID .)
    L_SHIFT         reduce using rule 141 (brace -> MULTIPLY ID .)
    R_SHIFT         reduce using rule 141 (brace -> MULTIPLY ID .)
    LE              reduce using rule 141 (brace -> MULTIPLY ID .)
    LT              reduce using rule 141 (brace -> MULTIPLY ID .)
    GE              reduce using rule 141 (brace -> MULTIPLY ID .)
    GT              reduce using rule 141 (brace -> MULTIPLY ID .)
    EQ              reduce using rule 141 (brace -> MULTIPLY ID .)
    NE              reduce using rule 141 (brace -> MULTIPLY ID .)
    BIT_AND         reduce using rule 141 (brace -> MULTIPLY ID .)
    BIT_XOR         reduce using rule 141 (brace -> MULTIPLY ID .)
    BIT_OR          reduce using rule 141 (brace -> MULTIPLY ID .)
    AND             reduce using rule 141 (brace -> MULTIPLY ID .)
    OR              reduce using rule 141 (brace -> MULTIPLY ID .)
    SEMICOLON       reduce using rule 141 (brace -> MULTIPLY ID .)
    ASSIGN          reduce using rule 141 (brace -> MULTIPLY ID .)
    PLUS_ASSIGN     reduce using rule 141 (brace -> MULTIPLY ID .)
    MINUS_ASSIGN    reduce using rule 141 (brace -> MULTIPLY ID .)
    MUL_ASSIGN      reduce using rule 141 (brace -> MULTIPLY ID .)
    DIV_ASSIGN      reduce using rule 141 (brace -> MULTIPLY ID .)
    AND_ASSIGN      reduce using rule 141 (brace -> MULTIPLY ID .)
    OR_ASSIGN       reduce using rule 141 (brace -> MULTIPLY ID .)
    XOR_ASSIGN      reduce using rule 141 (brace -> MULTIPLY ID .)
    MOD_ASSIGN      reduce using rule 141 (brace -> MULTIPLY ID .)
    L_SHIFT_ASSIGN  reduce using rule 141 (brace -> MULTIPLY ID .)
    R_SHIFT_ASSIGN  reduce using rule 141 (brace -> MULTIPLY ID .)
    R_PAREN         reduce using rule 141 (brace -> MULTIPLY ID .)
    COMMA           reduce using rule 141 (brace -> MULTIPLY ID .)
    R_SQBRACE       reduce using rule 141 (brace -> MULTIPLY ID .)
    R_FLOWBRACE     reduce using rule 141 (brace -> MULTIPLY ID .)


state 84

    (134) cast -> L_PAREN TYPE . R_PAREN
    (135) cast -> L_PAREN TYPE . MULTIPLY R_PAREN

    R_PAREN         shift and go to state 149
    MULTIPLY        shift and go to state 150


state 85

    (136) brace -> L_PAREN expr . R_PAREN
    (85) expr -> expr . assignment exprOR
    (87) assignment -> . ASSIGN
    (88) assignment -> . PLUS_ASSIGN
    (89) assignment -> . MINUS_ASSIGN
    (90) assignment -> . MUL_ASSIGN
    (91) assignment -> . DIV_ASSIGN
    (92) assignment -> . AND_ASSIGN
    (93) assignment -> . OR_ASSIGN
    (94) assignment -> . XOR_ASSIGN
    (95) assignment -> . MOD_ASSIGN
    (96) assignment -> . L_SHIFT_ASSIGN
    (97) assignment -> . R_SHIFT_ASSIGN

    R_PAREN         shift and go to state 151
    ASSIGN          shift and go to state 58
    PLUS_ASSIGN     shift and go to state 59
    MINUS_ASSIGN    shift and go to state 60
    MUL_ASSIGN      shift and go to state 61
    DIV_ASSIGN      shift and go to state 62
    AND_ASSIGN      shift and go to state 63
    OR_ASSIGN       shift and go to state 64
    XOR_ASSIGN      shift and go to state 65
    MOD_ASSIGN      shift and go to state 66
    L_SHIFT_ASSIGN  shift and go to state 67
    R_SHIFT_ASSIGN  shift and go to state 68

    assignment                     shift and go to state 57

state 86

    (100) exprAND -> exprAND AND . exprBITOR
    (102) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (103) exprBITOR -> . exprBITXOR
    (104) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (105) exprBITXOR -> . exprBITAND
    (106) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (107) exprBITAND -> . exprEQ
    (108) exprEQ -> . exprEQ EQ exprRELOP
    (109) exprEQ -> . exprEQ NE exprRELOP
    (110) exprEQ -> . exprRELOP
    (111) exprRELOP -> . exprRELOP relop exprSHIFT
    (112) exprRELOP -> . exprSHIFT
    (117) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (118) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (119) exprSHIFT -> . exprOP
    (120) exprOP -> . exprOP PLUS term
    (121) exprOP -> . exprOP MINUS term
    (122) exprOP -> . term
    (123) term -> . term MULTIPLY factor
    (124) term -> . term DIVIDE factor
    (125) term -> . term MOD factor
    (126) term -> . factor
    (127) factor -> . NOT factor
    (128) factor -> . PLUS factor
    (129) factor -> . MINUS factor
    (130) factor -> . PLUS_PLUS factor
    (131) factor -> . MINUS_MINUS factor
    (132) factor -> . cast brace
    (133) factor -> . brace
    (134) cast -> . L_PAREN TYPE R_PAREN
    (135) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (136) brace -> . L_PAREN expr R_PAREN
    (137) brace -> . brace PLUS_PLUS
    (138) brace -> . brace MINUS_MINUS
    (139) brace -> . NUM
    (140) brace -> . STRING
    (141) brace -> . MULTIPLY ID
    (142) brace -> . BIT_AND ID
    (143) brace -> . ID
    (144) brace -> . CHAR
    (145) brace -> . function_call
    (146) brace -> . ID narrayindex
    (147) NUM -> . INT_NUM
    (148) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    exprBITOR                      shift and go to state 152
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 87

    (102) exprBITOR -> exprBITOR BIT_OR . exprBITXOR
    (104) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (105) exprBITXOR -> . exprBITAND
    (106) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (107) exprBITAND -> . exprEQ
    (108) exprEQ -> . exprEQ EQ exprRELOP
    (109) exprEQ -> . exprEQ NE exprRELOP
    (110) exprEQ -> . exprRELOP
    (111) exprRELOP -> . exprRELOP relop exprSHIFT
    (112) exprRELOP -> . exprSHIFT
    (117) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (118) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (119) exprSHIFT -> . exprOP
    (120) exprOP -> . exprOP PLUS term
    (121) exprOP -> . exprOP MINUS term
    (122) exprOP -> . term
    (123) term -> . term MULTIPLY factor
    (124) term -> . term DIVIDE factor
    (125) term -> . term MOD factor
    (126) term -> . factor
    (127) factor -> . NOT factor
    (128) factor -> . PLUS factor
    (129) factor -> . MINUS factor
    (130) factor -> . PLUS_PLUS factor
    (131) factor -> . MINUS_MINUS factor
    (132) factor -> . cast brace
    (133) factor -> . brace
    (134) cast -> . L_PAREN TYPE R_PAREN
    (135) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (136) brace -> . L_PAREN expr R_PAREN
    (137) brace -> . brace PLUS_PLUS
    (138) brace -> . brace MINUS_MINUS
    (139) brace -> . NUM
    (140) brace -> . STRING
    (141) brace -> . MULTIPLY ID
    (142) brace -> . BIT_AND ID
    (143) brace -> . ID
    (144) brace -> . CHAR
    (145) brace -> . function_call
    (146) brace -> . ID narrayindex
    (147) NUM -> . INT_NUM
    (148) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    exprBITXOR                     shift and go to state 153
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 88

    (104) exprBITXOR -> exprBITXOR BIT_XOR . exprBITAND
    (106) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (107) exprBITAND -> . exprEQ
    (108) exprEQ -> . exprEQ EQ exprRELOP
    (109) exprEQ -> . exprEQ NE exprRELOP
    (110) exprEQ -> . exprRELOP
    (111) exprRELOP -> . exprRELOP relop exprSHIFT
    (112) exprRELOP -> . exprSHIFT
    (117) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (118) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (119) exprSHIFT -> . exprOP
    (120) exprOP -> . exprOP PLUS term
    (121) exprOP -> . exprOP MINUS term
    (122) exprOP -> . term
    (123) term -> . term MULTIPLY factor
    (124) term -> . term DIVIDE factor
    (125) term -> . term MOD factor
    (126) term -> . factor
    (127) factor -> . NOT factor
    (128) factor -> . PLUS factor
    (129) factor -> . MINUS factor
    (130) factor -> . PLUS_PLUS factor
    (131) factor -> . MINUS_MINUS factor
    (132) factor -> . cast brace
    (133) factor -> . brace
    (134) cast -> . L_PAREN TYPE R_PAREN
    (135) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (136) brace -> . L_PAREN expr R_PAREN
    (137) brace -> . brace PLUS_PLUS
    (138) brace -> . brace MINUS_MINUS
    (139) brace -> . NUM
    (140) brace -> . STRING
    (141) brace -> . MULTIPLY ID
    (142) brace -> . BIT_AND ID
    (143) brace -> . ID
    (144) brace -> . CHAR
    (145) brace -> . function_call
    (146) brace -> . ID narrayindex
    (147) NUM -> . INT_NUM
    (148) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    exprBITAND                     shift and go to state 154
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 89

    (106) exprBITAND -> exprBITAND BIT_AND . exprEQ
    (108) exprEQ -> . exprEQ EQ exprRELOP
    (109) exprEQ -> . exprEQ NE exprRELOP
    (110) exprEQ -> . exprRELOP
    (111) exprRELOP -> . exprRELOP relop exprSHIFT
    (112) exprRELOP -> . exprSHIFT
    (117) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (118) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (119) exprSHIFT -> . exprOP
    (120) exprOP -> . exprOP PLUS term
    (121) exprOP -> . exprOP MINUS term
    (122) exprOP -> . term
    (123) term -> . term MULTIPLY factor
    (124) term -> . term DIVIDE factor
    (125) term -> . term MOD factor
    (126) term -> . factor
    (127) factor -> . NOT factor
    (128) factor -> . PLUS factor
    (129) factor -> . MINUS factor
    (130) factor -> . PLUS_PLUS factor
    (131) factor -> . MINUS_MINUS factor
    (132) factor -> . cast brace
    (133) factor -> . brace
    (134) cast -> . L_PAREN TYPE R_PAREN
    (135) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (136) brace -> . L_PAREN expr R_PAREN
    (137) brace -> . brace PLUS_PLUS
    (138) brace -> . brace MINUS_MINUS
    (139) brace -> . NUM
    (140) brace -> . STRING
    (141) brace -> . MULTIPLY ID
    (142) brace -> . BIT_AND ID
    (143) brace -> . ID
    (144) brace -> . CHAR
    (145) brace -> . function_call
    (146) brace -> . ID narrayindex
    (147) NUM -> . INT_NUM
    (148) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    exprEQ                         shift and go to state 155
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 90

    (142) brace -> BIT_AND ID .

    PLUS_PLUS       reduce using rule 142 (brace -> BIT_AND ID .)
    MINUS_MINUS     reduce using rule 142 (brace -> BIT_AND ID .)
    MULTIPLY        reduce using rule 142 (brace -> BIT_AND ID .)
    DIVIDE          reduce using rule 142 (brace -> BIT_AND ID .)
    MOD             reduce using rule 142 (brace -> BIT_AND ID .)
    PLUS            reduce using rule 142 (brace -> BIT_AND ID .)
    MINUS           reduce using rule 142 (brace -> BIT_AND ID .)
    L_SHIFT         reduce using rule 142 (brace -> BIT_AND ID .)
    R_SHIFT         reduce using rule 142 (brace -> BIT_AND ID .)
    LE              reduce using rule 142 (brace -> BIT_AND ID .)
    LT              reduce using rule 142 (brace -> BIT_AND ID .)
    GE              reduce using rule 142 (brace -> BIT_AND ID .)
    GT              reduce using rule 142 (brace -> BIT_AND ID .)
    EQ              reduce using rule 142 (brace -> BIT_AND ID .)
    NE              reduce using rule 142 (brace -> BIT_AND ID .)
    BIT_AND         reduce using rule 142 (brace -> BIT_AND ID .)
    BIT_XOR         reduce using rule 142 (brace -> BIT_AND ID .)
    BIT_OR          reduce using rule 142 (brace -> BIT_AND ID .)
    AND             reduce using rule 142 (brace -> BIT_AND ID .)
    OR              reduce using rule 142 (brace -> BIT_AND ID .)
    SEMICOLON       reduce using rule 142 (brace -> BIT_AND ID .)
    ASSIGN          reduce using rule 142 (brace -> BIT_AND ID .)
    PLUS_ASSIGN     reduce using rule 142 (brace -> BIT_AND ID .)
    MINUS_ASSIGN    reduce using rule 142 (brace -> BIT_AND ID .)
    MUL_ASSIGN      reduce using rule 142 (brace -> BIT_AND ID .)
    DIV_ASSIGN      reduce using rule 142 (brace -> BIT_AND ID .)
    AND_ASSIGN      reduce using rule 142 (brace -> BIT_AND ID .)
    OR_ASSIGN       reduce using rule 142 (brace -> BIT_AND ID .)
    XOR_ASSIGN      reduce using rule 142 (brace -> BIT_AND ID .)
    MOD_ASSIGN      reduce using rule 142 (brace -> BIT_AND ID .)
    L_SHIFT_ASSIGN  reduce using rule 142 (brace -> BIT_AND ID .)
    R_SHIFT_ASSIGN  reduce using rule 142 (brace -> BIT_AND ID .)
    R_PAREN         reduce using rule 142 (brace -> BIT_AND ID .)
    COMMA           reduce using rule 142 (brace -> BIT_AND ID .)
    R_SQBRACE       reduce using rule 142 (brace -> BIT_AND ID .)
    R_FLOWBRACE     reduce using rule 142 (brace -> BIT_AND ID .)


state 91

    (108) exprEQ -> exprEQ EQ . exprRELOP
    (111) exprRELOP -> . exprRELOP relop exprSHIFT
    (112) exprRELOP -> . exprSHIFT
    (117) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (118) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (119) exprSHIFT -> . exprOP
    (120) exprOP -> . exprOP PLUS term
    (121) exprOP -> . exprOP MINUS term
    (122) exprOP -> . term
    (123) term -> . term MULTIPLY factor
    (124) term -> . term DIVIDE factor
    (125) term -> . term MOD factor
    (126) term -> . factor
    (127) factor -> . NOT factor
    (128) factor -> . PLUS factor
    (129) factor -> . MINUS factor
    (130) factor -> . PLUS_PLUS factor
    (131) factor -> . MINUS_MINUS factor
    (132) factor -> . cast brace
    (133) factor -> . brace
    (134) cast -> . L_PAREN TYPE R_PAREN
    (135) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (136) brace -> . L_PAREN expr R_PAREN
    (137) brace -> . brace PLUS_PLUS
    (138) brace -> . brace MINUS_MINUS
    (139) brace -> . NUM
    (140) brace -> . STRING
    (141) brace -> . MULTIPLY ID
    (142) brace -> . BIT_AND ID
    (143) brace -> . ID
    (144) brace -> . CHAR
    (145) brace -> . function_call
    (146) brace -> . ID narrayindex
    (147) NUM -> . INT_NUM
    (148) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    exprRELOP                      shift and go to state 156
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 92

    (109) exprEQ -> exprEQ NE . exprRELOP
    (111) exprRELOP -> . exprRELOP relop exprSHIFT
    (112) exprRELOP -> . exprSHIFT
    (117) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (118) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (119) exprSHIFT -> . exprOP
    (120) exprOP -> . exprOP PLUS term
    (121) exprOP -> . exprOP MINUS term
    (122) exprOP -> . term
    (123) term -> . term MULTIPLY factor
    (124) term -> . term DIVIDE factor
    (125) term -> . term MOD factor
    (126) term -> . factor
    (127) factor -> . NOT factor
    (128) factor -> . PLUS factor
    (129) factor -> . MINUS factor
    (130) factor -> . PLUS_PLUS factor
    (131) factor -> . MINUS_MINUS factor
    (132) factor -> . cast brace
    (133) factor -> . brace
    (134) cast -> . L_PAREN TYPE R_PAREN
    (135) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (136) brace -> . L_PAREN expr R_PAREN
    (137) brace -> . brace PLUS_PLUS
    (138) brace -> . brace MINUS_MINUS
    (139) brace -> . NUM
    (140) brace -> . STRING
    (141) brace -> . MULTIPLY ID
    (142) brace -> . BIT_AND ID
    (143) brace -> . ID
    (144) brace -> . CHAR
    (145) brace -> . function_call
    (146) brace -> . ID narrayindex
    (147) NUM -> . INT_NUM
    (148) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    exprRELOP                      shift and go to state 157
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 93

    (111) exprRELOP -> exprRELOP relop . exprSHIFT
    (117) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (118) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (119) exprSHIFT -> . exprOP
    (120) exprOP -> . exprOP PLUS term
    (121) exprOP -> . exprOP MINUS term
    (122) exprOP -> . term
    (123) term -> . term MULTIPLY factor
    (124) term -> . term DIVIDE factor
    (125) term -> . term MOD factor
    (126) term -> . factor
    (127) factor -> . NOT factor
    (128) factor -> . PLUS factor
    (129) factor -> . MINUS factor
    (130) factor -> . PLUS_PLUS factor
    (131) factor -> . MINUS_MINUS factor
    (132) factor -> . cast brace
    (133) factor -> . brace
    (134) cast -> . L_PAREN TYPE R_PAREN
    (135) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (136) brace -> . L_PAREN expr R_PAREN
    (137) brace -> . brace PLUS_PLUS
    (138) brace -> . brace MINUS_MINUS
    (139) brace -> . NUM
    (140) brace -> . STRING
    (141) brace -> . MULTIPLY ID
    (142) brace -> . BIT_AND ID
    (143) brace -> . ID
    (144) brace -> . CHAR
    (145) brace -> . function_call
    (146) brace -> . ID narrayindex
    (147) NUM -> . INT_NUM
    (148) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    exprSHIFT                      shift and go to state 158
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 94

    (113) relop -> LE .

    NOT             reduce using rule 113 (relop -> LE .)
    PLUS            reduce using rule 113 (relop -> LE .)
    MINUS           reduce using rule 113 (relop -> LE .)
    PLUS_PLUS       reduce using rule 113 (relop -> LE .)
    MINUS_MINUS     reduce using rule 113 (relop -> LE .)
    L_PAREN         reduce using rule 113 (relop -> LE .)
    STRING          reduce using rule 113 (relop -> LE .)
    MULTIPLY        reduce using rule 113 (relop -> LE .)
    BIT_AND         reduce using rule 113 (relop -> LE .)
    ID              reduce using rule 113 (relop -> LE .)
    CHAR            reduce using rule 113 (relop -> LE .)
    INT_NUM         reduce using rule 113 (relop -> LE .)
    FLOAT_NUM       reduce using rule 113 (relop -> LE .)


state 95

    (114) relop -> LT .

    NOT             reduce using rule 114 (relop -> LT .)
    PLUS            reduce using rule 114 (relop -> LT .)
    MINUS           reduce using rule 114 (relop -> LT .)
    PLUS_PLUS       reduce using rule 114 (relop -> LT .)
    MINUS_MINUS     reduce using rule 114 (relop -> LT .)
    L_PAREN         reduce using rule 114 (relop -> LT .)
    STRING          reduce using rule 114 (relop -> LT .)
    MULTIPLY        reduce using rule 114 (relop -> LT .)
    BIT_AND         reduce using rule 114 (relop -> LT .)
    ID              reduce using rule 114 (relop -> LT .)
    CHAR            reduce using rule 114 (relop -> LT .)
    INT_NUM         reduce using rule 114 (relop -> LT .)
    FLOAT_NUM       reduce using rule 114 (relop -> LT .)


state 96

    (115) relop -> GE .

    NOT             reduce using rule 115 (relop -> GE .)
    PLUS            reduce using rule 115 (relop -> GE .)
    MINUS           reduce using rule 115 (relop -> GE .)
    PLUS_PLUS       reduce using rule 115 (relop -> GE .)
    MINUS_MINUS     reduce using rule 115 (relop -> GE .)
    L_PAREN         reduce using rule 115 (relop -> GE .)
    STRING          reduce using rule 115 (relop -> GE .)
    MULTIPLY        reduce using rule 115 (relop -> GE .)
    BIT_AND         reduce using rule 115 (relop -> GE .)
    ID              reduce using rule 115 (relop -> GE .)
    CHAR            reduce using rule 115 (relop -> GE .)
    INT_NUM         reduce using rule 115 (relop -> GE .)
    FLOAT_NUM       reduce using rule 115 (relop -> GE .)


state 97

    (116) relop -> GT .

    NOT             reduce using rule 116 (relop -> GT .)
    PLUS            reduce using rule 116 (relop -> GT .)
    MINUS           reduce using rule 116 (relop -> GT .)
    PLUS_PLUS       reduce using rule 116 (relop -> GT .)
    MINUS_MINUS     reduce using rule 116 (relop -> GT .)
    L_PAREN         reduce using rule 116 (relop -> GT .)
    STRING          reduce using rule 116 (relop -> GT .)
    MULTIPLY        reduce using rule 116 (relop -> GT .)
    BIT_AND         reduce using rule 116 (relop -> GT .)
    ID              reduce using rule 116 (relop -> GT .)
    CHAR            reduce using rule 116 (relop -> GT .)
    INT_NUM         reduce using rule 116 (relop -> GT .)
    FLOAT_NUM       reduce using rule 116 (relop -> GT .)


state 98

    (117) exprSHIFT -> exprSHIFT L_SHIFT . exprOP
    (120) exprOP -> . exprOP PLUS term
    (121) exprOP -> . exprOP MINUS term
    (122) exprOP -> . term
    (123) term -> . term MULTIPLY factor
    (124) term -> . term DIVIDE factor
    (125) term -> . term MOD factor
    (126) term -> . factor
    (127) factor -> . NOT factor
    (128) factor -> . PLUS factor
    (129) factor -> . MINUS factor
    (130) factor -> . PLUS_PLUS factor
    (131) factor -> . MINUS_MINUS factor
    (132) factor -> . cast brace
    (133) factor -> . brace
    (134) cast -> . L_PAREN TYPE R_PAREN
    (135) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (136) brace -> . L_PAREN expr R_PAREN
    (137) brace -> . brace PLUS_PLUS
    (138) brace -> . brace MINUS_MINUS
    (139) brace -> . NUM
    (140) brace -> . STRING
    (141) brace -> . MULTIPLY ID
    (142) brace -> . BIT_AND ID
    (143) brace -> . ID
    (144) brace -> . CHAR
    (145) brace -> . function_call
    (146) brace -> . ID narrayindex
    (147) NUM -> . INT_NUM
    (148) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    exprOP                         shift and go to state 159
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 99

    (118) exprSHIFT -> exprSHIFT R_SHIFT . exprOP
    (120) exprOP -> . exprOP PLUS term
    (121) exprOP -> . exprOP MINUS term
    (122) exprOP -> . term
    (123) term -> . term MULTIPLY factor
    (124) term -> . term DIVIDE factor
    (125) term -> . term MOD factor
    (126) term -> . factor
    (127) factor -> . NOT factor
    (128) factor -> . PLUS factor
    (129) factor -> . MINUS factor
    (130) factor -> . PLUS_PLUS factor
    (131) factor -> . MINUS_MINUS factor
    (132) factor -> . cast brace
    (133) factor -> . brace
    (134) cast -> . L_PAREN TYPE R_PAREN
    (135) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (136) brace -> . L_PAREN expr R_PAREN
    (137) brace -> . brace PLUS_PLUS
    (138) brace -> . brace MINUS_MINUS
    (139) brace -> . NUM
    (140) brace -> . STRING
    (141) brace -> . MULTIPLY ID
    (142) brace -> . BIT_AND ID
    (143) brace -> . ID
    (144) brace -> . CHAR
    (145) brace -> . function_call
    (146) brace -> . ID narrayindex
    (147) NUM -> . INT_NUM
    (148) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    exprOP                         shift and go to state 160
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 100

    (120) exprOP -> exprOP PLUS . term
    (123) term -> . term MULTIPLY factor
    (124) term -> . term DIVIDE factor
    (125) term -> . term MOD factor
    (126) term -> . factor
    (127) factor -> . NOT factor
    (128) factor -> . PLUS factor
    (129) factor -> . MINUS factor
    (130) factor -> . PLUS_PLUS factor
    (131) factor -> . MINUS_MINUS factor
    (132) factor -> . cast brace
    (133) factor -> . brace
    (134) cast -> . L_PAREN TYPE R_PAREN
    (135) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (136) brace -> . L_PAREN expr R_PAREN
    (137) brace -> . brace PLUS_PLUS
    (138) brace -> . brace MINUS_MINUS
    (139) brace -> . NUM
    (140) brace -> . STRING
    (141) brace -> . MULTIPLY ID
    (142) brace -> . BIT_AND ID
    (143) brace -> . ID
    (144) brace -> . CHAR
    (145) brace -> . function_call
    (146) brace -> . ID narrayindex
    (147) NUM -> . INT_NUM
    (148) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    term                           shift and go to state 161
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 101

    (121) exprOP -> exprOP MINUS . term
    (123) term -> . term MULTIPLY factor
    (124) term -> . term DIVIDE factor
    (125) term -> . term MOD factor
    (126) term -> . factor
    (127) factor -> . NOT factor
    (128) factor -> . PLUS factor
    (129) factor -> . MINUS factor
    (130) factor -> . PLUS_PLUS factor
    (131) factor -> . MINUS_MINUS factor
    (132) factor -> . cast brace
    (133) factor -> . brace
    (134) cast -> . L_PAREN TYPE R_PAREN
    (135) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (136) brace -> . L_PAREN expr R_PAREN
    (137) brace -> . brace PLUS_PLUS
    (138) brace -> . brace MINUS_MINUS
    (139) brace -> . NUM
    (140) brace -> . STRING
    (141) brace -> . MULTIPLY ID
    (142) brace -> . BIT_AND ID
    (143) brace -> . ID
    (144) brace -> . CHAR
    (145) brace -> . function_call
    (146) brace -> . ID narrayindex
    (147) NUM -> . INT_NUM
    (148) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    term                           shift and go to state 162
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 102

    (128) factor -> PLUS factor .

    MULTIPLY        reduce using rule 128 (factor -> PLUS factor .)
    DIVIDE          reduce using rule 128 (factor -> PLUS factor .)
    MOD             reduce using rule 128 (factor -> PLUS factor .)
    PLUS            reduce using rule 128 (factor -> PLUS factor .)
    MINUS           reduce using rule 128 (factor -> PLUS factor .)
    L_SHIFT         reduce using rule 128 (factor -> PLUS factor .)
    R_SHIFT         reduce using rule 128 (factor -> PLUS factor .)
    LE              reduce using rule 128 (factor -> PLUS factor .)
    LT              reduce using rule 128 (factor -> PLUS factor .)
    GE              reduce using rule 128 (factor -> PLUS factor .)
    GT              reduce using rule 128 (factor -> PLUS factor .)
    EQ              reduce using rule 128 (factor -> PLUS factor .)
    NE              reduce using rule 128 (factor -> PLUS factor .)
    BIT_AND         reduce using rule 128 (factor -> PLUS factor .)
    BIT_XOR         reduce using rule 128 (factor -> PLUS factor .)
    BIT_OR          reduce using rule 128 (factor -> PLUS factor .)
    AND             reduce using rule 128 (factor -> PLUS factor .)
    OR              reduce using rule 128 (factor -> PLUS factor .)
    SEMICOLON       reduce using rule 128 (factor -> PLUS factor .)
    ASSIGN          reduce using rule 128 (factor -> PLUS factor .)
    PLUS_ASSIGN     reduce using rule 128 (factor -> PLUS factor .)
    MINUS_ASSIGN    reduce using rule 128 (factor -> PLUS factor .)
    MUL_ASSIGN      reduce using rule 128 (factor -> PLUS factor .)
    DIV_ASSIGN      reduce using rule 128 (factor -> PLUS factor .)
    AND_ASSIGN      reduce using rule 128 (factor -> PLUS factor .)
    OR_ASSIGN       reduce using rule 128 (factor -> PLUS factor .)
    XOR_ASSIGN      reduce using rule 128 (factor -> PLUS factor .)
    MOD_ASSIGN      reduce using rule 128 (factor -> PLUS factor .)
    L_SHIFT_ASSIGN  reduce using rule 128 (factor -> PLUS factor .)
    R_SHIFT_ASSIGN  reduce using rule 128 (factor -> PLUS factor .)
    R_PAREN         reduce using rule 128 (factor -> PLUS factor .)
    COMMA           reduce using rule 128 (factor -> PLUS factor .)
    R_SQBRACE       reduce using rule 128 (factor -> PLUS factor .)
    R_FLOWBRACE     reduce using rule 128 (factor -> PLUS factor .)


state 103

    (123) term -> term MULTIPLY . factor
    (127) factor -> . NOT factor
    (128) factor -> . PLUS factor
    (129) factor -> . MINUS factor
    (130) factor -> . PLUS_PLUS factor
    (131) factor -> . MINUS_MINUS factor
    (132) factor -> . cast brace
    (133) factor -> . brace
    (134) cast -> . L_PAREN TYPE R_PAREN
    (135) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (136) brace -> . L_PAREN expr R_PAREN
    (137) brace -> . brace PLUS_PLUS
    (138) brace -> . brace MINUS_MINUS
    (139) brace -> . NUM
    (140) brace -> . STRING
    (141) brace -> . MULTIPLY ID
    (142) brace -> . BIT_AND ID
    (143) brace -> . ID
    (144) brace -> . CHAR
    (145) brace -> . function_call
    (146) brace -> . ID narrayindex
    (147) NUM -> . INT_NUM
    (148) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    factor                         shift and go to state 163
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 104

    (124) term -> term DIVIDE . factor
    (127) factor -> . NOT factor
    (128) factor -> . PLUS factor
    (129) factor -> . MINUS factor
    (130) factor -> . PLUS_PLUS factor
    (131) factor -> . MINUS_MINUS factor
    (132) factor -> . cast brace
    (133) factor -> . brace
    (134) cast -> . L_PAREN TYPE R_PAREN
    (135) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (136) brace -> . L_PAREN expr R_PAREN
    (137) brace -> . brace PLUS_PLUS
    (138) brace -> . brace MINUS_MINUS
    (139) brace -> . NUM
    (140) brace -> . STRING
    (141) brace -> . MULTIPLY ID
    (142) brace -> . BIT_AND ID
    (143) brace -> . ID
    (144) brace -> . CHAR
    (145) brace -> . function_call
    (146) brace -> . ID narrayindex
    (147) NUM -> . INT_NUM
    (148) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    factor                         shift and go to state 164
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 105

    (125) term -> term MOD . factor
    (127) factor -> . NOT factor
    (128) factor -> . PLUS factor
    (129) factor -> . MINUS factor
    (130) factor -> . PLUS_PLUS factor
    (131) factor -> . MINUS_MINUS factor
    (132) factor -> . cast brace
    (133) factor -> . brace
    (134) cast -> . L_PAREN TYPE R_PAREN
    (135) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (136) brace -> . L_PAREN expr R_PAREN
    (137) brace -> . brace PLUS_PLUS
    (138) brace -> . brace MINUS_MINUS
    (139) brace -> . NUM
    (140) brace -> . STRING
    (141) brace -> . MULTIPLY ID
    (142) brace -> . BIT_AND ID
    (143) brace -> . ID
    (144) brace -> . CHAR
    (145) brace -> . function_call
    (146) brace -> . ID narrayindex
    (147) NUM -> . INT_NUM
    (148) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    factor                         shift and go to state 165
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 106

    (129) factor -> MINUS factor .

    MULTIPLY        reduce using rule 129 (factor -> MINUS factor .)
    DIVIDE          reduce using rule 129 (factor -> MINUS factor .)
    MOD             reduce using rule 129 (factor -> MINUS factor .)
    PLUS            reduce using rule 129 (factor -> MINUS factor .)
    MINUS           reduce using rule 129 (factor -> MINUS factor .)
    L_SHIFT         reduce using rule 129 (factor -> MINUS factor .)
    R_SHIFT         reduce using rule 129 (factor -> MINUS factor .)
    LE              reduce using rule 129 (factor -> MINUS factor .)
    LT              reduce using rule 129 (factor -> MINUS factor .)
    GE              reduce using rule 129 (factor -> MINUS factor .)
    GT              reduce using rule 129 (factor -> MINUS factor .)
    EQ              reduce using rule 129 (factor -> MINUS factor .)
    NE              reduce using rule 129 (factor -> MINUS factor .)
    BIT_AND         reduce using rule 129 (factor -> MINUS factor .)
    BIT_XOR         reduce using rule 129 (factor -> MINUS factor .)
    BIT_OR          reduce using rule 129 (factor -> MINUS factor .)
    AND             reduce using rule 129 (factor -> MINUS factor .)
    OR              reduce using rule 129 (factor -> MINUS factor .)
    SEMICOLON       reduce using rule 129 (factor -> MINUS factor .)
    ASSIGN          reduce using rule 129 (factor -> MINUS factor .)
    PLUS_ASSIGN     reduce using rule 129 (factor -> MINUS factor .)
    MINUS_ASSIGN    reduce using rule 129 (factor -> MINUS factor .)
    MUL_ASSIGN      reduce using rule 129 (factor -> MINUS factor .)
    DIV_ASSIGN      reduce using rule 129 (factor -> MINUS factor .)
    AND_ASSIGN      reduce using rule 129 (factor -> MINUS factor .)
    OR_ASSIGN       reduce using rule 129 (factor -> MINUS factor .)
    XOR_ASSIGN      reduce using rule 129 (factor -> MINUS factor .)
    MOD_ASSIGN      reduce using rule 129 (factor -> MINUS factor .)
    L_SHIFT_ASSIGN  reduce using rule 129 (factor -> MINUS factor .)
    R_SHIFT_ASSIGN  reduce using rule 129 (factor -> MINUS factor .)
    R_PAREN         reduce using rule 129 (factor -> MINUS factor .)
    COMMA           reduce using rule 129 (factor -> MINUS factor .)
    R_SQBRACE       reduce using rule 129 (factor -> MINUS factor .)
    R_FLOWBRACE     reduce using rule 129 (factor -> MINUS factor .)


state 107

    (127) factor -> NOT factor .

    MULTIPLY        reduce using rule 127 (factor -> NOT factor .)
    DIVIDE          reduce using rule 127 (factor -> NOT factor .)
    MOD             reduce using rule 127 (factor -> NOT factor .)
    PLUS            reduce using rule 127 (factor -> NOT factor .)
    MINUS           reduce using rule 127 (factor -> NOT factor .)
    L_SHIFT         reduce using rule 127 (factor -> NOT factor .)
    R_SHIFT         reduce using rule 127 (factor -> NOT factor .)
    LE              reduce using rule 127 (factor -> NOT factor .)
    LT              reduce using rule 127 (factor -> NOT factor .)
    GE              reduce using rule 127 (factor -> NOT factor .)
    GT              reduce using rule 127 (factor -> NOT factor .)
    EQ              reduce using rule 127 (factor -> NOT factor .)
    NE              reduce using rule 127 (factor -> NOT factor .)
    BIT_AND         reduce using rule 127 (factor -> NOT factor .)
    BIT_XOR         reduce using rule 127 (factor -> NOT factor .)
    BIT_OR          reduce using rule 127 (factor -> NOT factor .)
    AND             reduce using rule 127 (factor -> NOT factor .)
    OR              reduce using rule 127 (factor -> NOT factor .)
    SEMICOLON       reduce using rule 127 (factor -> NOT factor .)
    ASSIGN          reduce using rule 127 (factor -> NOT factor .)
    PLUS_ASSIGN     reduce using rule 127 (factor -> NOT factor .)
    MINUS_ASSIGN    reduce using rule 127 (factor -> NOT factor .)
    MUL_ASSIGN      reduce using rule 127 (factor -> NOT factor .)
    DIV_ASSIGN      reduce using rule 127 (factor -> NOT factor .)
    AND_ASSIGN      reduce using rule 127 (factor -> NOT factor .)
    OR_ASSIGN       reduce using rule 127 (factor -> NOT factor .)
    XOR_ASSIGN      reduce using rule 127 (factor -> NOT factor .)
    MOD_ASSIGN      reduce using rule 127 (factor -> NOT factor .)
    L_SHIFT_ASSIGN  reduce using rule 127 (factor -> NOT factor .)
    R_SHIFT_ASSIGN  reduce using rule 127 (factor -> NOT factor .)
    R_PAREN         reduce using rule 127 (factor -> NOT factor .)
    COMMA           reduce using rule 127 (factor -> NOT factor .)
    R_SQBRACE       reduce using rule 127 (factor -> NOT factor .)
    R_FLOWBRACE     reduce using rule 127 (factor -> NOT factor .)


state 108

    (130) factor -> PLUS_PLUS factor .

    MULTIPLY        reduce using rule 130 (factor -> PLUS_PLUS factor .)
    DIVIDE          reduce using rule 130 (factor -> PLUS_PLUS factor .)
    MOD             reduce using rule 130 (factor -> PLUS_PLUS factor .)
    PLUS            reduce using rule 130 (factor -> PLUS_PLUS factor .)
    MINUS           reduce using rule 130 (factor -> PLUS_PLUS factor .)
    L_SHIFT         reduce using rule 130 (factor -> PLUS_PLUS factor .)
    R_SHIFT         reduce using rule 130 (factor -> PLUS_PLUS factor .)
    LE              reduce using rule 130 (factor -> PLUS_PLUS factor .)
    LT              reduce using rule 130 (factor -> PLUS_PLUS factor .)
    GE              reduce using rule 130 (factor -> PLUS_PLUS factor .)
    GT              reduce using rule 130 (factor -> PLUS_PLUS factor .)
    EQ              reduce using rule 130 (factor -> PLUS_PLUS factor .)
    NE              reduce using rule 130 (factor -> PLUS_PLUS factor .)
    BIT_AND         reduce using rule 130 (factor -> PLUS_PLUS factor .)
    BIT_XOR         reduce using rule 130 (factor -> PLUS_PLUS factor .)
    BIT_OR          reduce using rule 130 (factor -> PLUS_PLUS factor .)
    AND             reduce using rule 130 (factor -> PLUS_PLUS factor .)
    OR              reduce using rule 130 (factor -> PLUS_PLUS factor .)
    SEMICOLON       reduce using rule 130 (factor -> PLUS_PLUS factor .)
    ASSIGN          reduce using rule 130 (factor -> PLUS_PLUS factor .)
    PLUS_ASSIGN     reduce using rule 130 (factor -> PLUS_PLUS factor .)
    MINUS_ASSIGN    reduce using rule 130 (factor -> PLUS_PLUS factor .)
    MUL_ASSIGN      reduce using rule 130 (factor -> PLUS_PLUS factor .)
    DIV_ASSIGN      reduce using rule 130 (factor -> PLUS_PLUS factor .)
    AND_ASSIGN      reduce using rule 130 (factor -> PLUS_PLUS factor .)
    OR_ASSIGN       reduce using rule 130 (factor -> PLUS_PLUS factor .)
    XOR_ASSIGN      reduce using rule 130 (factor -> PLUS_PLUS factor .)
    MOD_ASSIGN      reduce using rule 130 (factor -> PLUS_PLUS factor .)
    L_SHIFT_ASSIGN  reduce using rule 130 (factor -> PLUS_PLUS factor .)
    R_SHIFT_ASSIGN  reduce using rule 130 (factor -> PLUS_PLUS factor .)
    R_PAREN         reduce using rule 130 (factor -> PLUS_PLUS factor .)
    COMMA           reduce using rule 130 (factor -> PLUS_PLUS factor .)
    R_SQBRACE       reduce using rule 130 (factor -> PLUS_PLUS factor .)
    R_FLOWBRACE     reduce using rule 130 (factor -> PLUS_PLUS factor .)


state 109

    (131) factor -> MINUS_MINUS factor .

    MULTIPLY        reduce using rule 131 (factor -> MINUS_MINUS factor .)
    DIVIDE          reduce using rule 131 (factor -> MINUS_MINUS factor .)
    MOD             reduce using rule 131 (factor -> MINUS_MINUS factor .)
    PLUS            reduce using rule 131 (factor -> MINUS_MINUS factor .)
    MINUS           reduce using rule 131 (factor -> MINUS_MINUS factor .)
    L_SHIFT         reduce using rule 131 (factor -> MINUS_MINUS factor .)
    R_SHIFT         reduce using rule 131 (factor -> MINUS_MINUS factor .)
    LE              reduce using rule 131 (factor -> MINUS_MINUS factor .)
    LT              reduce using rule 131 (factor -> MINUS_MINUS factor .)
    GE              reduce using rule 131 (factor -> MINUS_MINUS factor .)
    GT              reduce using rule 131 (factor -> MINUS_MINUS factor .)
    EQ              reduce using rule 131 (factor -> MINUS_MINUS factor .)
    NE              reduce using rule 131 (factor -> MINUS_MINUS factor .)
    BIT_AND         reduce using rule 131 (factor -> MINUS_MINUS factor .)
    BIT_XOR         reduce using rule 131 (factor -> MINUS_MINUS factor .)
    BIT_OR          reduce using rule 131 (factor -> MINUS_MINUS factor .)
    AND             reduce using rule 131 (factor -> MINUS_MINUS factor .)
    OR              reduce using rule 131 (factor -> MINUS_MINUS factor .)
    SEMICOLON       reduce using rule 131 (factor -> MINUS_MINUS factor .)
    ASSIGN          reduce using rule 131 (factor -> MINUS_MINUS factor .)
    PLUS_ASSIGN     reduce using rule 131 (factor -> MINUS_MINUS factor .)
    MINUS_ASSIGN    reduce using rule 131 (factor -> MINUS_MINUS factor .)
    MUL_ASSIGN      reduce using rule 131 (factor -> MINUS_MINUS factor .)
    DIV_ASSIGN      reduce using rule 131 (factor -> MINUS_MINUS factor .)
    AND_ASSIGN      reduce using rule 131 (factor -> MINUS_MINUS factor .)
    OR_ASSIGN       reduce using rule 131 (factor -> MINUS_MINUS factor .)
    XOR_ASSIGN      reduce using rule 131 (factor -> MINUS_MINUS factor .)
    MOD_ASSIGN      reduce using rule 131 (factor -> MINUS_MINUS factor .)
    L_SHIFT_ASSIGN  reduce using rule 131 (factor -> MINUS_MINUS factor .)
    R_SHIFT_ASSIGN  reduce using rule 131 (factor -> MINUS_MINUS factor .)
    R_PAREN         reduce using rule 131 (factor -> MINUS_MINUS factor .)
    COMMA           reduce using rule 131 (factor -> MINUS_MINUS factor .)
    R_SQBRACE       reduce using rule 131 (factor -> MINUS_MINUS factor .)
    R_FLOWBRACE     reduce using rule 131 (factor -> MINUS_MINUS factor .)


state 110

    (132) factor -> cast brace .
    (137) brace -> brace . PLUS_PLUS
    (138) brace -> brace . MINUS_MINUS

    MULTIPLY        reduce using rule 132 (factor -> cast brace .)
    DIVIDE          reduce using rule 132 (factor -> cast brace .)
    MOD             reduce using rule 132 (factor -> cast brace .)
    PLUS            reduce using rule 132 (factor -> cast brace .)
    MINUS           reduce using rule 132 (factor -> cast brace .)
    L_SHIFT         reduce using rule 132 (factor -> cast brace .)
    R_SHIFT         reduce using rule 132 (factor -> cast brace .)
    LE              reduce using rule 132 (factor -> cast brace .)
    LT              reduce using rule 132 (factor -> cast brace .)
    GE              reduce using rule 132 (factor -> cast brace .)
    GT              reduce using rule 132 (factor -> cast brace .)
    EQ              reduce using rule 132 (factor -> cast brace .)
    NE              reduce using rule 132 (factor -> cast brace .)
    BIT_AND         reduce using rule 132 (factor -> cast brace .)
    BIT_XOR         reduce using rule 132 (factor -> cast brace .)
    BIT_OR          reduce using rule 132 (factor -> cast brace .)
    AND             reduce using rule 132 (factor -> cast brace .)
    OR              reduce using rule 132 (factor -> cast brace .)
    SEMICOLON       reduce using rule 132 (factor -> cast brace .)
    ASSIGN          reduce using rule 132 (factor -> cast brace .)
    PLUS_ASSIGN     reduce using rule 132 (factor -> cast brace .)
    MINUS_ASSIGN    reduce using rule 132 (factor -> cast brace .)
    MUL_ASSIGN      reduce using rule 132 (factor -> cast brace .)
    DIV_ASSIGN      reduce using rule 132 (factor -> cast brace .)
    AND_ASSIGN      reduce using rule 132 (factor -> cast brace .)
    OR_ASSIGN       reduce using rule 132 (factor -> cast brace .)
    XOR_ASSIGN      reduce using rule 132 (factor -> cast brace .)
    MOD_ASSIGN      reduce using rule 132 (factor -> cast brace .)
    L_SHIFT_ASSIGN  reduce using rule 132 (factor -> cast brace .)
    R_SHIFT_ASSIGN  reduce using rule 132 (factor -> cast brace .)
    R_PAREN         reduce using rule 132 (factor -> cast brace .)
    COMMA           reduce using rule 132 (factor -> cast brace .)
    R_SQBRACE       reduce using rule 132 (factor -> cast brace .)
    R_FLOWBRACE     reduce using rule 132 (factor -> cast brace .)
    PLUS_PLUS       shift and go to state 112
    MINUS_MINUS     shift and go to state 113


state 111

    (136) brace -> L_PAREN . expr R_PAREN
    (85) expr -> . expr assignment exprOR
    (86) expr -> . exprOR
    (98) exprOR -> . exprOR OR exprAND
    (99) exprOR -> . exprAND
    (100) exprAND -> . exprAND AND exprBITOR
    (101) exprAND -> . exprBITOR
    (102) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (103) exprBITOR -> . exprBITXOR
    (104) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (105) exprBITXOR -> . exprBITAND
    (106) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (107) exprBITAND -> . exprEQ
    (108) exprEQ -> . exprEQ EQ exprRELOP
    (109) exprEQ -> . exprEQ NE exprRELOP
    (110) exprEQ -> . exprRELOP
    (111) exprRELOP -> . exprRELOP relop exprSHIFT
    (112) exprRELOP -> . exprSHIFT
    (117) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (118) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (119) exprSHIFT -> . exprOP
    (120) exprOP -> . exprOP PLUS term
    (121) exprOP -> . exprOP MINUS term
    (122) exprOP -> . term
    (123) term -> . term MULTIPLY factor
    (124) term -> . term DIVIDE factor
    (125) term -> . term MOD factor
    (126) term -> . factor
    (127) factor -> . NOT factor
    (128) factor -> . PLUS factor
    (129) factor -> . MINUS factor
    (130) factor -> . PLUS_PLUS factor
    (131) factor -> . MINUS_MINUS factor
    (132) factor -> . cast brace
    (133) factor -> . brace
    (134) cast -> . L_PAREN TYPE R_PAREN
    (135) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (136) brace -> . L_PAREN expr R_PAREN
    (137) brace -> . brace PLUS_PLUS
    (138) brace -> . brace MINUS_MINUS
    (139) brace -> . NUM
    (140) brace -> . STRING
    (141) brace -> . MULTIPLY ID
    (142) brace -> . BIT_AND ID
    (143) brace -> . ID
    (144) brace -> . CHAR
    (145) brace -> . function_call
    (146) brace -> . ID narrayindex
    (147) NUM -> . INT_NUM
    (148) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    expr                           shift and go to state 85
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 112

    (137) brace -> brace PLUS_PLUS .

    PLUS_PLUS       reduce using rule 137 (brace -> brace PLUS_PLUS .)
    MINUS_MINUS     reduce using rule 137 (brace -> brace PLUS_PLUS .)
    MULTIPLY        reduce using rule 137 (brace -> brace PLUS_PLUS .)
    DIVIDE          reduce using rule 137 (brace -> brace PLUS_PLUS .)
    MOD             reduce using rule 137 (brace -> brace PLUS_PLUS .)
    PLUS            reduce using rule 137 (brace -> brace PLUS_PLUS .)
    MINUS           reduce using rule 137 (brace -> brace PLUS_PLUS .)
    L_SHIFT         reduce using rule 137 (brace -> brace PLUS_PLUS .)
    R_SHIFT         reduce using rule 137 (brace -> brace PLUS_PLUS .)
    LE              reduce using rule 137 (brace -> brace PLUS_PLUS .)
    LT              reduce using rule 137 (brace -> brace PLUS_PLUS .)
    GE              reduce using rule 137 (brace -> brace PLUS_PLUS .)
    GT              reduce using rule 137 (brace -> brace PLUS_PLUS .)
    EQ              reduce using rule 137 (brace -> brace PLUS_PLUS .)
    NE              reduce using rule 137 (brace -> brace PLUS_PLUS .)
    BIT_AND         reduce using rule 137 (brace -> brace PLUS_PLUS .)
    BIT_XOR         reduce using rule 137 (brace -> brace PLUS_PLUS .)
    BIT_OR          reduce using rule 137 (brace -> brace PLUS_PLUS .)
    AND             reduce using rule 137 (brace -> brace PLUS_PLUS .)
    OR              reduce using rule 137 (brace -> brace PLUS_PLUS .)
    SEMICOLON       reduce using rule 137 (brace -> brace PLUS_PLUS .)
    ASSIGN          reduce using rule 137 (brace -> brace PLUS_PLUS .)
    PLUS_ASSIGN     reduce using rule 137 (brace -> brace PLUS_PLUS .)
    MINUS_ASSIGN    reduce using rule 137 (brace -> brace PLUS_PLUS .)
    MUL_ASSIGN      reduce using rule 137 (brace -> brace PLUS_PLUS .)
    DIV_ASSIGN      reduce using rule 137 (brace -> brace PLUS_PLUS .)
    AND_ASSIGN      reduce using rule 137 (brace -> brace PLUS_PLUS .)
    OR_ASSIGN       reduce using rule 137 (brace -> brace PLUS_PLUS .)
    XOR_ASSIGN      reduce using rule 137 (brace -> brace PLUS_PLUS .)
    MOD_ASSIGN      reduce using rule 137 (brace -> brace PLUS_PLUS .)
    L_SHIFT_ASSIGN  reduce using rule 137 (brace -> brace PLUS_PLUS .)
    R_SHIFT_ASSIGN  reduce using rule 137 (brace -> brace PLUS_PLUS .)
    R_PAREN         reduce using rule 137 (brace -> brace PLUS_PLUS .)
    COMMA           reduce using rule 137 (brace -> brace PLUS_PLUS .)
    R_SQBRACE       reduce using rule 137 (brace -> brace PLUS_PLUS .)
    R_FLOWBRACE     reduce using rule 137 (brace -> brace PLUS_PLUS .)


state 113

    (138) brace -> brace MINUS_MINUS .

    PLUS_PLUS       reduce using rule 138 (brace -> brace MINUS_MINUS .)
    MINUS_MINUS     reduce using rule 138 (brace -> brace MINUS_MINUS .)
    MULTIPLY        reduce using rule 138 (brace -> brace MINUS_MINUS .)
    DIVIDE          reduce using rule 138 (brace -> brace MINUS_MINUS .)
    MOD             reduce using rule 138 (brace -> brace MINUS_MINUS .)
    PLUS            reduce using rule 138 (brace -> brace MINUS_MINUS .)
    MINUS           reduce using rule 138 (brace -> brace MINUS_MINUS .)
    L_SHIFT         reduce using rule 138 (brace -> brace MINUS_MINUS .)
    R_SHIFT         reduce using rule 138 (brace -> brace MINUS_MINUS .)
    LE              reduce using rule 138 (brace -> brace MINUS_MINUS .)
    LT              reduce using rule 138 (brace -> brace MINUS_MINUS .)
    GE              reduce using rule 138 (brace -> brace MINUS_MINUS .)
    GT              reduce using rule 138 (brace -> brace MINUS_MINUS .)
    EQ              reduce using rule 138 (brace -> brace MINUS_MINUS .)
    NE              reduce using rule 138 (brace -> brace MINUS_MINUS .)
    BIT_AND         reduce using rule 138 (brace -> brace MINUS_MINUS .)
    BIT_XOR         reduce using rule 138 (brace -> brace MINUS_MINUS .)
    BIT_OR          reduce using rule 138 (brace -> brace MINUS_MINUS .)
    AND             reduce using rule 138 (brace -> brace MINUS_MINUS .)
    OR              reduce using rule 138 (brace -> brace MINUS_MINUS .)
    SEMICOLON       reduce using rule 138 (brace -> brace MINUS_MINUS .)
    ASSIGN          reduce using rule 138 (brace -> brace MINUS_MINUS .)
    PLUS_ASSIGN     reduce using rule 138 (brace -> brace MINUS_MINUS .)
    MINUS_ASSIGN    reduce using rule 138 (brace -> brace MINUS_MINUS .)
    MUL_ASSIGN      reduce using rule 138 (brace -> brace MINUS_MINUS .)
    DIV_ASSIGN      reduce using rule 138 (brace -> brace MINUS_MINUS .)
    AND_ASSIGN      reduce using rule 138 (brace -> brace MINUS_MINUS .)
    OR_ASSIGN       reduce using rule 138 (brace -> brace MINUS_MINUS .)
    XOR_ASSIGN      reduce using rule 138 (brace -> brace MINUS_MINUS .)
    MOD_ASSIGN      reduce using rule 138 (brace -> brace MINUS_MINUS .)
    L_SHIFT_ASSIGN  reduce using rule 138 (brace -> brace MINUS_MINUS .)
    R_SHIFT_ASSIGN  reduce using rule 138 (brace -> brace MINUS_MINUS .)
    R_PAREN         reduce using rule 138 (brace -> brace MINUS_MINUS .)
    COMMA           reduce using rule 138 (brace -> brace MINUS_MINUS .)
    R_SQBRACE       reduce using rule 138 (brace -> brace MINUS_MINUS .)
    R_FLOWBRACE     reduce using rule 138 (brace -> brace MINUS_MINUS .)


state 114

    (13) closed -> IF . condition closed ELSE closed
    (6) open -> IF . condition statement
    (7) open -> IF . condition closed ELSE open
    (16) condition -> . L_PAREN expr R_PAREN

    L_PAREN         shift and go to state 52

    condition                      shift and go to state 166

state 115

    (6) open -> IF condition statement .

    IF              reduce using rule 6 (open -> IF condition statement .)
    WHILE           reduce using rule 6 (open -> IF condition statement .)
    FOR             reduce using rule 6 (open -> IF condition statement .)
    SEMICOLON       reduce using rule 6 (open -> IF condition statement .)
    RETURN          reduce using rule 6 (open -> IF condition statement .)
    HASH            reduce using rule 6 (open -> IF condition statement .)
    TYPE            reduce using rule 6 (open -> IF condition statement .)
    L_FLOWBRACE     reduce using rule 6 (open -> IF condition statement .)
    NOT             reduce using rule 6 (open -> IF condition statement .)
    PLUS            reduce using rule 6 (open -> IF condition statement .)
    MINUS           reduce using rule 6 (open -> IF condition statement .)
    PLUS_PLUS       reduce using rule 6 (open -> IF condition statement .)
    MINUS_MINUS     reduce using rule 6 (open -> IF condition statement .)
    L_PAREN         reduce using rule 6 (open -> IF condition statement .)
    STRING          reduce using rule 6 (open -> IF condition statement .)
    MULTIPLY        reduce using rule 6 (open -> IF condition statement .)
    BIT_AND         reduce using rule 6 (open -> IF condition statement .)
    ID              reduce using rule 6 (open -> IF condition statement .)
    CHAR            reduce using rule 6 (open -> IF condition statement .)
    INT_NUM         reduce using rule 6 (open -> IF condition statement .)
    FLOAT_NUM       reduce using rule 6 (open -> IF condition statement .)
    $end            reduce using rule 6 (open -> IF condition statement .)
    R_FLOWBRACE     reduce using rule 6 (open -> IF condition statement .)


state 116

    (7) open -> IF condition closed . ELSE open
    (13) closed -> IF condition closed . ELSE closed
    (5) statement -> closed .

    ELSE            shift and go to state 167
    IF              reduce using rule 5 (statement -> closed .)
    WHILE           reduce using rule 5 (statement -> closed .)
    FOR             reduce using rule 5 (statement -> closed .)
    SEMICOLON       reduce using rule 5 (statement -> closed .)
    RETURN          reduce using rule 5 (statement -> closed .)
    HASH            reduce using rule 5 (statement -> closed .)
    TYPE            reduce using rule 5 (statement -> closed .)
    L_FLOWBRACE     reduce using rule 5 (statement -> closed .)
    NOT             reduce using rule 5 (statement -> closed .)
    PLUS            reduce using rule 5 (statement -> closed .)
    MINUS           reduce using rule 5 (statement -> closed .)
    PLUS_PLUS       reduce using rule 5 (statement -> closed .)
    MINUS_MINUS     reduce using rule 5 (statement -> closed .)
    L_PAREN         reduce using rule 5 (statement -> closed .)
    STRING          reduce using rule 5 (statement -> closed .)
    MULTIPLY        reduce using rule 5 (statement -> closed .)
    BIT_AND         reduce using rule 5 (statement -> closed .)
    ID              reduce using rule 5 (statement -> closed .)
    CHAR            reduce using rule 5 (statement -> closed .)
    INT_NUM         reduce using rule 5 (statement -> closed .)
    FLOAT_NUM       reduce using rule 5 (statement -> closed .)
    $end            reduce using rule 5 (statement -> closed .)
    R_FLOWBRACE     reduce using rule 5 (statement -> closed .)


state 117

    (14) closed -> WHILE . condition closed
    (8) open -> WHILE . condition open
    (16) condition -> . L_PAREN expr R_PAREN

    L_PAREN         shift and go to state 52

    condition                      shift and go to state 168

state 118

    (15) closed -> for . for_condition closed
    (9) open -> for . for_condition open
    (17) for_condition -> . L_PAREN simple simple expr R_PAREN
    (18) for_condition -> . L_PAREN simple simple R_PAREN

    L_PAREN         shift and go to state 55

    for_condition                  shift and go to state 169

state 119

    (16) condition -> L_PAREN expr . R_PAREN
    (85) expr -> expr . assignment exprOR
    (87) assignment -> . ASSIGN
    (88) assignment -> . PLUS_ASSIGN
    (89) assignment -> . MINUS_ASSIGN
    (90) assignment -> . MUL_ASSIGN
    (91) assignment -> . DIV_ASSIGN
    (92) assignment -> . AND_ASSIGN
    (93) assignment -> . OR_ASSIGN
    (94) assignment -> . XOR_ASSIGN
    (95) assignment -> . MOD_ASSIGN
    (96) assignment -> . L_SHIFT_ASSIGN
    (97) assignment -> . R_SHIFT_ASSIGN

    R_PAREN         shift and go to state 170
    ASSIGN          shift and go to state 58
    PLUS_ASSIGN     shift and go to state 59
    MINUS_ASSIGN    shift and go to state 60
    MUL_ASSIGN      shift and go to state 61
    DIV_ASSIGN      shift and go to state 62
    AND_ASSIGN      shift and go to state 63
    OR_ASSIGN       shift and go to state 64
    XOR_ASSIGN      shift and go to state 65
    MOD_ASSIGN      shift and go to state 66
    L_SHIFT_ASSIGN  shift and go to state 67
    R_SHIFT_ASSIGN  shift and go to state 68

    assignment                     shift and go to state 57

state 120

    (8) open -> WHILE condition open .

    IF              reduce using rule 8 (open -> WHILE condition open .)
    WHILE           reduce using rule 8 (open -> WHILE condition open .)
    FOR             reduce using rule 8 (open -> WHILE condition open .)
    SEMICOLON       reduce using rule 8 (open -> WHILE condition open .)
    RETURN          reduce using rule 8 (open -> WHILE condition open .)
    HASH            reduce using rule 8 (open -> WHILE condition open .)
    TYPE            reduce using rule 8 (open -> WHILE condition open .)
    L_FLOWBRACE     reduce using rule 8 (open -> WHILE condition open .)
    NOT             reduce using rule 8 (open -> WHILE condition open .)
    PLUS            reduce using rule 8 (open -> WHILE condition open .)
    MINUS           reduce using rule 8 (open -> WHILE condition open .)
    PLUS_PLUS       reduce using rule 8 (open -> WHILE condition open .)
    MINUS_MINUS     reduce using rule 8 (open -> WHILE condition open .)
    L_PAREN         reduce using rule 8 (open -> WHILE condition open .)
    STRING          reduce using rule 8 (open -> WHILE condition open .)
    MULTIPLY        reduce using rule 8 (open -> WHILE condition open .)
    BIT_AND         reduce using rule 8 (open -> WHILE condition open .)
    ID              reduce using rule 8 (open -> WHILE condition open .)
    CHAR            reduce using rule 8 (open -> WHILE condition open .)
    INT_NUM         reduce using rule 8 (open -> WHILE condition open .)
    FLOAT_NUM       reduce using rule 8 (open -> WHILE condition open .)
    $end            reduce using rule 8 (open -> WHILE condition open .)
    R_FLOWBRACE     reduce using rule 8 (open -> WHILE condition open .)


state 121

    (14) closed -> WHILE condition closed .

    IF              reduce using rule 14 (closed -> WHILE condition closed .)
    WHILE           reduce using rule 14 (closed -> WHILE condition closed .)
    FOR             reduce using rule 14 (closed -> WHILE condition closed .)
    SEMICOLON       reduce using rule 14 (closed -> WHILE condition closed .)
    RETURN          reduce using rule 14 (closed -> WHILE condition closed .)
    HASH            reduce using rule 14 (closed -> WHILE condition closed .)
    TYPE            reduce using rule 14 (closed -> WHILE condition closed .)
    L_FLOWBRACE     reduce using rule 14 (closed -> WHILE condition closed .)
    NOT             reduce using rule 14 (closed -> WHILE condition closed .)
    PLUS            reduce using rule 14 (closed -> WHILE condition closed .)
    MINUS           reduce using rule 14 (closed -> WHILE condition closed .)
    PLUS_PLUS       reduce using rule 14 (closed -> WHILE condition closed .)
    MINUS_MINUS     reduce using rule 14 (closed -> WHILE condition closed .)
    L_PAREN         reduce using rule 14 (closed -> WHILE condition closed .)
    STRING          reduce using rule 14 (closed -> WHILE condition closed .)
    MULTIPLY        reduce using rule 14 (closed -> WHILE condition closed .)
    BIT_AND         reduce using rule 14 (closed -> WHILE condition closed .)
    ID              reduce using rule 14 (closed -> WHILE condition closed .)
    CHAR            reduce using rule 14 (closed -> WHILE condition closed .)
    INT_NUM         reduce using rule 14 (closed -> WHILE condition closed .)
    FLOAT_NUM       reduce using rule 14 (closed -> WHILE condition closed .)
    $end            reduce using rule 14 (closed -> WHILE condition closed .)
    R_FLOWBRACE     reduce using rule 14 (closed -> WHILE condition closed .)
    ELSE            reduce using rule 14 (closed -> WHILE condition closed .)


state 122

    (9) open -> for for_condition open .

    IF              reduce using rule 9 (open -> for for_condition open .)
    WHILE           reduce using rule 9 (open -> for for_condition open .)
    FOR             reduce using rule 9 (open -> for for_condition open .)
    SEMICOLON       reduce using rule 9 (open -> for for_condition open .)
    RETURN          reduce using rule 9 (open -> for for_condition open .)
    HASH            reduce using rule 9 (open -> for for_condition open .)
    TYPE            reduce using rule 9 (open -> for for_condition open .)
    L_FLOWBRACE     reduce using rule 9 (open -> for for_condition open .)
    NOT             reduce using rule 9 (open -> for for_condition open .)
    PLUS            reduce using rule 9 (open -> for for_condition open .)
    MINUS           reduce using rule 9 (open -> for for_condition open .)
    PLUS_PLUS       reduce using rule 9 (open -> for for_condition open .)
    MINUS_MINUS     reduce using rule 9 (open -> for for_condition open .)
    L_PAREN         reduce using rule 9 (open -> for for_condition open .)
    STRING          reduce using rule 9 (open -> for for_condition open .)
    MULTIPLY        reduce using rule 9 (open -> for for_condition open .)
    BIT_AND         reduce using rule 9 (open -> for for_condition open .)
    ID              reduce using rule 9 (open -> for for_condition open .)
    CHAR            reduce using rule 9 (open -> for for_condition open .)
    INT_NUM         reduce using rule 9 (open -> for for_condition open .)
    FLOAT_NUM       reduce using rule 9 (open -> for for_condition open .)
    $end            reduce using rule 9 (open -> for for_condition open .)
    R_FLOWBRACE     reduce using rule 9 (open -> for for_condition open .)


state 123

    (15) closed -> for for_condition closed .

    IF              reduce using rule 15 (closed -> for for_condition closed .)
    WHILE           reduce using rule 15 (closed -> for for_condition closed .)
    FOR             reduce using rule 15 (closed -> for for_condition closed .)
    SEMICOLON       reduce using rule 15 (closed -> for for_condition closed .)
    RETURN          reduce using rule 15 (closed -> for for_condition closed .)
    HASH            reduce using rule 15 (closed -> for for_condition closed .)
    TYPE            reduce using rule 15 (closed -> for for_condition closed .)
    L_FLOWBRACE     reduce using rule 15 (closed -> for for_condition closed .)
    NOT             reduce using rule 15 (closed -> for for_condition closed .)
    PLUS            reduce using rule 15 (closed -> for for_condition closed .)
    MINUS           reduce using rule 15 (closed -> for for_condition closed .)
    PLUS_PLUS       reduce using rule 15 (closed -> for for_condition closed .)
    MINUS_MINUS     reduce using rule 15 (closed -> for for_condition closed .)
    L_PAREN         reduce using rule 15 (closed -> for for_condition closed .)
    STRING          reduce using rule 15 (closed -> for for_condition closed .)
    MULTIPLY        reduce using rule 15 (closed -> for for_condition closed .)
    BIT_AND         reduce using rule 15 (closed -> for for_condition closed .)
    ID              reduce using rule 15 (closed -> for for_condition closed .)
    CHAR            reduce using rule 15 (closed -> for for_condition closed .)
    INT_NUM         reduce using rule 15 (closed -> for for_condition closed .)
    FLOAT_NUM       reduce using rule 15 (closed -> for for_condition closed .)
    $end            reduce using rule 15 (closed -> for for_condition closed .)
    R_FLOWBRACE     reduce using rule 15 (closed -> for for_condition closed .)
    ELSE            reduce using rule 15 (closed -> for for_condition closed .)


state 124

    (17) for_condition -> L_PAREN simple . simple expr R_PAREN
    (18) for_condition -> L_PAREN simple . simple R_PAREN
    (53) simple -> . expr SEMICOLON
    (54) simple -> . header
    (55) simple -> . declaration
    (56) simple -> . SEMICOLON
    (57) simple -> . function
    (58) simple -> . RETURN expr SEMICOLON
    (59) simple -> . RETURN SEMICOLON
    (85) expr -> . expr assignment exprOR
    (86) expr -> . exprOR
    (60) header -> . HASH INCLUDE STRING
    (61) header -> . HASH INCLUDE HEADER_FILE
    (34) declaration -> . TYPE ID SEMICOLON
    (35) declaration -> . TYPE MULTIPLY ID SEMICOLON
    (36) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (37) declaration -> . TYPE MULTIPLY ID ASSIGN expr SEMICOLON
    (38) declaration -> . TYPE multi_declaration stop
    (39) declaration -> . TYPE ID narrayindex SEMICOLON
    (40) declaration -> . TYPE ID narrayindex ASSIGN init_list SEMICOLON
    (82) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (98) exprOR -> . exprOR OR exprAND
    (99) exprOR -> . exprAND
    (100) exprAND -> . exprAND AND exprBITOR
    (101) exprAND -> . exprBITOR
    (102) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (103) exprBITOR -> . exprBITXOR
    (104) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (105) exprBITXOR -> . exprBITAND
    (106) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (107) exprBITAND -> . exprEQ
    (108) exprEQ -> . exprEQ EQ exprRELOP
    (109) exprEQ -> . exprEQ NE exprRELOP
    (110) exprEQ -> . exprRELOP
    (111) exprRELOP -> . exprRELOP relop exprSHIFT
    (112) exprRELOP -> . exprSHIFT
    (117) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (118) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (119) exprSHIFT -> . exprOP
    (120) exprOP -> . exprOP PLUS term
    (121) exprOP -> . exprOP MINUS term
    (122) exprOP -> . term
    (123) term -> . term MULTIPLY factor
    (124) term -> . term DIVIDE factor
    (125) term -> . term MOD factor
    (126) term -> . factor
    (127) factor -> . NOT factor
    (128) factor -> . PLUS factor
    (129) factor -> . MINUS factor
    (130) factor -> . PLUS_PLUS factor
    (131) factor -> . MINUS_MINUS factor
    (132) factor -> . cast brace
    (133) factor -> . brace
    (134) cast -> . L_PAREN TYPE R_PAREN
    (135) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (136) brace -> . L_PAREN expr R_PAREN
    (137) brace -> . brace PLUS_PLUS
    (138) brace -> . brace MINUS_MINUS
    (139) brace -> . NUM
    (140) brace -> . STRING
    (141) brace -> . MULTIPLY ID
    (142) brace -> . BIT_AND ID
    (143) brace -> . ID
    (144) brace -> . CHAR
    (145) brace -> . function_call
    (146) brace -> . ID narrayindex
    (147) NUM -> . INT_NUM
    (148) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    SEMICOLON       shift and go to state 13
    RETURN          shift and go to state 17
    HASH            shift and go to state 20
    TYPE            shift and go to state 22
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    simple                         shift and go to state 171
    expr                           shift and go to state 12
    header                         shift and go to state 14
    declaration                    shift and go to state 15
    function                       shift and go to state 16
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 125

    (85) expr -> expr assignment exprOR .
    (98) exprOR -> exprOR . OR exprAND

    SEMICOLON       reduce using rule 85 (expr -> expr assignment exprOR .)
    ASSIGN          reduce using rule 85 (expr -> expr assignment exprOR .)
    PLUS_ASSIGN     reduce using rule 85 (expr -> expr assignment exprOR .)
    MINUS_ASSIGN    reduce using rule 85 (expr -> expr assignment exprOR .)
    MUL_ASSIGN      reduce using rule 85 (expr -> expr assignment exprOR .)
    DIV_ASSIGN      reduce using rule 85 (expr -> expr assignment exprOR .)
    AND_ASSIGN      reduce using rule 85 (expr -> expr assignment exprOR .)
    OR_ASSIGN       reduce using rule 85 (expr -> expr assignment exprOR .)
    XOR_ASSIGN      reduce using rule 85 (expr -> expr assignment exprOR .)
    MOD_ASSIGN      reduce using rule 85 (expr -> expr assignment exprOR .)
    L_SHIFT_ASSIGN  reduce using rule 85 (expr -> expr assignment exprOR .)
    R_SHIFT_ASSIGN  reduce using rule 85 (expr -> expr assignment exprOR .)
    R_PAREN         reduce using rule 85 (expr -> expr assignment exprOR .)
    COMMA           reduce using rule 85 (expr -> expr assignment exprOR .)
    R_SQBRACE       reduce using rule 85 (expr -> expr assignment exprOR .)
    R_FLOWBRACE     reduce using rule 85 (expr -> expr assignment exprOR .)
    OR              shift and go to state 74


state 126

    (58) simple -> RETURN expr SEMICOLON .

    IF              reduce using rule 58 (simple -> RETURN expr SEMICOLON .)
    WHILE           reduce using rule 58 (simple -> RETURN expr SEMICOLON .)
    FOR             reduce using rule 58 (simple -> RETURN expr SEMICOLON .)
    SEMICOLON       reduce using rule 58 (simple -> RETURN expr SEMICOLON .)
    RETURN          reduce using rule 58 (simple -> RETURN expr SEMICOLON .)
    HASH            reduce using rule 58 (simple -> RETURN expr SEMICOLON .)
    TYPE            reduce using rule 58 (simple -> RETURN expr SEMICOLON .)
    L_FLOWBRACE     reduce using rule 58 (simple -> RETURN expr SEMICOLON .)
    NOT             reduce using rule 58 (simple -> RETURN expr SEMICOLON .)
    PLUS            reduce using rule 58 (simple -> RETURN expr SEMICOLON .)
    MINUS           reduce using rule 58 (simple -> RETURN expr SEMICOLON .)
    PLUS_PLUS       reduce using rule 58 (simple -> RETURN expr SEMICOLON .)
    MINUS_MINUS     reduce using rule 58 (simple -> RETURN expr SEMICOLON .)
    L_PAREN         reduce using rule 58 (simple -> RETURN expr SEMICOLON .)
    STRING          reduce using rule 58 (simple -> RETURN expr SEMICOLON .)
    MULTIPLY        reduce using rule 58 (simple -> RETURN expr SEMICOLON .)
    BIT_AND         reduce using rule 58 (simple -> RETURN expr SEMICOLON .)
    ID              reduce using rule 58 (simple -> RETURN expr SEMICOLON .)
    CHAR            reduce using rule 58 (simple -> RETURN expr SEMICOLON .)
    INT_NUM         reduce using rule 58 (simple -> RETURN expr SEMICOLON .)
    FLOAT_NUM       reduce using rule 58 (simple -> RETURN expr SEMICOLON .)
    $end            reduce using rule 58 (simple -> RETURN expr SEMICOLON .)
    R_FLOWBRACE     reduce using rule 58 (simple -> RETURN expr SEMICOLON .)
    ELSE            reduce using rule 58 (simple -> RETURN expr SEMICOLON .)
    R_PAREN         reduce using rule 58 (simple -> RETURN expr SEMICOLON .)


state 127

    (49) block -> left_flower multiple_statements right_flower .

    IF              reduce using rule 49 (block -> left_flower multiple_statements right_flower .)
    WHILE           reduce using rule 49 (block -> left_flower multiple_statements right_flower .)
    FOR             reduce using rule 49 (block -> left_flower multiple_statements right_flower .)
    SEMICOLON       reduce using rule 49 (block -> left_flower multiple_statements right_flower .)
    RETURN          reduce using rule 49 (block -> left_flower multiple_statements right_flower .)
    HASH            reduce using rule 49 (block -> left_flower multiple_statements right_flower .)
    TYPE            reduce using rule 49 (block -> left_flower multiple_statements right_flower .)
    L_FLOWBRACE     reduce using rule 49 (block -> left_flower multiple_statements right_flower .)
    NOT             reduce using rule 49 (block -> left_flower multiple_statements right_flower .)
    PLUS            reduce using rule 49 (block -> left_flower multiple_statements right_flower .)
    MINUS           reduce using rule 49 (block -> left_flower multiple_statements right_flower .)
    PLUS_PLUS       reduce using rule 49 (block -> left_flower multiple_statements right_flower .)
    MINUS_MINUS     reduce using rule 49 (block -> left_flower multiple_statements right_flower .)
    L_PAREN         reduce using rule 49 (block -> left_flower multiple_statements right_flower .)
    STRING          reduce using rule 49 (block -> left_flower multiple_statements right_flower .)
    MULTIPLY        reduce using rule 49 (block -> left_flower multiple_statements right_flower .)
    BIT_AND         reduce using rule 49 (block -> left_flower multiple_statements right_flower .)
    ID              reduce using rule 49 (block -> left_flower multiple_statements right_flower .)
    CHAR            reduce using rule 49 (block -> left_flower multiple_statements right_flower .)
    INT_NUM         reduce using rule 49 (block -> left_flower multiple_statements right_flower .)
    FLOAT_NUM       reduce using rule 49 (block -> left_flower multiple_statements right_flower .)
    $end            reduce using rule 49 (block -> left_flower multiple_statements right_flower .)
    R_FLOWBRACE     reduce using rule 49 (block -> left_flower multiple_statements right_flower .)
    ELSE            reduce using rule 49 (block -> left_flower multiple_statements right_flower .)
    R_PAREN         reduce using rule 49 (block -> left_flower multiple_statements right_flower .)


state 128

    (98) exprOR -> exprOR OR exprAND .
    (100) exprAND -> exprAND . AND exprBITOR

    OR              reduce using rule 98 (exprOR -> exprOR OR exprAND .)
    SEMICOLON       reduce using rule 98 (exprOR -> exprOR OR exprAND .)
    ASSIGN          reduce using rule 98 (exprOR -> exprOR OR exprAND .)
    PLUS_ASSIGN     reduce using rule 98 (exprOR -> exprOR OR exprAND .)
    MINUS_ASSIGN    reduce using rule 98 (exprOR -> exprOR OR exprAND .)
    MUL_ASSIGN      reduce using rule 98 (exprOR -> exprOR OR exprAND .)
    DIV_ASSIGN      reduce using rule 98 (exprOR -> exprOR OR exprAND .)
    AND_ASSIGN      reduce using rule 98 (exprOR -> exprOR OR exprAND .)
    OR_ASSIGN       reduce using rule 98 (exprOR -> exprOR OR exprAND .)
    XOR_ASSIGN      reduce using rule 98 (exprOR -> exprOR OR exprAND .)
    MOD_ASSIGN      reduce using rule 98 (exprOR -> exprOR OR exprAND .)
    L_SHIFT_ASSIGN  reduce using rule 98 (exprOR -> exprOR OR exprAND .)
    R_SHIFT_ASSIGN  reduce using rule 98 (exprOR -> exprOR OR exprAND .)
    R_PAREN         reduce using rule 98 (exprOR -> exprOR OR exprAND .)
    COMMA           reduce using rule 98 (exprOR -> exprOR OR exprAND .)
    R_SQBRACE       reduce using rule 98 (exprOR -> exprOR OR exprAND .)
    R_FLOWBRACE     reduce using rule 98 (exprOR -> exprOR OR exprAND .)
    AND             shift and go to state 86


state 129

    (60) header -> HASH INCLUDE STRING .

    IF              reduce using rule 60 (header -> HASH INCLUDE STRING .)
    WHILE           reduce using rule 60 (header -> HASH INCLUDE STRING .)
    FOR             reduce using rule 60 (header -> HASH INCLUDE STRING .)
    SEMICOLON       reduce using rule 60 (header -> HASH INCLUDE STRING .)
    RETURN          reduce using rule 60 (header -> HASH INCLUDE STRING .)
    HASH            reduce using rule 60 (header -> HASH INCLUDE STRING .)
    TYPE            reduce using rule 60 (header -> HASH INCLUDE STRING .)
    L_FLOWBRACE     reduce using rule 60 (header -> HASH INCLUDE STRING .)
    NOT             reduce using rule 60 (header -> HASH INCLUDE STRING .)
    PLUS            reduce using rule 60 (header -> HASH INCLUDE STRING .)
    MINUS           reduce using rule 60 (header -> HASH INCLUDE STRING .)
    PLUS_PLUS       reduce using rule 60 (header -> HASH INCLUDE STRING .)
    MINUS_MINUS     reduce using rule 60 (header -> HASH INCLUDE STRING .)
    L_PAREN         reduce using rule 60 (header -> HASH INCLUDE STRING .)
    STRING          reduce using rule 60 (header -> HASH INCLUDE STRING .)
    MULTIPLY        reduce using rule 60 (header -> HASH INCLUDE STRING .)
    BIT_AND         reduce using rule 60 (header -> HASH INCLUDE STRING .)
    ID              reduce using rule 60 (header -> HASH INCLUDE STRING .)
    CHAR            reduce using rule 60 (header -> HASH INCLUDE STRING .)
    INT_NUM         reduce using rule 60 (header -> HASH INCLUDE STRING .)
    FLOAT_NUM       reduce using rule 60 (header -> HASH INCLUDE STRING .)
    $end            reduce using rule 60 (header -> HASH INCLUDE STRING .)
    R_FLOWBRACE     reduce using rule 60 (header -> HASH INCLUDE STRING .)
    ELSE            reduce using rule 60 (header -> HASH INCLUDE STRING .)
    R_PAREN         reduce using rule 60 (header -> HASH INCLUDE STRING .)


state 130

    (61) header -> HASH INCLUDE HEADER_FILE .

    IF              reduce using rule 61 (header -> HASH INCLUDE HEADER_FILE .)
    WHILE           reduce using rule 61 (header -> HASH INCLUDE HEADER_FILE .)
    FOR             reduce using rule 61 (header -> HASH INCLUDE HEADER_FILE .)
    SEMICOLON       reduce using rule 61 (header -> HASH INCLUDE HEADER_FILE .)
    RETURN          reduce using rule 61 (header -> HASH INCLUDE HEADER_FILE .)
    HASH            reduce using rule 61 (header -> HASH INCLUDE HEADER_FILE .)
    TYPE            reduce using rule 61 (header -> HASH INCLUDE HEADER_FILE .)
    L_FLOWBRACE     reduce using rule 61 (header -> HASH INCLUDE HEADER_FILE .)
    NOT             reduce using rule 61 (header -> HASH INCLUDE HEADER_FILE .)
    PLUS            reduce using rule 61 (header -> HASH INCLUDE HEADER_FILE .)
    MINUS           reduce using rule 61 (header -> HASH INCLUDE HEADER_FILE .)
    PLUS_PLUS       reduce using rule 61 (header -> HASH INCLUDE HEADER_FILE .)
    MINUS_MINUS     reduce using rule 61 (header -> HASH INCLUDE HEADER_FILE .)
    L_PAREN         reduce using rule 61 (header -> HASH INCLUDE HEADER_FILE .)
    STRING          reduce using rule 61 (header -> HASH INCLUDE HEADER_FILE .)
    MULTIPLY        reduce using rule 61 (header -> HASH INCLUDE HEADER_FILE .)
    BIT_AND         reduce using rule 61 (header -> HASH INCLUDE HEADER_FILE .)
    ID              reduce using rule 61 (header -> HASH INCLUDE HEADER_FILE .)
    CHAR            reduce using rule 61 (header -> HASH INCLUDE HEADER_FILE .)
    INT_NUM         reduce using rule 61 (header -> HASH INCLUDE HEADER_FILE .)
    FLOAT_NUM       reduce using rule 61 (header -> HASH INCLUDE HEADER_FILE .)
    $end            reduce using rule 61 (header -> HASH INCLUDE HEADER_FILE .)
    R_FLOWBRACE     reduce using rule 61 (header -> HASH INCLUDE HEADER_FILE .)
    ELSE            reduce using rule 61 (header -> HASH INCLUDE HEADER_FILE .)
    R_PAREN         reduce using rule 61 (header -> HASH INCLUDE HEADER_FILE .)


state 131

    (34) declaration -> TYPE ID SEMICOLON .

    IF              reduce using rule 34 (declaration -> TYPE ID SEMICOLON .)
    WHILE           reduce using rule 34 (declaration -> TYPE ID SEMICOLON .)
    FOR             reduce using rule 34 (declaration -> TYPE ID SEMICOLON .)
    SEMICOLON       reduce using rule 34 (declaration -> TYPE ID SEMICOLON .)
    RETURN          reduce using rule 34 (declaration -> TYPE ID SEMICOLON .)
    HASH            reduce using rule 34 (declaration -> TYPE ID SEMICOLON .)
    TYPE            reduce using rule 34 (declaration -> TYPE ID SEMICOLON .)
    L_FLOWBRACE     reduce using rule 34 (declaration -> TYPE ID SEMICOLON .)
    NOT             reduce using rule 34 (declaration -> TYPE ID SEMICOLON .)
    PLUS            reduce using rule 34 (declaration -> TYPE ID SEMICOLON .)
    MINUS           reduce using rule 34 (declaration -> TYPE ID SEMICOLON .)
    PLUS_PLUS       reduce using rule 34 (declaration -> TYPE ID SEMICOLON .)
    MINUS_MINUS     reduce using rule 34 (declaration -> TYPE ID SEMICOLON .)
    L_PAREN         reduce using rule 34 (declaration -> TYPE ID SEMICOLON .)
    STRING          reduce using rule 34 (declaration -> TYPE ID SEMICOLON .)
    MULTIPLY        reduce using rule 34 (declaration -> TYPE ID SEMICOLON .)
    BIT_AND         reduce using rule 34 (declaration -> TYPE ID SEMICOLON .)
    ID              reduce using rule 34 (declaration -> TYPE ID SEMICOLON .)
    CHAR            reduce using rule 34 (declaration -> TYPE ID SEMICOLON .)
    INT_NUM         reduce using rule 34 (declaration -> TYPE ID SEMICOLON .)
    FLOAT_NUM       reduce using rule 34 (declaration -> TYPE ID SEMICOLON .)
    $end            reduce using rule 34 (declaration -> TYPE ID SEMICOLON .)
    R_FLOWBRACE     reduce using rule 34 (declaration -> TYPE ID SEMICOLON .)
    ELSE            reduce using rule 34 (declaration -> TYPE ID SEMICOLON .)
    R_PAREN         reduce using rule 34 (declaration -> TYPE ID SEMICOLON .)


state 132

    (36) declaration -> TYPE ID ASSIGN . expr SEMICOLON
    (24) multi_declaration -> ID ASSIGN . expr COMMA
    (85) expr -> . expr assignment exprOR
    (86) expr -> . exprOR
    (98) exprOR -> . exprOR OR exprAND
    (99) exprOR -> . exprAND
    (100) exprAND -> . exprAND AND exprBITOR
    (101) exprAND -> . exprBITOR
    (102) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (103) exprBITOR -> . exprBITXOR
    (104) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (105) exprBITXOR -> . exprBITAND
    (106) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (107) exprBITAND -> . exprEQ
    (108) exprEQ -> . exprEQ EQ exprRELOP
    (109) exprEQ -> . exprEQ NE exprRELOP
    (110) exprEQ -> . exprRELOP
    (111) exprRELOP -> . exprRELOP relop exprSHIFT
    (112) exprRELOP -> . exprSHIFT
    (117) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (118) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (119) exprSHIFT -> . exprOP
    (120) exprOP -> . exprOP PLUS term
    (121) exprOP -> . exprOP MINUS term
    (122) exprOP -> . term
    (123) term -> . term MULTIPLY factor
    (124) term -> . term DIVIDE factor
    (125) term -> . term MOD factor
    (126) term -> . factor
    (127) factor -> . NOT factor
    (128) factor -> . PLUS factor
    (129) factor -> . MINUS factor
    (130) factor -> . PLUS_PLUS factor
    (131) factor -> . MINUS_MINUS factor
    (132) factor -> . cast brace
    (133) factor -> . brace
    (134) cast -> . L_PAREN TYPE R_PAREN
    (135) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (136) brace -> . L_PAREN expr R_PAREN
    (137) brace -> . brace PLUS_PLUS
    (138) brace -> . brace MINUS_MINUS
    (139) brace -> . NUM
    (140) brace -> . STRING
    (141) brace -> . MULTIPLY ID
    (142) brace -> . BIT_AND ID
    (143) brace -> . ID
    (144) brace -> . CHAR
    (145) brace -> . function_call
    (146) brace -> . ID narrayindex
    (147) NUM -> . INT_NUM
    (148) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    expr                           shift and go to state 172
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 133

    (39) declaration -> TYPE ID narrayindex . SEMICOLON
    (40) declaration -> TYPE ID narrayindex . ASSIGN init_list SEMICOLON
    (32) narrayindex -> narrayindex . arrayindex
    (31) arrayindex -> . L_SQBRACE index R_SQBRACE

    SEMICOLON       shift and go to state 173
    ASSIGN          shift and go to state 174
    L_SQBRACE       shift and go to state 82

    arrayindex                     shift and go to state 140

state 134

    (82) function -> TYPE ID L_PAREN . dec_params R_PAREN function_2
    (79) dec_params -> . empty
    (80) dec_params -> . yes_dec_params end_dec_params
    (81) dec_params -> . end_dec_params
    (62) empty -> .
    (70) yes_dec_params -> . yes_dec_params TYPE expr COMMA
    (71) yes_dec_params -> . yes_dec_params TYPE COMMA
    (72) yes_dec_params -> . yes_dec_params TYPE MULTIPLY COMMA
    (73) yes_dec_params -> . TYPE expr COMMA
    (74) yes_dec_params -> . TYPE COMMA
    (75) yes_dec_params -> . TYPE MULTIPLY COMMA
    (76) end_dec_params -> . TYPE expr
    (77) end_dec_params -> . TYPE
    (78) end_dec_params -> . TYPE MULTIPLY

    R_PAREN         reduce using rule 62 (empty -> .)
    TYPE            shift and go to state 175

    dec_params                     shift and go to state 176
    empty                          shift and go to state 177
    yes_dec_params                 shift and go to state 178
    end_dec_params                 shift and go to state 179

state 135

    (23) multi_declaration -> ID COMMA .

    ID              reduce using rule 23 (multi_declaration -> ID COMMA .)
    MULTIPLY        reduce using rule 23 (multi_declaration -> ID COMMA .)


state 136

    (35) declaration -> TYPE MULTIPLY ID . SEMICOLON
    (37) declaration -> TYPE MULTIPLY ID . ASSIGN expr SEMICOLON
    (25) multi_declaration -> MULTIPLY ID . COMMA
    (26) multi_declaration -> MULTIPLY ID . ASSIGN expr COMMA

    SEMICOLON       shift and go to state 180
    ASSIGN          shift and go to state 181
    COMMA           shift and go to state 182


state 137

    (38) declaration -> TYPE multi_declaration stop .

    IF              reduce using rule 38 (declaration -> TYPE multi_declaration stop .)
    WHILE           reduce using rule 38 (declaration -> TYPE multi_declaration stop .)
    FOR             reduce using rule 38 (declaration -> TYPE multi_declaration stop .)
    SEMICOLON       reduce using rule 38 (declaration -> TYPE multi_declaration stop .)
    RETURN          reduce using rule 38 (declaration -> TYPE multi_declaration stop .)
    HASH            reduce using rule 38 (declaration -> TYPE multi_declaration stop .)
    TYPE            reduce using rule 38 (declaration -> TYPE multi_declaration stop .)
    L_FLOWBRACE     reduce using rule 38 (declaration -> TYPE multi_declaration stop .)
    NOT             reduce using rule 38 (declaration -> TYPE multi_declaration stop .)
    PLUS            reduce using rule 38 (declaration -> TYPE multi_declaration stop .)
    MINUS           reduce using rule 38 (declaration -> TYPE multi_declaration stop .)
    PLUS_PLUS       reduce using rule 38 (declaration -> TYPE multi_declaration stop .)
    MINUS_MINUS     reduce using rule 38 (declaration -> TYPE multi_declaration stop .)
    L_PAREN         reduce using rule 38 (declaration -> TYPE multi_declaration stop .)
    STRING          reduce using rule 38 (declaration -> TYPE multi_declaration stop .)
    MULTIPLY        reduce using rule 38 (declaration -> TYPE multi_declaration stop .)
    BIT_AND         reduce using rule 38 (declaration -> TYPE multi_declaration stop .)
    ID              reduce using rule 38 (declaration -> TYPE multi_declaration stop .)
    CHAR            reduce using rule 38 (declaration -> TYPE multi_declaration stop .)
    INT_NUM         reduce using rule 38 (declaration -> TYPE multi_declaration stop .)
    FLOAT_NUM       reduce using rule 38 (declaration -> TYPE multi_declaration stop .)
    $end            reduce using rule 38 (declaration -> TYPE multi_declaration stop .)
    R_FLOWBRACE     reduce using rule 38 (declaration -> TYPE multi_declaration stop .)
    ELSE            reduce using rule 38 (declaration -> TYPE multi_declaration stop .)
    R_PAREN         reduce using rule 38 (declaration -> TYPE multi_declaration stop .)


state 138

    (19) multi_declaration -> multi_declaration ID . COMMA
    (21) multi_declaration -> multi_declaration ID . ASSIGN expr COMMA
    (27) stop -> ID . SEMICOLON
    (29) stop -> ID . ASSIGN expr SEMICOLON

    COMMA           shift and go to state 183
    ASSIGN          shift and go to state 184
    SEMICOLON       shift and go to state 185


state 139

    (20) multi_declaration -> multi_declaration MULTIPLY . ID COMMA
    (22) multi_declaration -> multi_declaration MULTIPLY . ID ASSIGN expr COMMA
    (28) stop -> MULTIPLY . ID SEMICOLON
    (30) stop -> MULTIPLY . ID ASSIGN expr SEMICOLON

    ID              shift and go to state 186


state 140

    (32) narrayindex -> narrayindex arrayindex .

    L_SQBRACE       reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    PLUS_PLUS       reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    MINUS_MINUS     reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    MULTIPLY        reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    DIVIDE          reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    MOD             reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    PLUS            reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    MINUS           reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    L_SHIFT         reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    R_SHIFT         reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    LE              reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    LT              reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    GE              reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    GT              reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    EQ              reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    NE              reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    BIT_AND         reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    BIT_XOR         reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    BIT_OR          reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    AND             reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    OR              reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    SEMICOLON       reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    ASSIGN          reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    PLUS_ASSIGN     reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    MINUS_ASSIGN    reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    MUL_ASSIGN      reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    DIV_ASSIGN      reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    AND_ASSIGN      reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    OR_ASSIGN       reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    XOR_ASSIGN      reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    MOD_ASSIGN      reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    L_SHIFT_ASSIGN  reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    R_SHIFT_ASSIGN  reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    R_PAREN         reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    COMMA           reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    R_SQBRACE       reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    R_FLOWBRACE     reduce using rule 32 (narrayindex -> narrayindex arrayindex .)


state 141

    (63) function_call -> ID L_PAREN call_params . R_PAREN

    R_PAREN         shift and go to state 187


state 142

    (64) call_params -> empty .

    R_PAREN         reduce using rule 64 (call_params -> empty .)


state 143

    (65) call_params -> yes_call_params . end_call_params
    (67) yes_call_params -> yes_call_params . expr COMMA
    (69) end_call_params -> . expr
    (85) expr -> . expr assignment exprOR
    (86) expr -> . exprOR
    (98) exprOR -> . exprOR OR exprAND
    (99) exprOR -> . exprAND
    (100) exprAND -> . exprAND AND exprBITOR
    (101) exprAND -> . exprBITOR
    (102) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (103) exprBITOR -> . exprBITXOR
    (104) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (105) exprBITXOR -> . exprBITAND
    (106) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (107) exprBITAND -> . exprEQ
    (108) exprEQ -> . exprEQ EQ exprRELOP
    (109) exprEQ -> . exprEQ NE exprRELOP
    (110) exprEQ -> . exprRELOP
    (111) exprRELOP -> . exprRELOP relop exprSHIFT
    (112) exprRELOP -> . exprSHIFT
    (117) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (118) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (119) exprSHIFT -> . exprOP
    (120) exprOP -> . exprOP PLUS term
    (121) exprOP -> . exprOP MINUS term
    (122) exprOP -> . term
    (123) term -> . term MULTIPLY factor
    (124) term -> . term DIVIDE factor
    (125) term -> . term MOD factor
    (126) term -> . factor
    (127) factor -> . NOT factor
    (128) factor -> . PLUS factor
    (129) factor -> . MINUS factor
    (130) factor -> . PLUS_PLUS factor
    (131) factor -> . MINUS_MINUS factor
    (132) factor -> . cast brace
    (133) factor -> . brace
    (134) cast -> . L_PAREN TYPE R_PAREN
    (135) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (136) brace -> . L_PAREN expr R_PAREN
    (137) brace -> . brace PLUS_PLUS
    (138) brace -> . brace MINUS_MINUS
    (139) brace -> . NUM
    (140) brace -> . STRING
    (141) brace -> . MULTIPLY ID
    (142) brace -> . BIT_AND ID
    (143) brace -> . ID
    (144) brace -> . CHAR
    (145) brace -> . function_call
    (146) brace -> . ID narrayindex
    (147) NUM -> . INT_NUM
    (148) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    end_call_params                shift and go to state 188
    expr                           shift and go to state 189
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 144

    (66) call_params -> end_call_params .

    R_PAREN         reduce using rule 66 (call_params -> end_call_params .)


state 145

    (68) yes_call_params -> expr . COMMA
    (69) end_call_params -> expr .
    (85) expr -> expr . assignment exprOR
    (87) assignment -> . ASSIGN
    (88) assignment -> . PLUS_ASSIGN
    (89) assignment -> . MINUS_ASSIGN
    (90) assignment -> . MUL_ASSIGN
    (91) assignment -> . DIV_ASSIGN
    (92) assignment -> . AND_ASSIGN
    (93) assignment -> . OR_ASSIGN
    (94) assignment -> . XOR_ASSIGN
    (95) assignment -> . MOD_ASSIGN
    (96) assignment -> . L_SHIFT_ASSIGN
    (97) assignment -> . R_SHIFT_ASSIGN

    COMMA           shift and go to state 190
    R_PAREN         reduce using rule 69 (end_call_params -> expr .)
    ASSIGN          shift and go to state 58
    PLUS_ASSIGN     shift and go to state 59
    MINUS_ASSIGN    shift and go to state 60
    MUL_ASSIGN      shift and go to state 61
    DIV_ASSIGN      shift and go to state 62
    AND_ASSIGN      shift and go to state 63
    OR_ASSIGN       shift and go to state 64
    XOR_ASSIGN      shift and go to state 65
    MOD_ASSIGN      shift and go to state 66
    L_SHIFT_ASSIGN  shift and go to state 67
    R_SHIFT_ASSIGN  shift and go to state 68

    assignment                     shift and go to state 57

state 146

    (31) arrayindex -> L_SQBRACE index . R_SQBRACE

    R_SQBRACE       shift and go to state 191


state 147

    (47) index -> expr .
    (85) expr -> expr . assignment exprOR
    (87) assignment -> . ASSIGN
    (88) assignment -> . PLUS_ASSIGN
    (89) assignment -> . MINUS_ASSIGN
    (90) assignment -> . MUL_ASSIGN
    (91) assignment -> . DIV_ASSIGN
    (92) assignment -> . AND_ASSIGN
    (93) assignment -> . OR_ASSIGN
    (94) assignment -> . XOR_ASSIGN
    (95) assignment -> . MOD_ASSIGN
    (96) assignment -> . L_SHIFT_ASSIGN
    (97) assignment -> . R_SHIFT_ASSIGN

    R_SQBRACE       reduce using rule 47 (index -> expr .)
    ASSIGN          shift and go to state 58
    PLUS_ASSIGN     shift and go to state 59
    MINUS_ASSIGN    shift and go to state 60
    MUL_ASSIGN      shift and go to state 61
    DIV_ASSIGN      shift and go to state 62
    AND_ASSIGN      shift and go to state 63
    OR_ASSIGN       shift and go to state 64
    XOR_ASSIGN      shift and go to state 65
    MOD_ASSIGN      shift and go to state 66
    L_SHIFT_ASSIGN  shift and go to state 67
    R_SHIFT_ASSIGN  shift and go to state 68

    assignment                     shift and go to state 57

state 148

    (48) index -> empty .

    R_SQBRACE       reduce using rule 48 (index -> empty .)


state 149

    (134) cast -> L_PAREN TYPE R_PAREN .

    L_PAREN         reduce using rule 134 (cast -> L_PAREN TYPE R_PAREN .)
    STRING          reduce using rule 134 (cast -> L_PAREN TYPE R_PAREN .)
    MULTIPLY        reduce using rule 134 (cast -> L_PAREN TYPE R_PAREN .)
    BIT_AND         reduce using rule 134 (cast -> L_PAREN TYPE R_PAREN .)
    ID              reduce using rule 134 (cast -> L_PAREN TYPE R_PAREN .)
    CHAR            reduce using rule 134 (cast -> L_PAREN TYPE R_PAREN .)
    INT_NUM         reduce using rule 134 (cast -> L_PAREN TYPE R_PAREN .)
    FLOAT_NUM       reduce using rule 134 (cast -> L_PAREN TYPE R_PAREN .)


state 150

    (135) cast -> L_PAREN TYPE MULTIPLY . R_PAREN

    R_PAREN         shift and go to state 192


state 151

    (136) brace -> L_PAREN expr R_PAREN .

    PLUS_PLUS       reduce using rule 136 (brace -> L_PAREN expr R_PAREN .)
    MINUS_MINUS     reduce using rule 136 (brace -> L_PAREN expr R_PAREN .)
    MULTIPLY        reduce using rule 136 (brace -> L_PAREN expr R_PAREN .)
    DIVIDE          reduce using rule 136 (brace -> L_PAREN expr R_PAREN .)
    MOD             reduce using rule 136 (brace -> L_PAREN expr R_PAREN .)
    PLUS            reduce using rule 136 (brace -> L_PAREN expr R_PAREN .)
    MINUS           reduce using rule 136 (brace -> L_PAREN expr R_PAREN .)
    L_SHIFT         reduce using rule 136 (brace -> L_PAREN expr R_PAREN .)
    R_SHIFT         reduce using rule 136 (brace -> L_PAREN expr R_PAREN .)
    LE              reduce using rule 136 (brace -> L_PAREN expr R_PAREN .)
    LT              reduce using rule 136 (brace -> L_PAREN expr R_PAREN .)
    GE              reduce using rule 136 (brace -> L_PAREN expr R_PAREN .)
    GT              reduce using rule 136 (brace -> L_PAREN expr R_PAREN .)
    EQ              reduce using rule 136 (brace -> L_PAREN expr R_PAREN .)
    NE              reduce using rule 136 (brace -> L_PAREN expr R_PAREN .)
    BIT_AND         reduce using rule 136 (brace -> L_PAREN expr R_PAREN .)
    BIT_XOR         reduce using rule 136 (brace -> L_PAREN expr R_PAREN .)
    BIT_OR          reduce using rule 136 (brace -> L_PAREN expr R_PAREN .)
    AND             reduce using rule 136 (brace -> L_PAREN expr R_PAREN .)
    OR              reduce using rule 136 (brace -> L_PAREN expr R_PAREN .)
    SEMICOLON       reduce using rule 136 (brace -> L_PAREN expr R_PAREN .)
    ASSIGN          reduce using rule 136 (brace -> L_PAREN expr R_PAREN .)
    PLUS_ASSIGN     reduce using rule 136 (brace -> L_PAREN expr R_PAREN .)
    MINUS_ASSIGN    reduce using rule 136 (brace -> L_PAREN expr R_PAREN .)
    MUL_ASSIGN      reduce using rule 136 (brace -> L_PAREN expr R_PAREN .)
    DIV_ASSIGN      reduce using rule 136 (brace -> L_PAREN expr R_PAREN .)
    AND_ASSIGN      reduce using rule 136 (brace -> L_PAREN expr R_PAREN .)
    OR_ASSIGN       reduce using rule 136 (brace -> L_PAREN expr R_PAREN .)
    XOR_ASSIGN      reduce using rule 136 (brace -> L_PAREN expr R_PAREN .)
    MOD_ASSIGN      reduce using rule 136 (brace -> L_PAREN expr R_PAREN .)
    L_SHIFT_ASSIGN  reduce using rule 136 (brace -> L_PAREN expr R_PAREN .)
    R_SHIFT_ASSIGN  reduce using rule 136 (brace -> L_PAREN expr R_PAREN .)
    R_PAREN         reduce using rule 136 (brace -> L_PAREN expr R_PAREN .)
    COMMA           reduce using rule 136 (brace -> L_PAREN expr R_PAREN .)
    R_SQBRACE       reduce using rule 136 (brace -> L_PAREN expr R_PAREN .)
    R_FLOWBRACE     reduce using rule 136 (brace -> L_PAREN expr R_PAREN .)


state 152

    (100) exprAND -> exprAND AND exprBITOR .
    (102) exprBITOR -> exprBITOR . BIT_OR exprBITXOR

    AND             reduce using rule 100 (exprAND -> exprAND AND exprBITOR .)
    OR              reduce using rule 100 (exprAND -> exprAND AND exprBITOR .)
    SEMICOLON       reduce using rule 100 (exprAND -> exprAND AND exprBITOR .)
    ASSIGN          reduce using rule 100 (exprAND -> exprAND AND exprBITOR .)
    PLUS_ASSIGN     reduce using rule 100 (exprAND -> exprAND AND exprBITOR .)
    MINUS_ASSIGN    reduce using rule 100 (exprAND -> exprAND AND exprBITOR .)
    MUL_ASSIGN      reduce using rule 100 (exprAND -> exprAND AND exprBITOR .)
    DIV_ASSIGN      reduce using rule 100 (exprAND -> exprAND AND exprBITOR .)
    AND_ASSIGN      reduce using rule 100 (exprAND -> exprAND AND exprBITOR .)
    OR_ASSIGN       reduce using rule 100 (exprAND -> exprAND AND exprBITOR .)
    XOR_ASSIGN      reduce using rule 100 (exprAND -> exprAND AND exprBITOR .)
    MOD_ASSIGN      reduce using rule 100 (exprAND -> exprAND AND exprBITOR .)
    L_SHIFT_ASSIGN  reduce using rule 100 (exprAND -> exprAND AND exprBITOR .)
    R_SHIFT_ASSIGN  reduce using rule 100 (exprAND -> exprAND AND exprBITOR .)
    R_PAREN         reduce using rule 100 (exprAND -> exprAND AND exprBITOR .)
    COMMA           reduce using rule 100 (exprAND -> exprAND AND exprBITOR .)
    R_SQBRACE       reduce using rule 100 (exprAND -> exprAND AND exprBITOR .)
    R_FLOWBRACE     reduce using rule 100 (exprAND -> exprAND AND exprBITOR .)
    BIT_OR          shift and go to state 87


state 153

    (102) exprBITOR -> exprBITOR BIT_OR exprBITXOR .
    (104) exprBITXOR -> exprBITXOR . BIT_XOR exprBITAND

    BIT_OR          reduce using rule 102 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    AND             reduce using rule 102 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    OR              reduce using rule 102 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    SEMICOLON       reduce using rule 102 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    ASSIGN          reduce using rule 102 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    PLUS_ASSIGN     reduce using rule 102 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    MINUS_ASSIGN    reduce using rule 102 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    MUL_ASSIGN      reduce using rule 102 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    DIV_ASSIGN      reduce using rule 102 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    AND_ASSIGN      reduce using rule 102 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    OR_ASSIGN       reduce using rule 102 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    XOR_ASSIGN      reduce using rule 102 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    MOD_ASSIGN      reduce using rule 102 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    L_SHIFT_ASSIGN  reduce using rule 102 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    R_SHIFT_ASSIGN  reduce using rule 102 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    R_PAREN         reduce using rule 102 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    COMMA           reduce using rule 102 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    R_SQBRACE       reduce using rule 102 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    R_FLOWBRACE     reduce using rule 102 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    BIT_XOR         shift and go to state 88


state 154

    (104) exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .
    (106) exprBITAND -> exprBITAND . BIT_AND exprEQ

    BIT_XOR         reduce using rule 104 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    BIT_OR          reduce using rule 104 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    AND             reduce using rule 104 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    OR              reduce using rule 104 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    SEMICOLON       reduce using rule 104 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    ASSIGN          reduce using rule 104 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    PLUS_ASSIGN     reduce using rule 104 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    MINUS_ASSIGN    reduce using rule 104 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    MUL_ASSIGN      reduce using rule 104 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    DIV_ASSIGN      reduce using rule 104 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    AND_ASSIGN      reduce using rule 104 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    OR_ASSIGN       reduce using rule 104 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    XOR_ASSIGN      reduce using rule 104 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    MOD_ASSIGN      reduce using rule 104 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    L_SHIFT_ASSIGN  reduce using rule 104 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    R_SHIFT_ASSIGN  reduce using rule 104 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    R_PAREN         reduce using rule 104 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    COMMA           reduce using rule 104 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    R_SQBRACE       reduce using rule 104 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    R_FLOWBRACE     reduce using rule 104 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    BIT_AND         shift and go to state 89


state 155

    (106) exprBITAND -> exprBITAND BIT_AND exprEQ .
    (108) exprEQ -> exprEQ . EQ exprRELOP
    (109) exprEQ -> exprEQ . NE exprRELOP

    BIT_AND         reduce using rule 106 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    BIT_XOR         reduce using rule 106 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    BIT_OR          reduce using rule 106 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    AND             reduce using rule 106 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    OR              reduce using rule 106 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    SEMICOLON       reduce using rule 106 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    ASSIGN          reduce using rule 106 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    PLUS_ASSIGN     reduce using rule 106 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    MINUS_ASSIGN    reduce using rule 106 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    MUL_ASSIGN      reduce using rule 106 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    DIV_ASSIGN      reduce using rule 106 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    AND_ASSIGN      reduce using rule 106 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    OR_ASSIGN       reduce using rule 106 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    XOR_ASSIGN      reduce using rule 106 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    MOD_ASSIGN      reduce using rule 106 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    L_SHIFT_ASSIGN  reduce using rule 106 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    R_SHIFT_ASSIGN  reduce using rule 106 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    R_PAREN         reduce using rule 106 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    COMMA           reduce using rule 106 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    R_SQBRACE       reduce using rule 106 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    R_FLOWBRACE     reduce using rule 106 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    EQ              shift and go to state 91
    NE              shift and go to state 92


state 156

    (108) exprEQ -> exprEQ EQ exprRELOP .
    (111) exprRELOP -> exprRELOP . relop exprSHIFT
    (113) relop -> . LE
    (114) relop -> . LT
    (115) relop -> . GE
    (116) relop -> . GT

    EQ              reduce using rule 108 (exprEQ -> exprEQ EQ exprRELOP .)
    NE              reduce using rule 108 (exprEQ -> exprEQ EQ exprRELOP .)
    BIT_AND         reduce using rule 108 (exprEQ -> exprEQ EQ exprRELOP .)
    BIT_XOR         reduce using rule 108 (exprEQ -> exprEQ EQ exprRELOP .)
    BIT_OR          reduce using rule 108 (exprEQ -> exprEQ EQ exprRELOP .)
    AND             reduce using rule 108 (exprEQ -> exprEQ EQ exprRELOP .)
    OR              reduce using rule 108 (exprEQ -> exprEQ EQ exprRELOP .)
    SEMICOLON       reduce using rule 108 (exprEQ -> exprEQ EQ exprRELOP .)
    ASSIGN          reduce using rule 108 (exprEQ -> exprEQ EQ exprRELOP .)
    PLUS_ASSIGN     reduce using rule 108 (exprEQ -> exprEQ EQ exprRELOP .)
    MINUS_ASSIGN    reduce using rule 108 (exprEQ -> exprEQ EQ exprRELOP .)
    MUL_ASSIGN      reduce using rule 108 (exprEQ -> exprEQ EQ exprRELOP .)
    DIV_ASSIGN      reduce using rule 108 (exprEQ -> exprEQ EQ exprRELOP .)
    AND_ASSIGN      reduce using rule 108 (exprEQ -> exprEQ EQ exprRELOP .)
    OR_ASSIGN       reduce using rule 108 (exprEQ -> exprEQ EQ exprRELOP .)
    XOR_ASSIGN      reduce using rule 108 (exprEQ -> exprEQ EQ exprRELOP .)
    MOD_ASSIGN      reduce using rule 108 (exprEQ -> exprEQ EQ exprRELOP .)
    L_SHIFT_ASSIGN  reduce using rule 108 (exprEQ -> exprEQ EQ exprRELOP .)
    R_SHIFT_ASSIGN  reduce using rule 108 (exprEQ -> exprEQ EQ exprRELOP .)
    R_PAREN         reduce using rule 108 (exprEQ -> exprEQ EQ exprRELOP .)
    COMMA           reduce using rule 108 (exprEQ -> exprEQ EQ exprRELOP .)
    R_SQBRACE       reduce using rule 108 (exprEQ -> exprEQ EQ exprRELOP .)
    R_FLOWBRACE     reduce using rule 108 (exprEQ -> exprEQ EQ exprRELOP .)
    LE              shift and go to state 94
    LT              shift and go to state 95
    GE              shift and go to state 96
    GT              shift and go to state 97

    relop                          shift and go to state 93

state 157

    (109) exprEQ -> exprEQ NE exprRELOP .
    (111) exprRELOP -> exprRELOP . relop exprSHIFT
    (113) relop -> . LE
    (114) relop -> . LT
    (115) relop -> . GE
    (116) relop -> . GT

    EQ              reduce using rule 109 (exprEQ -> exprEQ NE exprRELOP .)
    NE              reduce using rule 109 (exprEQ -> exprEQ NE exprRELOP .)
    BIT_AND         reduce using rule 109 (exprEQ -> exprEQ NE exprRELOP .)
    BIT_XOR         reduce using rule 109 (exprEQ -> exprEQ NE exprRELOP .)
    BIT_OR          reduce using rule 109 (exprEQ -> exprEQ NE exprRELOP .)
    AND             reduce using rule 109 (exprEQ -> exprEQ NE exprRELOP .)
    OR              reduce using rule 109 (exprEQ -> exprEQ NE exprRELOP .)
    SEMICOLON       reduce using rule 109 (exprEQ -> exprEQ NE exprRELOP .)
    ASSIGN          reduce using rule 109 (exprEQ -> exprEQ NE exprRELOP .)
    PLUS_ASSIGN     reduce using rule 109 (exprEQ -> exprEQ NE exprRELOP .)
    MINUS_ASSIGN    reduce using rule 109 (exprEQ -> exprEQ NE exprRELOP .)
    MUL_ASSIGN      reduce using rule 109 (exprEQ -> exprEQ NE exprRELOP .)
    DIV_ASSIGN      reduce using rule 109 (exprEQ -> exprEQ NE exprRELOP .)
    AND_ASSIGN      reduce using rule 109 (exprEQ -> exprEQ NE exprRELOP .)
    OR_ASSIGN       reduce using rule 109 (exprEQ -> exprEQ NE exprRELOP .)
    XOR_ASSIGN      reduce using rule 109 (exprEQ -> exprEQ NE exprRELOP .)
    MOD_ASSIGN      reduce using rule 109 (exprEQ -> exprEQ NE exprRELOP .)
    L_SHIFT_ASSIGN  reduce using rule 109 (exprEQ -> exprEQ NE exprRELOP .)
    R_SHIFT_ASSIGN  reduce using rule 109 (exprEQ -> exprEQ NE exprRELOP .)
    R_PAREN         reduce using rule 109 (exprEQ -> exprEQ NE exprRELOP .)
    COMMA           reduce using rule 109 (exprEQ -> exprEQ NE exprRELOP .)
    R_SQBRACE       reduce using rule 109 (exprEQ -> exprEQ NE exprRELOP .)
    R_FLOWBRACE     reduce using rule 109 (exprEQ -> exprEQ NE exprRELOP .)
    LE              shift and go to state 94
    LT              shift and go to state 95
    GE              shift and go to state 96
    GT              shift and go to state 97

    relop                          shift and go to state 93

state 158

    (111) exprRELOP -> exprRELOP relop exprSHIFT .
    (117) exprSHIFT -> exprSHIFT . L_SHIFT exprOP
    (118) exprSHIFT -> exprSHIFT . R_SHIFT exprOP

    LE              reduce using rule 111 (exprRELOP -> exprRELOP relop exprSHIFT .)
    LT              reduce using rule 111 (exprRELOP -> exprRELOP relop exprSHIFT .)
    GE              reduce using rule 111 (exprRELOP -> exprRELOP relop exprSHIFT .)
    GT              reduce using rule 111 (exprRELOP -> exprRELOP relop exprSHIFT .)
    EQ              reduce using rule 111 (exprRELOP -> exprRELOP relop exprSHIFT .)
    NE              reduce using rule 111 (exprRELOP -> exprRELOP relop exprSHIFT .)
    BIT_AND         reduce using rule 111 (exprRELOP -> exprRELOP relop exprSHIFT .)
    BIT_XOR         reduce using rule 111 (exprRELOP -> exprRELOP relop exprSHIFT .)
    BIT_OR          reduce using rule 111 (exprRELOP -> exprRELOP relop exprSHIFT .)
    AND             reduce using rule 111 (exprRELOP -> exprRELOP relop exprSHIFT .)
    OR              reduce using rule 111 (exprRELOP -> exprRELOP relop exprSHIFT .)
    SEMICOLON       reduce using rule 111 (exprRELOP -> exprRELOP relop exprSHIFT .)
    ASSIGN          reduce using rule 111 (exprRELOP -> exprRELOP relop exprSHIFT .)
    PLUS_ASSIGN     reduce using rule 111 (exprRELOP -> exprRELOP relop exprSHIFT .)
    MINUS_ASSIGN    reduce using rule 111 (exprRELOP -> exprRELOP relop exprSHIFT .)
    MUL_ASSIGN      reduce using rule 111 (exprRELOP -> exprRELOP relop exprSHIFT .)
    DIV_ASSIGN      reduce using rule 111 (exprRELOP -> exprRELOP relop exprSHIFT .)
    AND_ASSIGN      reduce using rule 111 (exprRELOP -> exprRELOP relop exprSHIFT .)
    OR_ASSIGN       reduce using rule 111 (exprRELOP -> exprRELOP relop exprSHIFT .)
    XOR_ASSIGN      reduce using rule 111 (exprRELOP -> exprRELOP relop exprSHIFT .)
    MOD_ASSIGN      reduce using rule 111 (exprRELOP -> exprRELOP relop exprSHIFT .)
    L_SHIFT_ASSIGN  reduce using rule 111 (exprRELOP -> exprRELOP relop exprSHIFT .)
    R_SHIFT_ASSIGN  reduce using rule 111 (exprRELOP -> exprRELOP relop exprSHIFT .)
    R_PAREN         reduce using rule 111 (exprRELOP -> exprRELOP relop exprSHIFT .)
    COMMA           reduce using rule 111 (exprRELOP -> exprRELOP relop exprSHIFT .)
    R_SQBRACE       reduce using rule 111 (exprRELOP -> exprRELOP relop exprSHIFT .)
    R_FLOWBRACE     reduce using rule 111 (exprRELOP -> exprRELOP relop exprSHIFT .)
    L_SHIFT         shift and go to state 98
    R_SHIFT         shift and go to state 99


state 159

    (117) exprSHIFT -> exprSHIFT L_SHIFT exprOP .
    (120) exprOP -> exprOP . PLUS term
    (121) exprOP -> exprOP . MINUS term

    L_SHIFT         reduce using rule 117 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    R_SHIFT         reduce using rule 117 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    LE              reduce using rule 117 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    LT              reduce using rule 117 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    GE              reduce using rule 117 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    GT              reduce using rule 117 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    EQ              reduce using rule 117 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    NE              reduce using rule 117 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    BIT_AND         reduce using rule 117 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    BIT_XOR         reduce using rule 117 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    BIT_OR          reduce using rule 117 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    AND             reduce using rule 117 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    OR              reduce using rule 117 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    SEMICOLON       reduce using rule 117 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    ASSIGN          reduce using rule 117 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    PLUS_ASSIGN     reduce using rule 117 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    MINUS_ASSIGN    reduce using rule 117 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    MUL_ASSIGN      reduce using rule 117 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    DIV_ASSIGN      reduce using rule 117 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    AND_ASSIGN      reduce using rule 117 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    OR_ASSIGN       reduce using rule 117 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    XOR_ASSIGN      reduce using rule 117 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    MOD_ASSIGN      reduce using rule 117 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    L_SHIFT_ASSIGN  reduce using rule 117 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    R_SHIFT_ASSIGN  reduce using rule 117 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    R_PAREN         reduce using rule 117 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    COMMA           reduce using rule 117 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    R_SQBRACE       reduce using rule 117 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    R_FLOWBRACE     reduce using rule 117 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101


state 160

    (118) exprSHIFT -> exprSHIFT R_SHIFT exprOP .
    (120) exprOP -> exprOP . PLUS term
    (121) exprOP -> exprOP . MINUS term

    L_SHIFT         reduce using rule 118 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    R_SHIFT         reduce using rule 118 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    LE              reduce using rule 118 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    LT              reduce using rule 118 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    GE              reduce using rule 118 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    GT              reduce using rule 118 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    EQ              reduce using rule 118 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    NE              reduce using rule 118 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    BIT_AND         reduce using rule 118 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    BIT_XOR         reduce using rule 118 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    BIT_OR          reduce using rule 118 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    AND             reduce using rule 118 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    OR              reduce using rule 118 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    SEMICOLON       reduce using rule 118 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    ASSIGN          reduce using rule 118 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    PLUS_ASSIGN     reduce using rule 118 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    MINUS_ASSIGN    reduce using rule 118 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    MUL_ASSIGN      reduce using rule 118 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    DIV_ASSIGN      reduce using rule 118 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    AND_ASSIGN      reduce using rule 118 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    OR_ASSIGN       reduce using rule 118 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    XOR_ASSIGN      reduce using rule 118 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    MOD_ASSIGN      reduce using rule 118 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    L_SHIFT_ASSIGN  reduce using rule 118 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    R_SHIFT_ASSIGN  reduce using rule 118 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    R_PAREN         reduce using rule 118 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    COMMA           reduce using rule 118 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    R_SQBRACE       reduce using rule 118 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    R_FLOWBRACE     reduce using rule 118 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101


state 161

    (120) exprOP -> exprOP PLUS term .
    (123) term -> term . MULTIPLY factor
    (124) term -> term . DIVIDE factor
    (125) term -> term . MOD factor

    PLUS            reduce using rule 120 (exprOP -> exprOP PLUS term .)
    MINUS           reduce using rule 120 (exprOP -> exprOP PLUS term .)
    L_SHIFT         reduce using rule 120 (exprOP -> exprOP PLUS term .)
    R_SHIFT         reduce using rule 120 (exprOP -> exprOP PLUS term .)
    LE              reduce using rule 120 (exprOP -> exprOP PLUS term .)
    LT              reduce using rule 120 (exprOP -> exprOP PLUS term .)
    GE              reduce using rule 120 (exprOP -> exprOP PLUS term .)
    GT              reduce using rule 120 (exprOP -> exprOP PLUS term .)
    EQ              reduce using rule 120 (exprOP -> exprOP PLUS term .)
    NE              reduce using rule 120 (exprOP -> exprOP PLUS term .)
    BIT_AND         reduce using rule 120 (exprOP -> exprOP PLUS term .)
    BIT_XOR         reduce using rule 120 (exprOP -> exprOP PLUS term .)
    BIT_OR          reduce using rule 120 (exprOP -> exprOP PLUS term .)
    AND             reduce using rule 120 (exprOP -> exprOP PLUS term .)
    OR              reduce using rule 120 (exprOP -> exprOP PLUS term .)
    SEMICOLON       reduce using rule 120 (exprOP -> exprOP PLUS term .)
    ASSIGN          reduce using rule 120 (exprOP -> exprOP PLUS term .)
    PLUS_ASSIGN     reduce using rule 120 (exprOP -> exprOP PLUS term .)
    MINUS_ASSIGN    reduce using rule 120 (exprOP -> exprOP PLUS term .)
    MUL_ASSIGN      reduce using rule 120 (exprOP -> exprOP PLUS term .)
    DIV_ASSIGN      reduce using rule 120 (exprOP -> exprOP PLUS term .)
    AND_ASSIGN      reduce using rule 120 (exprOP -> exprOP PLUS term .)
    OR_ASSIGN       reduce using rule 120 (exprOP -> exprOP PLUS term .)
    XOR_ASSIGN      reduce using rule 120 (exprOP -> exprOP PLUS term .)
    MOD_ASSIGN      reduce using rule 120 (exprOP -> exprOP PLUS term .)
    L_SHIFT_ASSIGN  reduce using rule 120 (exprOP -> exprOP PLUS term .)
    R_SHIFT_ASSIGN  reduce using rule 120 (exprOP -> exprOP PLUS term .)
    R_PAREN         reduce using rule 120 (exprOP -> exprOP PLUS term .)
    COMMA           reduce using rule 120 (exprOP -> exprOP PLUS term .)
    R_SQBRACE       reduce using rule 120 (exprOP -> exprOP PLUS term .)
    R_FLOWBRACE     reduce using rule 120 (exprOP -> exprOP PLUS term .)
    MULTIPLY        shift and go to state 103
    DIVIDE          shift and go to state 104
    MOD             shift and go to state 105


state 162

    (121) exprOP -> exprOP MINUS term .
    (123) term -> term . MULTIPLY factor
    (124) term -> term . DIVIDE factor
    (125) term -> term . MOD factor

    PLUS            reduce using rule 121 (exprOP -> exprOP MINUS term .)
    MINUS           reduce using rule 121 (exprOP -> exprOP MINUS term .)
    L_SHIFT         reduce using rule 121 (exprOP -> exprOP MINUS term .)
    R_SHIFT         reduce using rule 121 (exprOP -> exprOP MINUS term .)
    LE              reduce using rule 121 (exprOP -> exprOP MINUS term .)
    LT              reduce using rule 121 (exprOP -> exprOP MINUS term .)
    GE              reduce using rule 121 (exprOP -> exprOP MINUS term .)
    GT              reduce using rule 121 (exprOP -> exprOP MINUS term .)
    EQ              reduce using rule 121 (exprOP -> exprOP MINUS term .)
    NE              reduce using rule 121 (exprOP -> exprOP MINUS term .)
    BIT_AND         reduce using rule 121 (exprOP -> exprOP MINUS term .)
    BIT_XOR         reduce using rule 121 (exprOP -> exprOP MINUS term .)
    BIT_OR          reduce using rule 121 (exprOP -> exprOP MINUS term .)
    AND             reduce using rule 121 (exprOP -> exprOP MINUS term .)
    OR              reduce using rule 121 (exprOP -> exprOP MINUS term .)
    SEMICOLON       reduce using rule 121 (exprOP -> exprOP MINUS term .)
    ASSIGN          reduce using rule 121 (exprOP -> exprOP MINUS term .)
    PLUS_ASSIGN     reduce using rule 121 (exprOP -> exprOP MINUS term .)
    MINUS_ASSIGN    reduce using rule 121 (exprOP -> exprOP MINUS term .)
    MUL_ASSIGN      reduce using rule 121 (exprOP -> exprOP MINUS term .)
    DIV_ASSIGN      reduce using rule 121 (exprOP -> exprOP MINUS term .)
    AND_ASSIGN      reduce using rule 121 (exprOP -> exprOP MINUS term .)
    OR_ASSIGN       reduce using rule 121 (exprOP -> exprOP MINUS term .)
    XOR_ASSIGN      reduce using rule 121 (exprOP -> exprOP MINUS term .)
    MOD_ASSIGN      reduce using rule 121 (exprOP -> exprOP MINUS term .)
    L_SHIFT_ASSIGN  reduce using rule 121 (exprOP -> exprOP MINUS term .)
    R_SHIFT_ASSIGN  reduce using rule 121 (exprOP -> exprOP MINUS term .)
    R_PAREN         reduce using rule 121 (exprOP -> exprOP MINUS term .)
    COMMA           reduce using rule 121 (exprOP -> exprOP MINUS term .)
    R_SQBRACE       reduce using rule 121 (exprOP -> exprOP MINUS term .)
    R_FLOWBRACE     reduce using rule 121 (exprOP -> exprOP MINUS term .)
    MULTIPLY        shift and go to state 103
    DIVIDE          shift and go to state 104
    MOD             shift and go to state 105


state 163

    (123) term -> term MULTIPLY factor .

    MULTIPLY        reduce using rule 123 (term -> term MULTIPLY factor .)
    DIVIDE          reduce using rule 123 (term -> term MULTIPLY factor .)
    MOD             reduce using rule 123 (term -> term MULTIPLY factor .)
    PLUS            reduce using rule 123 (term -> term MULTIPLY factor .)
    MINUS           reduce using rule 123 (term -> term MULTIPLY factor .)
    L_SHIFT         reduce using rule 123 (term -> term MULTIPLY factor .)
    R_SHIFT         reduce using rule 123 (term -> term MULTIPLY factor .)
    LE              reduce using rule 123 (term -> term MULTIPLY factor .)
    LT              reduce using rule 123 (term -> term MULTIPLY factor .)
    GE              reduce using rule 123 (term -> term MULTIPLY factor .)
    GT              reduce using rule 123 (term -> term MULTIPLY factor .)
    EQ              reduce using rule 123 (term -> term MULTIPLY factor .)
    NE              reduce using rule 123 (term -> term MULTIPLY factor .)
    BIT_AND         reduce using rule 123 (term -> term MULTIPLY factor .)
    BIT_XOR         reduce using rule 123 (term -> term MULTIPLY factor .)
    BIT_OR          reduce using rule 123 (term -> term MULTIPLY factor .)
    AND             reduce using rule 123 (term -> term MULTIPLY factor .)
    OR              reduce using rule 123 (term -> term MULTIPLY factor .)
    SEMICOLON       reduce using rule 123 (term -> term MULTIPLY factor .)
    ASSIGN          reduce using rule 123 (term -> term MULTIPLY factor .)
    PLUS_ASSIGN     reduce using rule 123 (term -> term MULTIPLY factor .)
    MINUS_ASSIGN    reduce using rule 123 (term -> term MULTIPLY factor .)
    MUL_ASSIGN      reduce using rule 123 (term -> term MULTIPLY factor .)
    DIV_ASSIGN      reduce using rule 123 (term -> term MULTIPLY factor .)
    AND_ASSIGN      reduce using rule 123 (term -> term MULTIPLY factor .)
    OR_ASSIGN       reduce using rule 123 (term -> term MULTIPLY factor .)
    XOR_ASSIGN      reduce using rule 123 (term -> term MULTIPLY factor .)
    MOD_ASSIGN      reduce using rule 123 (term -> term MULTIPLY factor .)
    L_SHIFT_ASSIGN  reduce using rule 123 (term -> term MULTIPLY factor .)
    R_SHIFT_ASSIGN  reduce using rule 123 (term -> term MULTIPLY factor .)
    R_PAREN         reduce using rule 123 (term -> term MULTIPLY factor .)
    COMMA           reduce using rule 123 (term -> term MULTIPLY factor .)
    R_SQBRACE       reduce using rule 123 (term -> term MULTIPLY factor .)
    R_FLOWBRACE     reduce using rule 123 (term -> term MULTIPLY factor .)


state 164

    (124) term -> term DIVIDE factor .

    MULTIPLY        reduce using rule 124 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 124 (term -> term DIVIDE factor .)
    MOD             reduce using rule 124 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 124 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 124 (term -> term DIVIDE factor .)
    L_SHIFT         reduce using rule 124 (term -> term DIVIDE factor .)
    R_SHIFT         reduce using rule 124 (term -> term DIVIDE factor .)
    LE              reduce using rule 124 (term -> term DIVIDE factor .)
    LT              reduce using rule 124 (term -> term DIVIDE factor .)
    GE              reduce using rule 124 (term -> term DIVIDE factor .)
    GT              reduce using rule 124 (term -> term DIVIDE factor .)
    EQ              reduce using rule 124 (term -> term DIVIDE factor .)
    NE              reduce using rule 124 (term -> term DIVIDE factor .)
    BIT_AND         reduce using rule 124 (term -> term DIVIDE factor .)
    BIT_XOR         reduce using rule 124 (term -> term DIVIDE factor .)
    BIT_OR          reduce using rule 124 (term -> term DIVIDE factor .)
    AND             reduce using rule 124 (term -> term DIVIDE factor .)
    OR              reduce using rule 124 (term -> term DIVIDE factor .)
    SEMICOLON       reduce using rule 124 (term -> term DIVIDE factor .)
    ASSIGN          reduce using rule 124 (term -> term DIVIDE factor .)
    PLUS_ASSIGN     reduce using rule 124 (term -> term DIVIDE factor .)
    MINUS_ASSIGN    reduce using rule 124 (term -> term DIVIDE factor .)
    MUL_ASSIGN      reduce using rule 124 (term -> term DIVIDE factor .)
    DIV_ASSIGN      reduce using rule 124 (term -> term DIVIDE factor .)
    AND_ASSIGN      reduce using rule 124 (term -> term DIVIDE factor .)
    OR_ASSIGN       reduce using rule 124 (term -> term DIVIDE factor .)
    XOR_ASSIGN      reduce using rule 124 (term -> term DIVIDE factor .)
    MOD_ASSIGN      reduce using rule 124 (term -> term DIVIDE factor .)
    L_SHIFT_ASSIGN  reduce using rule 124 (term -> term DIVIDE factor .)
    R_SHIFT_ASSIGN  reduce using rule 124 (term -> term DIVIDE factor .)
    R_PAREN         reduce using rule 124 (term -> term DIVIDE factor .)
    COMMA           reduce using rule 124 (term -> term DIVIDE factor .)
    R_SQBRACE       reduce using rule 124 (term -> term DIVIDE factor .)
    R_FLOWBRACE     reduce using rule 124 (term -> term DIVIDE factor .)


state 165

    (125) term -> term MOD factor .

    MULTIPLY        reduce using rule 125 (term -> term MOD factor .)
    DIVIDE          reduce using rule 125 (term -> term MOD factor .)
    MOD             reduce using rule 125 (term -> term MOD factor .)
    PLUS            reduce using rule 125 (term -> term MOD factor .)
    MINUS           reduce using rule 125 (term -> term MOD factor .)
    L_SHIFT         reduce using rule 125 (term -> term MOD factor .)
    R_SHIFT         reduce using rule 125 (term -> term MOD factor .)
    LE              reduce using rule 125 (term -> term MOD factor .)
    LT              reduce using rule 125 (term -> term MOD factor .)
    GE              reduce using rule 125 (term -> term MOD factor .)
    GT              reduce using rule 125 (term -> term MOD factor .)
    EQ              reduce using rule 125 (term -> term MOD factor .)
    NE              reduce using rule 125 (term -> term MOD factor .)
    BIT_AND         reduce using rule 125 (term -> term MOD factor .)
    BIT_XOR         reduce using rule 125 (term -> term MOD factor .)
    BIT_OR          reduce using rule 125 (term -> term MOD factor .)
    AND             reduce using rule 125 (term -> term MOD factor .)
    OR              reduce using rule 125 (term -> term MOD factor .)
    SEMICOLON       reduce using rule 125 (term -> term MOD factor .)
    ASSIGN          reduce using rule 125 (term -> term MOD factor .)
    PLUS_ASSIGN     reduce using rule 125 (term -> term MOD factor .)
    MINUS_ASSIGN    reduce using rule 125 (term -> term MOD factor .)
    MUL_ASSIGN      reduce using rule 125 (term -> term MOD factor .)
    DIV_ASSIGN      reduce using rule 125 (term -> term MOD factor .)
    AND_ASSIGN      reduce using rule 125 (term -> term MOD factor .)
    OR_ASSIGN       reduce using rule 125 (term -> term MOD factor .)
    XOR_ASSIGN      reduce using rule 125 (term -> term MOD factor .)
    MOD_ASSIGN      reduce using rule 125 (term -> term MOD factor .)
    L_SHIFT_ASSIGN  reduce using rule 125 (term -> term MOD factor .)
    R_SHIFT_ASSIGN  reduce using rule 125 (term -> term MOD factor .)
    R_PAREN         reduce using rule 125 (term -> term MOD factor .)
    COMMA           reduce using rule 125 (term -> term MOD factor .)
    R_SQBRACE       reduce using rule 125 (term -> term MOD factor .)
    R_FLOWBRACE     reduce using rule 125 (term -> term MOD factor .)


state 166

    (13) closed -> IF condition . closed ELSE closed
    (6) open -> IF condition . statement
    (7) open -> IF condition . closed ELSE open
    (11) closed -> . simple
    (12) closed -> . block
    (13) closed -> . IF condition closed ELSE closed
    (14) closed -> . WHILE condition closed
    (15) closed -> . for for_condition closed
    (4) statement -> . open
    (5) statement -> . closed
    (53) simple -> . expr SEMICOLON
    (54) simple -> . header
    (55) simple -> . declaration
    (56) simple -> . SEMICOLON
    (57) simple -> . function
    (58) simple -> . RETURN expr SEMICOLON
    (59) simple -> . RETURN SEMICOLON
    (49) block -> . left_flower multiple_statements right_flower
    (50) block -> . left_flower right_flower
    (10) for -> . FOR
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) open -> . for for_condition open
    (85) expr -> . expr assignment exprOR
    (86) expr -> . exprOR
    (60) header -> . HASH INCLUDE STRING
    (61) header -> . HASH INCLUDE HEADER_FILE
    (34) declaration -> . TYPE ID SEMICOLON
    (35) declaration -> . TYPE MULTIPLY ID SEMICOLON
    (36) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (37) declaration -> . TYPE MULTIPLY ID ASSIGN expr SEMICOLON
    (38) declaration -> . TYPE multi_declaration stop
    (39) declaration -> . TYPE ID narrayindex SEMICOLON
    (40) declaration -> . TYPE ID narrayindex ASSIGN init_list SEMICOLON
    (82) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (51) left_flower -> . L_FLOWBRACE
    (98) exprOR -> . exprOR OR exprAND
    (99) exprOR -> . exprAND
    (100) exprAND -> . exprAND AND exprBITOR
    (101) exprAND -> . exprBITOR
    (102) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (103) exprBITOR -> . exprBITXOR
    (104) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (105) exprBITXOR -> . exprBITAND
    (106) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (107) exprBITAND -> . exprEQ
    (108) exprEQ -> . exprEQ EQ exprRELOP
    (109) exprEQ -> . exprEQ NE exprRELOP
    (110) exprEQ -> . exprRELOP
    (111) exprRELOP -> . exprRELOP relop exprSHIFT
    (112) exprRELOP -> . exprSHIFT
    (117) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (118) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (119) exprSHIFT -> . exprOP
    (120) exprOP -> . exprOP PLUS term
    (121) exprOP -> . exprOP MINUS term
    (122) exprOP -> . term
    (123) term -> . term MULTIPLY factor
    (124) term -> . term DIVIDE factor
    (125) term -> . term MOD factor
    (126) term -> . factor
    (127) factor -> . NOT factor
    (128) factor -> . PLUS factor
    (129) factor -> . MINUS factor
    (130) factor -> . PLUS_PLUS factor
    (131) factor -> . MINUS_MINUS factor
    (132) factor -> . cast brace
    (133) factor -> . brace
    (134) cast -> . L_PAREN TYPE R_PAREN
    (135) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (136) brace -> . L_PAREN expr R_PAREN
    (137) brace -> . brace PLUS_PLUS
    (138) brace -> . brace MINUS_MINUS
    (139) brace -> . NUM
    (140) brace -> . STRING
    (141) brace -> . MULTIPLY ID
    (142) brace -> . BIT_AND ID
    (143) brace -> . ID
    (144) brace -> . CHAR
    (145) brace -> . function_call
    (146) brace -> . ID narrayindex
    (147) NUM -> . INT_NUM
    (148) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    IF              shift and go to state 114
    WHILE           shift and go to state 117
    SEMICOLON       shift and go to state 13
    RETURN          shift and go to state 17
    FOR             shift and go to state 11
    HASH            shift and go to state 20
    TYPE            shift and go to state 22
    L_FLOWBRACE     shift and go to state 26
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    closed                         shift and go to state 193
    statement                      shift and go to state 115
    open                           shift and go to state 4
    simple                         shift and go to state 9
    block                          shift and go to state 10
    for                            shift and go to state 118
    expr                           shift and go to state 12
    header                         shift and go to state 14
    declaration                    shift and go to state 15
    function                       shift and go to state 16
    left_flower                    shift and go to state 18
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 167

    (7) open -> IF condition closed ELSE . open
    (13) closed -> IF condition closed ELSE . closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) open -> . for for_condition open
    (11) closed -> . simple
    (12) closed -> . block
    (13) closed -> . IF condition closed ELSE closed
    (14) closed -> . WHILE condition closed
    (15) closed -> . for for_condition closed
    (10) for -> . FOR
    (53) simple -> . expr SEMICOLON
    (54) simple -> . header
    (55) simple -> . declaration
    (56) simple -> . SEMICOLON
    (57) simple -> . function
    (58) simple -> . RETURN expr SEMICOLON
    (59) simple -> . RETURN SEMICOLON
    (49) block -> . left_flower multiple_statements right_flower
    (50) block -> . left_flower right_flower
    (85) expr -> . expr assignment exprOR
    (86) expr -> . exprOR
    (60) header -> . HASH INCLUDE STRING
    (61) header -> . HASH INCLUDE HEADER_FILE
    (34) declaration -> . TYPE ID SEMICOLON
    (35) declaration -> . TYPE MULTIPLY ID SEMICOLON
    (36) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (37) declaration -> . TYPE MULTIPLY ID ASSIGN expr SEMICOLON
    (38) declaration -> . TYPE multi_declaration stop
    (39) declaration -> . TYPE ID narrayindex SEMICOLON
    (40) declaration -> . TYPE ID narrayindex ASSIGN init_list SEMICOLON
    (82) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (51) left_flower -> . L_FLOWBRACE
    (98) exprOR -> . exprOR OR exprAND
    (99) exprOR -> . exprAND
    (100) exprAND -> . exprAND AND exprBITOR
    (101) exprAND -> . exprBITOR
    (102) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (103) exprBITOR -> . exprBITXOR
    (104) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (105) exprBITXOR -> . exprBITAND
    (106) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (107) exprBITAND -> . exprEQ
    (108) exprEQ -> . exprEQ EQ exprRELOP
    (109) exprEQ -> . exprEQ NE exprRELOP
    (110) exprEQ -> . exprRELOP
    (111) exprRELOP -> . exprRELOP relop exprSHIFT
    (112) exprRELOP -> . exprSHIFT
    (117) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (118) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (119) exprSHIFT -> . exprOP
    (120) exprOP -> . exprOP PLUS term
    (121) exprOP -> . exprOP MINUS term
    (122) exprOP -> . term
    (123) term -> . term MULTIPLY factor
    (124) term -> . term DIVIDE factor
    (125) term -> . term MOD factor
    (126) term -> . factor
    (127) factor -> . NOT factor
    (128) factor -> . PLUS factor
    (129) factor -> . MINUS factor
    (130) factor -> . PLUS_PLUS factor
    (131) factor -> . MINUS_MINUS factor
    (132) factor -> . cast brace
    (133) factor -> . brace
    (134) cast -> . L_PAREN TYPE R_PAREN
    (135) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (136) brace -> . L_PAREN expr R_PAREN
    (137) brace -> . brace PLUS_PLUS
    (138) brace -> . brace MINUS_MINUS
    (139) brace -> . NUM
    (140) brace -> . STRING
    (141) brace -> . MULTIPLY ID
    (142) brace -> . BIT_AND ID
    (143) brace -> . ID
    (144) brace -> . CHAR
    (145) brace -> . function_call
    (146) brace -> . ID narrayindex
    (147) NUM -> . INT_NUM
    (148) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    IF              shift and go to state 6
    WHILE           shift and go to state 7
    FOR             shift and go to state 11
    SEMICOLON       shift and go to state 13
    RETURN          shift and go to state 17
    HASH            shift and go to state 20
    TYPE            shift and go to state 22
    L_FLOWBRACE     shift and go to state 26
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    closed                         shift and go to state 194
    open                           shift and go to state 195
    for                            shift and go to state 8
    simple                         shift and go to state 9
    block                          shift and go to state 10
    expr                           shift and go to state 12
    header                         shift and go to state 14
    declaration                    shift and go to state 15
    function                       shift and go to state 16
    left_flower                    shift and go to state 18
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 168

    (14) closed -> WHILE condition . closed
    (8) open -> WHILE condition . open
    (11) closed -> . simple
    (12) closed -> . block
    (13) closed -> . IF condition closed ELSE closed
    (14) closed -> . WHILE condition closed
    (15) closed -> . for for_condition closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) open -> . for for_condition open
    (53) simple -> . expr SEMICOLON
    (54) simple -> . header
    (55) simple -> . declaration
    (56) simple -> . SEMICOLON
    (57) simple -> . function
    (58) simple -> . RETURN expr SEMICOLON
    (59) simple -> . RETURN SEMICOLON
    (49) block -> . left_flower multiple_statements right_flower
    (50) block -> . left_flower right_flower
    (10) for -> . FOR
    (85) expr -> . expr assignment exprOR
    (86) expr -> . exprOR
    (60) header -> . HASH INCLUDE STRING
    (61) header -> . HASH INCLUDE HEADER_FILE
    (34) declaration -> . TYPE ID SEMICOLON
    (35) declaration -> . TYPE MULTIPLY ID SEMICOLON
    (36) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (37) declaration -> . TYPE MULTIPLY ID ASSIGN expr SEMICOLON
    (38) declaration -> . TYPE multi_declaration stop
    (39) declaration -> . TYPE ID narrayindex SEMICOLON
    (40) declaration -> . TYPE ID narrayindex ASSIGN init_list SEMICOLON
    (82) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (51) left_flower -> . L_FLOWBRACE
    (98) exprOR -> . exprOR OR exprAND
    (99) exprOR -> . exprAND
    (100) exprAND -> . exprAND AND exprBITOR
    (101) exprAND -> . exprBITOR
    (102) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (103) exprBITOR -> . exprBITXOR
    (104) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (105) exprBITXOR -> . exprBITAND
    (106) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (107) exprBITAND -> . exprEQ
    (108) exprEQ -> . exprEQ EQ exprRELOP
    (109) exprEQ -> . exprEQ NE exprRELOP
    (110) exprEQ -> . exprRELOP
    (111) exprRELOP -> . exprRELOP relop exprSHIFT
    (112) exprRELOP -> . exprSHIFT
    (117) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (118) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (119) exprSHIFT -> . exprOP
    (120) exprOP -> . exprOP PLUS term
    (121) exprOP -> . exprOP MINUS term
    (122) exprOP -> . term
    (123) term -> . term MULTIPLY factor
    (124) term -> . term DIVIDE factor
    (125) term -> . term MOD factor
    (126) term -> . factor
    (127) factor -> . NOT factor
    (128) factor -> . PLUS factor
    (129) factor -> . MINUS factor
    (130) factor -> . PLUS_PLUS factor
    (131) factor -> . MINUS_MINUS factor
    (132) factor -> . cast brace
    (133) factor -> . brace
    (134) cast -> . L_PAREN TYPE R_PAREN
    (135) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (136) brace -> . L_PAREN expr R_PAREN
    (137) brace -> . brace PLUS_PLUS
    (138) brace -> . brace MINUS_MINUS
    (139) brace -> . NUM
    (140) brace -> . STRING
    (141) brace -> . MULTIPLY ID
    (142) brace -> . BIT_AND ID
    (143) brace -> . ID
    (144) brace -> . CHAR
    (145) brace -> . function_call
    (146) brace -> . ID narrayindex
    (147) NUM -> . INT_NUM
    (148) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    IF              shift and go to state 114
    WHILE           shift and go to state 117
    SEMICOLON       shift and go to state 13
    RETURN          shift and go to state 17
    FOR             shift and go to state 11
    HASH            shift and go to state 20
    TYPE            shift and go to state 22
    L_FLOWBRACE     shift and go to state 26
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    closed                         shift and go to state 121
    open                           shift and go to state 120
    simple                         shift and go to state 9
    block                          shift and go to state 10
    for                            shift and go to state 118
    expr                           shift and go to state 12
    header                         shift and go to state 14
    declaration                    shift and go to state 15
    function                       shift and go to state 16
    left_flower                    shift and go to state 18
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 169

    (15) closed -> for for_condition . closed
    (9) open -> for for_condition . open
    (11) closed -> . simple
    (12) closed -> . block
    (13) closed -> . IF condition closed ELSE closed
    (14) closed -> . WHILE condition closed
    (15) closed -> . for for_condition closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) open -> . for for_condition open
    (53) simple -> . expr SEMICOLON
    (54) simple -> . header
    (55) simple -> . declaration
    (56) simple -> . SEMICOLON
    (57) simple -> . function
    (58) simple -> . RETURN expr SEMICOLON
    (59) simple -> . RETURN SEMICOLON
    (49) block -> . left_flower multiple_statements right_flower
    (50) block -> . left_flower right_flower
    (10) for -> . FOR
    (85) expr -> . expr assignment exprOR
    (86) expr -> . exprOR
    (60) header -> . HASH INCLUDE STRING
    (61) header -> . HASH INCLUDE HEADER_FILE
    (34) declaration -> . TYPE ID SEMICOLON
    (35) declaration -> . TYPE MULTIPLY ID SEMICOLON
    (36) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (37) declaration -> . TYPE MULTIPLY ID ASSIGN expr SEMICOLON
    (38) declaration -> . TYPE multi_declaration stop
    (39) declaration -> . TYPE ID narrayindex SEMICOLON
    (40) declaration -> . TYPE ID narrayindex ASSIGN init_list SEMICOLON
    (82) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (51) left_flower -> . L_FLOWBRACE
    (98) exprOR -> . exprOR OR exprAND
    (99) exprOR -> . exprAND
    (100) exprAND -> . exprAND AND exprBITOR
    (101) exprAND -> . exprBITOR
    (102) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (103) exprBITOR -> . exprBITXOR
    (104) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (105) exprBITXOR -> . exprBITAND
    (106) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (107) exprBITAND -> . exprEQ
    (108) exprEQ -> . exprEQ EQ exprRELOP
    (109) exprEQ -> . exprEQ NE exprRELOP
    (110) exprEQ -> . exprRELOP
    (111) exprRELOP -> . exprRELOP relop exprSHIFT
    (112) exprRELOP -> . exprSHIFT
    (117) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (118) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (119) exprSHIFT -> . exprOP
    (120) exprOP -> . exprOP PLUS term
    (121) exprOP -> . exprOP MINUS term
    (122) exprOP -> . term
    (123) term -> . term MULTIPLY factor
    (124) term -> . term DIVIDE factor
    (125) term -> . term MOD factor
    (126) term -> . factor
    (127) factor -> . NOT factor
    (128) factor -> . PLUS factor
    (129) factor -> . MINUS factor
    (130) factor -> . PLUS_PLUS factor
    (131) factor -> . MINUS_MINUS factor
    (132) factor -> . cast brace
    (133) factor -> . brace
    (134) cast -> . L_PAREN TYPE R_PAREN
    (135) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (136) brace -> . L_PAREN expr R_PAREN
    (137) brace -> . brace PLUS_PLUS
    (138) brace -> . brace MINUS_MINUS
    (139) brace -> . NUM
    (140) brace -> . STRING
    (141) brace -> . MULTIPLY ID
    (142) brace -> . BIT_AND ID
    (143) brace -> . ID
    (144) brace -> . CHAR
    (145) brace -> . function_call
    (146) brace -> . ID narrayindex
    (147) NUM -> . INT_NUM
    (148) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    IF              shift and go to state 114
    WHILE           shift and go to state 117
    SEMICOLON       shift and go to state 13
    RETURN          shift and go to state 17
    FOR             shift and go to state 11
    HASH            shift and go to state 20
    TYPE            shift and go to state 22
    L_FLOWBRACE     shift and go to state 26
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    for                            shift and go to state 118
    closed                         shift and go to state 123
    open                           shift and go to state 122
    simple                         shift and go to state 9
    block                          shift and go to state 10
    expr                           shift and go to state 12
    header                         shift and go to state 14
    declaration                    shift and go to state 15
    function                       shift and go to state 16
    left_flower                    shift and go to state 18
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 170

    (16) condition -> L_PAREN expr R_PAREN .

    IF              reduce using rule 16 (condition -> L_PAREN expr R_PAREN .)
    WHILE           reduce using rule 16 (condition -> L_PAREN expr R_PAREN .)
    SEMICOLON       reduce using rule 16 (condition -> L_PAREN expr R_PAREN .)
    RETURN          reduce using rule 16 (condition -> L_PAREN expr R_PAREN .)
    FOR             reduce using rule 16 (condition -> L_PAREN expr R_PAREN .)
    HASH            reduce using rule 16 (condition -> L_PAREN expr R_PAREN .)
    TYPE            reduce using rule 16 (condition -> L_PAREN expr R_PAREN .)
    L_FLOWBRACE     reduce using rule 16 (condition -> L_PAREN expr R_PAREN .)
    NOT             reduce using rule 16 (condition -> L_PAREN expr R_PAREN .)
    PLUS            reduce using rule 16 (condition -> L_PAREN expr R_PAREN .)
    MINUS           reduce using rule 16 (condition -> L_PAREN expr R_PAREN .)
    PLUS_PLUS       reduce using rule 16 (condition -> L_PAREN expr R_PAREN .)
    MINUS_MINUS     reduce using rule 16 (condition -> L_PAREN expr R_PAREN .)
    L_PAREN         reduce using rule 16 (condition -> L_PAREN expr R_PAREN .)
    STRING          reduce using rule 16 (condition -> L_PAREN expr R_PAREN .)
    MULTIPLY        reduce using rule 16 (condition -> L_PAREN expr R_PAREN .)
    BIT_AND         reduce using rule 16 (condition -> L_PAREN expr R_PAREN .)
    ID              reduce using rule 16 (condition -> L_PAREN expr R_PAREN .)
    CHAR            reduce using rule 16 (condition -> L_PAREN expr R_PAREN .)
    INT_NUM         reduce using rule 16 (condition -> L_PAREN expr R_PAREN .)
    FLOAT_NUM       reduce using rule 16 (condition -> L_PAREN expr R_PAREN .)


state 171

    (17) for_condition -> L_PAREN simple simple . expr R_PAREN
    (18) for_condition -> L_PAREN simple simple . R_PAREN
    (85) expr -> . expr assignment exprOR
    (86) expr -> . exprOR
    (98) exprOR -> . exprOR OR exprAND
    (99) exprOR -> . exprAND
    (100) exprAND -> . exprAND AND exprBITOR
    (101) exprAND -> . exprBITOR
    (102) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (103) exprBITOR -> . exprBITXOR
    (104) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (105) exprBITXOR -> . exprBITAND
    (106) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (107) exprBITAND -> . exprEQ
    (108) exprEQ -> . exprEQ EQ exprRELOP
    (109) exprEQ -> . exprEQ NE exprRELOP
    (110) exprEQ -> . exprRELOP
    (111) exprRELOP -> . exprRELOP relop exprSHIFT
    (112) exprRELOP -> . exprSHIFT
    (117) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (118) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (119) exprSHIFT -> . exprOP
    (120) exprOP -> . exprOP PLUS term
    (121) exprOP -> . exprOP MINUS term
    (122) exprOP -> . term
    (123) term -> . term MULTIPLY factor
    (124) term -> . term DIVIDE factor
    (125) term -> . term MOD factor
    (126) term -> . factor
    (127) factor -> . NOT factor
    (128) factor -> . PLUS factor
    (129) factor -> . MINUS factor
    (130) factor -> . PLUS_PLUS factor
    (131) factor -> . MINUS_MINUS factor
    (132) factor -> . cast brace
    (133) factor -> . brace
    (134) cast -> . L_PAREN TYPE R_PAREN
    (135) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (136) brace -> . L_PAREN expr R_PAREN
    (137) brace -> . brace PLUS_PLUS
    (138) brace -> . brace MINUS_MINUS
    (139) brace -> . NUM
    (140) brace -> . STRING
    (141) brace -> . MULTIPLY ID
    (142) brace -> . BIT_AND ID
    (143) brace -> . ID
    (144) brace -> . CHAR
    (145) brace -> . function_call
    (146) brace -> . ID narrayindex
    (147) NUM -> . INT_NUM
    (148) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    R_PAREN         shift and go to state 197
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    expr                           shift and go to state 196
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 172

    (36) declaration -> TYPE ID ASSIGN expr . SEMICOLON
    (24) multi_declaration -> ID ASSIGN expr . COMMA
    (85) expr -> expr . assignment exprOR
    (87) assignment -> . ASSIGN
    (88) assignment -> . PLUS_ASSIGN
    (89) assignment -> . MINUS_ASSIGN
    (90) assignment -> . MUL_ASSIGN
    (91) assignment -> . DIV_ASSIGN
    (92) assignment -> . AND_ASSIGN
    (93) assignment -> . OR_ASSIGN
    (94) assignment -> . XOR_ASSIGN
    (95) assignment -> . MOD_ASSIGN
    (96) assignment -> . L_SHIFT_ASSIGN
    (97) assignment -> . R_SHIFT_ASSIGN

    SEMICOLON       shift and go to state 198
    COMMA           shift and go to state 199
    ASSIGN          shift and go to state 58
    PLUS_ASSIGN     shift and go to state 59
    MINUS_ASSIGN    shift and go to state 60
    MUL_ASSIGN      shift and go to state 61
    DIV_ASSIGN      shift and go to state 62
    AND_ASSIGN      shift and go to state 63
    OR_ASSIGN       shift and go to state 64
    XOR_ASSIGN      shift and go to state 65
    MOD_ASSIGN      shift and go to state 66
    L_SHIFT_ASSIGN  shift and go to state 67
    R_SHIFT_ASSIGN  shift and go to state 68

    assignment                     shift and go to state 57

state 173

    (39) declaration -> TYPE ID narrayindex SEMICOLON .

    IF              reduce using rule 39 (declaration -> TYPE ID narrayindex SEMICOLON .)
    WHILE           reduce using rule 39 (declaration -> TYPE ID narrayindex SEMICOLON .)
    FOR             reduce using rule 39 (declaration -> TYPE ID narrayindex SEMICOLON .)
    SEMICOLON       reduce using rule 39 (declaration -> TYPE ID narrayindex SEMICOLON .)
    RETURN          reduce using rule 39 (declaration -> TYPE ID narrayindex SEMICOLON .)
    HASH            reduce using rule 39 (declaration -> TYPE ID narrayindex SEMICOLON .)
    TYPE            reduce using rule 39 (declaration -> TYPE ID narrayindex SEMICOLON .)
    L_FLOWBRACE     reduce using rule 39 (declaration -> TYPE ID narrayindex SEMICOLON .)
    NOT             reduce using rule 39 (declaration -> TYPE ID narrayindex SEMICOLON .)
    PLUS            reduce using rule 39 (declaration -> TYPE ID narrayindex SEMICOLON .)
    MINUS           reduce using rule 39 (declaration -> TYPE ID narrayindex SEMICOLON .)
    PLUS_PLUS       reduce using rule 39 (declaration -> TYPE ID narrayindex SEMICOLON .)
    MINUS_MINUS     reduce using rule 39 (declaration -> TYPE ID narrayindex SEMICOLON .)
    L_PAREN         reduce using rule 39 (declaration -> TYPE ID narrayindex SEMICOLON .)
    STRING          reduce using rule 39 (declaration -> TYPE ID narrayindex SEMICOLON .)
    MULTIPLY        reduce using rule 39 (declaration -> TYPE ID narrayindex SEMICOLON .)
    BIT_AND         reduce using rule 39 (declaration -> TYPE ID narrayindex SEMICOLON .)
    ID              reduce using rule 39 (declaration -> TYPE ID narrayindex SEMICOLON .)
    CHAR            reduce using rule 39 (declaration -> TYPE ID narrayindex SEMICOLON .)
    INT_NUM         reduce using rule 39 (declaration -> TYPE ID narrayindex SEMICOLON .)
    FLOAT_NUM       reduce using rule 39 (declaration -> TYPE ID narrayindex SEMICOLON .)
    $end            reduce using rule 39 (declaration -> TYPE ID narrayindex SEMICOLON .)
    R_FLOWBRACE     reduce using rule 39 (declaration -> TYPE ID narrayindex SEMICOLON .)
    ELSE            reduce using rule 39 (declaration -> TYPE ID narrayindex SEMICOLON .)
    R_PAREN         reduce using rule 39 (declaration -> TYPE ID narrayindex SEMICOLON .)


state 174

    (40) declaration -> TYPE ID narrayindex ASSIGN . init_list SEMICOLON
    (43) init_list -> . L_FLOWBRACE init_list R_FLOWBRACE COMMA init_list
    (44) init_list -> . L_FLOWBRACE init R_FLOWBRACE COMMA init_list
    (45) init_list -> . L_FLOWBRACE init R_FLOWBRACE
    (46) init_list -> . L_FLOWBRACE init_list R_FLOWBRACE

    L_FLOWBRACE     shift and go to state 201

    init_list                      shift and go to state 200

state 175

    (73) yes_dec_params -> TYPE . expr COMMA
    (74) yes_dec_params -> TYPE . COMMA
    (75) yes_dec_params -> TYPE . MULTIPLY COMMA
    (76) end_dec_params -> TYPE . expr
    (77) end_dec_params -> TYPE .
    (78) end_dec_params -> TYPE . MULTIPLY
    (85) expr -> . expr assignment exprOR
    (86) expr -> . exprOR
    (98) exprOR -> . exprOR OR exprAND
    (99) exprOR -> . exprAND
    (100) exprAND -> . exprAND AND exprBITOR
    (101) exprAND -> . exprBITOR
    (102) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (103) exprBITOR -> . exprBITXOR
    (104) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (105) exprBITXOR -> . exprBITAND
    (106) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (107) exprBITAND -> . exprEQ
    (108) exprEQ -> . exprEQ EQ exprRELOP
    (109) exprEQ -> . exprEQ NE exprRELOP
    (110) exprEQ -> . exprRELOP
    (111) exprRELOP -> . exprRELOP relop exprSHIFT
    (112) exprRELOP -> . exprSHIFT
    (117) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (118) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (119) exprSHIFT -> . exprOP
    (120) exprOP -> . exprOP PLUS term
    (121) exprOP -> . exprOP MINUS term
    (122) exprOP -> . term
    (123) term -> . term MULTIPLY factor
    (124) term -> . term DIVIDE factor
    (125) term -> . term MOD factor
    (126) term -> . factor
    (127) factor -> . NOT factor
    (128) factor -> . PLUS factor
    (129) factor -> . MINUS factor
    (130) factor -> . PLUS_PLUS factor
    (131) factor -> . MINUS_MINUS factor
    (132) factor -> . cast brace
    (133) factor -> . brace
    (134) cast -> . L_PAREN TYPE R_PAREN
    (135) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (136) brace -> . L_PAREN expr R_PAREN
    (137) brace -> . brace PLUS_PLUS
    (138) brace -> . brace MINUS_MINUS
    (139) brace -> . NUM
    (140) brace -> . STRING
    (141) brace -> . MULTIPLY ID
    (142) brace -> . BIT_AND ID
    (143) brace -> . ID
    (144) brace -> . CHAR
    (145) brace -> . function_call
    (146) brace -> . ID narrayindex
    (147) NUM -> . INT_NUM
    (148) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    COMMA           shift and go to state 203
    MULTIPLY        shift and go to state 204
    R_PAREN         reduce using rule 77 (end_dec_params -> TYPE .)
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    expr                           shift and go to state 202
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 176

    (82) function -> TYPE ID L_PAREN dec_params . R_PAREN function_2

    R_PAREN         shift and go to state 205


state 177

    (79) dec_params -> empty .

    R_PAREN         reduce using rule 79 (dec_params -> empty .)


state 178

    (80) dec_params -> yes_dec_params . end_dec_params
    (70) yes_dec_params -> yes_dec_params . TYPE expr COMMA
    (71) yes_dec_params -> yes_dec_params . TYPE COMMA
    (72) yes_dec_params -> yes_dec_params . TYPE MULTIPLY COMMA
    (76) end_dec_params -> . TYPE expr
    (77) end_dec_params -> . TYPE
    (78) end_dec_params -> . TYPE MULTIPLY

    TYPE            shift and go to state 207

    end_dec_params                 shift and go to state 206

state 179

    (81) dec_params -> end_dec_params .

    R_PAREN         reduce using rule 81 (dec_params -> end_dec_params .)


state 180

    (35) declaration -> TYPE MULTIPLY ID SEMICOLON .

    IF              reduce using rule 35 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    WHILE           reduce using rule 35 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    FOR             reduce using rule 35 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    SEMICOLON       reduce using rule 35 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    RETURN          reduce using rule 35 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    HASH            reduce using rule 35 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    TYPE            reduce using rule 35 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    L_FLOWBRACE     reduce using rule 35 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    NOT             reduce using rule 35 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    PLUS            reduce using rule 35 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    MINUS           reduce using rule 35 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    PLUS_PLUS       reduce using rule 35 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    MINUS_MINUS     reduce using rule 35 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    L_PAREN         reduce using rule 35 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    STRING          reduce using rule 35 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    MULTIPLY        reduce using rule 35 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    BIT_AND         reduce using rule 35 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    ID              reduce using rule 35 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    CHAR            reduce using rule 35 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    INT_NUM         reduce using rule 35 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    FLOAT_NUM       reduce using rule 35 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    $end            reduce using rule 35 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    R_FLOWBRACE     reduce using rule 35 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    ELSE            reduce using rule 35 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    R_PAREN         reduce using rule 35 (declaration -> TYPE MULTIPLY ID SEMICOLON .)


state 181

    (37) declaration -> TYPE MULTIPLY ID ASSIGN . expr SEMICOLON
    (26) multi_declaration -> MULTIPLY ID ASSIGN . expr COMMA
    (85) expr -> . expr assignment exprOR
    (86) expr -> . exprOR
    (98) exprOR -> . exprOR OR exprAND
    (99) exprOR -> . exprAND
    (100) exprAND -> . exprAND AND exprBITOR
    (101) exprAND -> . exprBITOR
    (102) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (103) exprBITOR -> . exprBITXOR
    (104) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (105) exprBITXOR -> . exprBITAND
    (106) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (107) exprBITAND -> . exprEQ
    (108) exprEQ -> . exprEQ EQ exprRELOP
    (109) exprEQ -> . exprEQ NE exprRELOP
    (110) exprEQ -> . exprRELOP
    (111) exprRELOP -> . exprRELOP relop exprSHIFT
    (112) exprRELOP -> . exprSHIFT
    (117) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (118) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (119) exprSHIFT -> . exprOP
    (120) exprOP -> . exprOP PLUS term
    (121) exprOP -> . exprOP MINUS term
    (122) exprOP -> . term
    (123) term -> . term MULTIPLY factor
    (124) term -> . term DIVIDE factor
    (125) term -> . term MOD factor
    (126) term -> . factor
    (127) factor -> . NOT factor
    (128) factor -> . PLUS factor
    (129) factor -> . MINUS factor
    (130) factor -> . PLUS_PLUS factor
    (131) factor -> . MINUS_MINUS factor
    (132) factor -> . cast brace
    (133) factor -> . brace
    (134) cast -> . L_PAREN TYPE R_PAREN
    (135) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (136) brace -> . L_PAREN expr R_PAREN
    (137) brace -> . brace PLUS_PLUS
    (138) brace -> . brace MINUS_MINUS
    (139) brace -> . NUM
    (140) brace -> . STRING
    (141) brace -> . MULTIPLY ID
    (142) brace -> . BIT_AND ID
    (143) brace -> . ID
    (144) brace -> . CHAR
    (145) brace -> . function_call
    (146) brace -> . ID narrayindex
    (147) NUM -> . INT_NUM
    (148) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    expr                           shift and go to state 208
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 182

    (25) multi_declaration -> MULTIPLY ID COMMA .

    ID              reduce using rule 25 (multi_declaration -> MULTIPLY ID COMMA .)
    MULTIPLY        reduce using rule 25 (multi_declaration -> MULTIPLY ID COMMA .)


state 183

    (19) multi_declaration -> multi_declaration ID COMMA .

    ID              reduce using rule 19 (multi_declaration -> multi_declaration ID COMMA .)
    MULTIPLY        reduce using rule 19 (multi_declaration -> multi_declaration ID COMMA .)


state 184

    (21) multi_declaration -> multi_declaration ID ASSIGN . expr COMMA
    (29) stop -> ID ASSIGN . expr SEMICOLON
    (85) expr -> . expr assignment exprOR
    (86) expr -> . exprOR
    (98) exprOR -> . exprOR OR exprAND
    (99) exprOR -> . exprAND
    (100) exprAND -> . exprAND AND exprBITOR
    (101) exprAND -> . exprBITOR
    (102) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (103) exprBITOR -> . exprBITXOR
    (104) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (105) exprBITXOR -> . exprBITAND
    (106) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (107) exprBITAND -> . exprEQ
    (108) exprEQ -> . exprEQ EQ exprRELOP
    (109) exprEQ -> . exprEQ NE exprRELOP
    (110) exprEQ -> . exprRELOP
    (111) exprRELOP -> . exprRELOP relop exprSHIFT
    (112) exprRELOP -> . exprSHIFT
    (117) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (118) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (119) exprSHIFT -> . exprOP
    (120) exprOP -> . exprOP PLUS term
    (121) exprOP -> . exprOP MINUS term
    (122) exprOP -> . term
    (123) term -> . term MULTIPLY factor
    (124) term -> . term DIVIDE factor
    (125) term -> . term MOD factor
    (126) term -> . factor
    (127) factor -> . NOT factor
    (128) factor -> . PLUS factor
    (129) factor -> . MINUS factor
    (130) factor -> . PLUS_PLUS factor
    (131) factor -> . MINUS_MINUS factor
    (132) factor -> . cast brace
    (133) factor -> . brace
    (134) cast -> . L_PAREN TYPE R_PAREN
    (135) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (136) brace -> . L_PAREN expr R_PAREN
    (137) brace -> . brace PLUS_PLUS
    (138) brace -> . brace MINUS_MINUS
    (139) brace -> . NUM
    (140) brace -> . STRING
    (141) brace -> . MULTIPLY ID
    (142) brace -> . BIT_AND ID
    (143) brace -> . ID
    (144) brace -> . CHAR
    (145) brace -> . function_call
    (146) brace -> . ID narrayindex
    (147) NUM -> . INT_NUM
    (148) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    expr                           shift and go to state 209
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 185

    (27) stop -> ID SEMICOLON .

    IF              reduce using rule 27 (stop -> ID SEMICOLON .)
    WHILE           reduce using rule 27 (stop -> ID SEMICOLON .)
    FOR             reduce using rule 27 (stop -> ID SEMICOLON .)
    SEMICOLON       reduce using rule 27 (stop -> ID SEMICOLON .)
    RETURN          reduce using rule 27 (stop -> ID SEMICOLON .)
    HASH            reduce using rule 27 (stop -> ID SEMICOLON .)
    TYPE            reduce using rule 27 (stop -> ID SEMICOLON .)
    L_FLOWBRACE     reduce using rule 27 (stop -> ID SEMICOLON .)
    NOT             reduce using rule 27 (stop -> ID SEMICOLON .)
    PLUS            reduce using rule 27 (stop -> ID SEMICOLON .)
    MINUS           reduce using rule 27 (stop -> ID SEMICOLON .)
    PLUS_PLUS       reduce using rule 27 (stop -> ID SEMICOLON .)
    MINUS_MINUS     reduce using rule 27 (stop -> ID SEMICOLON .)
    L_PAREN         reduce using rule 27 (stop -> ID SEMICOLON .)
    STRING          reduce using rule 27 (stop -> ID SEMICOLON .)
    MULTIPLY        reduce using rule 27 (stop -> ID SEMICOLON .)
    BIT_AND         reduce using rule 27 (stop -> ID SEMICOLON .)
    ID              reduce using rule 27 (stop -> ID SEMICOLON .)
    CHAR            reduce using rule 27 (stop -> ID SEMICOLON .)
    INT_NUM         reduce using rule 27 (stop -> ID SEMICOLON .)
    FLOAT_NUM       reduce using rule 27 (stop -> ID SEMICOLON .)
    $end            reduce using rule 27 (stop -> ID SEMICOLON .)
    R_FLOWBRACE     reduce using rule 27 (stop -> ID SEMICOLON .)
    ELSE            reduce using rule 27 (stop -> ID SEMICOLON .)
    R_PAREN         reduce using rule 27 (stop -> ID SEMICOLON .)


state 186

    (20) multi_declaration -> multi_declaration MULTIPLY ID . COMMA
    (22) multi_declaration -> multi_declaration MULTIPLY ID . ASSIGN expr COMMA
    (28) stop -> MULTIPLY ID . SEMICOLON
    (30) stop -> MULTIPLY ID . ASSIGN expr SEMICOLON

    COMMA           shift and go to state 210
    ASSIGN          shift and go to state 211
    SEMICOLON       shift and go to state 212


state 187

    (63) function_call -> ID L_PAREN call_params R_PAREN .

    PLUS_PLUS       reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    MINUS_MINUS     reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    MULTIPLY        reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    DIVIDE          reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    MOD             reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    PLUS            reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    MINUS           reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    L_SHIFT         reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    R_SHIFT         reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    LE              reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    LT              reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    GE              reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    GT              reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    EQ              reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    NE              reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    BIT_AND         reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    BIT_XOR         reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    BIT_OR          reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    AND             reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    OR              reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    SEMICOLON       reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    ASSIGN          reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    PLUS_ASSIGN     reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    MINUS_ASSIGN    reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    MUL_ASSIGN      reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    DIV_ASSIGN      reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    AND_ASSIGN      reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    OR_ASSIGN       reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    XOR_ASSIGN      reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    MOD_ASSIGN      reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    L_SHIFT_ASSIGN  reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    R_SHIFT_ASSIGN  reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    R_PAREN         reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    COMMA           reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    R_SQBRACE       reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    R_FLOWBRACE     reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)


state 188

    (65) call_params -> yes_call_params end_call_params .

    R_PAREN         reduce using rule 65 (call_params -> yes_call_params end_call_params .)


state 189

    (67) yes_call_params -> yes_call_params expr . COMMA
    (69) end_call_params -> expr .
    (85) expr -> expr . assignment exprOR
    (87) assignment -> . ASSIGN
    (88) assignment -> . PLUS_ASSIGN
    (89) assignment -> . MINUS_ASSIGN
    (90) assignment -> . MUL_ASSIGN
    (91) assignment -> . DIV_ASSIGN
    (92) assignment -> . AND_ASSIGN
    (93) assignment -> . OR_ASSIGN
    (94) assignment -> . XOR_ASSIGN
    (95) assignment -> . MOD_ASSIGN
    (96) assignment -> . L_SHIFT_ASSIGN
    (97) assignment -> . R_SHIFT_ASSIGN

    COMMA           shift and go to state 213
    R_PAREN         reduce using rule 69 (end_call_params -> expr .)
    ASSIGN          shift and go to state 58
    PLUS_ASSIGN     shift and go to state 59
    MINUS_ASSIGN    shift and go to state 60
    MUL_ASSIGN      shift and go to state 61
    DIV_ASSIGN      shift and go to state 62
    AND_ASSIGN      shift and go to state 63
    OR_ASSIGN       shift and go to state 64
    XOR_ASSIGN      shift and go to state 65
    MOD_ASSIGN      shift and go to state 66
    L_SHIFT_ASSIGN  shift and go to state 67
    R_SHIFT_ASSIGN  shift and go to state 68

    assignment                     shift and go to state 57

state 190

    (68) yes_call_params -> expr COMMA .

    NOT             reduce using rule 68 (yes_call_params -> expr COMMA .)
    PLUS            reduce using rule 68 (yes_call_params -> expr COMMA .)
    MINUS           reduce using rule 68 (yes_call_params -> expr COMMA .)
    PLUS_PLUS       reduce using rule 68 (yes_call_params -> expr COMMA .)
    MINUS_MINUS     reduce using rule 68 (yes_call_params -> expr COMMA .)
    L_PAREN         reduce using rule 68 (yes_call_params -> expr COMMA .)
    STRING          reduce using rule 68 (yes_call_params -> expr COMMA .)
    MULTIPLY        reduce using rule 68 (yes_call_params -> expr COMMA .)
    BIT_AND         reduce using rule 68 (yes_call_params -> expr COMMA .)
    ID              reduce using rule 68 (yes_call_params -> expr COMMA .)
    CHAR            reduce using rule 68 (yes_call_params -> expr COMMA .)
    INT_NUM         reduce using rule 68 (yes_call_params -> expr COMMA .)
    FLOAT_NUM       reduce using rule 68 (yes_call_params -> expr COMMA .)


state 191

    (31) arrayindex -> L_SQBRACE index R_SQBRACE .

    L_SQBRACE       reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    PLUS_PLUS       reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    MINUS_MINUS     reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    MULTIPLY        reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    DIVIDE          reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    MOD             reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    PLUS            reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    MINUS           reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    L_SHIFT         reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    R_SHIFT         reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    LE              reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    LT              reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    GE              reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    GT              reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    EQ              reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    NE              reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    BIT_AND         reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    BIT_XOR         reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    BIT_OR          reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    AND             reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    OR              reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    SEMICOLON       reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    ASSIGN          reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    PLUS_ASSIGN     reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    MINUS_ASSIGN    reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    MUL_ASSIGN      reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    DIV_ASSIGN      reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    AND_ASSIGN      reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    OR_ASSIGN       reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    XOR_ASSIGN      reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    MOD_ASSIGN      reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    L_SHIFT_ASSIGN  reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    R_SHIFT_ASSIGN  reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    R_PAREN         reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    COMMA           reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    R_SQBRACE       reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    R_FLOWBRACE     reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)


state 192

    (135) cast -> L_PAREN TYPE MULTIPLY R_PAREN .

    L_PAREN         reduce using rule 135 (cast -> L_PAREN TYPE MULTIPLY R_PAREN .)
    STRING          reduce using rule 135 (cast -> L_PAREN TYPE MULTIPLY R_PAREN .)
    MULTIPLY        reduce using rule 135 (cast -> L_PAREN TYPE MULTIPLY R_PAREN .)
    BIT_AND         reduce using rule 135 (cast -> L_PAREN TYPE MULTIPLY R_PAREN .)
    ID              reduce using rule 135 (cast -> L_PAREN TYPE MULTIPLY R_PAREN .)
    CHAR            reduce using rule 135 (cast -> L_PAREN TYPE MULTIPLY R_PAREN .)
    INT_NUM         reduce using rule 135 (cast -> L_PAREN TYPE MULTIPLY R_PAREN .)
    FLOAT_NUM       reduce using rule 135 (cast -> L_PAREN TYPE MULTIPLY R_PAREN .)


state 193

    (13) closed -> IF condition closed . ELSE closed
    (7) open -> IF condition closed . ELSE open
    (5) statement -> closed .

    ELSE            shift and go to state 214
    IF              reduce using rule 5 (statement -> closed .)
    WHILE           reduce using rule 5 (statement -> closed .)
    FOR             reduce using rule 5 (statement -> closed .)
    SEMICOLON       reduce using rule 5 (statement -> closed .)
    RETURN          reduce using rule 5 (statement -> closed .)
    HASH            reduce using rule 5 (statement -> closed .)
    TYPE            reduce using rule 5 (statement -> closed .)
    L_FLOWBRACE     reduce using rule 5 (statement -> closed .)
    NOT             reduce using rule 5 (statement -> closed .)
    PLUS            reduce using rule 5 (statement -> closed .)
    MINUS           reduce using rule 5 (statement -> closed .)
    PLUS_PLUS       reduce using rule 5 (statement -> closed .)
    MINUS_MINUS     reduce using rule 5 (statement -> closed .)
    L_PAREN         reduce using rule 5 (statement -> closed .)
    STRING          reduce using rule 5 (statement -> closed .)
    MULTIPLY        reduce using rule 5 (statement -> closed .)
    BIT_AND         reduce using rule 5 (statement -> closed .)
    ID              reduce using rule 5 (statement -> closed .)
    CHAR            reduce using rule 5 (statement -> closed .)
    INT_NUM         reduce using rule 5 (statement -> closed .)
    FLOAT_NUM       reduce using rule 5 (statement -> closed .)
    $end            reduce using rule 5 (statement -> closed .)
    R_FLOWBRACE     reduce using rule 5 (statement -> closed .)


state 194

    (13) closed -> IF condition closed ELSE closed .

    IF              reduce using rule 13 (closed -> IF condition closed ELSE closed .)
    WHILE           reduce using rule 13 (closed -> IF condition closed ELSE closed .)
    FOR             reduce using rule 13 (closed -> IF condition closed ELSE closed .)
    SEMICOLON       reduce using rule 13 (closed -> IF condition closed ELSE closed .)
    RETURN          reduce using rule 13 (closed -> IF condition closed ELSE closed .)
    HASH            reduce using rule 13 (closed -> IF condition closed ELSE closed .)
    TYPE            reduce using rule 13 (closed -> IF condition closed ELSE closed .)
    L_FLOWBRACE     reduce using rule 13 (closed -> IF condition closed ELSE closed .)
    NOT             reduce using rule 13 (closed -> IF condition closed ELSE closed .)
    PLUS            reduce using rule 13 (closed -> IF condition closed ELSE closed .)
    MINUS           reduce using rule 13 (closed -> IF condition closed ELSE closed .)
    PLUS_PLUS       reduce using rule 13 (closed -> IF condition closed ELSE closed .)
    MINUS_MINUS     reduce using rule 13 (closed -> IF condition closed ELSE closed .)
    L_PAREN         reduce using rule 13 (closed -> IF condition closed ELSE closed .)
    STRING          reduce using rule 13 (closed -> IF condition closed ELSE closed .)
    MULTIPLY        reduce using rule 13 (closed -> IF condition closed ELSE closed .)
    BIT_AND         reduce using rule 13 (closed -> IF condition closed ELSE closed .)
    ID              reduce using rule 13 (closed -> IF condition closed ELSE closed .)
    CHAR            reduce using rule 13 (closed -> IF condition closed ELSE closed .)
    INT_NUM         reduce using rule 13 (closed -> IF condition closed ELSE closed .)
    FLOAT_NUM       reduce using rule 13 (closed -> IF condition closed ELSE closed .)
    $end            reduce using rule 13 (closed -> IF condition closed ELSE closed .)
    R_FLOWBRACE     reduce using rule 13 (closed -> IF condition closed ELSE closed .)
    ELSE            reduce using rule 13 (closed -> IF condition closed ELSE closed .)


state 195

    (7) open -> IF condition closed ELSE open .

    IF              reduce using rule 7 (open -> IF condition closed ELSE open .)
    WHILE           reduce using rule 7 (open -> IF condition closed ELSE open .)
    FOR             reduce using rule 7 (open -> IF condition closed ELSE open .)
    SEMICOLON       reduce using rule 7 (open -> IF condition closed ELSE open .)
    RETURN          reduce using rule 7 (open -> IF condition closed ELSE open .)
    HASH            reduce using rule 7 (open -> IF condition closed ELSE open .)
    TYPE            reduce using rule 7 (open -> IF condition closed ELSE open .)
    L_FLOWBRACE     reduce using rule 7 (open -> IF condition closed ELSE open .)
    NOT             reduce using rule 7 (open -> IF condition closed ELSE open .)
    PLUS            reduce using rule 7 (open -> IF condition closed ELSE open .)
    MINUS           reduce using rule 7 (open -> IF condition closed ELSE open .)
    PLUS_PLUS       reduce using rule 7 (open -> IF condition closed ELSE open .)
    MINUS_MINUS     reduce using rule 7 (open -> IF condition closed ELSE open .)
    L_PAREN         reduce using rule 7 (open -> IF condition closed ELSE open .)
    STRING          reduce using rule 7 (open -> IF condition closed ELSE open .)
    MULTIPLY        reduce using rule 7 (open -> IF condition closed ELSE open .)
    BIT_AND         reduce using rule 7 (open -> IF condition closed ELSE open .)
    ID              reduce using rule 7 (open -> IF condition closed ELSE open .)
    CHAR            reduce using rule 7 (open -> IF condition closed ELSE open .)
    INT_NUM         reduce using rule 7 (open -> IF condition closed ELSE open .)
    FLOAT_NUM       reduce using rule 7 (open -> IF condition closed ELSE open .)
    $end            reduce using rule 7 (open -> IF condition closed ELSE open .)
    R_FLOWBRACE     reduce using rule 7 (open -> IF condition closed ELSE open .)


state 196

    (17) for_condition -> L_PAREN simple simple expr . R_PAREN
    (85) expr -> expr . assignment exprOR
    (87) assignment -> . ASSIGN
    (88) assignment -> . PLUS_ASSIGN
    (89) assignment -> . MINUS_ASSIGN
    (90) assignment -> . MUL_ASSIGN
    (91) assignment -> . DIV_ASSIGN
    (92) assignment -> . AND_ASSIGN
    (93) assignment -> . OR_ASSIGN
    (94) assignment -> . XOR_ASSIGN
    (95) assignment -> . MOD_ASSIGN
    (96) assignment -> . L_SHIFT_ASSIGN
    (97) assignment -> . R_SHIFT_ASSIGN

    R_PAREN         shift and go to state 215
    ASSIGN          shift and go to state 58
    PLUS_ASSIGN     shift and go to state 59
    MINUS_ASSIGN    shift and go to state 60
    MUL_ASSIGN      shift and go to state 61
    DIV_ASSIGN      shift and go to state 62
    AND_ASSIGN      shift and go to state 63
    OR_ASSIGN       shift and go to state 64
    XOR_ASSIGN      shift and go to state 65
    MOD_ASSIGN      shift and go to state 66
    L_SHIFT_ASSIGN  shift and go to state 67
    R_SHIFT_ASSIGN  shift and go to state 68

    assignment                     shift and go to state 57

state 197

    (18) for_condition -> L_PAREN simple simple R_PAREN .

    IF              reduce using rule 18 (for_condition -> L_PAREN simple simple R_PAREN .)
    WHILE           reduce using rule 18 (for_condition -> L_PAREN simple simple R_PAREN .)
    FOR             reduce using rule 18 (for_condition -> L_PAREN simple simple R_PAREN .)
    SEMICOLON       reduce using rule 18 (for_condition -> L_PAREN simple simple R_PAREN .)
    RETURN          reduce using rule 18 (for_condition -> L_PAREN simple simple R_PAREN .)
    HASH            reduce using rule 18 (for_condition -> L_PAREN simple simple R_PAREN .)
    TYPE            reduce using rule 18 (for_condition -> L_PAREN simple simple R_PAREN .)
    L_FLOWBRACE     reduce using rule 18 (for_condition -> L_PAREN simple simple R_PAREN .)
    NOT             reduce using rule 18 (for_condition -> L_PAREN simple simple R_PAREN .)
    PLUS            reduce using rule 18 (for_condition -> L_PAREN simple simple R_PAREN .)
    MINUS           reduce using rule 18 (for_condition -> L_PAREN simple simple R_PAREN .)
    PLUS_PLUS       reduce using rule 18 (for_condition -> L_PAREN simple simple R_PAREN .)
    MINUS_MINUS     reduce using rule 18 (for_condition -> L_PAREN simple simple R_PAREN .)
    L_PAREN         reduce using rule 18 (for_condition -> L_PAREN simple simple R_PAREN .)
    STRING          reduce using rule 18 (for_condition -> L_PAREN simple simple R_PAREN .)
    MULTIPLY        reduce using rule 18 (for_condition -> L_PAREN simple simple R_PAREN .)
    BIT_AND         reduce using rule 18 (for_condition -> L_PAREN simple simple R_PAREN .)
    ID              reduce using rule 18 (for_condition -> L_PAREN simple simple R_PAREN .)
    CHAR            reduce using rule 18 (for_condition -> L_PAREN simple simple R_PAREN .)
    INT_NUM         reduce using rule 18 (for_condition -> L_PAREN simple simple R_PAREN .)
    FLOAT_NUM       reduce using rule 18 (for_condition -> L_PAREN simple simple R_PAREN .)


state 198

    (36) declaration -> TYPE ID ASSIGN expr SEMICOLON .

    IF              reduce using rule 36 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    WHILE           reduce using rule 36 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    FOR             reduce using rule 36 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    SEMICOLON       reduce using rule 36 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    RETURN          reduce using rule 36 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    HASH            reduce using rule 36 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    TYPE            reduce using rule 36 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    L_FLOWBRACE     reduce using rule 36 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    NOT             reduce using rule 36 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    PLUS            reduce using rule 36 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    MINUS           reduce using rule 36 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    PLUS_PLUS       reduce using rule 36 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    MINUS_MINUS     reduce using rule 36 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    L_PAREN         reduce using rule 36 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    STRING          reduce using rule 36 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    MULTIPLY        reduce using rule 36 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    BIT_AND         reduce using rule 36 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    ID              reduce using rule 36 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    CHAR            reduce using rule 36 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    INT_NUM         reduce using rule 36 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    FLOAT_NUM       reduce using rule 36 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    $end            reduce using rule 36 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    R_FLOWBRACE     reduce using rule 36 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    ELSE            reduce using rule 36 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    R_PAREN         reduce using rule 36 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)


state 199

    (24) multi_declaration -> ID ASSIGN expr COMMA .

    ID              reduce using rule 24 (multi_declaration -> ID ASSIGN expr COMMA .)
    MULTIPLY        reduce using rule 24 (multi_declaration -> ID ASSIGN expr COMMA .)


state 200

    (40) declaration -> TYPE ID narrayindex ASSIGN init_list . SEMICOLON

    SEMICOLON       shift and go to state 216


state 201

    (43) init_list -> L_FLOWBRACE . init_list R_FLOWBRACE COMMA init_list
    (44) init_list -> L_FLOWBRACE . init R_FLOWBRACE COMMA init_list
    (45) init_list -> L_FLOWBRACE . init R_FLOWBRACE
    (46) init_list -> L_FLOWBRACE . init_list R_FLOWBRACE
    (43) init_list -> . L_FLOWBRACE init_list R_FLOWBRACE COMMA init_list
    (44) init_list -> . L_FLOWBRACE init R_FLOWBRACE COMMA init_list
    (45) init_list -> . L_FLOWBRACE init R_FLOWBRACE
    (46) init_list -> . L_FLOWBRACE init_list R_FLOWBRACE
    (41) init -> . expr COMMA init
    (42) init -> . expr
    (85) expr -> . expr assignment exprOR
    (86) expr -> . exprOR
    (98) exprOR -> . exprOR OR exprAND
    (99) exprOR -> . exprAND
    (100) exprAND -> . exprAND AND exprBITOR
    (101) exprAND -> . exprBITOR
    (102) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (103) exprBITOR -> . exprBITXOR
    (104) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (105) exprBITXOR -> . exprBITAND
    (106) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (107) exprBITAND -> . exprEQ
    (108) exprEQ -> . exprEQ EQ exprRELOP
    (109) exprEQ -> . exprEQ NE exprRELOP
    (110) exprEQ -> . exprRELOP
    (111) exprRELOP -> . exprRELOP relop exprSHIFT
    (112) exprRELOP -> . exprSHIFT
    (117) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (118) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (119) exprSHIFT -> . exprOP
    (120) exprOP -> . exprOP PLUS term
    (121) exprOP -> . exprOP MINUS term
    (122) exprOP -> . term
    (123) term -> . term MULTIPLY factor
    (124) term -> . term DIVIDE factor
    (125) term -> . term MOD factor
    (126) term -> . factor
    (127) factor -> . NOT factor
    (128) factor -> . PLUS factor
    (129) factor -> . MINUS factor
    (130) factor -> . PLUS_PLUS factor
    (131) factor -> . MINUS_MINUS factor
    (132) factor -> . cast brace
    (133) factor -> . brace
    (134) cast -> . L_PAREN TYPE R_PAREN
    (135) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (136) brace -> . L_PAREN expr R_PAREN
    (137) brace -> . brace PLUS_PLUS
    (138) brace -> . brace MINUS_MINUS
    (139) brace -> . NUM
    (140) brace -> . STRING
    (141) brace -> . MULTIPLY ID
    (142) brace -> . BIT_AND ID
    (143) brace -> . ID
    (144) brace -> . CHAR
    (145) brace -> . function_call
    (146) brace -> . ID narrayindex
    (147) NUM -> . INT_NUM
    (148) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    L_FLOWBRACE     shift and go to state 201
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    init_list                      shift and go to state 217
    init                           shift and go to state 218
    expr                           shift and go to state 219
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 202

    (73) yes_dec_params -> TYPE expr . COMMA
    (76) end_dec_params -> TYPE expr .
    (85) expr -> expr . assignment exprOR
    (87) assignment -> . ASSIGN
    (88) assignment -> . PLUS_ASSIGN
    (89) assignment -> . MINUS_ASSIGN
    (90) assignment -> . MUL_ASSIGN
    (91) assignment -> . DIV_ASSIGN
    (92) assignment -> . AND_ASSIGN
    (93) assignment -> . OR_ASSIGN
    (94) assignment -> . XOR_ASSIGN
    (95) assignment -> . MOD_ASSIGN
    (96) assignment -> . L_SHIFT_ASSIGN
    (97) assignment -> . R_SHIFT_ASSIGN

    COMMA           shift and go to state 220
    R_PAREN         reduce using rule 76 (end_dec_params -> TYPE expr .)
    ASSIGN          shift and go to state 58
    PLUS_ASSIGN     shift and go to state 59
    MINUS_ASSIGN    shift and go to state 60
    MUL_ASSIGN      shift and go to state 61
    DIV_ASSIGN      shift and go to state 62
    AND_ASSIGN      shift and go to state 63
    OR_ASSIGN       shift and go to state 64
    XOR_ASSIGN      shift and go to state 65
    MOD_ASSIGN      shift and go to state 66
    L_SHIFT_ASSIGN  shift and go to state 67
    R_SHIFT_ASSIGN  shift and go to state 68

    assignment                     shift and go to state 57

state 203

    (74) yes_dec_params -> TYPE COMMA .

    TYPE            reduce using rule 74 (yes_dec_params -> TYPE COMMA .)


state 204

    (75) yes_dec_params -> TYPE MULTIPLY . COMMA
    (78) end_dec_params -> TYPE MULTIPLY .
    (141) brace -> MULTIPLY . ID

    COMMA           shift and go to state 221
    R_PAREN         reduce using rule 78 (end_dec_params -> TYPE MULTIPLY .)
    ID              shift and go to state 83


state 205

    (82) function -> TYPE ID L_PAREN dec_params R_PAREN . function_2
    (83) function_2 -> . SEMICOLON
    (84) function_2 -> . block
    (49) block -> . left_flower multiple_statements right_flower
    (50) block -> . left_flower right_flower
    (51) left_flower -> . L_FLOWBRACE

    SEMICOLON       shift and go to state 223
    L_FLOWBRACE     shift and go to state 26

    function_2                     shift and go to state 222
    block                          shift and go to state 224
    left_flower                    shift and go to state 18

state 206

    (80) dec_params -> yes_dec_params end_dec_params .

    R_PAREN         reduce using rule 80 (dec_params -> yes_dec_params end_dec_params .)


state 207

    (70) yes_dec_params -> yes_dec_params TYPE . expr COMMA
    (71) yes_dec_params -> yes_dec_params TYPE . COMMA
    (72) yes_dec_params -> yes_dec_params TYPE . MULTIPLY COMMA
    (76) end_dec_params -> TYPE . expr
    (77) end_dec_params -> TYPE .
    (78) end_dec_params -> TYPE . MULTIPLY
    (85) expr -> . expr assignment exprOR
    (86) expr -> . exprOR
    (98) exprOR -> . exprOR OR exprAND
    (99) exprOR -> . exprAND
    (100) exprAND -> . exprAND AND exprBITOR
    (101) exprAND -> . exprBITOR
    (102) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (103) exprBITOR -> . exprBITXOR
    (104) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (105) exprBITXOR -> . exprBITAND
    (106) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (107) exprBITAND -> . exprEQ
    (108) exprEQ -> . exprEQ EQ exprRELOP
    (109) exprEQ -> . exprEQ NE exprRELOP
    (110) exprEQ -> . exprRELOP
    (111) exprRELOP -> . exprRELOP relop exprSHIFT
    (112) exprRELOP -> . exprSHIFT
    (117) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (118) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (119) exprSHIFT -> . exprOP
    (120) exprOP -> . exprOP PLUS term
    (121) exprOP -> . exprOP MINUS term
    (122) exprOP -> . term
    (123) term -> . term MULTIPLY factor
    (124) term -> . term DIVIDE factor
    (125) term -> . term MOD factor
    (126) term -> . factor
    (127) factor -> . NOT factor
    (128) factor -> . PLUS factor
    (129) factor -> . MINUS factor
    (130) factor -> . PLUS_PLUS factor
    (131) factor -> . MINUS_MINUS factor
    (132) factor -> . cast brace
    (133) factor -> . brace
    (134) cast -> . L_PAREN TYPE R_PAREN
    (135) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (136) brace -> . L_PAREN expr R_PAREN
    (137) brace -> . brace PLUS_PLUS
    (138) brace -> . brace MINUS_MINUS
    (139) brace -> . NUM
    (140) brace -> . STRING
    (141) brace -> . MULTIPLY ID
    (142) brace -> . BIT_AND ID
    (143) brace -> . ID
    (144) brace -> . CHAR
    (145) brace -> . function_call
    (146) brace -> . ID narrayindex
    (147) NUM -> . INT_NUM
    (148) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    COMMA           shift and go to state 226
    MULTIPLY        shift and go to state 227
    R_PAREN         reduce using rule 77 (end_dec_params -> TYPE .)
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    expr                           shift and go to state 225
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 208

    (37) declaration -> TYPE MULTIPLY ID ASSIGN expr . SEMICOLON
    (26) multi_declaration -> MULTIPLY ID ASSIGN expr . COMMA
    (85) expr -> expr . assignment exprOR
    (87) assignment -> . ASSIGN
    (88) assignment -> . PLUS_ASSIGN
    (89) assignment -> . MINUS_ASSIGN
    (90) assignment -> . MUL_ASSIGN
    (91) assignment -> . DIV_ASSIGN
    (92) assignment -> . AND_ASSIGN
    (93) assignment -> . OR_ASSIGN
    (94) assignment -> . XOR_ASSIGN
    (95) assignment -> . MOD_ASSIGN
    (96) assignment -> . L_SHIFT_ASSIGN
    (97) assignment -> . R_SHIFT_ASSIGN

    SEMICOLON       shift and go to state 228
    COMMA           shift and go to state 229
    ASSIGN          shift and go to state 58
    PLUS_ASSIGN     shift and go to state 59
    MINUS_ASSIGN    shift and go to state 60
    MUL_ASSIGN      shift and go to state 61
    DIV_ASSIGN      shift and go to state 62
    AND_ASSIGN      shift and go to state 63
    OR_ASSIGN       shift and go to state 64
    XOR_ASSIGN      shift and go to state 65
    MOD_ASSIGN      shift and go to state 66
    L_SHIFT_ASSIGN  shift and go to state 67
    R_SHIFT_ASSIGN  shift and go to state 68

    assignment                     shift and go to state 57

state 209

    (21) multi_declaration -> multi_declaration ID ASSIGN expr . COMMA
    (29) stop -> ID ASSIGN expr . SEMICOLON
    (85) expr -> expr . assignment exprOR
    (87) assignment -> . ASSIGN
    (88) assignment -> . PLUS_ASSIGN
    (89) assignment -> . MINUS_ASSIGN
    (90) assignment -> . MUL_ASSIGN
    (91) assignment -> . DIV_ASSIGN
    (92) assignment -> . AND_ASSIGN
    (93) assignment -> . OR_ASSIGN
    (94) assignment -> . XOR_ASSIGN
    (95) assignment -> . MOD_ASSIGN
    (96) assignment -> . L_SHIFT_ASSIGN
    (97) assignment -> . R_SHIFT_ASSIGN

    COMMA           shift and go to state 230
    SEMICOLON       shift and go to state 231
    ASSIGN          shift and go to state 58
    PLUS_ASSIGN     shift and go to state 59
    MINUS_ASSIGN    shift and go to state 60
    MUL_ASSIGN      shift and go to state 61
    DIV_ASSIGN      shift and go to state 62
    AND_ASSIGN      shift and go to state 63
    OR_ASSIGN       shift and go to state 64
    XOR_ASSIGN      shift and go to state 65
    MOD_ASSIGN      shift and go to state 66
    L_SHIFT_ASSIGN  shift and go to state 67
    R_SHIFT_ASSIGN  shift and go to state 68

    assignment                     shift and go to state 57

state 210

    (20) multi_declaration -> multi_declaration MULTIPLY ID COMMA .

    ID              reduce using rule 20 (multi_declaration -> multi_declaration MULTIPLY ID COMMA .)
    MULTIPLY        reduce using rule 20 (multi_declaration -> multi_declaration MULTIPLY ID COMMA .)


state 211

    (22) multi_declaration -> multi_declaration MULTIPLY ID ASSIGN . expr COMMA
    (30) stop -> MULTIPLY ID ASSIGN . expr SEMICOLON
    (85) expr -> . expr assignment exprOR
    (86) expr -> . exprOR
    (98) exprOR -> . exprOR OR exprAND
    (99) exprOR -> . exprAND
    (100) exprAND -> . exprAND AND exprBITOR
    (101) exprAND -> . exprBITOR
    (102) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (103) exprBITOR -> . exprBITXOR
    (104) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (105) exprBITXOR -> . exprBITAND
    (106) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (107) exprBITAND -> . exprEQ
    (108) exprEQ -> . exprEQ EQ exprRELOP
    (109) exprEQ -> . exprEQ NE exprRELOP
    (110) exprEQ -> . exprRELOP
    (111) exprRELOP -> . exprRELOP relop exprSHIFT
    (112) exprRELOP -> . exprSHIFT
    (117) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (118) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (119) exprSHIFT -> . exprOP
    (120) exprOP -> . exprOP PLUS term
    (121) exprOP -> . exprOP MINUS term
    (122) exprOP -> . term
    (123) term -> . term MULTIPLY factor
    (124) term -> . term DIVIDE factor
    (125) term -> . term MOD factor
    (126) term -> . factor
    (127) factor -> . NOT factor
    (128) factor -> . PLUS factor
    (129) factor -> . MINUS factor
    (130) factor -> . PLUS_PLUS factor
    (131) factor -> . MINUS_MINUS factor
    (132) factor -> . cast brace
    (133) factor -> . brace
    (134) cast -> . L_PAREN TYPE R_PAREN
    (135) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (136) brace -> . L_PAREN expr R_PAREN
    (137) brace -> . brace PLUS_PLUS
    (138) brace -> . brace MINUS_MINUS
    (139) brace -> . NUM
    (140) brace -> . STRING
    (141) brace -> . MULTIPLY ID
    (142) brace -> . BIT_AND ID
    (143) brace -> . ID
    (144) brace -> . CHAR
    (145) brace -> . function_call
    (146) brace -> . ID narrayindex
    (147) NUM -> . INT_NUM
    (148) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    expr                           shift and go to state 232
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 212

    (28) stop -> MULTIPLY ID SEMICOLON .

    IF              reduce using rule 28 (stop -> MULTIPLY ID SEMICOLON .)
    WHILE           reduce using rule 28 (stop -> MULTIPLY ID SEMICOLON .)
    FOR             reduce using rule 28 (stop -> MULTIPLY ID SEMICOLON .)
    SEMICOLON       reduce using rule 28 (stop -> MULTIPLY ID SEMICOLON .)
    RETURN          reduce using rule 28 (stop -> MULTIPLY ID SEMICOLON .)
    HASH            reduce using rule 28 (stop -> MULTIPLY ID SEMICOLON .)
    TYPE            reduce using rule 28 (stop -> MULTIPLY ID SEMICOLON .)
    L_FLOWBRACE     reduce using rule 28 (stop -> MULTIPLY ID SEMICOLON .)
    NOT             reduce using rule 28 (stop -> MULTIPLY ID SEMICOLON .)
    PLUS            reduce using rule 28 (stop -> MULTIPLY ID SEMICOLON .)
    MINUS           reduce using rule 28 (stop -> MULTIPLY ID SEMICOLON .)
    PLUS_PLUS       reduce using rule 28 (stop -> MULTIPLY ID SEMICOLON .)
    MINUS_MINUS     reduce using rule 28 (stop -> MULTIPLY ID SEMICOLON .)
    L_PAREN         reduce using rule 28 (stop -> MULTIPLY ID SEMICOLON .)
    STRING          reduce using rule 28 (stop -> MULTIPLY ID SEMICOLON .)
    MULTIPLY        reduce using rule 28 (stop -> MULTIPLY ID SEMICOLON .)
    BIT_AND         reduce using rule 28 (stop -> MULTIPLY ID SEMICOLON .)
    ID              reduce using rule 28 (stop -> MULTIPLY ID SEMICOLON .)
    CHAR            reduce using rule 28 (stop -> MULTIPLY ID SEMICOLON .)
    INT_NUM         reduce using rule 28 (stop -> MULTIPLY ID SEMICOLON .)
    FLOAT_NUM       reduce using rule 28 (stop -> MULTIPLY ID SEMICOLON .)
    $end            reduce using rule 28 (stop -> MULTIPLY ID SEMICOLON .)
    R_FLOWBRACE     reduce using rule 28 (stop -> MULTIPLY ID SEMICOLON .)
    ELSE            reduce using rule 28 (stop -> MULTIPLY ID SEMICOLON .)
    R_PAREN         reduce using rule 28 (stop -> MULTIPLY ID SEMICOLON .)


state 213

    (67) yes_call_params -> yes_call_params expr COMMA .

    NOT             reduce using rule 67 (yes_call_params -> yes_call_params expr COMMA .)
    PLUS            reduce using rule 67 (yes_call_params -> yes_call_params expr COMMA .)
    MINUS           reduce using rule 67 (yes_call_params -> yes_call_params expr COMMA .)
    PLUS_PLUS       reduce using rule 67 (yes_call_params -> yes_call_params expr COMMA .)
    MINUS_MINUS     reduce using rule 67 (yes_call_params -> yes_call_params expr COMMA .)
    L_PAREN         reduce using rule 67 (yes_call_params -> yes_call_params expr COMMA .)
    STRING          reduce using rule 67 (yes_call_params -> yes_call_params expr COMMA .)
    MULTIPLY        reduce using rule 67 (yes_call_params -> yes_call_params expr COMMA .)
    BIT_AND         reduce using rule 67 (yes_call_params -> yes_call_params expr COMMA .)
    ID              reduce using rule 67 (yes_call_params -> yes_call_params expr COMMA .)
    CHAR            reduce using rule 67 (yes_call_params -> yes_call_params expr COMMA .)
    INT_NUM         reduce using rule 67 (yes_call_params -> yes_call_params expr COMMA .)
    FLOAT_NUM       reduce using rule 67 (yes_call_params -> yes_call_params expr COMMA .)


state 214

    (13) closed -> IF condition closed ELSE . closed
    (7) open -> IF condition closed ELSE . open
    (11) closed -> . simple
    (12) closed -> . block
    (13) closed -> . IF condition closed ELSE closed
    (14) closed -> . WHILE condition closed
    (15) closed -> . for for_condition closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) open -> . for for_condition open
    (53) simple -> . expr SEMICOLON
    (54) simple -> . header
    (55) simple -> . declaration
    (56) simple -> . SEMICOLON
    (57) simple -> . function
    (58) simple -> . RETURN expr SEMICOLON
    (59) simple -> . RETURN SEMICOLON
    (49) block -> . left_flower multiple_statements right_flower
    (50) block -> . left_flower right_flower
    (10) for -> . FOR
    (85) expr -> . expr assignment exprOR
    (86) expr -> . exprOR
    (60) header -> . HASH INCLUDE STRING
    (61) header -> . HASH INCLUDE HEADER_FILE
    (34) declaration -> . TYPE ID SEMICOLON
    (35) declaration -> . TYPE MULTIPLY ID SEMICOLON
    (36) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (37) declaration -> . TYPE MULTIPLY ID ASSIGN expr SEMICOLON
    (38) declaration -> . TYPE multi_declaration stop
    (39) declaration -> . TYPE ID narrayindex SEMICOLON
    (40) declaration -> . TYPE ID narrayindex ASSIGN init_list SEMICOLON
    (82) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (51) left_flower -> . L_FLOWBRACE
    (98) exprOR -> . exprOR OR exprAND
    (99) exprOR -> . exprAND
    (100) exprAND -> . exprAND AND exprBITOR
    (101) exprAND -> . exprBITOR
    (102) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (103) exprBITOR -> . exprBITXOR
    (104) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (105) exprBITXOR -> . exprBITAND
    (106) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (107) exprBITAND -> . exprEQ
    (108) exprEQ -> . exprEQ EQ exprRELOP
    (109) exprEQ -> . exprEQ NE exprRELOP
    (110) exprEQ -> . exprRELOP
    (111) exprRELOP -> . exprRELOP relop exprSHIFT
    (112) exprRELOP -> . exprSHIFT
    (117) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (118) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (119) exprSHIFT -> . exprOP
    (120) exprOP -> . exprOP PLUS term
    (121) exprOP -> . exprOP MINUS term
    (122) exprOP -> . term
    (123) term -> . term MULTIPLY factor
    (124) term -> . term DIVIDE factor
    (125) term -> . term MOD factor
    (126) term -> . factor
    (127) factor -> . NOT factor
    (128) factor -> . PLUS factor
    (129) factor -> . MINUS factor
    (130) factor -> . PLUS_PLUS factor
    (131) factor -> . MINUS_MINUS factor
    (132) factor -> . cast brace
    (133) factor -> . brace
    (134) cast -> . L_PAREN TYPE R_PAREN
    (135) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (136) brace -> . L_PAREN expr R_PAREN
    (137) brace -> . brace PLUS_PLUS
    (138) brace -> . brace MINUS_MINUS
    (139) brace -> . NUM
    (140) brace -> . STRING
    (141) brace -> . MULTIPLY ID
    (142) brace -> . BIT_AND ID
    (143) brace -> . ID
    (144) brace -> . CHAR
    (145) brace -> . function_call
    (146) brace -> . ID narrayindex
    (147) NUM -> . INT_NUM
    (148) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    IF              shift and go to state 114
    WHILE           shift and go to state 117
    SEMICOLON       shift and go to state 13
    RETURN          shift and go to state 17
    FOR             shift and go to state 11
    HASH            shift and go to state 20
    TYPE            shift and go to state 22
    L_FLOWBRACE     shift and go to state 26
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    closed                         shift and go to state 194
    open                           shift and go to state 195
    simple                         shift and go to state 9
    block                          shift and go to state 10
    for                            shift and go to state 118
    expr                           shift and go to state 12
    header                         shift and go to state 14
    declaration                    shift and go to state 15
    function                       shift and go to state 16
    left_flower                    shift and go to state 18
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 215

    (17) for_condition -> L_PAREN simple simple expr R_PAREN .

    IF              reduce using rule 17 (for_condition -> L_PAREN simple simple expr R_PAREN .)
    WHILE           reduce using rule 17 (for_condition -> L_PAREN simple simple expr R_PAREN .)
    FOR             reduce using rule 17 (for_condition -> L_PAREN simple simple expr R_PAREN .)
    SEMICOLON       reduce using rule 17 (for_condition -> L_PAREN simple simple expr R_PAREN .)
    RETURN          reduce using rule 17 (for_condition -> L_PAREN simple simple expr R_PAREN .)
    HASH            reduce using rule 17 (for_condition -> L_PAREN simple simple expr R_PAREN .)
    TYPE            reduce using rule 17 (for_condition -> L_PAREN simple simple expr R_PAREN .)
    L_FLOWBRACE     reduce using rule 17 (for_condition -> L_PAREN simple simple expr R_PAREN .)
    NOT             reduce using rule 17 (for_condition -> L_PAREN simple simple expr R_PAREN .)
    PLUS            reduce using rule 17 (for_condition -> L_PAREN simple simple expr R_PAREN .)
    MINUS           reduce using rule 17 (for_condition -> L_PAREN simple simple expr R_PAREN .)
    PLUS_PLUS       reduce using rule 17 (for_condition -> L_PAREN simple simple expr R_PAREN .)
    MINUS_MINUS     reduce using rule 17 (for_condition -> L_PAREN simple simple expr R_PAREN .)
    L_PAREN         reduce using rule 17 (for_condition -> L_PAREN simple simple expr R_PAREN .)
    STRING          reduce using rule 17 (for_condition -> L_PAREN simple simple expr R_PAREN .)
    MULTIPLY        reduce using rule 17 (for_condition -> L_PAREN simple simple expr R_PAREN .)
    BIT_AND         reduce using rule 17 (for_condition -> L_PAREN simple simple expr R_PAREN .)
    ID              reduce using rule 17 (for_condition -> L_PAREN simple simple expr R_PAREN .)
    CHAR            reduce using rule 17 (for_condition -> L_PAREN simple simple expr R_PAREN .)
    INT_NUM         reduce using rule 17 (for_condition -> L_PAREN simple simple expr R_PAREN .)
    FLOAT_NUM       reduce using rule 17 (for_condition -> L_PAREN simple simple expr R_PAREN .)


state 216

    (40) declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .

    IF              reduce using rule 40 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    WHILE           reduce using rule 40 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    FOR             reduce using rule 40 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    SEMICOLON       reduce using rule 40 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    RETURN          reduce using rule 40 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    HASH            reduce using rule 40 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    TYPE            reduce using rule 40 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    L_FLOWBRACE     reduce using rule 40 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    NOT             reduce using rule 40 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    PLUS            reduce using rule 40 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    MINUS           reduce using rule 40 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    PLUS_PLUS       reduce using rule 40 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    MINUS_MINUS     reduce using rule 40 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    L_PAREN         reduce using rule 40 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    STRING          reduce using rule 40 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    MULTIPLY        reduce using rule 40 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    BIT_AND         reduce using rule 40 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    ID              reduce using rule 40 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    CHAR            reduce using rule 40 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    INT_NUM         reduce using rule 40 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    FLOAT_NUM       reduce using rule 40 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    $end            reduce using rule 40 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    R_FLOWBRACE     reduce using rule 40 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    ELSE            reduce using rule 40 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    R_PAREN         reduce using rule 40 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)


state 217

    (43) init_list -> L_FLOWBRACE init_list . R_FLOWBRACE COMMA init_list
    (46) init_list -> L_FLOWBRACE init_list . R_FLOWBRACE

    R_FLOWBRACE     shift and go to state 233


state 218

    (44) init_list -> L_FLOWBRACE init . R_FLOWBRACE COMMA init_list
    (45) init_list -> L_FLOWBRACE init . R_FLOWBRACE

    R_FLOWBRACE     shift and go to state 234


state 219

    (41) init -> expr . COMMA init
    (42) init -> expr .
    (85) expr -> expr . assignment exprOR
    (87) assignment -> . ASSIGN
    (88) assignment -> . PLUS_ASSIGN
    (89) assignment -> . MINUS_ASSIGN
    (90) assignment -> . MUL_ASSIGN
    (91) assignment -> . DIV_ASSIGN
    (92) assignment -> . AND_ASSIGN
    (93) assignment -> . OR_ASSIGN
    (94) assignment -> . XOR_ASSIGN
    (95) assignment -> . MOD_ASSIGN
    (96) assignment -> . L_SHIFT_ASSIGN
    (97) assignment -> . R_SHIFT_ASSIGN

    COMMA           shift and go to state 235
    R_FLOWBRACE     reduce using rule 42 (init -> expr .)
    ASSIGN          shift and go to state 58
    PLUS_ASSIGN     shift and go to state 59
    MINUS_ASSIGN    shift and go to state 60
    MUL_ASSIGN      shift and go to state 61
    DIV_ASSIGN      shift and go to state 62
    AND_ASSIGN      shift and go to state 63
    OR_ASSIGN       shift and go to state 64
    XOR_ASSIGN      shift and go to state 65
    MOD_ASSIGN      shift and go to state 66
    L_SHIFT_ASSIGN  shift and go to state 67
    R_SHIFT_ASSIGN  shift and go to state 68

    assignment                     shift and go to state 57

state 220

    (73) yes_dec_params -> TYPE expr COMMA .

    TYPE            reduce using rule 73 (yes_dec_params -> TYPE expr COMMA .)


state 221

    (75) yes_dec_params -> TYPE MULTIPLY COMMA .

    TYPE            reduce using rule 75 (yes_dec_params -> TYPE MULTIPLY COMMA .)


state 222

    (82) function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .

    IF              reduce using rule 82 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    WHILE           reduce using rule 82 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    FOR             reduce using rule 82 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    SEMICOLON       reduce using rule 82 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    RETURN          reduce using rule 82 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    HASH            reduce using rule 82 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    TYPE            reduce using rule 82 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    L_FLOWBRACE     reduce using rule 82 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    NOT             reduce using rule 82 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    PLUS            reduce using rule 82 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    MINUS           reduce using rule 82 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    PLUS_PLUS       reduce using rule 82 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    MINUS_MINUS     reduce using rule 82 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    L_PAREN         reduce using rule 82 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    STRING          reduce using rule 82 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    MULTIPLY        reduce using rule 82 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    BIT_AND         reduce using rule 82 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    ID              reduce using rule 82 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    CHAR            reduce using rule 82 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    INT_NUM         reduce using rule 82 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    FLOAT_NUM       reduce using rule 82 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    $end            reduce using rule 82 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    R_FLOWBRACE     reduce using rule 82 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    ELSE            reduce using rule 82 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    R_PAREN         reduce using rule 82 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)


state 223

    (83) function_2 -> SEMICOLON .

    IF              reduce using rule 83 (function_2 -> SEMICOLON .)
    WHILE           reduce using rule 83 (function_2 -> SEMICOLON .)
    FOR             reduce using rule 83 (function_2 -> SEMICOLON .)
    SEMICOLON       reduce using rule 83 (function_2 -> SEMICOLON .)
    RETURN          reduce using rule 83 (function_2 -> SEMICOLON .)
    HASH            reduce using rule 83 (function_2 -> SEMICOLON .)
    TYPE            reduce using rule 83 (function_2 -> SEMICOLON .)
    L_FLOWBRACE     reduce using rule 83 (function_2 -> SEMICOLON .)
    NOT             reduce using rule 83 (function_2 -> SEMICOLON .)
    PLUS            reduce using rule 83 (function_2 -> SEMICOLON .)
    MINUS           reduce using rule 83 (function_2 -> SEMICOLON .)
    PLUS_PLUS       reduce using rule 83 (function_2 -> SEMICOLON .)
    MINUS_MINUS     reduce using rule 83 (function_2 -> SEMICOLON .)
    L_PAREN         reduce using rule 83 (function_2 -> SEMICOLON .)
    STRING          reduce using rule 83 (function_2 -> SEMICOLON .)
    MULTIPLY        reduce using rule 83 (function_2 -> SEMICOLON .)
    BIT_AND         reduce using rule 83 (function_2 -> SEMICOLON .)
    ID              reduce using rule 83 (function_2 -> SEMICOLON .)
    CHAR            reduce using rule 83 (function_2 -> SEMICOLON .)
    INT_NUM         reduce using rule 83 (function_2 -> SEMICOLON .)
    FLOAT_NUM       reduce using rule 83 (function_2 -> SEMICOLON .)
    $end            reduce using rule 83 (function_2 -> SEMICOLON .)
    R_FLOWBRACE     reduce using rule 83 (function_2 -> SEMICOLON .)
    ELSE            reduce using rule 83 (function_2 -> SEMICOLON .)
    R_PAREN         reduce using rule 83 (function_2 -> SEMICOLON .)


state 224

    (84) function_2 -> block .

    IF              reduce using rule 84 (function_2 -> block .)
    WHILE           reduce using rule 84 (function_2 -> block .)
    FOR             reduce using rule 84 (function_2 -> block .)
    SEMICOLON       reduce using rule 84 (function_2 -> block .)
    RETURN          reduce using rule 84 (function_2 -> block .)
    HASH            reduce using rule 84 (function_2 -> block .)
    TYPE            reduce using rule 84 (function_2 -> block .)
    L_FLOWBRACE     reduce using rule 84 (function_2 -> block .)
    NOT             reduce using rule 84 (function_2 -> block .)
    PLUS            reduce using rule 84 (function_2 -> block .)
    MINUS           reduce using rule 84 (function_2 -> block .)
    PLUS_PLUS       reduce using rule 84 (function_2 -> block .)
    MINUS_MINUS     reduce using rule 84 (function_2 -> block .)
    L_PAREN         reduce using rule 84 (function_2 -> block .)
    STRING          reduce using rule 84 (function_2 -> block .)
    MULTIPLY        reduce using rule 84 (function_2 -> block .)
    BIT_AND         reduce using rule 84 (function_2 -> block .)
    ID              reduce using rule 84 (function_2 -> block .)
    CHAR            reduce using rule 84 (function_2 -> block .)
    INT_NUM         reduce using rule 84 (function_2 -> block .)
    FLOAT_NUM       reduce using rule 84 (function_2 -> block .)
    $end            reduce using rule 84 (function_2 -> block .)
    R_FLOWBRACE     reduce using rule 84 (function_2 -> block .)
    ELSE            reduce using rule 84 (function_2 -> block .)
    R_PAREN         reduce using rule 84 (function_2 -> block .)


state 225

    (70) yes_dec_params -> yes_dec_params TYPE expr . COMMA
    (76) end_dec_params -> TYPE expr .
    (85) expr -> expr . assignment exprOR
    (87) assignment -> . ASSIGN
    (88) assignment -> . PLUS_ASSIGN
    (89) assignment -> . MINUS_ASSIGN
    (90) assignment -> . MUL_ASSIGN
    (91) assignment -> . DIV_ASSIGN
    (92) assignment -> . AND_ASSIGN
    (93) assignment -> . OR_ASSIGN
    (94) assignment -> . XOR_ASSIGN
    (95) assignment -> . MOD_ASSIGN
    (96) assignment -> . L_SHIFT_ASSIGN
    (97) assignment -> . R_SHIFT_ASSIGN

    COMMA           shift and go to state 236
    R_PAREN         reduce using rule 76 (end_dec_params -> TYPE expr .)
    ASSIGN          shift and go to state 58
    PLUS_ASSIGN     shift and go to state 59
    MINUS_ASSIGN    shift and go to state 60
    MUL_ASSIGN      shift and go to state 61
    DIV_ASSIGN      shift and go to state 62
    AND_ASSIGN      shift and go to state 63
    OR_ASSIGN       shift and go to state 64
    XOR_ASSIGN      shift and go to state 65
    MOD_ASSIGN      shift and go to state 66
    L_SHIFT_ASSIGN  shift and go to state 67
    R_SHIFT_ASSIGN  shift and go to state 68

    assignment                     shift and go to state 57

state 226

    (71) yes_dec_params -> yes_dec_params TYPE COMMA .

    TYPE            reduce using rule 71 (yes_dec_params -> yes_dec_params TYPE COMMA .)


state 227

    (72) yes_dec_params -> yes_dec_params TYPE MULTIPLY . COMMA
    (78) end_dec_params -> TYPE MULTIPLY .
    (141) brace -> MULTIPLY . ID

    COMMA           shift and go to state 237
    R_PAREN         reduce using rule 78 (end_dec_params -> TYPE MULTIPLY .)
    ID              shift and go to state 83


state 228

    (37) declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .

    IF              reduce using rule 37 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    WHILE           reduce using rule 37 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    FOR             reduce using rule 37 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    SEMICOLON       reduce using rule 37 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    RETURN          reduce using rule 37 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    HASH            reduce using rule 37 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    TYPE            reduce using rule 37 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    L_FLOWBRACE     reduce using rule 37 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    NOT             reduce using rule 37 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    PLUS            reduce using rule 37 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    MINUS           reduce using rule 37 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    PLUS_PLUS       reduce using rule 37 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    MINUS_MINUS     reduce using rule 37 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    L_PAREN         reduce using rule 37 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    STRING          reduce using rule 37 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    MULTIPLY        reduce using rule 37 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    BIT_AND         reduce using rule 37 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    ID              reduce using rule 37 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    CHAR            reduce using rule 37 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    INT_NUM         reduce using rule 37 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    FLOAT_NUM       reduce using rule 37 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    $end            reduce using rule 37 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    R_FLOWBRACE     reduce using rule 37 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    ELSE            reduce using rule 37 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    R_PAREN         reduce using rule 37 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)


state 229

    (26) multi_declaration -> MULTIPLY ID ASSIGN expr COMMA .

    ID              reduce using rule 26 (multi_declaration -> MULTIPLY ID ASSIGN expr COMMA .)
    MULTIPLY        reduce using rule 26 (multi_declaration -> MULTIPLY ID ASSIGN expr COMMA .)


state 230

    (21) multi_declaration -> multi_declaration ID ASSIGN expr COMMA .

    ID              reduce using rule 21 (multi_declaration -> multi_declaration ID ASSIGN expr COMMA .)
    MULTIPLY        reduce using rule 21 (multi_declaration -> multi_declaration ID ASSIGN expr COMMA .)


state 231

    (29) stop -> ID ASSIGN expr SEMICOLON .

    IF              reduce using rule 29 (stop -> ID ASSIGN expr SEMICOLON .)
    WHILE           reduce using rule 29 (stop -> ID ASSIGN expr SEMICOLON .)
    FOR             reduce using rule 29 (stop -> ID ASSIGN expr SEMICOLON .)
    SEMICOLON       reduce using rule 29 (stop -> ID ASSIGN expr SEMICOLON .)
    RETURN          reduce using rule 29 (stop -> ID ASSIGN expr SEMICOLON .)
    HASH            reduce using rule 29 (stop -> ID ASSIGN expr SEMICOLON .)
    TYPE            reduce using rule 29 (stop -> ID ASSIGN expr SEMICOLON .)
    L_FLOWBRACE     reduce using rule 29 (stop -> ID ASSIGN expr SEMICOLON .)
    NOT             reduce using rule 29 (stop -> ID ASSIGN expr SEMICOLON .)
    PLUS            reduce using rule 29 (stop -> ID ASSIGN expr SEMICOLON .)
    MINUS           reduce using rule 29 (stop -> ID ASSIGN expr SEMICOLON .)
    PLUS_PLUS       reduce using rule 29 (stop -> ID ASSIGN expr SEMICOLON .)
    MINUS_MINUS     reduce using rule 29 (stop -> ID ASSIGN expr SEMICOLON .)
    L_PAREN         reduce using rule 29 (stop -> ID ASSIGN expr SEMICOLON .)
    STRING          reduce using rule 29 (stop -> ID ASSIGN expr SEMICOLON .)
    MULTIPLY        reduce using rule 29 (stop -> ID ASSIGN expr SEMICOLON .)
    BIT_AND         reduce using rule 29 (stop -> ID ASSIGN expr SEMICOLON .)
    ID              reduce using rule 29 (stop -> ID ASSIGN expr SEMICOLON .)
    CHAR            reduce using rule 29 (stop -> ID ASSIGN expr SEMICOLON .)
    INT_NUM         reduce using rule 29 (stop -> ID ASSIGN expr SEMICOLON .)
    FLOAT_NUM       reduce using rule 29 (stop -> ID ASSIGN expr SEMICOLON .)
    $end            reduce using rule 29 (stop -> ID ASSIGN expr SEMICOLON .)
    R_FLOWBRACE     reduce using rule 29 (stop -> ID ASSIGN expr SEMICOLON .)
    ELSE            reduce using rule 29 (stop -> ID ASSIGN expr SEMICOLON .)
    R_PAREN         reduce using rule 29 (stop -> ID ASSIGN expr SEMICOLON .)


state 232

    (22) multi_declaration -> multi_declaration MULTIPLY ID ASSIGN expr . COMMA
    (30) stop -> MULTIPLY ID ASSIGN expr . SEMICOLON
    (85) expr -> expr . assignment exprOR
    (87) assignment -> . ASSIGN
    (88) assignment -> . PLUS_ASSIGN
    (89) assignment -> . MINUS_ASSIGN
    (90) assignment -> . MUL_ASSIGN
    (91) assignment -> . DIV_ASSIGN
    (92) assignment -> . AND_ASSIGN
    (93) assignment -> . OR_ASSIGN
    (94) assignment -> . XOR_ASSIGN
    (95) assignment -> . MOD_ASSIGN
    (96) assignment -> . L_SHIFT_ASSIGN
    (97) assignment -> . R_SHIFT_ASSIGN

    COMMA           shift and go to state 238
    SEMICOLON       shift and go to state 239
    ASSIGN          shift and go to state 58
    PLUS_ASSIGN     shift and go to state 59
    MINUS_ASSIGN    shift and go to state 60
    MUL_ASSIGN      shift and go to state 61
    DIV_ASSIGN      shift and go to state 62
    AND_ASSIGN      shift and go to state 63
    OR_ASSIGN       shift and go to state 64
    XOR_ASSIGN      shift and go to state 65
    MOD_ASSIGN      shift and go to state 66
    L_SHIFT_ASSIGN  shift and go to state 67
    R_SHIFT_ASSIGN  shift and go to state 68

    assignment                     shift and go to state 57

state 233

    (43) init_list -> L_FLOWBRACE init_list R_FLOWBRACE . COMMA init_list
    (46) init_list -> L_FLOWBRACE init_list R_FLOWBRACE .

    COMMA           shift and go to state 240
    SEMICOLON       reduce using rule 46 (init_list -> L_FLOWBRACE init_list R_FLOWBRACE .)
    R_FLOWBRACE     reduce using rule 46 (init_list -> L_FLOWBRACE init_list R_FLOWBRACE .)


state 234

    (44) init_list -> L_FLOWBRACE init R_FLOWBRACE . COMMA init_list
    (45) init_list -> L_FLOWBRACE init R_FLOWBRACE .

    COMMA           shift and go to state 241
    SEMICOLON       reduce using rule 45 (init_list -> L_FLOWBRACE init R_FLOWBRACE .)
    R_FLOWBRACE     reduce using rule 45 (init_list -> L_FLOWBRACE init R_FLOWBRACE .)


state 235

    (41) init -> expr COMMA . init
    (41) init -> . expr COMMA init
    (42) init -> . expr
    (85) expr -> . expr assignment exprOR
    (86) expr -> . exprOR
    (98) exprOR -> . exprOR OR exprAND
    (99) exprOR -> . exprAND
    (100) exprAND -> . exprAND AND exprBITOR
    (101) exprAND -> . exprBITOR
    (102) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (103) exprBITOR -> . exprBITXOR
    (104) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (105) exprBITXOR -> . exprBITAND
    (106) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (107) exprBITAND -> . exprEQ
    (108) exprEQ -> . exprEQ EQ exprRELOP
    (109) exprEQ -> . exprEQ NE exprRELOP
    (110) exprEQ -> . exprRELOP
    (111) exprRELOP -> . exprRELOP relop exprSHIFT
    (112) exprRELOP -> . exprSHIFT
    (117) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (118) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (119) exprSHIFT -> . exprOP
    (120) exprOP -> . exprOP PLUS term
    (121) exprOP -> . exprOP MINUS term
    (122) exprOP -> . term
    (123) term -> . term MULTIPLY factor
    (124) term -> . term DIVIDE factor
    (125) term -> . term MOD factor
    (126) term -> . factor
    (127) factor -> . NOT factor
    (128) factor -> . PLUS factor
    (129) factor -> . MINUS factor
    (130) factor -> . PLUS_PLUS factor
    (131) factor -> . MINUS_MINUS factor
    (132) factor -> . cast brace
    (133) factor -> . brace
    (134) cast -> . L_PAREN TYPE R_PAREN
    (135) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (136) brace -> . L_PAREN expr R_PAREN
    (137) brace -> . brace PLUS_PLUS
    (138) brace -> . brace MINUS_MINUS
    (139) brace -> . NUM
    (140) brace -> . STRING
    (141) brace -> . MULTIPLY ID
    (142) brace -> . BIT_AND ID
    (143) brace -> . ID
    (144) brace -> . CHAR
    (145) brace -> . function_call
    (146) brace -> . ID narrayindex
    (147) NUM -> . INT_NUM
    (148) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    expr                           shift and go to state 219
    init                           shift and go to state 242
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 236

    (70) yes_dec_params -> yes_dec_params TYPE expr COMMA .

    TYPE            reduce using rule 70 (yes_dec_params -> yes_dec_params TYPE expr COMMA .)


state 237

    (72) yes_dec_params -> yes_dec_params TYPE MULTIPLY COMMA .

    TYPE            reduce using rule 72 (yes_dec_params -> yes_dec_params TYPE MULTIPLY COMMA .)


state 238

    (22) multi_declaration -> multi_declaration MULTIPLY ID ASSIGN expr COMMA .

    ID              reduce using rule 22 (multi_declaration -> multi_declaration MULTIPLY ID ASSIGN expr COMMA .)
    MULTIPLY        reduce using rule 22 (multi_declaration -> multi_declaration MULTIPLY ID ASSIGN expr COMMA .)


state 239

    (30) stop -> MULTIPLY ID ASSIGN expr SEMICOLON .

    IF              reduce using rule 30 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    WHILE           reduce using rule 30 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    FOR             reduce using rule 30 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    SEMICOLON       reduce using rule 30 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    RETURN          reduce using rule 30 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    HASH            reduce using rule 30 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    TYPE            reduce using rule 30 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    L_FLOWBRACE     reduce using rule 30 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    NOT             reduce using rule 30 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    PLUS            reduce using rule 30 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    MINUS           reduce using rule 30 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    PLUS_PLUS       reduce using rule 30 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    MINUS_MINUS     reduce using rule 30 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    L_PAREN         reduce using rule 30 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    STRING          reduce using rule 30 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    MULTIPLY        reduce using rule 30 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    BIT_AND         reduce using rule 30 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    ID              reduce using rule 30 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    CHAR            reduce using rule 30 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    INT_NUM         reduce using rule 30 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    FLOAT_NUM       reduce using rule 30 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    $end            reduce using rule 30 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    R_FLOWBRACE     reduce using rule 30 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    ELSE            reduce using rule 30 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    R_PAREN         reduce using rule 30 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)


state 240

    (43) init_list -> L_FLOWBRACE init_list R_FLOWBRACE COMMA . init_list
    (43) init_list -> . L_FLOWBRACE init_list R_FLOWBRACE COMMA init_list
    (44) init_list -> . L_FLOWBRACE init R_FLOWBRACE COMMA init_list
    (45) init_list -> . L_FLOWBRACE init R_FLOWBRACE
    (46) init_list -> . L_FLOWBRACE init_list R_FLOWBRACE

    L_FLOWBRACE     shift and go to state 201

    init_list                      shift and go to state 243

state 241

    (44) init_list -> L_FLOWBRACE init R_FLOWBRACE COMMA . init_list
    (43) init_list -> . L_FLOWBRACE init_list R_FLOWBRACE COMMA init_list
    (44) init_list -> . L_FLOWBRACE init R_FLOWBRACE COMMA init_list
    (45) init_list -> . L_FLOWBRACE init R_FLOWBRACE
    (46) init_list -> . L_FLOWBRACE init_list R_FLOWBRACE

    L_FLOWBRACE     shift and go to state 201

    init_list                      shift and go to state 244

state 242

    (41) init -> expr COMMA init .

    R_FLOWBRACE     reduce using rule 41 (init -> expr COMMA init .)


state 243

    (43) init_list -> L_FLOWBRACE init_list R_FLOWBRACE COMMA init_list .

    SEMICOLON       reduce using rule 43 (init_list -> L_FLOWBRACE init_list R_FLOWBRACE COMMA init_list .)
    R_FLOWBRACE     reduce using rule 43 (init_list -> L_FLOWBRACE init_list R_FLOWBRACE COMMA init_list .)


state 244

    (44) init_list -> L_FLOWBRACE init R_FLOWBRACE COMMA init_list .

    SEMICOLON       reduce using rule 44 (init_list -> L_FLOWBRACE init R_FLOWBRACE COMMA init_list .)
    R_FLOWBRACE     reduce using rule 44 (init_list -> L_FLOWBRACE init R_FLOWBRACE COMMA init_list .)

