Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> start
Rule 1     start -> multiple_statements
Rule 2     multiple_statements -> multiple_statements statement
Rule 3     multiple_statements -> statement
Rule 4     statement -> open
Rule 5     statement -> closed
Rule 6     else -> ELSE
Rule 7     open -> IF condition statement
Rule 8     open -> IF condition closed else open
Rule 9     open -> WHILE condition open
Rule 10    open -> for for_condition open
Rule 11    for -> FOR
Rule 12    closed -> simple
Rule 13    closed -> block
Rule 14    closed -> IF condition closed else closed
Rule 15    closed -> WHILE condition closed
Rule 16    closed -> for for_condition closed
Rule 17    condition -> L_PAREN expr R_PAREN
Rule 18    for_condition -> L_PAREN simple simple expr R_PAREN
Rule 19    for_condition -> L_PAREN simple simple R_PAREN
Rule 20    multi_declaration -> multi_declaration ID COMMA
Rule 21    multi_declaration -> multi_declaration MULTIPLY ID COMMA
Rule 22    multi_declaration -> multi_declaration ID ASSIGN expr COMMA
Rule 23    multi_declaration -> multi_declaration MULTIPLY ID ASSIGN expr COMMA
Rule 24    multi_declaration -> ID COMMA
Rule 25    multi_declaration -> ID ASSIGN expr COMMA
Rule 26    multi_declaration -> MULTIPLY ID COMMA
Rule 27    multi_declaration -> MULTIPLY ID ASSIGN expr COMMA
Rule 28    stop -> ID SEMICOLON
Rule 29    stop -> MULTIPLY ID SEMICOLON
Rule 30    stop -> ID ASSIGN expr SEMICOLON
Rule 31    stop -> MULTIPLY ID ASSIGN expr SEMICOLON
Rule 32    arrayindex -> L_SQBRACE index R_SQBRACE
Rule 33    narrayindex -> narrayindex arrayindex
Rule 34    narrayindex -> arrayindex
Rule 35    declaration -> TYPE ID SEMICOLON
Rule 36    declaration -> TYPE MULTIPLY ID SEMICOLON
Rule 37    declaration -> TYPE ID ASSIGN expr SEMICOLON
Rule 38    declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON
Rule 39    declaration -> TYPE multi_declaration stop
Rule 40    declaration -> TYPE ID narrayindex SEMICOLON
Rule 41    declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON
Rule 42    init -> expr COMMA init
Rule 43    init -> expr
Rule 44    init_list -> L_FLOWBRACE init_list R_FLOWBRACE COMMA init_list
Rule 45    init_list -> L_FLOWBRACE init R_FLOWBRACE COMMA init_list
Rule 46    init_list -> L_FLOWBRACE init R_FLOWBRACE
Rule 47    init_list -> L_FLOWBRACE init_list R_FLOWBRACE
Rule 48    index -> expr
Rule 49    index -> empty
Rule 50    block -> left_flower multiple_statements right_flower
Rule 51    block -> left_flower right_flower
Rule 52    left_flower -> L_FLOWBRACE
Rule 53    right_flower -> R_FLOWBRACE
Rule 54    simple -> expr SEMICOLON
Rule 55    simple -> header
Rule 56    simple -> declaration
Rule 57    simple -> SEMICOLON
Rule 58    simple -> function
Rule 59    simple -> RETURN expr SEMICOLON
Rule 60    simple -> RETURN SEMICOLON
Rule 61    header -> HASH INCLUDE STRING
Rule 62    header -> HASH INCLUDE HEADER_FILE
Rule 63    empty -> <empty>
Rule 64    function_call -> ID L_PAREN call_params R_PAREN
Rule 65    call_params -> empty
Rule 66    call_params -> yes_call_params end_call_params
Rule 67    call_params -> end_call_params
Rule 68    yes_call_params -> yes_call_params expr COMMA
Rule 69    yes_call_params -> expr COMMA
Rule 70    end_call_params -> expr
Rule 71    yes_dec_params -> yes_dec_params TYPE expr COMMA
Rule 72    yes_dec_params -> yes_dec_params TYPE COMMA
Rule 73    yes_dec_params -> yes_dec_params TYPE MULTIPLY COMMA
Rule 74    yes_dec_params -> TYPE expr COMMA
Rule 75    yes_dec_params -> TYPE COMMA
Rule 76    yes_dec_params -> TYPE MULTIPLY COMMA
Rule 77    end_dec_params -> TYPE expr
Rule 78    end_dec_params -> TYPE
Rule 79    end_dec_params -> TYPE MULTIPLY
Rule 80    dec_params -> empty
Rule 81    dec_params -> yes_dec_params end_dec_params
Rule 82    dec_params -> end_dec_params
Rule 83    function -> TYPE ID L_PAREN dec_params R_PAREN function_2
Rule 84    function_2 -> SEMICOLON
Rule 85    function_2 -> block
Rule 86    expr -> expr assignment exprOR
Rule 87    expr -> exprOR
Rule 88    assignment -> ASSIGN
Rule 89    assignment -> PLUS_ASSIGN
Rule 90    assignment -> MINUS_ASSIGN
Rule 91    assignment -> MUL_ASSIGN
Rule 92    assignment -> DIV_ASSIGN
Rule 93    assignment -> AND_ASSIGN
Rule 94    assignment -> OR_ASSIGN
Rule 95    assignment -> XOR_ASSIGN
Rule 96    assignment -> MOD_ASSIGN
Rule 97    assignment -> L_SHIFT_ASSIGN
Rule 98    assignment -> R_SHIFT_ASSIGN
Rule 99    exprOR -> exprOR OR exprAND
Rule 100   exprOR -> exprAND
Rule 101   exprAND -> exprAND AND exprBITOR
Rule 102   exprAND -> exprBITOR
Rule 103   exprBITOR -> exprBITOR BIT_OR exprBITXOR
Rule 104   exprBITOR -> exprBITXOR
Rule 105   exprBITXOR -> exprBITXOR BIT_XOR exprBITAND
Rule 106   exprBITXOR -> exprBITAND
Rule 107   exprBITAND -> exprBITAND BIT_AND exprEQ
Rule 108   exprBITAND -> exprEQ
Rule 109   exprEQ -> exprEQ EQ exprRELOP
Rule 110   exprEQ -> exprEQ NE exprRELOP
Rule 111   exprEQ -> exprRELOP
Rule 112   exprRELOP -> exprRELOP relop exprSHIFT
Rule 113   exprRELOP -> exprSHIFT
Rule 114   relop -> LE
Rule 115   relop -> LT
Rule 116   relop -> GE
Rule 117   relop -> GT
Rule 118   exprSHIFT -> exprSHIFT L_SHIFT exprOP
Rule 119   exprSHIFT -> exprSHIFT R_SHIFT exprOP
Rule 120   exprSHIFT -> exprOP
Rule 121   exprOP -> exprOP PLUS term
Rule 122   exprOP -> exprOP MINUS term
Rule 123   exprOP -> term
Rule 124   term -> term MULTIPLY factor
Rule 125   term -> term DIVIDE factor
Rule 126   term -> term MOD factor
Rule 127   term -> factor
Rule 128   factor -> NOT factor
Rule 129   factor -> PLUS factor
Rule 130   factor -> MINUS factor
Rule 131   factor -> PLUS_PLUS factor
Rule 132   factor -> MINUS_MINUS factor
Rule 133   factor -> cast brace
Rule 134   factor -> brace
Rule 135   cast -> L_PAREN TYPE R_PAREN
Rule 136   cast -> L_PAREN TYPE MULTIPLY R_PAREN
Rule 137   brace -> L_PAREN expr R_PAREN
Rule 138   brace -> brace PLUS_PLUS
Rule 139   brace -> brace MINUS_MINUS
Rule 140   brace -> NUM
Rule 141   brace -> STRING
Rule 142   brace -> MULTIPLY ID
Rule 143   brace -> BIT_AND ID
Rule 144   brace -> ID
Rule 145   brace -> CHAR
Rule 146   brace -> function_call
Rule 147   brace -> ID narrayindex
Rule 148   NUM -> INT_NUM
Rule 149   NUM -> FLOAT_NUM

Terminals, with rules where they appear

AND                  : 101
AND_ASSIGN           : 93
ASSIGN               : 22 23 25 27 30 31 37 38 41 88
BIT_AND              : 107 143
BIT_OR               : 103
BIT_XOR              : 105
CHAR                 : 145
COMMA                : 20 21 22 23 24 25 26 27 42 44 45 68 69 71 72 73 74 75 76
DIVIDE               : 125
DIV_ASSIGN           : 92
ELSE                 : 6
EQ                   : 109
FLOAT_NUM            : 149
FOR                  : 11
GE                   : 116
GT                   : 117
HASH                 : 61 62
HEADER_FILE          : 62
ID                   : 20 21 22 23 24 25 26 27 28 29 30 31 35 36 37 38 40 41 64 83 142 143 144 147
IF                   : 7 8 14
INCLUDE              : 61 62
INT_NUM              : 148
LE                   : 114
LT                   : 115
L_FLOWBRACE          : 44 45 46 47 52
L_PAREN              : 17 18 19 64 83 135 136 137
L_SHIFT              : 118
L_SHIFT_ASSIGN       : 97
L_SQBRACE            : 32
MINUS                : 122 130
MINUS_ASSIGN         : 90
MINUS_MINUS          : 132 139
MOD                  : 126
MOD_ASSIGN           : 96
MULTIPLY             : 21 23 26 27 29 31 36 38 73 76 79 124 136 142
MUL_ASSIGN           : 91
NE                   : 110
NOT                  : 128
OR                   : 99
OR_ASSIGN            : 94
PLUS                 : 121 129
PLUS_ASSIGN          : 89
PLUS_PLUS            : 131 138
RETURN               : 59 60
R_FLOWBRACE          : 44 45 46 47 53
R_PAREN              : 17 18 19 64 83 135 136 137
R_SHIFT              : 119
R_SHIFT_ASSIGN       : 98
R_SQBRACE            : 32
SEMICOLON            : 28 29 30 31 35 36 37 38 40 41 54 57 59 60 84
STRING               : 61 141
TYPE                 : 35 36 37 38 39 40 41 71 72 73 74 75 76 77 78 79 83 135 136
WHILE                : 9 15
XOR_ASSIGN           : 95
error                : 

Nonterminals, with rules where they appear

NUM                  : 140
arrayindex           : 33 34
assignment           : 86
block                : 13 85
brace                : 133 134 138 139
call_params          : 64
cast                 : 133
closed               : 5 8 14 14 15 16
condition            : 7 8 9 14 15
dec_params           : 83
declaration          : 56
else                 : 8 14
empty                : 49 65 80
end_call_params      : 66 67
end_dec_params       : 81 82
expr                 : 17 18 22 23 25 27 30 31 37 38 42 43 48 54 59 68 69 70 71 74 77 86 137
exprAND              : 99 100 101
exprBITAND           : 105 106 107
exprBITOR            : 101 102 103
exprBITXOR           : 103 104 105
exprEQ               : 107 108 109 110
exprOP               : 118 119 120 121 122
exprOR               : 86 87 99
exprRELOP            : 109 110 111 112
exprSHIFT            : 112 113 118 119
factor               : 124 125 126 127 128 129 130 131 132
for                  : 10 16
for_condition        : 10 16
function             : 58
function_2           : 83
function_call        : 146
header               : 55
index                : 32
init                 : 42 45 46
init_list            : 41 44 44 45 47
left_flower          : 50 51
multi_declaration    : 20 21 22 23 39
multiple_statements  : 1 2 50
narrayindex          : 33 40 41 147
open                 : 4 8 9 10
relop                : 112
right_flower         : 50 51
simple               : 12 18 18 19 19
start                : 0
statement            : 2 3 7
stop                 : 39
term                 : 121 122 123 124 125 126
yes_call_params      : 66 68
yes_dec_params       : 71 72 73 81

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . multiple_statements
    (2) multiple_statements -> . multiple_statements statement
    (3) multiple_statements -> . statement
    (4) statement -> . open
    (5) statement -> . closed
    (7) open -> . IF condition statement
    (8) open -> . IF condition closed else open
    (9) open -> . WHILE condition open
    (10) open -> . for for_condition open
    (12) closed -> . simple
    (13) closed -> . block
    (14) closed -> . IF condition closed else closed
    (15) closed -> . WHILE condition closed
    (16) closed -> . for for_condition closed
    (11) for -> . FOR
    (54) simple -> . expr SEMICOLON
    (55) simple -> . header
    (56) simple -> . declaration
    (57) simple -> . SEMICOLON
    (58) simple -> . function
    (59) simple -> . RETURN expr SEMICOLON
    (60) simple -> . RETURN SEMICOLON
    (50) block -> . left_flower multiple_statements right_flower
    (51) block -> . left_flower right_flower
    (86) expr -> . expr assignment exprOR
    (87) expr -> . exprOR
    (61) header -> . HASH INCLUDE STRING
    (62) header -> . HASH INCLUDE HEADER_FILE
    (35) declaration -> . TYPE ID SEMICOLON
    (36) declaration -> . TYPE MULTIPLY ID SEMICOLON
    (37) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (38) declaration -> . TYPE MULTIPLY ID ASSIGN expr SEMICOLON
    (39) declaration -> . TYPE multi_declaration stop
    (40) declaration -> . TYPE ID narrayindex SEMICOLON
    (41) declaration -> . TYPE ID narrayindex ASSIGN init_list SEMICOLON
    (83) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (52) left_flower -> . L_FLOWBRACE
    (99) exprOR -> . exprOR OR exprAND
    (100) exprOR -> . exprAND
    (101) exprAND -> . exprAND AND exprBITOR
    (102) exprAND -> . exprBITOR
    (103) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (104) exprBITOR -> . exprBITXOR
    (105) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (106) exprBITXOR -> . exprBITAND
    (107) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (108) exprBITAND -> . exprEQ
    (109) exprEQ -> . exprEQ EQ exprRELOP
    (110) exprEQ -> . exprEQ NE exprRELOP
    (111) exprEQ -> . exprRELOP
    (112) exprRELOP -> . exprRELOP relop exprSHIFT
    (113) exprRELOP -> . exprSHIFT
    (118) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (119) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (120) exprSHIFT -> . exprOP
    (121) exprOP -> . exprOP PLUS term
    (122) exprOP -> . exprOP MINUS term
    (123) exprOP -> . term
    (124) term -> . term MULTIPLY factor
    (125) term -> . term DIVIDE factor
    (126) term -> . term MOD factor
    (127) term -> . factor
    (128) factor -> . NOT factor
    (129) factor -> . PLUS factor
    (130) factor -> . MINUS factor
    (131) factor -> . PLUS_PLUS factor
    (132) factor -> . MINUS_MINUS factor
    (133) factor -> . cast brace
    (134) factor -> . brace
    (135) cast -> . L_PAREN TYPE R_PAREN
    (136) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (137) brace -> . L_PAREN expr R_PAREN
    (138) brace -> . brace PLUS_PLUS
    (139) brace -> . brace MINUS_MINUS
    (140) brace -> . NUM
    (141) brace -> . STRING
    (142) brace -> . MULTIPLY ID
    (143) brace -> . BIT_AND ID
    (144) brace -> . ID
    (145) brace -> . CHAR
    (146) brace -> . function_call
    (147) brace -> . ID narrayindex
    (148) NUM -> . INT_NUM
    (149) NUM -> . FLOAT_NUM
    (64) function_call -> . ID L_PAREN call_params R_PAREN

    IF              shift and go to state 6
    WHILE           shift and go to state 7
    FOR             shift and go to state 11
    SEMICOLON       shift and go to state 13
    RETURN          shift and go to state 17
    HASH            shift and go to state 20
    TYPE            shift and go to state 22
    L_FLOWBRACE     shift and go to state 26
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    start                          shift and go to state 1
    multiple_statements            shift and go to state 2
    statement                      shift and go to state 3
    open                           shift and go to state 4
    closed                         shift and go to state 5
    for                            shift and go to state 8
    simple                         shift and go to state 9
    block                          shift and go to state 10
    expr                           shift and go to state 12
    header                         shift and go to state 14
    declaration                    shift and go to state 15
    function                       shift and go to state 16
    left_flower                    shift and go to state 18
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 1

    (0) S' -> start .



state 2

    (1) start -> multiple_statements .
    (2) multiple_statements -> multiple_statements . statement
    (4) statement -> . open
    (5) statement -> . closed
    (7) open -> . IF condition statement
    (8) open -> . IF condition closed else open
    (9) open -> . WHILE condition open
    (10) open -> . for for_condition open
    (12) closed -> . simple
    (13) closed -> . block
    (14) closed -> . IF condition closed else closed
    (15) closed -> . WHILE condition closed
    (16) closed -> . for for_condition closed
    (11) for -> . FOR
    (54) simple -> . expr SEMICOLON
    (55) simple -> . header
    (56) simple -> . declaration
    (57) simple -> . SEMICOLON
    (58) simple -> . function
    (59) simple -> . RETURN expr SEMICOLON
    (60) simple -> . RETURN SEMICOLON
    (50) block -> . left_flower multiple_statements right_flower
    (51) block -> . left_flower right_flower
    (86) expr -> . expr assignment exprOR
    (87) expr -> . exprOR
    (61) header -> . HASH INCLUDE STRING
    (62) header -> . HASH INCLUDE HEADER_FILE
    (35) declaration -> . TYPE ID SEMICOLON
    (36) declaration -> . TYPE MULTIPLY ID SEMICOLON
    (37) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (38) declaration -> . TYPE MULTIPLY ID ASSIGN expr SEMICOLON
    (39) declaration -> . TYPE multi_declaration stop
    (40) declaration -> . TYPE ID narrayindex SEMICOLON
    (41) declaration -> . TYPE ID narrayindex ASSIGN init_list SEMICOLON
    (83) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (52) left_flower -> . L_FLOWBRACE
    (99) exprOR -> . exprOR OR exprAND
    (100) exprOR -> . exprAND
    (101) exprAND -> . exprAND AND exprBITOR
    (102) exprAND -> . exprBITOR
    (103) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (104) exprBITOR -> . exprBITXOR
    (105) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (106) exprBITXOR -> . exprBITAND
    (107) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (108) exprBITAND -> . exprEQ
    (109) exprEQ -> . exprEQ EQ exprRELOP
    (110) exprEQ -> . exprEQ NE exprRELOP
    (111) exprEQ -> . exprRELOP
    (112) exprRELOP -> . exprRELOP relop exprSHIFT
    (113) exprRELOP -> . exprSHIFT
    (118) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (119) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (120) exprSHIFT -> . exprOP
    (121) exprOP -> . exprOP PLUS term
    (122) exprOP -> . exprOP MINUS term
    (123) exprOP -> . term
    (124) term -> . term MULTIPLY factor
    (125) term -> . term DIVIDE factor
    (126) term -> . term MOD factor
    (127) term -> . factor
    (128) factor -> . NOT factor
    (129) factor -> . PLUS factor
    (130) factor -> . MINUS factor
    (131) factor -> . PLUS_PLUS factor
    (132) factor -> . MINUS_MINUS factor
    (133) factor -> . cast brace
    (134) factor -> . brace
    (135) cast -> . L_PAREN TYPE R_PAREN
    (136) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (137) brace -> . L_PAREN expr R_PAREN
    (138) brace -> . brace PLUS_PLUS
    (139) brace -> . brace MINUS_MINUS
    (140) brace -> . NUM
    (141) brace -> . STRING
    (142) brace -> . MULTIPLY ID
    (143) brace -> . BIT_AND ID
    (144) brace -> . ID
    (145) brace -> . CHAR
    (146) brace -> . function_call
    (147) brace -> . ID narrayindex
    (148) NUM -> . INT_NUM
    (149) NUM -> . FLOAT_NUM
    (64) function_call -> . ID L_PAREN call_params R_PAREN

    $end            reduce using rule 1 (start -> multiple_statements .)
    IF              shift and go to state 6
    WHILE           shift and go to state 7
    FOR             shift and go to state 11
    SEMICOLON       shift and go to state 13
    RETURN          shift and go to state 17
    HASH            shift and go to state 20
    TYPE            shift and go to state 22
    L_FLOWBRACE     shift and go to state 26
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    statement                      shift and go to state 50
    open                           shift and go to state 4
    closed                         shift and go to state 5
    for                            shift and go to state 8
    simple                         shift and go to state 9
    block                          shift and go to state 10
    expr                           shift and go to state 12
    header                         shift and go to state 14
    declaration                    shift and go to state 15
    function                       shift and go to state 16
    left_flower                    shift and go to state 18
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 3

    (3) multiple_statements -> statement .

    IF              reduce using rule 3 (multiple_statements -> statement .)
    WHILE           reduce using rule 3 (multiple_statements -> statement .)
    FOR             reduce using rule 3 (multiple_statements -> statement .)
    SEMICOLON       reduce using rule 3 (multiple_statements -> statement .)
    RETURN          reduce using rule 3 (multiple_statements -> statement .)
    HASH            reduce using rule 3 (multiple_statements -> statement .)
    TYPE            reduce using rule 3 (multiple_statements -> statement .)
    L_FLOWBRACE     reduce using rule 3 (multiple_statements -> statement .)
    NOT             reduce using rule 3 (multiple_statements -> statement .)
    PLUS            reduce using rule 3 (multiple_statements -> statement .)
    MINUS           reduce using rule 3 (multiple_statements -> statement .)
    PLUS_PLUS       reduce using rule 3 (multiple_statements -> statement .)
    MINUS_MINUS     reduce using rule 3 (multiple_statements -> statement .)
    L_PAREN         reduce using rule 3 (multiple_statements -> statement .)
    STRING          reduce using rule 3 (multiple_statements -> statement .)
    MULTIPLY        reduce using rule 3 (multiple_statements -> statement .)
    BIT_AND         reduce using rule 3 (multiple_statements -> statement .)
    ID              reduce using rule 3 (multiple_statements -> statement .)
    CHAR            reduce using rule 3 (multiple_statements -> statement .)
    INT_NUM         reduce using rule 3 (multiple_statements -> statement .)
    FLOAT_NUM       reduce using rule 3 (multiple_statements -> statement .)
    $end            reduce using rule 3 (multiple_statements -> statement .)
    R_FLOWBRACE     reduce using rule 3 (multiple_statements -> statement .)


state 4

    (4) statement -> open .

    IF              reduce using rule 4 (statement -> open .)
    WHILE           reduce using rule 4 (statement -> open .)
    FOR             reduce using rule 4 (statement -> open .)
    SEMICOLON       reduce using rule 4 (statement -> open .)
    RETURN          reduce using rule 4 (statement -> open .)
    HASH            reduce using rule 4 (statement -> open .)
    TYPE            reduce using rule 4 (statement -> open .)
    L_FLOWBRACE     reduce using rule 4 (statement -> open .)
    NOT             reduce using rule 4 (statement -> open .)
    PLUS            reduce using rule 4 (statement -> open .)
    MINUS           reduce using rule 4 (statement -> open .)
    PLUS_PLUS       reduce using rule 4 (statement -> open .)
    MINUS_MINUS     reduce using rule 4 (statement -> open .)
    L_PAREN         reduce using rule 4 (statement -> open .)
    STRING          reduce using rule 4 (statement -> open .)
    MULTIPLY        reduce using rule 4 (statement -> open .)
    BIT_AND         reduce using rule 4 (statement -> open .)
    ID              reduce using rule 4 (statement -> open .)
    CHAR            reduce using rule 4 (statement -> open .)
    INT_NUM         reduce using rule 4 (statement -> open .)
    FLOAT_NUM       reduce using rule 4 (statement -> open .)
    $end            reduce using rule 4 (statement -> open .)
    R_FLOWBRACE     reduce using rule 4 (statement -> open .)


state 5

    (5) statement -> closed .

    IF              reduce using rule 5 (statement -> closed .)
    WHILE           reduce using rule 5 (statement -> closed .)
    FOR             reduce using rule 5 (statement -> closed .)
    SEMICOLON       reduce using rule 5 (statement -> closed .)
    RETURN          reduce using rule 5 (statement -> closed .)
    HASH            reduce using rule 5 (statement -> closed .)
    TYPE            reduce using rule 5 (statement -> closed .)
    L_FLOWBRACE     reduce using rule 5 (statement -> closed .)
    NOT             reduce using rule 5 (statement -> closed .)
    PLUS            reduce using rule 5 (statement -> closed .)
    MINUS           reduce using rule 5 (statement -> closed .)
    PLUS_PLUS       reduce using rule 5 (statement -> closed .)
    MINUS_MINUS     reduce using rule 5 (statement -> closed .)
    L_PAREN         reduce using rule 5 (statement -> closed .)
    STRING          reduce using rule 5 (statement -> closed .)
    MULTIPLY        reduce using rule 5 (statement -> closed .)
    BIT_AND         reduce using rule 5 (statement -> closed .)
    ID              reduce using rule 5 (statement -> closed .)
    CHAR            reduce using rule 5 (statement -> closed .)
    INT_NUM         reduce using rule 5 (statement -> closed .)
    FLOAT_NUM       reduce using rule 5 (statement -> closed .)
    $end            reduce using rule 5 (statement -> closed .)
    R_FLOWBRACE     reduce using rule 5 (statement -> closed .)


state 6

    (7) open -> IF . condition statement
    (8) open -> IF . condition closed else open
    (14) closed -> IF . condition closed else closed
    (17) condition -> . L_PAREN expr R_PAREN

    L_PAREN         shift and go to state 52

    condition                      shift and go to state 51

state 7

    (9) open -> WHILE . condition open
    (15) closed -> WHILE . condition closed
    (17) condition -> . L_PAREN expr R_PAREN

    L_PAREN         shift and go to state 52

    condition                      shift and go to state 53

state 8

    (10) open -> for . for_condition open
    (16) closed -> for . for_condition closed
    (18) for_condition -> . L_PAREN simple simple expr R_PAREN
    (19) for_condition -> . L_PAREN simple simple R_PAREN

    L_PAREN         shift and go to state 55

    for_condition                  shift and go to state 54

state 9

    (12) closed -> simple .

    IF              reduce using rule 12 (closed -> simple .)
    WHILE           reduce using rule 12 (closed -> simple .)
    FOR             reduce using rule 12 (closed -> simple .)
    SEMICOLON       reduce using rule 12 (closed -> simple .)
    RETURN          reduce using rule 12 (closed -> simple .)
    HASH            reduce using rule 12 (closed -> simple .)
    TYPE            reduce using rule 12 (closed -> simple .)
    L_FLOWBRACE     reduce using rule 12 (closed -> simple .)
    NOT             reduce using rule 12 (closed -> simple .)
    PLUS            reduce using rule 12 (closed -> simple .)
    MINUS           reduce using rule 12 (closed -> simple .)
    PLUS_PLUS       reduce using rule 12 (closed -> simple .)
    MINUS_MINUS     reduce using rule 12 (closed -> simple .)
    L_PAREN         reduce using rule 12 (closed -> simple .)
    STRING          reduce using rule 12 (closed -> simple .)
    MULTIPLY        reduce using rule 12 (closed -> simple .)
    BIT_AND         reduce using rule 12 (closed -> simple .)
    ID              reduce using rule 12 (closed -> simple .)
    CHAR            reduce using rule 12 (closed -> simple .)
    INT_NUM         reduce using rule 12 (closed -> simple .)
    FLOAT_NUM       reduce using rule 12 (closed -> simple .)
    $end            reduce using rule 12 (closed -> simple .)
    R_FLOWBRACE     reduce using rule 12 (closed -> simple .)
    ELSE            reduce using rule 12 (closed -> simple .)


state 10

    (13) closed -> block .

    IF              reduce using rule 13 (closed -> block .)
    WHILE           reduce using rule 13 (closed -> block .)
    FOR             reduce using rule 13 (closed -> block .)
    SEMICOLON       reduce using rule 13 (closed -> block .)
    RETURN          reduce using rule 13 (closed -> block .)
    HASH            reduce using rule 13 (closed -> block .)
    TYPE            reduce using rule 13 (closed -> block .)
    L_FLOWBRACE     reduce using rule 13 (closed -> block .)
    NOT             reduce using rule 13 (closed -> block .)
    PLUS            reduce using rule 13 (closed -> block .)
    MINUS           reduce using rule 13 (closed -> block .)
    PLUS_PLUS       reduce using rule 13 (closed -> block .)
    MINUS_MINUS     reduce using rule 13 (closed -> block .)
    L_PAREN         reduce using rule 13 (closed -> block .)
    STRING          reduce using rule 13 (closed -> block .)
    MULTIPLY        reduce using rule 13 (closed -> block .)
    BIT_AND         reduce using rule 13 (closed -> block .)
    ID              reduce using rule 13 (closed -> block .)
    CHAR            reduce using rule 13 (closed -> block .)
    INT_NUM         reduce using rule 13 (closed -> block .)
    FLOAT_NUM       reduce using rule 13 (closed -> block .)
    $end            reduce using rule 13 (closed -> block .)
    R_FLOWBRACE     reduce using rule 13 (closed -> block .)
    ELSE            reduce using rule 13 (closed -> block .)


state 11

    (11) for -> FOR .

    L_PAREN         reduce using rule 11 (for -> FOR .)


state 12

    (54) simple -> expr . SEMICOLON
    (86) expr -> expr . assignment exprOR
    (88) assignment -> . ASSIGN
    (89) assignment -> . PLUS_ASSIGN
    (90) assignment -> . MINUS_ASSIGN
    (91) assignment -> . MUL_ASSIGN
    (92) assignment -> . DIV_ASSIGN
    (93) assignment -> . AND_ASSIGN
    (94) assignment -> . OR_ASSIGN
    (95) assignment -> . XOR_ASSIGN
    (96) assignment -> . MOD_ASSIGN
    (97) assignment -> . L_SHIFT_ASSIGN
    (98) assignment -> . R_SHIFT_ASSIGN

    SEMICOLON       shift and go to state 56
    ASSIGN          shift and go to state 58
    PLUS_ASSIGN     shift and go to state 59
    MINUS_ASSIGN    shift and go to state 60
    MUL_ASSIGN      shift and go to state 61
    DIV_ASSIGN      shift and go to state 62
    AND_ASSIGN      shift and go to state 63
    OR_ASSIGN       shift and go to state 64
    XOR_ASSIGN      shift and go to state 65
    MOD_ASSIGN      shift and go to state 66
    L_SHIFT_ASSIGN  shift and go to state 67
    R_SHIFT_ASSIGN  shift and go to state 68

    assignment                     shift and go to state 57

state 13

    (57) simple -> SEMICOLON .

    IF              reduce using rule 57 (simple -> SEMICOLON .)
    WHILE           reduce using rule 57 (simple -> SEMICOLON .)
    FOR             reduce using rule 57 (simple -> SEMICOLON .)
    SEMICOLON       reduce using rule 57 (simple -> SEMICOLON .)
    RETURN          reduce using rule 57 (simple -> SEMICOLON .)
    HASH            reduce using rule 57 (simple -> SEMICOLON .)
    TYPE            reduce using rule 57 (simple -> SEMICOLON .)
    L_FLOWBRACE     reduce using rule 57 (simple -> SEMICOLON .)
    NOT             reduce using rule 57 (simple -> SEMICOLON .)
    PLUS            reduce using rule 57 (simple -> SEMICOLON .)
    MINUS           reduce using rule 57 (simple -> SEMICOLON .)
    PLUS_PLUS       reduce using rule 57 (simple -> SEMICOLON .)
    MINUS_MINUS     reduce using rule 57 (simple -> SEMICOLON .)
    L_PAREN         reduce using rule 57 (simple -> SEMICOLON .)
    STRING          reduce using rule 57 (simple -> SEMICOLON .)
    MULTIPLY        reduce using rule 57 (simple -> SEMICOLON .)
    BIT_AND         reduce using rule 57 (simple -> SEMICOLON .)
    ID              reduce using rule 57 (simple -> SEMICOLON .)
    CHAR            reduce using rule 57 (simple -> SEMICOLON .)
    INT_NUM         reduce using rule 57 (simple -> SEMICOLON .)
    FLOAT_NUM       reduce using rule 57 (simple -> SEMICOLON .)
    $end            reduce using rule 57 (simple -> SEMICOLON .)
    R_FLOWBRACE     reduce using rule 57 (simple -> SEMICOLON .)
    ELSE            reduce using rule 57 (simple -> SEMICOLON .)
    R_PAREN         reduce using rule 57 (simple -> SEMICOLON .)


state 14

    (55) simple -> header .

    IF              reduce using rule 55 (simple -> header .)
    WHILE           reduce using rule 55 (simple -> header .)
    FOR             reduce using rule 55 (simple -> header .)
    SEMICOLON       reduce using rule 55 (simple -> header .)
    RETURN          reduce using rule 55 (simple -> header .)
    HASH            reduce using rule 55 (simple -> header .)
    TYPE            reduce using rule 55 (simple -> header .)
    L_FLOWBRACE     reduce using rule 55 (simple -> header .)
    NOT             reduce using rule 55 (simple -> header .)
    PLUS            reduce using rule 55 (simple -> header .)
    MINUS           reduce using rule 55 (simple -> header .)
    PLUS_PLUS       reduce using rule 55 (simple -> header .)
    MINUS_MINUS     reduce using rule 55 (simple -> header .)
    L_PAREN         reduce using rule 55 (simple -> header .)
    STRING          reduce using rule 55 (simple -> header .)
    MULTIPLY        reduce using rule 55 (simple -> header .)
    BIT_AND         reduce using rule 55 (simple -> header .)
    ID              reduce using rule 55 (simple -> header .)
    CHAR            reduce using rule 55 (simple -> header .)
    INT_NUM         reduce using rule 55 (simple -> header .)
    FLOAT_NUM       reduce using rule 55 (simple -> header .)
    $end            reduce using rule 55 (simple -> header .)
    R_FLOWBRACE     reduce using rule 55 (simple -> header .)
    ELSE            reduce using rule 55 (simple -> header .)
    R_PAREN         reduce using rule 55 (simple -> header .)


state 15

    (56) simple -> declaration .

    IF              reduce using rule 56 (simple -> declaration .)
    WHILE           reduce using rule 56 (simple -> declaration .)
    FOR             reduce using rule 56 (simple -> declaration .)
    SEMICOLON       reduce using rule 56 (simple -> declaration .)
    RETURN          reduce using rule 56 (simple -> declaration .)
    HASH            reduce using rule 56 (simple -> declaration .)
    TYPE            reduce using rule 56 (simple -> declaration .)
    L_FLOWBRACE     reduce using rule 56 (simple -> declaration .)
    NOT             reduce using rule 56 (simple -> declaration .)
    PLUS            reduce using rule 56 (simple -> declaration .)
    MINUS           reduce using rule 56 (simple -> declaration .)
    PLUS_PLUS       reduce using rule 56 (simple -> declaration .)
    MINUS_MINUS     reduce using rule 56 (simple -> declaration .)
    L_PAREN         reduce using rule 56 (simple -> declaration .)
    STRING          reduce using rule 56 (simple -> declaration .)
    MULTIPLY        reduce using rule 56 (simple -> declaration .)
    BIT_AND         reduce using rule 56 (simple -> declaration .)
    ID              reduce using rule 56 (simple -> declaration .)
    CHAR            reduce using rule 56 (simple -> declaration .)
    INT_NUM         reduce using rule 56 (simple -> declaration .)
    FLOAT_NUM       reduce using rule 56 (simple -> declaration .)
    $end            reduce using rule 56 (simple -> declaration .)
    R_FLOWBRACE     reduce using rule 56 (simple -> declaration .)
    ELSE            reduce using rule 56 (simple -> declaration .)
    R_PAREN         reduce using rule 56 (simple -> declaration .)


state 16

    (58) simple -> function .

    IF              reduce using rule 58 (simple -> function .)
    WHILE           reduce using rule 58 (simple -> function .)
    FOR             reduce using rule 58 (simple -> function .)
    SEMICOLON       reduce using rule 58 (simple -> function .)
    RETURN          reduce using rule 58 (simple -> function .)
    HASH            reduce using rule 58 (simple -> function .)
    TYPE            reduce using rule 58 (simple -> function .)
    L_FLOWBRACE     reduce using rule 58 (simple -> function .)
    NOT             reduce using rule 58 (simple -> function .)
    PLUS            reduce using rule 58 (simple -> function .)
    MINUS           reduce using rule 58 (simple -> function .)
    PLUS_PLUS       reduce using rule 58 (simple -> function .)
    MINUS_MINUS     reduce using rule 58 (simple -> function .)
    L_PAREN         reduce using rule 58 (simple -> function .)
    STRING          reduce using rule 58 (simple -> function .)
    MULTIPLY        reduce using rule 58 (simple -> function .)
    BIT_AND         reduce using rule 58 (simple -> function .)
    ID              reduce using rule 58 (simple -> function .)
    CHAR            reduce using rule 58 (simple -> function .)
    INT_NUM         reduce using rule 58 (simple -> function .)
    FLOAT_NUM       reduce using rule 58 (simple -> function .)
    $end            reduce using rule 58 (simple -> function .)
    R_FLOWBRACE     reduce using rule 58 (simple -> function .)
    ELSE            reduce using rule 58 (simple -> function .)
    R_PAREN         reduce using rule 58 (simple -> function .)


state 17

    (59) simple -> RETURN . expr SEMICOLON
    (60) simple -> RETURN . SEMICOLON
    (86) expr -> . expr assignment exprOR
    (87) expr -> . exprOR
    (99) exprOR -> . exprOR OR exprAND
    (100) exprOR -> . exprAND
    (101) exprAND -> . exprAND AND exprBITOR
    (102) exprAND -> . exprBITOR
    (103) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (104) exprBITOR -> . exprBITXOR
    (105) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (106) exprBITXOR -> . exprBITAND
    (107) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (108) exprBITAND -> . exprEQ
    (109) exprEQ -> . exprEQ EQ exprRELOP
    (110) exprEQ -> . exprEQ NE exprRELOP
    (111) exprEQ -> . exprRELOP
    (112) exprRELOP -> . exprRELOP relop exprSHIFT
    (113) exprRELOP -> . exprSHIFT
    (118) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (119) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (120) exprSHIFT -> . exprOP
    (121) exprOP -> . exprOP PLUS term
    (122) exprOP -> . exprOP MINUS term
    (123) exprOP -> . term
    (124) term -> . term MULTIPLY factor
    (125) term -> . term DIVIDE factor
    (126) term -> . term MOD factor
    (127) term -> . factor
    (128) factor -> . NOT factor
    (129) factor -> . PLUS factor
    (130) factor -> . MINUS factor
    (131) factor -> . PLUS_PLUS factor
    (132) factor -> . MINUS_MINUS factor
    (133) factor -> . cast brace
    (134) factor -> . brace
    (135) cast -> . L_PAREN TYPE R_PAREN
    (136) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (137) brace -> . L_PAREN expr R_PAREN
    (138) brace -> . brace PLUS_PLUS
    (139) brace -> . brace MINUS_MINUS
    (140) brace -> . NUM
    (141) brace -> . STRING
    (142) brace -> . MULTIPLY ID
    (143) brace -> . BIT_AND ID
    (144) brace -> . ID
    (145) brace -> . CHAR
    (146) brace -> . function_call
    (147) brace -> . ID narrayindex
    (148) NUM -> . INT_NUM
    (149) NUM -> . FLOAT_NUM
    (64) function_call -> . ID L_PAREN call_params R_PAREN

    SEMICOLON       shift and go to state 70
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    expr                           shift and go to state 69
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 18

    (50) block -> left_flower . multiple_statements right_flower
    (51) block -> left_flower . right_flower
    (2) multiple_statements -> . multiple_statements statement
    (3) multiple_statements -> . statement
    (53) right_flower -> . R_FLOWBRACE
    (4) statement -> . open
    (5) statement -> . closed
    (7) open -> . IF condition statement
    (8) open -> . IF condition closed else open
    (9) open -> . WHILE condition open
    (10) open -> . for for_condition open
    (12) closed -> . simple
    (13) closed -> . block
    (14) closed -> . IF condition closed else closed
    (15) closed -> . WHILE condition closed
    (16) closed -> . for for_condition closed
    (11) for -> . FOR
    (54) simple -> . expr SEMICOLON
    (55) simple -> . header
    (56) simple -> . declaration
    (57) simple -> . SEMICOLON
    (58) simple -> . function
    (59) simple -> . RETURN expr SEMICOLON
    (60) simple -> . RETURN SEMICOLON
    (50) block -> . left_flower multiple_statements right_flower
    (51) block -> . left_flower right_flower
    (86) expr -> . expr assignment exprOR
    (87) expr -> . exprOR
    (61) header -> . HASH INCLUDE STRING
    (62) header -> . HASH INCLUDE HEADER_FILE
    (35) declaration -> . TYPE ID SEMICOLON
    (36) declaration -> . TYPE MULTIPLY ID SEMICOLON
    (37) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (38) declaration -> . TYPE MULTIPLY ID ASSIGN expr SEMICOLON
    (39) declaration -> . TYPE multi_declaration stop
    (40) declaration -> . TYPE ID narrayindex SEMICOLON
    (41) declaration -> . TYPE ID narrayindex ASSIGN init_list SEMICOLON
    (83) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (52) left_flower -> . L_FLOWBRACE
    (99) exprOR -> . exprOR OR exprAND
    (100) exprOR -> . exprAND
    (101) exprAND -> . exprAND AND exprBITOR
    (102) exprAND -> . exprBITOR
    (103) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (104) exprBITOR -> . exprBITXOR
    (105) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (106) exprBITXOR -> . exprBITAND
    (107) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (108) exprBITAND -> . exprEQ
    (109) exprEQ -> . exprEQ EQ exprRELOP
    (110) exprEQ -> . exprEQ NE exprRELOP
    (111) exprEQ -> . exprRELOP
    (112) exprRELOP -> . exprRELOP relop exprSHIFT
    (113) exprRELOP -> . exprSHIFT
    (118) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (119) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (120) exprSHIFT -> . exprOP
    (121) exprOP -> . exprOP PLUS term
    (122) exprOP -> . exprOP MINUS term
    (123) exprOP -> . term
    (124) term -> . term MULTIPLY factor
    (125) term -> . term DIVIDE factor
    (126) term -> . term MOD factor
    (127) term -> . factor
    (128) factor -> . NOT factor
    (129) factor -> . PLUS factor
    (130) factor -> . MINUS factor
    (131) factor -> . PLUS_PLUS factor
    (132) factor -> . MINUS_MINUS factor
    (133) factor -> . cast brace
    (134) factor -> . brace
    (135) cast -> . L_PAREN TYPE R_PAREN
    (136) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (137) brace -> . L_PAREN expr R_PAREN
    (138) brace -> . brace PLUS_PLUS
    (139) brace -> . brace MINUS_MINUS
    (140) brace -> . NUM
    (141) brace -> . STRING
    (142) brace -> . MULTIPLY ID
    (143) brace -> . BIT_AND ID
    (144) brace -> . ID
    (145) brace -> . CHAR
    (146) brace -> . function_call
    (147) brace -> . ID narrayindex
    (148) NUM -> . INT_NUM
    (149) NUM -> . FLOAT_NUM
    (64) function_call -> . ID L_PAREN call_params R_PAREN

    R_FLOWBRACE     shift and go to state 73
    IF              shift and go to state 6
    WHILE           shift and go to state 7
    FOR             shift and go to state 11
    SEMICOLON       shift and go to state 13
    RETURN          shift and go to state 17
    HASH            shift and go to state 20
    TYPE            shift and go to state 22
    L_FLOWBRACE     shift and go to state 26
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    left_flower                    shift and go to state 18
    multiple_statements            shift and go to state 71
    right_flower                   shift and go to state 72
    statement                      shift and go to state 3
    open                           shift and go to state 4
    closed                         shift and go to state 5
    for                            shift and go to state 8
    simple                         shift and go to state 9
    block                          shift and go to state 10
    expr                           shift and go to state 12
    header                         shift and go to state 14
    declaration                    shift and go to state 15
    function                       shift and go to state 16
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 19

    (87) expr -> exprOR .
    (99) exprOR -> exprOR . OR exprAND

    SEMICOLON       reduce using rule 87 (expr -> exprOR .)
    ASSIGN          reduce using rule 87 (expr -> exprOR .)
    PLUS_ASSIGN     reduce using rule 87 (expr -> exprOR .)
    MINUS_ASSIGN    reduce using rule 87 (expr -> exprOR .)
    MUL_ASSIGN      reduce using rule 87 (expr -> exprOR .)
    DIV_ASSIGN      reduce using rule 87 (expr -> exprOR .)
    AND_ASSIGN      reduce using rule 87 (expr -> exprOR .)
    OR_ASSIGN       reduce using rule 87 (expr -> exprOR .)
    XOR_ASSIGN      reduce using rule 87 (expr -> exprOR .)
    MOD_ASSIGN      reduce using rule 87 (expr -> exprOR .)
    L_SHIFT_ASSIGN  reduce using rule 87 (expr -> exprOR .)
    R_SHIFT_ASSIGN  reduce using rule 87 (expr -> exprOR .)
    R_PAREN         reduce using rule 87 (expr -> exprOR .)
    COMMA           reduce using rule 87 (expr -> exprOR .)
    R_SQBRACE       reduce using rule 87 (expr -> exprOR .)
    R_FLOWBRACE     reduce using rule 87 (expr -> exprOR .)
    OR              shift and go to state 74


state 20

    (61) header -> HASH . INCLUDE STRING
    (62) header -> HASH . INCLUDE HEADER_FILE

    INCLUDE         shift and go to state 75


state 21

    (141) brace -> STRING .

    PLUS_PLUS       reduce using rule 141 (brace -> STRING .)
    MINUS_MINUS     reduce using rule 141 (brace -> STRING .)
    MULTIPLY        reduce using rule 141 (brace -> STRING .)
    DIVIDE          reduce using rule 141 (brace -> STRING .)
    MOD             reduce using rule 141 (brace -> STRING .)
    PLUS            reduce using rule 141 (brace -> STRING .)
    MINUS           reduce using rule 141 (brace -> STRING .)
    L_SHIFT         reduce using rule 141 (brace -> STRING .)
    R_SHIFT         reduce using rule 141 (brace -> STRING .)
    LE              reduce using rule 141 (brace -> STRING .)
    LT              reduce using rule 141 (brace -> STRING .)
    GE              reduce using rule 141 (brace -> STRING .)
    GT              reduce using rule 141 (brace -> STRING .)
    EQ              reduce using rule 141 (brace -> STRING .)
    NE              reduce using rule 141 (brace -> STRING .)
    BIT_AND         reduce using rule 141 (brace -> STRING .)
    BIT_XOR         reduce using rule 141 (brace -> STRING .)
    BIT_OR          reduce using rule 141 (brace -> STRING .)
    AND             reduce using rule 141 (brace -> STRING .)
    OR              reduce using rule 141 (brace -> STRING .)
    SEMICOLON       reduce using rule 141 (brace -> STRING .)
    ASSIGN          reduce using rule 141 (brace -> STRING .)
    PLUS_ASSIGN     reduce using rule 141 (brace -> STRING .)
    MINUS_ASSIGN    reduce using rule 141 (brace -> STRING .)
    MUL_ASSIGN      reduce using rule 141 (brace -> STRING .)
    DIV_ASSIGN      reduce using rule 141 (brace -> STRING .)
    AND_ASSIGN      reduce using rule 141 (brace -> STRING .)
    OR_ASSIGN       reduce using rule 141 (brace -> STRING .)
    XOR_ASSIGN      reduce using rule 141 (brace -> STRING .)
    MOD_ASSIGN      reduce using rule 141 (brace -> STRING .)
    L_SHIFT_ASSIGN  reduce using rule 141 (brace -> STRING .)
    R_SHIFT_ASSIGN  reduce using rule 141 (brace -> STRING .)
    R_PAREN         reduce using rule 141 (brace -> STRING .)
    COMMA           reduce using rule 141 (brace -> STRING .)
    R_SQBRACE       reduce using rule 141 (brace -> STRING .)
    R_FLOWBRACE     reduce using rule 141 (brace -> STRING .)


state 22

    (35) declaration -> TYPE . ID SEMICOLON
    (36) declaration -> TYPE . MULTIPLY ID SEMICOLON
    (37) declaration -> TYPE . ID ASSIGN expr SEMICOLON
    (38) declaration -> TYPE . MULTIPLY ID ASSIGN expr SEMICOLON
    (39) declaration -> TYPE . multi_declaration stop
    (40) declaration -> TYPE . ID narrayindex SEMICOLON
    (41) declaration -> TYPE . ID narrayindex ASSIGN init_list SEMICOLON
    (83) function -> TYPE . ID L_PAREN dec_params R_PAREN function_2
    (20) multi_declaration -> . multi_declaration ID COMMA
    (21) multi_declaration -> . multi_declaration MULTIPLY ID COMMA
    (22) multi_declaration -> . multi_declaration ID ASSIGN expr COMMA
    (23) multi_declaration -> . multi_declaration MULTIPLY ID ASSIGN expr COMMA
    (24) multi_declaration -> . ID COMMA
    (25) multi_declaration -> . ID ASSIGN expr COMMA
    (26) multi_declaration -> . MULTIPLY ID COMMA
    (27) multi_declaration -> . MULTIPLY ID ASSIGN expr COMMA

    ID              shift and go to state 76
    MULTIPLY        shift and go to state 77

    multi_declaration              shift and go to state 78

state 23

    (144) brace -> ID .
    (147) brace -> ID . narrayindex
    (64) function_call -> ID . L_PAREN call_params R_PAREN
    (33) narrayindex -> . narrayindex arrayindex
    (34) narrayindex -> . arrayindex
    (32) arrayindex -> . L_SQBRACE index R_SQBRACE

    PLUS_PLUS       reduce using rule 144 (brace -> ID .)
    MINUS_MINUS     reduce using rule 144 (brace -> ID .)
    MULTIPLY        reduce using rule 144 (brace -> ID .)
    DIVIDE          reduce using rule 144 (brace -> ID .)
    MOD             reduce using rule 144 (brace -> ID .)
    PLUS            reduce using rule 144 (brace -> ID .)
    MINUS           reduce using rule 144 (brace -> ID .)
    L_SHIFT         reduce using rule 144 (brace -> ID .)
    R_SHIFT         reduce using rule 144 (brace -> ID .)
    LE              reduce using rule 144 (brace -> ID .)
    LT              reduce using rule 144 (brace -> ID .)
    GE              reduce using rule 144 (brace -> ID .)
    GT              reduce using rule 144 (brace -> ID .)
    EQ              reduce using rule 144 (brace -> ID .)
    NE              reduce using rule 144 (brace -> ID .)
    BIT_AND         reduce using rule 144 (brace -> ID .)
    BIT_XOR         reduce using rule 144 (brace -> ID .)
    BIT_OR          reduce using rule 144 (brace -> ID .)
    AND             reduce using rule 144 (brace -> ID .)
    OR              reduce using rule 144 (brace -> ID .)
    SEMICOLON       reduce using rule 144 (brace -> ID .)
    ASSIGN          reduce using rule 144 (brace -> ID .)
    PLUS_ASSIGN     reduce using rule 144 (brace -> ID .)
    MINUS_ASSIGN    reduce using rule 144 (brace -> ID .)
    MUL_ASSIGN      reduce using rule 144 (brace -> ID .)
    DIV_ASSIGN      reduce using rule 144 (brace -> ID .)
    AND_ASSIGN      reduce using rule 144 (brace -> ID .)
    OR_ASSIGN       reduce using rule 144 (brace -> ID .)
    XOR_ASSIGN      reduce using rule 144 (brace -> ID .)
    MOD_ASSIGN      reduce using rule 144 (brace -> ID .)
    L_SHIFT_ASSIGN  reduce using rule 144 (brace -> ID .)
    R_SHIFT_ASSIGN  reduce using rule 144 (brace -> ID .)
    R_PAREN         reduce using rule 144 (brace -> ID .)
    COMMA           reduce using rule 144 (brace -> ID .)
    R_SQBRACE       reduce using rule 144 (brace -> ID .)
    R_FLOWBRACE     reduce using rule 144 (brace -> ID .)
    L_PAREN         shift and go to state 80
    L_SQBRACE       shift and go to state 82

    narrayindex                    shift and go to state 79
    arrayindex                     shift and go to state 81

state 24

    (142) brace -> MULTIPLY . ID

    ID              shift and go to state 83


state 25

    (135) cast -> L_PAREN . TYPE R_PAREN
    (136) cast -> L_PAREN . TYPE MULTIPLY R_PAREN
    (137) brace -> L_PAREN . expr R_PAREN
    (86) expr -> . expr assignment exprOR
    (87) expr -> . exprOR
    (99) exprOR -> . exprOR OR exprAND
    (100) exprOR -> . exprAND
    (101) exprAND -> . exprAND AND exprBITOR
    (102) exprAND -> . exprBITOR
    (103) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (104) exprBITOR -> . exprBITXOR
    (105) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (106) exprBITXOR -> . exprBITAND
    (107) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (108) exprBITAND -> . exprEQ
    (109) exprEQ -> . exprEQ EQ exprRELOP
    (110) exprEQ -> . exprEQ NE exprRELOP
    (111) exprEQ -> . exprRELOP
    (112) exprRELOP -> . exprRELOP relop exprSHIFT
    (113) exprRELOP -> . exprSHIFT
    (118) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (119) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (120) exprSHIFT -> . exprOP
    (121) exprOP -> . exprOP PLUS term
    (122) exprOP -> . exprOP MINUS term
    (123) exprOP -> . term
    (124) term -> . term MULTIPLY factor
    (125) term -> . term DIVIDE factor
    (126) term -> . term MOD factor
    (127) term -> . factor
    (128) factor -> . NOT factor
    (129) factor -> . PLUS factor
    (130) factor -> . MINUS factor
    (131) factor -> . PLUS_PLUS factor
    (132) factor -> . MINUS_MINUS factor
    (133) factor -> . cast brace
    (134) factor -> . brace
    (135) cast -> . L_PAREN TYPE R_PAREN
    (136) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (137) brace -> . L_PAREN expr R_PAREN
    (138) brace -> . brace PLUS_PLUS
    (139) brace -> . brace MINUS_MINUS
    (140) brace -> . NUM
    (141) brace -> . STRING
    (142) brace -> . MULTIPLY ID
    (143) brace -> . BIT_AND ID
    (144) brace -> . ID
    (145) brace -> . CHAR
    (146) brace -> . function_call
    (147) brace -> . ID narrayindex
    (148) NUM -> . INT_NUM
    (149) NUM -> . FLOAT_NUM
    (64) function_call -> . ID L_PAREN call_params R_PAREN

    TYPE            shift and go to state 84
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    expr                           shift and go to state 85
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 26

    (52) left_flower -> L_FLOWBRACE .

    R_FLOWBRACE     reduce using rule 52 (left_flower -> L_FLOWBRACE .)
    IF              reduce using rule 52 (left_flower -> L_FLOWBRACE .)
    WHILE           reduce using rule 52 (left_flower -> L_FLOWBRACE .)
    FOR             reduce using rule 52 (left_flower -> L_FLOWBRACE .)
    SEMICOLON       reduce using rule 52 (left_flower -> L_FLOWBRACE .)
    RETURN          reduce using rule 52 (left_flower -> L_FLOWBRACE .)
    HASH            reduce using rule 52 (left_flower -> L_FLOWBRACE .)
    TYPE            reduce using rule 52 (left_flower -> L_FLOWBRACE .)
    L_FLOWBRACE     reduce using rule 52 (left_flower -> L_FLOWBRACE .)
    NOT             reduce using rule 52 (left_flower -> L_FLOWBRACE .)
    PLUS            reduce using rule 52 (left_flower -> L_FLOWBRACE .)
    MINUS           reduce using rule 52 (left_flower -> L_FLOWBRACE .)
    PLUS_PLUS       reduce using rule 52 (left_flower -> L_FLOWBRACE .)
    MINUS_MINUS     reduce using rule 52 (left_flower -> L_FLOWBRACE .)
    L_PAREN         reduce using rule 52 (left_flower -> L_FLOWBRACE .)
    STRING          reduce using rule 52 (left_flower -> L_FLOWBRACE .)
    MULTIPLY        reduce using rule 52 (left_flower -> L_FLOWBRACE .)
    BIT_AND         reduce using rule 52 (left_flower -> L_FLOWBRACE .)
    ID              reduce using rule 52 (left_flower -> L_FLOWBRACE .)
    CHAR            reduce using rule 52 (left_flower -> L_FLOWBRACE .)
    INT_NUM         reduce using rule 52 (left_flower -> L_FLOWBRACE .)
    FLOAT_NUM       reduce using rule 52 (left_flower -> L_FLOWBRACE .)


state 27

    (100) exprOR -> exprAND .
    (101) exprAND -> exprAND . AND exprBITOR

    OR              reduce using rule 100 (exprOR -> exprAND .)
    SEMICOLON       reduce using rule 100 (exprOR -> exprAND .)
    ASSIGN          reduce using rule 100 (exprOR -> exprAND .)
    PLUS_ASSIGN     reduce using rule 100 (exprOR -> exprAND .)
    MINUS_ASSIGN    reduce using rule 100 (exprOR -> exprAND .)
    MUL_ASSIGN      reduce using rule 100 (exprOR -> exprAND .)
    DIV_ASSIGN      reduce using rule 100 (exprOR -> exprAND .)
    AND_ASSIGN      reduce using rule 100 (exprOR -> exprAND .)
    OR_ASSIGN       reduce using rule 100 (exprOR -> exprAND .)
    XOR_ASSIGN      reduce using rule 100 (exprOR -> exprAND .)
    MOD_ASSIGN      reduce using rule 100 (exprOR -> exprAND .)
    L_SHIFT_ASSIGN  reduce using rule 100 (exprOR -> exprAND .)
    R_SHIFT_ASSIGN  reduce using rule 100 (exprOR -> exprAND .)
    R_PAREN         reduce using rule 100 (exprOR -> exprAND .)
    COMMA           reduce using rule 100 (exprOR -> exprAND .)
    R_SQBRACE       reduce using rule 100 (exprOR -> exprAND .)
    R_FLOWBRACE     reduce using rule 100 (exprOR -> exprAND .)
    AND             shift and go to state 86


state 28

    (102) exprAND -> exprBITOR .
    (103) exprBITOR -> exprBITOR . BIT_OR exprBITXOR

    AND             reduce using rule 102 (exprAND -> exprBITOR .)
    OR              reduce using rule 102 (exprAND -> exprBITOR .)
    SEMICOLON       reduce using rule 102 (exprAND -> exprBITOR .)
    ASSIGN          reduce using rule 102 (exprAND -> exprBITOR .)
    PLUS_ASSIGN     reduce using rule 102 (exprAND -> exprBITOR .)
    MINUS_ASSIGN    reduce using rule 102 (exprAND -> exprBITOR .)
    MUL_ASSIGN      reduce using rule 102 (exprAND -> exprBITOR .)
    DIV_ASSIGN      reduce using rule 102 (exprAND -> exprBITOR .)
    AND_ASSIGN      reduce using rule 102 (exprAND -> exprBITOR .)
    OR_ASSIGN       reduce using rule 102 (exprAND -> exprBITOR .)
    XOR_ASSIGN      reduce using rule 102 (exprAND -> exprBITOR .)
    MOD_ASSIGN      reduce using rule 102 (exprAND -> exprBITOR .)
    L_SHIFT_ASSIGN  reduce using rule 102 (exprAND -> exprBITOR .)
    R_SHIFT_ASSIGN  reduce using rule 102 (exprAND -> exprBITOR .)
    R_PAREN         reduce using rule 102 (exprAND -> exprBITOR .)
    COMMA           reduce using rule 102 (exprAND -> exprBITOR .)
    R_SQBRACE       reduce using rule 102 (exprAND -> exprBITOR .)
    R_FLOWBRACE     reduce using rule 102 (exprAND -> exprBITOR .)
    BIT_OR          shift and go to state 87


state 29

    (104) exprBITOR -> exprBITXOR .
    (105) exprBITXOR -> exprBITXOR . BIT_XOR exprBITAND

    BIT_OR          reduce using rule 104 (exprBITOR -> exprBITXOR .)
    AND             reduce using rule 104 (exprBITOR -> exprBITXOR .)
    OR              reduce using rule 104 (exprBITOR -> exprBITXOR .)
    SEMICOLON       reduce using rule 104 (exprBITOR -> exprBITXOR .)
    ASSIGN          reduce using rule 104 (exprBITOR -> exprBITXOR .)
    PLUS_ASSIGN     reduce using rule 104 (exprBITOR -> exprBITXOR .)
    MINUS_ASSIGN    reduce using rule 104 (exprBITOR -> exprBITXOR .)
    MUL_ASSIGN      reduce using rule 104 (exprBITOR -> exprBITXOR .)
    DIV_ASSIGN      reduce using rule 104 (exprBITOR -> exprBITXOR .)
    AND_ASSIGN      reduce using rule 104 (exprBITOR -> exprBITXOR .)
    OR_ASSIGN       reduce using rule 104 (exprBITOR -> exprBITXOR .)
    XOR_ASSIGN      reduce using rule 104 (exprBITOR -> exprBITXOR .)
    MOD_ASSIGN      reduce using rule 104 (exprBITOR -> exprBITXOR .)
    L_SHIFT_ASSIGN  reduce using rule 104 (exprBITOR -> exprBITXOR .)
    R_SHIFT_ASSIGN  reduce using rule 104 (exprBITOR -> exprBITXOR .)
    R_PAREN         reduce using rule 104 (exprBITOR -> exprBITXOR .)
    COMMA           reduce using rule 104 (exprBITOR -> exprBITXOR .)
    R_SQBRACE       reduce using rule 104 (exprBITOR -> exprBITXOR .)
    R_FLOWBRACE     reduce using rule 104 (exprBITOR -> exprBITXOR .)
    BIT_XOR         shift and go to state 88


state 30

    (106) exprBITXOR -> exprBITAND .
    (107) exprBITAND -> exprBITAND . BIT_AND exprEQ

    BIT_XOR         reduce using rule 106 (exprBITXOR -> exprBITAND .)
    BIT_OR          reduce using rule 106 (exprBITXOR -> exprBITAND .)
    AND             reduce using rule 106 (exprBITXOR -> exprBITAND .)
    OR              reduce using rule 106 (exprBITXOR -> exprBITAND .)
    SEMICOLON       reduce using rule 106 (exprBITXOR -> exprBITAND .)
    ASSIGN          reduce using rule 106 (exprBITXOR -> exprBITAND .)
    PLUS_ASSIGN     reduce using rule 106 (exprBITXOR -> exprBITAND .)
    MINUS_ASSIGN    reduce using rule 106 (exprBITXOR -> exprBITAND .)
    MUL_ASSIGN      reduce using rule 106 (exprBITXOR -> exprBITAND .)
    DIV_ASSIGN      reduce using rule 106 (exprBITXOR -> exprBITAND .)
    AND_ASSIGN      reduce using rule 106 (exprBITXOR -> exprBITAND .)
    OR_ASSIGN       reduce using rule 106 (exprBITXOR -> exprBITAND .)
    XOR_ASSIGN      reduce using rule 106 (exprBITXOR -> exprBITAND .)
    MOD_ASSIGN      reduce using rule 106 (exprBITXOR -> exprBITAND .)
    L_SHIFT_ASSIGN  reduce using rule 106 (exprBITXOR -> exprBITAND .)
    R_SHIFT_ASSIGN  reduce using rule 106 (exprBITXOR -> exprBITAND .)
    R_PAREN         reduce using rule 106 (exprBITXOR -> exprBITAND .)
    COMMA           reduce using rule 106 (exprBITXOR -> exprBITAND .)
    R_SQBRACE       reduce using rule 106 (exprBITXOR -> exprBITAND .)
    R_FLOWBRACE     reduce using rule 106 (exprBITXOR -> exprBITAND .)
    BIT_AND         shift and go to state 89


state 31

    (143) brace -> BIT_AND . ID

    ID              shift and go to state 90


state 32

    (108) exprBITAND -> exprEQ .
    (109) exprEQ -> exprEQ . EQ exprRELOP
    (110) exprEQ -> exprEQ . NE exprRELOP

    BIT_AND         reduce using rule 108 (exprBITAND -> exprEQ .)
    BIT_XOR         reduce using rule 108 (exprBITAND -> exprEQ .)
    BIT_OR          reduce using rule 108 (exprBITAND -> exprEQ .)
    AND             reduce using rule 108 (exprBITAND -> exprEQ .)
    OR              reduce using rule 108 (exprBITAND -> exprEQ .)
    SEMICOLON       reduce using rule 108 (exprBITAND -> exprEQ .)
    ASSIGN          reduce using rule 108 (exprBITAND -> exprEQ .)
    PLUS_ASSIGN     reduce using rule 108 (exprBITAND -> exprEQ .)
    MINUS_ASSIGN    reduce using rule 108 (exprBITAND -> exprEQ .)
    MUL_ASSIGN      reduce using rule 108 (exprBITAND -> exprEQ .)
    DIV_ASSIGN      reduce using rule 108 (exprBITAND -> exprEQ .)
    AND_ASSIGN      reduce using rule 108 (exprBITAND -> exprEQ .)
    OR_ASSIGN       reduce using rule 108 (exprBITAND -> exprEQ .)
    XOR_ASSIGN      reduce using rule 108 (exprBITAND -> exprEQ .)
    MOD_ASSIGN      reduce using rule 108 (exprBITAND -> exprEQ .)
    L_SHIFT_ASSIGN  reduce using rule 108 (exprBITAND -> exprEQ .)
    R_SHIFT_ASSIGN  reduce using rule 108 (exprBITAND -> exprEQ .)
    R_PAREN         reduce using rule 108 (exprBITAND -> exprEQ .)
    COMMA           reduce using rule 108 (exprBITAND -> exprEQ .)
    R_SQBRACE       reduce using rule 108 (exprBITAND -> exprEQ .)
    R_FLOWBRACE     reduce using rule 108 (exprBITAND -> exprEQ .)
    EQ              shift and go to state 91
    NE              shift and go to state 92


state 33

    (111) exprEQ -> exprRELOP .
    (112) exprRELOP -> exprRELOP . relop exprSHIFT
    (114) relop -> . LE
    (115) relop -> . LT
    (116) relop -> . GE
    (117) relop -> . GT

    EQ              reduce using rule 111 (exprEQ -> exprRELOP .)
    NE              reduce using rule 111 (exprEQ -> exprRELOP .)
    BIT_AND         reduce using rule 111 (exprEQ -> exprRELOP .)
    BIT_XOR         reduce using rule 111 (exprEQ -> exprRELOP .)
    BIT_OR          reduce using rule 111 (exprEQ -> exprRELOP .)
    AND             reduce using rule 111 (exprEQ -> exprRELOP .)
    OR              reduce using rule 111 (exprEQ -> exprRELOP .)
    SEMICOLON       reduce using rule 111 (exprEQ -> exprRELOP .)
    ASSIGN          reduce using rule 111 (exprEQ -> exprRELOP .)
    PLUS_ASSIGN     reduce using rule 111 (exprEQ -> exprRELOP .)
    MINUS_ASSIGN    reduce using rule 111 (exprEQ -> exprRELOP .)
    MUL_ASSIGN      reduce using rule 111 (exprEQ -> exprRELOP .)
    DIV_ASSIGN      reduce using rule 111 (exprEQ -> exprRELOP .)
    AND_ASSIGN      reduce using rule 111 (exprEQ -> exprRELOP .)
    OR_ASSIGN       reduce using rule 111 (exprEQ -> exprRELOP .)
    XOR_ASSIGN      reduce using rule 111 (exprEQ -> exprRELOP .)
    MOD_ASSIGN      reduce using rule 111 (exprEQ -> exprRELOP .)
    L_SHIFT_ASSIGN  reduce using rule 111 (exprEQ -> exprRELOP .)
    R_SHIFT_ASSIGN  reduce using rule 111 (exprEQ -> exprRELOP .)
    R_PAREN         reduce using rule 111 (exprEQ -> exprRELOP .)
    COMMA           reduce using rule 111 (exprEQ -> exprRELOP .)
    R_SQBRACE       reduce using rule 111 (exprEQ -> exprRELOP .)
    R_FLOWBRACE     reduce using rule 111 (exprEQ -> exprRELOP .)
    LE              shift and go to state 94
    LT              shift and go to state 95
    GE              shift and go to state 96
    GT              shift and go to state 97

    relop                          shift and go to state 93

state 34

    (113) exprRELOP -> exprSHIFT .
    (118) exprSHIFT -> exprSHIFT . L_SHIFT exprOP
    (119) exprSHIFT -> exprSHIFT . R_SHIFT exprOP

    LE              reduce using rule 113 (exprRELOP -> exprSHIFT .)
    LT              reduce using rule 113 (exprRELOP -> exprSHIFT .)
    GE              reduce using rule 113 (exprRELOP -> exprSHIFT .)
    GT              reduce using rule 113 (exprRELOP -> exprSHIFT .)
    EQ              reduce using rule 113 (exprRELOP -> exprSHIFT .)
    NE              reduce using rule 113 (exprRELOP -> exprSHIFT .)
    BIT_AND         reduce using rule 113 (exprRELOP -> exprSHIFT .)
    BIT_XOR         reduce using rule 113 (exprRELOP -> exprSHIFT .)
    BIT_OR          reduce using rule 113 (exprRELOP -> exprSHIFT .)
    AND             reduce using rule 113 (exprRELOP -> exprSHIFT .)
    OR              reduce using rule 113 (exprRELOP -> exprSHIFT .)
    SEMICOLON       reduce using rule 113 (exprRELOP -> exprSHIFT .)
    ASSIGN          reduce using rule 113 (exprRELOP -> exprSHIFT .)
    PLUS_ASSIGN     reduce using rule 113 (exprRELOP -> exprSHIFT .)
    MINUS_ASSIGN    reduce using rule 113 (exprRELOP -> exprSHIFT .)
    MUL_ASSIGN      reduce using rule 113 (exprRELOP -> exprSHIFT .)
    DIV_ASSIGN      reduce using rule 113 (exprRELOP -> exprSHIFT .)
    AND_ASSIGN      reduce using rule 113 (exprRELOP -> exprSHIFT .)
    OR_ASSIGN       reduce using rule 113 (exprRELOP -> exprSHIFT .)
    XOR_ASSIGN      reduce using rule 113 (exprRELOP -> exprSHIFT .)
    MOD_ASSIGN      reduce using rule 113 (exprRELOP -> exprSHIFT .)
    L_SHIFT_ASSIGN  reduce using rule 113 (exprRELOP -> exprSHIFT .)
    R_SHIFT_ASSIGN  reduce using rule 113 (exprRELOP -> exprSHIFT .)
    R_PAREN         reduce using rule 113 (exprRELOP -> exprSHIFT .)
    COMMA           reduce using rule 113 (exprRELOP -> exprSHIFT .)
    R_SQBRACE       reduce using rule 113 (exprRELOP -> exprSHIFT .)
    R_FLOWBRACE     reduce using rule 113 (exprRELOP -> exprSHIFT .)
    L_SHIFT         shift and go to state 98
    R_SHIFT         shift and go to state 99


state 35

    (120) exprSHIFT -> exprOP .
    (121) exprOP -> exprOP . PLUS term
    (122) exprOP -> exprOP . MINUS term

    L_SHIFT         reduce using rule 120 (exprSHIFT -> exprOP .)
    R_SHIFT         reduce using rule 120 (exprSHIFT -> exprOP .)
    LE              reduce using rule 120 (exprSHIFT -> exprOP .)
    LT              reduce using rule 120 (exprSHIFT -> exprOP .)
    GE              reduce using rule 120 (exprSHIFT -> exprOP .)
    GT              reduce using rule 120 (exprSHIFT -> exprOP .)
    EQ              reduce using rule 120 (exprSHIFT -> exprOP .)
    NE              reduce using rule 120 (exprSHIFT -> exprOP .)
    BIT_AND         reduce using rule 120 (exprSHIFT -> exprOP .)
    BIT_XOR         reduce using rule 120 (exprSHIFT -> exprOP .)
    BIT_OR          reduce using rule 120 (exprSHIFT -> exprOP .)
    AND             reduce using rule 120 (exprSHIFT -> exprOP .)
    OR              reduce using rule 120 (exprSHIFT -> exprOP .)
    SEMICOLON       reduce using rule 120 (exprSHIFT -> exprOP .)
    ASSIGN          reduce using rule 120 (exprSHIFT -> exprOP .)
    PLUS_ASSIGN     reduce using rule 120 (exprSHIFT -> exprOP .)
    MINUS_ASSIGN    reduce using rule 120 (exprSHIFT -> exprOP .)
    MUL_ASSIGN      reduce using rule 120 (exprSHIFT -> exprOP .)
    DIV_ASSIGN      reduce using rule 120 (exprSHIFT -> exprOP .)
    AND_ASSIGN      reduce using rule 120 (exprSHIFT -> exprOP .)
    OR_ASSIGN       reduce using rule 120 (exprSHIFT -> exprOP .)
    XOR_ASSIGN      reduce using rule 120 (exprSHIFT -> exprOP .)
    MOD_ASSIGN      reduce using rule 120 (exprSHIFT -> exprOP .)
    L_SHIFT_ASSIGN  reduce using rule 120 (exprSHIFT -> exprOP .)
    R_SHIFT_ASSIGN  reduce using rule 120 (exprSHIFT -> exprOP .)
    R_PAREN         reduce using rule 120 (exprSHIFT -> exprOP .)
    COMMA           reduce using rule 120 (exprSHIFT -> exprOP .)
    R_SQBRACE       reduce using rule 120 (exprSHIFT -> exprOP .)
    R_FLOWBRACE     reduce using rule 120 (exprSHIFT -> exprOP .)
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101


state 36

    (129) factor -> PLUS . factor
    (128) factor -> . NOT factor
    (129) factor -> . PLUS factor
    (130) factor -> . MINUS factor
    (131) factor -> . PLUS_PLUS factor
    (132) factor -> . MINUS_MINUS factor
    (133) factor -> . cast brace
    (134) factor -> . brace
    (135) cast -> . L_PAREN TYPE R_PAREN
    (136) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (137) brace -> . L_PAREN expr R_PAREN
    (138) brace -> . brace PLUS_PLUS
    (139) brace -> . brace MINUS_MINUS
    (140) brace -> . NUM
    (141) brace -> . STRING
    (142) brace -> . MULTIPLY ID
    (143) brace -> . BIT_AND ID
    (144) brace -> . ID
    (145) brace -> . CHAR
    (146) brace -> . function_call
    (147) brace -> . ID narrayindex
    (148) NUM -> . INT_NUM
    (149) NUM -> . FLOAT_NUM
    (64) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    factor                         shift and go to state 102
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 37

    (123) exprOP -> term .
    (124) term -> term . MULTIPLY factor
    (125) term -> term . DIVIDE factor
    (126) term -> term . MOD factor

    PLUS            reduce using rule 123 (exprOP -> term .)
    MINUS           reduce using rule 123 (exprOP -> term .)
    L_SHIFT         reduce using rule 123 (exprOP -> term .)
    R_SHIFT         reduce using rule 123 (exprOP -> term .)
    LE              reduce using rule 123 (exprOP -> term .)
    LT              reduce using rule 123 (exprOP -> term .)
    GE              reduce using rule 123 (exprOP -> term .)
    GT              reduce using rule 123 (exprOP -> term .)
    EQ              reduce using rule 123 (exprOP -> term .)
    NE              reduce using rule 123 (exprOP -> term .)
    BIT_AND         reduce using rule 123 (exprOP -> term .)
    BIT_XOR         reduce using rule 123 (exprOP -> term .)
    BIT_OR          reduce using rule 123 (exprOP -> term .)
    AND             reduce using rule 123 (exprOP -> term .)
    OR              reduce using rule 123 (exprOP -> term .)
    SEMICOLON       reduce using rule 123 (exprOP -> term .)
    ASSIGN          reduce using rule 123 (exprOP -> term .)
    PLUS_ASSIGN     reduce using rule 123 (exprOP -> term .)
    MINUS_ASSIGN    reduce using rule 123 (exprOP -> term .)
    MUL_ASSIGN      reduce using rule 123 (exprOP -> term .)
    DIV_ASSIGN      reduce using rule 123 (exprOP -> term .)
    AND_ASSIGN      reduce using rule 123 (exprOP -> term .)
    OR_ASSIGN       reduce using rule 123 (exprOP -> term .)
    XOR_ASSIGN      reduce using rule 123 (exprOP -> term .)
    MOD_ASSIGN      reduce using rule 123 (exprOP -> term .)
    L_SHIFT_ASSIGN  reduce using rule 123 (exprOP -> term .)
    R_SHIFT_ASSIGN  reduce using rule 123 (exprOP -> term .)
    R_PAREN         reduce using rule 123 (exprOP -> term .)
    COMMA           reduce using rule 123 (exprOP -> term .)
    R_SQBRACE       reduce using rule 123 (exprOP -> term .)
    R_FLOWBRACE     reduce using rule 123 (exprOP -> term .)
    MULTIPLY        shift and go to state 103
    DIVIDE          shift and go to state 104
    MOD             shift and go to state 105


state 38

    (130) factor -> MINUS . factor
    (128) factor -> . NOT factor
    (129) factor -> . PLUS factor
    (130) factor -> . MINUS factor
    (131) factor -> . PLUS_PLUS factor
    (132) factor -> . MINUS_MINUS factor
    (133) factor -> . cast brace
    (134) factor -> . brace
    (135) cast -> . L_PAREN TYPE R_PAREN
    (136) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (137) brace -> . L_PAREN expr R_PAREN
    (138) brace -> . brace PLUS_PLUS
    (139) brace -> . brace MINUS_MINUS
    (140) brace -> . NUM
    (141) brace -> . STRING
    (142) brace -> . MULTIPLY ID
    (143) brace -> . BIT_AND ID
    (144) brace -> . ID
    (145) brace -> . CHAR
    (146) brace -> . function_call
    (147) brace -> . ID narrayindex
    (148) NUM -> . INT_NUM
    (149) NUM -> . FLOAT_NUM
    (64) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    factor                         shift and go to state 106
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 39

    (127) term -> factor .

    MULTIPLY        reduce using rule 127 (term -> factor .)
    DIVIDE          reduce using rule 127 (term -> factor .)
    MOD             reduce using rule 127 (term -> factor .)
    PLUS            reduce using rule 127 (term -> factor .)
    MINUS           reduce using rule 127 (term -> factor .)
    L_SHIFT         reduce using rule 127 (term -> factor .)
    R_SHIFT         reduce using rule 127 (term -> factor .)
    LE              reduce using rule 127 (term -> factor .)
    LT              reduce using rule 127 (term -> factor .)
    GE              reduce using rule 127 (term -> factor .)
    GT              reduce using rule 127 (term -> factor .)
    EQ              reduce using rule 127 (term -> factor .)
    NE              reduce using rule 127 (term -> factor .)
    BIT_AND         reduce using rule 127 (term -> factor .)
    BIT_XOR         reduce using rule 127 (term -> factor .)
    BIT_OR          reduce using rule 127 (term -> factor .)
    AND             reduce using rule 127 (term -> factor .)
    OR              reduce using rule 127 (term -> factor .)
    SEMICOLON       reduce using rule 127 (term -> factor .)
    ASSIGN          reduce using rule 127 (term -> factor .)
    PLUS_ASSIGN     reduce using rule 127 (term -> factor .)
    MINUS_ASSIGN    reduce using rule 127 (term -> factor .)
    MUL_ASSIGN      reduce using rule 127 (term -> factor .)
    DIV_ASSIGN      reduce using rule 127 (term -> factor .)
    AND_ASSIGN      reduce using rule 127 (term -> factor .)
    OR_ASSIGN       reduce using rule 127 (term -> factor .)
    XOR_ASSIGN      reduce using rule 127 (term -> factor .)
    MOD_ASSIGN      reduce using rule 127 (term -> factor .)
    L_SHIFT_ASSIGN  reduce using rule 127 (term -> factor .)
    R_SHIFT_ASSIGN  reduce using rule 127 (term -> factor .)
    R_PAREN         reduce using rule 127 (term -> factor .)
    COMMA           reduce using rule 127 (term -> factor .)
    R_SQBRACE       reduce using rule 127 (term -> factor .)
    R_FLOWBRACE     reduce using rule 127 (term -> factor .)


state 40

    (128) factor -> NOT . factor
    (128) factor -> . NOT factor
    (129) factor -> . PLUS factor
    (130) factor -> . MINUS factor
    (131) factor -> . PLUS_PLUS factor
    (132) factor -> . MINUS_MINUS factor
    (133) factor -> . cast brace
    (134) factor -> . brace
    (135) cast -> . L_PAREN TYPE R_PAREN
    (136) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (137) brace -> . L_PAREN expr R_PAREN
    (138) brace -> . brace PLUS_PLUS
    (139) brace -> . brace MINUS_MINUS
    (140) brace -> . NUM
    (141) brace -> . STRING
    (142) brace -> . MULTIPLY ID
    (143) brace -> . BIT_AND ID
    (144) brace -> . ID
    (145) brace -> . CHAR
    (146) brace -> . function_call
    (147) brace -> . ID narrayindex
    (148) NUM -> . INT_NUM
    (149) NUM -> . FLOAT_NUM
    (64) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    factor                         shift and go to state 107
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 41

    (131) factor -> PLUS_PLUS . factor
    (128) factor -> . NOT factor
    (129) factor -> . PLUS factor
    (130) factor -> . MINUS factor
    (131) factor -> . PLUS_PLUS factor
    (132) factor -> . MINUS_MINUS factor
    (133) factor -> . cast brace
    (134) factor -> . brace
    (135) cast -> . L_PAREN TYPE R_PAREN
    (136) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (137) brace -> . L_PAREN expr R_PAREN
    (138) brace -> . brace PLUS_PLUS
    (139) brace -> . brace MINUS_MINUS
    (140) brace -> . NUM
    (141) brace -> . STRING
    (142) brace -> . MULTIPLY ID
    (143) brace -> . BIT_AND ID
    (144) brace -> . ID
    (145) brace -> . CHAR
    (146) brace -> . function_call
    (147) brace -> . ID narrayindex
    (148) NUM -> . INT_NUM
    (149) NUM -> . FLOAT_NUM
    (64) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    factor                         shift and go to state 108
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 42

    (132) factor -> MINUS_MINUS . factor
    (128) factor -> . NOT factor
    (129) factor -> . PLUS factor
    (130) factor -> . MINUS factor
    (131) factor -> . PLUS_PLUS factor
    (132) factor -> . MINUS_MINUS factor
    (133) factor -> . cast brace
    (134) factor -> . brace
    (135) cast -> . L_PAREN TYPE R_PAREN
    (136) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (137) brace -> . L_PAREN expr R_PAREN
    (138) brace -> . brace PLUS_PLUS
    (139) brace -> . brace MINUS_MINUS
    (140) brace -> . NUM
    (141) brace -> . STRING
    (142) brace -> . MULTIPLY ID
    (143) brace -> . BIT_AND ID
    (144) brace -> . ID
    (145) brace -> . CHAR
    (146) brace -> . function_call
    (147) brace -> . ID narrayindex
    (148) NUM -> . INT_NUM
    (149) NUM -> . FLOAT_NUM
    (64) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    factor                         shift and go to state 109
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 43

    (133) factor -> cast . brace
    (137) brace -> . L_PAREN expr R_PAREN
    (138) brace -> . brace PLUS_PLUS
    (139) brace -> . brace MINUS_MINUS
    (140) brace -> . NUM
    (141) brace -> . STRING
    (142) brace -> . MULTIPLY ID
    (143) brace -> . BIT_AND ID
    (144) brace -> . ID
    (145) brace -> . CHAR
    (146) brace -> . function_call
    (147) brace -> . ID narrayindex
    (148) NUM -> . INT_NUM
    (149) NUM -> . FLOAT_NUM
    (64) function_call -> . ID L_PAREN call_params R_PAREN

    L_PAREN         shift and go to state 111
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    brace                          shift and go to state 110
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 44

    (134) factor -> brace .
    (138) brace -> brace . PLUS_PLUS
    (139) brace -> brace . MINUS_MINUS

    MULTIPLY        reduce using rule 134 (factor -> brace .)
    DIVIDE          reduce using rule 134 (factor -> brace .)
    MOD             reduce using rule 134 (factor -> brace .)
    PLUS            reduce using rule 134 (factor -> brace .)
    MINUS           reduce using rule 134 (factor -> brace .)
    L_SHIFT         reduce using rule 134 (factor -> brace .)
    R_SHIFT         reduce using rule 134 (factor -> brace .)
    LE              reduce using rule 134 (factor -> brace .)
    LT              reduce using rule 134 (factor -> brace .)
    GE              reduce using rule 134 (factor -> brace .)
    GT              reduce using rule 134 (factor -> brace .)
    EQ              reduce using rule 134 (factor -> brace .)
    NE              reduce using rule 134 (factor -> brace .)
    BIT_AND         reduce using rule 134 (factor -> brace .)
    BIT_XOR         reduce using rule 134 (factor -> brace .)
    BIT_OR          reduce using rule 134 (factor -> brace .)
    AND             reduce using rule 134 (factor -> brace .)
    OR              reduce using rule 134 (factor -> brace .)
    SEMICOLON       reduce using rule 134 (factor -> brace .)
    ASSIGN          reduce using rule 134 (factor -> brace .)
    PLUS_ASSIGN     reduce using rule 134 (factor -> brace .)
    MINUS_ASSIGN    reduce using rule 134 (factor -> brace .)
    MUL_ASSIGN      reduce using rule 134 (factor -> brace .)
    DIV_ASSIGN      reduce using rule 134 (factor -> brace .)
    AND_ASSIGN      reduce using rule 134 (factor -> brace .)
    OR_ASSIGN       reduce using rule 134 (factor -> brace .)
    XOR_ASSIGN      reduce using rule 134 (factor -> brace .)
    MOD_ASSIGN      reduce using rule 134 (factor -> brace .)
    L_SHIFT_ASSIGN  reduce using rule 134 (factor -> brace .)
    R_SHIFT_ASSIGN  reduce using rule 134 (factor -> brace .)
    R_PAREN         reduce using rule 134 (factor -> brace .)
    COMMA           reduce using rule 134 (factor -> brace .)
    R_SQBRACE       reduce using rule 134 (factor -> brace .)
    R_FLOWBRACE     reduce using rule 134 (factor -> brace .)
    PLUS_PLUS       shift and go to state 112
    MINUS_MINUS     shift and go to state 113


state 45

    (140) brace -> NUM .

    PLUS_PLUS       reduce using rule 140 (brace -> NUM .)
    MINUS_MINUS     reduce using rule 140 (brace -> NUM .)
    MULTIPLY        reduce using rule 140 (brace -> NUM .)
    DIVIDE          reduce using rule 140 (brace -> NUM .)
    MOD             reduce using rule 140 (brace -> NUM .)
    PLUS            reduce using rule 140 (brace -> NUM .)
    MINUS           reduce using rule 140 (brace -> NUM .)
    L_SHIFT         reduce using rule 140 (brace -> NUM .)
    R_SHIFT         reduce using rule 140 (brace -> NUM .)
    LE              reduce using rule 140 (brace -> NUM .)
    LT              reduce using rule 140 (brace -> NUM .)
    GE              reduce using rule 140 (brace -> NUM .)
    GT              reduce using rule 140 (brace -> NUM .)
    EQ              reduce using rule 140 (brace -> NUM .)
    NE              reduce using rule 140 (brace -> NUM .)
    BIT_AND         reduce using rule 140 (brace -> NUM .)
    BIT_XOR         reduce using rule 140 (brace -> NUM .)
    BIT_OR          reduce using rule 140 (brace -> NUM .)
    AND             reduce using rule 140 (brace -> NUM .)
    OR              reduce using rule 140 (brace -> NUM .)
    SEMICOLON       reduce using rule 140 (brace -> NUM .)
    ASSIGN          reduce using rule 140 (brace -> NUM .)
    PLUS_ASSIGN     reduce using rule 140 (brace -> NUM .)
    MINUS_ASSIGN    reduce using rule 140 (brace -> NUM .)
    MUL_ASSIGN      reduce using rule 140 (brace -> NUM .)
    DIV_ASSIGN      reduce using rule 140 (brace -> NUM .)
    AND_ASSIGN      reduce using rule 140 (brace -> NUM .)
    OR_ASSIGN       reduce using rule 140 (brace -> NUM .)
    XOR_ASSIGN      reduce using rule 140 (brace -> NUM .)
    MOD_ASSIGN      reduce using rule 140 (brace -> NUM .)
    L_SHIFT_ASSIGN  reduce using rule 140 (brace -> NUM .)
    R_SHIFT_ASSIGN  reduce using rule 140 (brace -> NUM .)
    R_PAREN         reduce using rule 140 (brace -> NUM .)
    COMMA           reduce using rule 140 (brace -> NUM .)
    R_SQBRACE       reduce using rule 140 (brace -> NUM .)
    R_FLOWBRACE     reduce using rule 140 (brace -> NUM .)


state 46

    (145) brace -> CHAR .

    PLUS_PLUS       reduce using rule 145 (brace -> CHAR .)
    MINUS_MINUS     reduce using rule 145 (brace -> CHAR .)
    MULTIPLY        reduce using rule 145 (brace -> CHAR .)
    DIVIDE          reduce using rule 145 (brace -> CHAR .)
    MOD             reduce using rule 145 (brace -> CHAR .)
    PLUS            reduce using rule 145 (brace -> CHAR .)
    MINUS           reduce using rule 145 (brace -> CHAR .)
    L_SHIFT         reduce using rule 145 (brace -> CHAR .)
    R_SHIFT         reduce using rule 145 (brace -> CHAR .)
    LE              reduce using rule 145 (brace -> CHAR .)
    LT              reduce using rule 145 (brace -> CHAR .)
    GE              reduce using rule 145 (brace -> CHAR .)
    GT              reduce using rule 145 (brace -> CHAR .)
    EQ              reduce using rule 145 (brace -> CHAR .)
    NE              reduce using rule 145 (brace -> CHAR .)
    BIT_AND         reduce using rule 145 (brace -> CHAR .)
    BIT_XOR         reduce using rule 145 (brace -> CHAR .)
    BIT_OR          reduce using rule 145 (brace -> CHAR .)
    AND             reduce using rule 145 (brace -> CHAR .)
    OR              reduce using rule 145 (brace -> CHAR .)
    SEMICOLON       reduce using rule 145 (brace -> CHAR .)
    ASSIGN          reduce using rule 145 (brace -> CHAR .)
    PLUS_ASSIGN     reduce using rule 145 (brace -> CHAR .)
    MINUS_ASSIGN    reduce using rule 145 (brace -> CHAR .)
    MUL_ASSIGN      reduce using rule 145 (brace -> CHAR .)
    DIV_ASSIGN      reduce using rule 145 (brace -> CHAR .)
    AND_ASSIGN      reduce using rule 145 (brace -> CHAR .)
    OR_ASSIGN       reduce using rule 145 (brace -> CHAR .)
    XOR_ASSIGN      reduce using rule 145 (brace -> CHAR .)
    MOD_ASSIGN      reduce using rule 145 (brace -> CHAR .)
    L_SHIFT_ASSIGN  reduce using rule 145 (brace -> CHAR .)
    R_SHIFT_ASSIGN  reduce using rule 145 (brace -> CHAR .)
    R_PAREN         reduce using rule 145 (brace -> CHAR .)
    COMMA           reduce using rule 145 (brace -> CHAR .)
    R_SQBRACE       reduce using rule 145 (brace -> CHAR .)
    R_FLOWBRACE     reduce using rule 145 (brace -> CHAR .)


state 47

    (146) brace -> function_call .

    PLUS_PLUS       reduce using rule 146 (brace -> function_call .)
    MINUS_MINUS     reduce using rule 146 (brace -> function_call .)
    MULTIPLY        reduce using rule 146 (brace -> function_call .)
    DIVIDE          reduce using rule 146 (brace -> function_call .)
    MOD             reduce using rule 146 (brace -> function_call .)
    PLUS            reduce using rule 146 (brace -> function_call .)
    MINUS           reduce using rule 146 (brace -> function_call .)
    L_SHIFT         reduce using rule 146 (brace -> function_call .)
    R_SHIFT         reduce using rule 146 (brace -> function_call .)
    LE              reduce using rule 146 (brace -> function_call .)
    LT              reduce using rule 146 (brace -> function_call .)
    GE              reduce using rule 146 (brace -> function_call .)
    GT              reduce using rule 146 (brace -> function_call .)
    EQ              reduce using rule 146 (brace -> function_call .)
    NE              reduce using rule 146 (brace -> function_call .)
    BIT_AND         reduce using rule 146 (brace -> function_call .)
    BIT_XOR         reduce using rule 146 (brace -> function_call .)
    BIT_OR          reduce using rule 146 (brace -> function_call .)
    AND             reduce using rule 146 (brace -> function_call .)
    OR              reduce using rule 146 (brace -> function_call .)
    SEMICOLON       reduce using rule 146 (brace -> function_call .)
    ASSIGN          reduce using rule 146 (brace -> function_call .)
    PLUS_ASSIGN     reduce using rule 146 (brace -> function_call .)
    MINUS_ASSIGN    reduce using rule 146 (brace -> function_call .)
    MUL_ASSIGN      reduce using rule 146 (brace -> function_call .)
    DIV_ASSIGN      reduce using rule 146 (brace -> function_call .)
    AND_ASSIGN      reduce using rule 146 (brace -> function_call .)
    OR_ASSIGN       reduce using rule 146 (brace -> function_call .)
    XOR_ASSIGN      reduce using rule 146 (brace -> function_call .)
    MOD_ASSIGN      reduce using rule 146 (brace -> function_call .)
    L_SHIFT_ASSIGN  reduce using rule 146 (brace -> function_call .)
    R_SHIFT_ASSIGN  reduce using rule 146 (brace -> function_call .)
    R_PAREN         reduce using rule 146 (brace -> function_call .)
    COMMA           reduce using rule 146 (brace -> function_call .)
    R_SQBRACE       reduce using rule 146 (brace -> function_call .)
    R_FLOWBRACE     reduce using rule 146 (brace -> function_call .)


state 48

    (148) NUM -> INT_NUM .

    PLUS_PLUS       reduce using rule 148 (NUM -> INT_NUM .)
    MINUS_MINUS     reduce using rule 148 (NUM -> INT_NUM .)
    MULTIPLY        reduce using rule 148 (NUM -> INT_NUM .)
    DIVIDE          reduce using rule 148 (NUM -> INT_NUM .)
    MOD             reduce using rule 148 (NUM -> INT_NUM .)
    PLUS            reduce using rule 148 (NUM -> INT_NUM .)
    MINUS           reduce using rule 148 (NUM -> INT_NUM .)
    L_SHIFT         reduce using rule 148 (NUM -> INT_NUM .)
    R_SHIFT         reduce using rule 148 (NUM -> INT_NUM .)
    LE              reduce using rule 148 (NUM -> INT_NUM .)
    LT              reduce using rule 148 (NUM -> INT_NUM .)
    GE              reduce using rule 148 (NUM -> INT_NUM .)
    GT              reduce using rule 148 (NUM -> INT_NUM .)
    EQ              reduce using rule 148 (NUM -> INT_NUM .)
    NE              reduce using rule 148 (NUM -> INT_NUM .)
    BIT_AND         reduce using rule 148 (NUM -> INT_NUM .)
    BIT_XOR         reduce using rule 148 (NUM -> INT_NUM .)
    BIT_OR          reduce using rule 148 (NUM -> INT_NUM .)
    AND             reduce using rule 148 (NUM -> INT_NUM .)
    OR              reduce using rule 148 (NUM -> INT_NUM .)
    SEMICOLON       reduce using rule 148 (NUM -> INT_NUM .)
    ASSIGN          reduce using rule 148 (NUM -> INT_NUM .)
    PLUS_ASSIGN     reduce using rule 148 (NUM -> INT_NUM .)
    MINUS_ASSIGN    reduce using rule 148 (NUM -> INT_NUM .)
    MUL_ASSIGN      reduce using rule 148 (NUM -> INT_NUM .)
    DIV_ASSIGN      reduce using rule 148 (NUM -> INT_NUM .)
    AND_ASSIGN      reduce using rule 148 (NUM -> INT_NUM .)
    OR_ASSIGN       reduce using rule 148 (NUM -> INT_NUM .)
    XOR_ASSIGN      reduce using rule 148 (NUM -> INT_NUM .)
    MOD_ASSIGN      reduce using rule 148 (NUM -> INT_NUM .)
    L_SHIFT_ASSIGN  reduce using rule 148 (NUM -> INT_NUM .)
    R_SHIFT_ASSIGN  reduce using rule 148 (NUM -> INT_NUM .)
    R_PAREN         reduce using rule 148 (NUM -> INT_NUM .)
    COMMA           reduce using rule 148 (NUM -> INT_NUM .)
    R_SQBRACE       reduce using rule 148 (NUM -> INT_NUM .)
    R_FLOWBRACE     reduce using rule 148 (NUM -> INT_NUM .)


state 49

    (149) NUM -> FLOAT_NUM .

    PLUS_PLUS       reduce using rule 149 (NUM -> FLOAT_NUM .)
    MINUS_MINUS     reduce using rule 149 (NUM -> FLOAT_NUM .)
    MULTIPLY        reduce using rule 149 (NUM -> FLOAT_NUM .)
    DIVIDE          reduce using rule 149 (NUM -> FLOAT_NUM .)
    MOD             reduce using rule 149 (NUM -> FLOAT_NUM .)
    PLUS            reduce using rule 149 (NUM -> FLOAT_NUM .)
    MINUS           reduce using rule 149 (NUM -> FLOAT_NUM .)
    L_SHIFT         reduce using rule 149 (NUM -> FLOAT_NUM .)
    R_SHIFT         reduce using rule 149 (NUM -> FLOAT_NUM .)
    LE              reduce using rule 149 (NUM -> FLOAT_NUM .)
    LT              reduce using rule 149 (NUM -> FLOAT_NUM .)
    GE              reduce using rule 149 (NUM -> FLOAT_NUM .)
    GT              reduce using rule 149 (NUM -> FLOAT_NUM .)
    EQ              reduce using rule 149 (NUM -> FLOAT_NUM .)
    NE              reduce using rule 149 (NUM -> FLOAT_NUM .)
    BIT_AND         reduce using rule 149 (NUM -> FLOAT_NUM .)
    BIT_XOR         reduce using rule 149 (NUM -> FLOAT_NUM .)
    BIT_OR          reduce using rule 149 (NUM -> FLOAT_NUM .)
    AND             reduce using rule 149 (NUM -> FLOAT_NUM .)
    OR              reduce using rule 149 (NUM -> FLOAT_NUM .)
    SEMICOLON       reduce using rule 149 (NUM -> FLOAT_NUM .)
    ASSIGN          reduce using rule 149 (NUM -> FLOAT_NUM .)
    PLUS_ASSIGN     reduce using rule 149 (NUM -> FLOAT_NUM .)
    MINUS_ASSIGN    reduce using rule 149 (NUM -> FLOAT_NUM .)
    MUL_ASSIGN      reduce using rule 149 (NUM -> FLOAT_NUM .)
    DIV_ASSIGN      reduce using rule 149 (NUM -> FLOAT_NUM .)
    AND_ASSIGN      reduce using rule 149 (NUM -> FLOAT_NUM .)
    OR_ASSIGN       reduce using rule 149 (NUM -> FLOAT_NUM .)
    XOR_ASSIGN      reduce using rule 149 (NUM -> FLOAT_NUM .)
    MOD_ASSIGN      reduce using rule 149 (NUM -> FLOAT_NUM .)
    L_SHIFT_ASSIGN  reduce using rule 149 (NUM -> FLOAT_NUM .)
    R_SHIFT_ASSIGN  reduce using rule 149 (NUM -> FLOAT_NUM .)
    R_PAREN         reduce using rule 149 (NUM -> FLOAT_NUM .)
    COMMA           reduce using rule 149 (NUM -> FLOAT_NUM .)
    R_SQBRACE       reduce using rule 149 (NUM -> FLOAT_NUM .)
    R_FLOWBRACE     reduce using rule 149 (NUM -> FLOAT_NUM .)


state 50

    (2) multiple_statements -> multiple_statements statement .

    IF              reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    WHILE           reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    FOR             reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    SEMICOLON       reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    RETURN          reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    HASH            reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    TYPE            reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    L_FLOWBRACE     reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    NOT             reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    PLUS            reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    MINUS           reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    PLUS_PLUS       reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    MINUS_MINUS     reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    L_PAREN         reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    STRING          reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    MULTIPLY        reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    BIT_AND         reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    ID              reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    CHAR            reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    INT_NUM         reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    FLOAT_NUM       reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    $end            reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    R_FLOWBRACE     reduce using rule 2 (multiple_statements -> multiple_statements statement .)


state 51

    (7) open -> IF condition . statement
    (8) open -> IF condition . closed else open
    (14) closed -> IF condition . closed else closed
    (4) statement -> . open
    (5) statement -> . closed
    (12) closed -> . simple
    (13) closed -> . block
    (14) closed -> . IF condition closed else closed
    (15) closed -> . WHILE condition closed
    (16) closed -> . for for_condition closed
    (7) open -> . IF condition statement
    (8) open -> . IF condition closed else open
    (9) open -> . WHILE condition open
    (10) open -> . for for_condition open
    (54) simple -> . expr SEMICOLON
    (55) simple -> . header
    (56) simple -> . declaration
    (57) simple -> . SEMICOLON
    (58) simple -> . function
    (59) simple -> . RETURN expr SEMICOLON
    (60) simple -> . RETURN SEMICOLON
    (50) block -> . left_flower multiple_statements right_flower
    (51) block -> . left_flower right_flower
    (11) for -> . FOR
    (86) expr -> . expr assignment exprOR
    (87) expr -> . exprOR
    (61) header -> . HASH INCLUDE STRING
    (62) header -> . HASH INCLUDE HEADER_FILE
    (35) declaration -> . TYPE ID SEMICOLON
    (36) declaration -> . TYPE MULTIPLY ID SEMICOLON
    (37) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (38) declaration -> . TYPE MULTIPLY ID ASSIGN expr SEMICOLON
    (39) declaration -> . TYPE multi_declaration stop
    (40) declaration -> . TYPE ID narrayindex SEMICOLON
    (41) declaration -> . TYPE ID narrayindex ASSIGN init_list SEMICOLON
    (83) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (52) left_flower -> . L_FLOWBRACE
    (99) exprOR -> . exprOR OR exprAND
    (100) exprOR -> . exprAND
    (101) exprAND -> . exprAND AND exprBITOR
    (102) exprAND -> . exprBITOR
    (103) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (104) exprBITOR -> . exprBITXOR
    (105) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (106) exprBITXOR -> . exprBITAND
    (107) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (108) exprBITAND -> . exprEQ
    (109) exprEQ -> . exprEQ EQ exprRELOP
    (110) exprEQ -> . exprEQ NE exprRELOP
    (111) exprEQ -> . exprRELOP
    (112) exprRELOP -> . exprRELOP relop exprSHIFT
    (113) exprRELOP -> . exprSHIFT
    (118) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (119) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (120) exprSHIFT -> . exprOP
    (121) exprOP -> . exprOP PLUS term
    (122) exprOP -> . exprOP MINUS term
    (123) exprOP -> . term
    (124) term -> . term MULTIPLY factor
    (125) term -> . term DIVIDE factor
    (126) term -> . term MOD factor
    (127) term -> . factor
    (128) factor -> . NOT factor
    (129) factor -> . PLUS factor
    (130) factor -> . MINUS factor
    (131) factor -> . PLUS_PLUS factor
    (132) factor -> . MINUS_MINUS factor
    (133) factor -> . cast brace
    (134) factor -> . brace
    (135) cast -> . L_PAREN TYPE R_PAREN
    (136) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (137) brace -> . L_PAREN expr R_PAREN
    (138) brace -> . brace PLUS_PLUS
    (139) brace -> . brace MINUS_MINUS
    (140) brace -> . NUM
    (141) brace -> . STRING
    (142) brace -> . MULTIPLY ID
    (143) brace -> . BIT_AND ID
    (144) brace -> . ID
    (145) brace -> . CHAR
    (146) brace -> . function_call
    (147) brace -> . ID narrayindex
    (148) NUM -> . INT_NUM
    (149) NUM -> . FLOAT_NUM
    (64) function_call -> . ID L_PAREN call_params R_PAREN

    IF              shift and go to state 114
    WHILE           shift and go to state 117
    SEMICOLON       shift and go to state 13
    RETURN          shift and go to state 17
    FOR             shift and go to state 11
    HASH            shift and go to state 20
    TYPE            shift and go to state 22
    L_FLOWBRACE     shift and go to state 26
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    statement                      shift and go to state 115
    closed                         shift and go to state 116
    open                           shift and go to state 4
    simple                         shift and go to state 9
    block                          shift and go to state 10
    for                            shift and go to state 118
    expr                           shift and go to state 12
    header                         shift and go to state 14
    declaration                    shift and go to state 15
    function                       shift and go to state 16
    left_flower                    shift and go to state 18
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 52

    (17) condition -> L_PAREN . expr R_PAREN
    (86) expr -> . expr assignment exprOR
    (87) expr -> . exprOR
    (99) exprOR -> . exprOR OR exprAND
    (100) exprOR -> . exprAND
    (101) exprAND -> . exprAND AND exprBITOR
    (102) exprAND -> . exprBITOR
    (103) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (104) exprBITOR -> . exprBITXOR
    (105) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (106) exprBITXOR -> . exprBITAND
    (107) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (108) exprBITAND -> . exprEQ
    (109) exprEQ -> . exprEQ EQ exprRELOP
    (110) exprEQ -> . exprEQ NE exprRELOP
    (111) exprEQ -> . exprRELOP
    (112) exprRELOP -> . exprRELOP relop exprSHIFT
    (113) exprRELOP -> . exprSHIFT
    (118) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (119) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (120) exprSHIFT -> . exprOP
    (121) exprOP -> . exprOP PLUS term
    (122) exprOP -> . exprOP MINUS term
    (123) exprOP -> . term
    (124) term -> . term MULTIPLY factor
    (125) term -> . term DIVIDE factor
    (126) term -> . term MOD factor
    (127) term -> . factor
    (128) factor -> . NOT factor
    (129) factor -> . PLUS factor
    (130) factor -> . MINUS factor
    (131) factor -> . PLUS_PLUS factor
    (132) factor -> . MINUS_MINUS factor
    (133) factor -> . cast brace
    (134) factor -> . brace
    (135) cast -> . L_PAREN TYPE R_PAREN
    (136) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (137) brace -> . L_PAREN expr R_PAREN
    (138) brace -> . brace PLUS_PLUS
    (139) brace -> . brace MINUS_MINUS
    (140) brace -> . NUM
    (141) brace -> . STRING
    (142) brace -> . MULTIPLY ID
    (143) brace -> . BIT_AND ID
    (144) brace -> . ID
    (145) brace -> . CHAR
    (146) brace -> . function_call
    (147) brace -> . ID narrayindex
    (148) NUM -> . INT_NUM
    (149) NUM -> . FLOAT_NUM
    (64) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    expr                           shift and go to state 119
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 53

    (9) open -> WHILE condition . open
    (15) closed -> WHILE condition . closed
    (7) open -> . IF condition statement
    (8) open -> . IF condition closed else open
    (9) open -> . WHILE condition open
    (10) open -> . for for_condition open
    (12) closed -> . simple
    (13) closed -> . block
    (14) closed -> . IF condition closed else closed
    (15) closed -> . WHILE condition closed
    (16) closed -> . for for_condition closed
    (11) for -> . FOR
    (54) simple -> . expr SEMICOLON
    (55) simple -> . header
    (56) simple -> . declaration
    (57) simple -> . SEMICOLON
    (58) simple -> . function
    (59) simple -> . RETURN expr SEMICOLON
    (60) simple -> . RETURN SEMICOLON
    (50) block -> . left_flower multiple_statements right_flower
    (51) block -> . left_flower right_flower
    (86) expr -> . expr assignment exprOR
    (87) expr -> . exprOR
    (61) header -> . HASH INCLUDE STRING
    (62) header -> . HASH INCLUDE HEADER_FILE
    (35) declaration -> . TYPE ID SEMICOLON
    (36) declaration -> . TYPE MULTIPLY ID SEMICOLON
    (37) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (38) declaration -> . TYPE MULTIPLY ID ASSIGN expr SEMICOLON
    (39) declaration -> . TYPE multi_declaration stop
    (40) declaration -> . TYPE ID narrayindex SEMICOLON
    (41) declaration -> . TYPE ID narrayindex ASSIGN init_list SEMICOLON
    (83) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (52) left_flower -> . L_FLOWBRACE
    (99) exprOR -> . exprOR OR exprAND
    (100) exprOR -> . exprAND
    (101) exprAND -> . exprAND AND exprBITOR
    (102) exprAND -> . exprBITOR
    (103) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (104) exprBITOR -> . exprBITXOR
    (105) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (106) exprBITXOR -> . exprBITAND
    (107) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (108) exprBITAND -> . exprEQ
    (109) exprEQ -> . exprEQ EQ exprRELOP
    (110) exprEQ -> . exprEQ NE exprRELOP
    (111) exprEQ -> . exprRELOP
    (112) exprRELOP -> . exprRELOP relop exprSHIFT
    (113) exprRELOP -> . exprSHIFT
    (118) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (119) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (120) exprSHIFT -> . exprOP
    (121) exprOP -> . exprOP PLUS term
    (122) exprOP -> . exprOP MINUS term
    (123) exprOP -> . term
    (124) term -> . term MULTIPLY factor
    (125) term -> . term DIVIDE factor
    (126) term -> . term MOD factor
    (127) term -> . factor
    (128) factor -> . NOT factor
    (129) factor -> . PLUS factor
    (130) factor -> . MINUS factor
    (131) factor -> . PLUS_PLUS factor
    (132) factor -> . MINUS_MINUS factor
    (133) factor -> . cast brace
    (134) factor -> . brace
    (135) cast -> . L_PAREN TYPE R_PAREN
    (136) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (137) brace -> . L_PAREN expr R_PAREN
    (138) brace -> . brace PLUS_PLUS
    (139) brace -> . brace MINUS_MINUS
    (140) brace -> . NUM
    (141) brace -> . STRING
    (142) brace -> . MULTIPLY ID
    (143) brace -> . BIT_AND ID
    (144) brace -> . ID
    (145) brace -> . CHAR
    (146) brace -> . function_call
    (147) brace -> . ID narrayindex
    (148) NUM -> . INT_NUM
    (149) NUM -> . FLOAT_NUM
    (64) function_call -> . ID L_PAREN call_params R_PAREN

    IF              shift and go to state 6
    WHILE           shift and go to state 7
    FOR             shift and go to state 11
    SEMICOLON       shift and go to state 13
    RETURN          shift and go to state 17
    HASH            shift and go to state 20
    TYPE            shift and go to state 22
    L_FLOWBRACE     shift and go to state 26
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    open                           shift and go to state 120
    closed                         shift and go to state 121
    for                            shift and go to state 8
    simple                         shift and go to state 9
    block                          shift and go to state 10
    expr                           shift and go to state 12
    header                         shift and go to state 14
    declaration                    shift and go to state 15
    function                       shift and go to state 16
    left_flower                    shift and go to state 18
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 54

    (10) open -> for for_condition . open
    (16) closed -> for for_condition . closed
    (7) open -> . IF condition statement
    (8) open -> . IF condition closed else open
    (9) open -> . WHILE condition open
    (10) open -> . for for_condition open
    (12) closed -> . simple
    (13) closed -> . block
    (14) closed -> . IF condition closed else closed
    (15) closed -> . WHILE condition closed
    (16) closed -> . for for_condition closed
    (11) for -> . FOR
    (54) simple -> . expr SEMICOLON
    (55) simple -> . header
    (56) simple -> . declaration
    (57) simple -> . SEMICOLON
    (58) simple -> . function
    (59) simple -> . RETURN expr SEMICOLON
    (60) simple -> . RETURN SEMICOLON
    (50) block -> . left_flower multiple_statements right_flower
    (51) block -> . left_flower right_flower
    (86) expr -> . expr assignment exprOR
    (87) expr -> . exprOR
    (61) header -> . HASH INCLUDE STRING
    (62) header -> . HASH INCLUDE HEADER_FILE
    (35) declaration -> . TYPE ID SEMICOLON
    (36) declaration -> . TYPE MULTIPLY ID SEMICOLON
    (37) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (38) declaration -> . TYPE MULTIPLY ID ASSIGN expr SEMICOLON
    (39) declaration -> . TYPE multi_declaration stop
    (40) declaration -> . TYPE ID narrayindex SEMICOLON
    (41) declaration -> . TYPE ID narrayindex ASSIGN init_list SEMICOLON
    (83) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (52) left_flower -> . L_FLOWBRACE
    (99) exprOR -> . exprOR OR exprAND
    (100) exprOR -> . exprAND
    (101) exprAND -> . exprAND AND exprBITOR
    (102) exprAND -> . exprBITOR
    (103) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (104) exprBITOR -> . exprBITXOR
    (105) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (106) exprBITXOR -> . exprBITAND
    (107) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (108) exprBITAND -> . exprEQ
    (109) exprEQ -> . exprEQ EQ exprRELOP
    (110) exprEQ -> . exprEQ NE exprRELOP
    (111) exprEQ -> . exprRELOP
    (112) exprRELOP -> . exprRELOP relop exprSHIFT
    (113) exprRELOP -> . exprSHIFT
    (118) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (119) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (120) exprSHIFT -> . exprOP
    (121) exprOP -> . exprOP PLUS term
    (122) exprOP -> . exprOP MINUS term
    (123) exprOP -> . term
    (124) term -> . term MULTIPLY factor
    (125) term -> . term DIVIDE factor
    (126) term -> . term MOD factor
    (127) term -> . factor
    (128) factor -> . NOT factor
    (129) factor -> . PLUS factor
    (130) factor -> . MINUS factor
    (131) factor -> . PLUS_PLUS factor
    (132) factor -> . MINUS_MINUS factor
    (133) factor -> . cast brace
    (134) factor -> . brace
    (135) cast -> . L_PAREN TYPE R_PAREN
    (136) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (137) brace -> . L_PAREN expr R_PAREN
    (138) brace -> . brace PLUS_PLUS
    (139) brace -> . brace MINUS_MINUS
    (140) brace -> . NUM
    (141) brace -> . STRING
    (142) brace -> . MULTIPLY ID
    (143) brace -> . BIT_AND ID
    (144) brace -> . ID
    (145) brace -> . CHAR
    (146) brace -> . function_call
    (147) brace -> . ID narrayindex
    (148) NUM -> . INT_NUM
    (149) NUM -> . FLOAT_NUM
    (64) function_call -> . ID L_PAREN call_params R_PAREN

    IF              shift and go to state 6
    WHILE           shift and go to state 7
    FOR             shift and go to state 11
    SEMICOLON       shift and go to state 13
    RETURN          shift and go to state 17
    HASH            shift and go to state 20
    TYPE            shift and go to state 22
    L_FLOWBRACE     shift and go to state 26
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    for                            shift and go to state 8
    open                           shift and go to state 122
    closed                         shift and go to state 123
    simple                         shift and go to state 9
    block                          shift and go to state 10
    expr                           shift and go to state 12
    header                         shift and go to state 14
    declaration                    shift and go to state 15
    function                       shift and go to state 16
    left_flower                    shift and go to state 18
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 55

    (18) for_condition -> L_PAREN . simple simple expr R_PAREN
    (19) for_condition -> L_PAREN . simple simple R_PAREN
    (54) simple -> . expr SEMICOLON
    (55) simple -> . header
    (56) simple -> . declaration
    (57) simple -> . SEMICOLON
    (58) simple -> . function
    (59) simple -> . RETURN expr SEMICOLON
    (60) simple -> . RETURN SEMICOLON
    (86) expr -> . expr assignment exprOR
    (87) expr -> . exprOR
    (61) header -> . HASH INCLUDE STRING
    (62) header -> . HASH INCLUDE HEADER_FILE
    (35) declaration -> . TYPE ID SEMICOLON
    (36) declaration -> . TYPE MULTIPLY ID SEMICOLON
    (37) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (38) declaration -> . TYPE MULTIPLY ID ASSIGN expr SEMICOLON
    (39) declaration -> . TYPE multi_declaration stop
    (40) declaration -> . TYPE ID narrayindex SEMICOLON
    (41) declaration -> . TYPE ID narrayindex ASSIGN init_list SEMICOLON
    (83) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (99) exprOR -> . exprOR OR exprAND
    (100) exprOR -> . exprAND
    (101) exprAND -> . exprAND AND exprBITOR
    (102) exprAND -> . exprBITOR
    (103) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (104) exprBITOR -> . exprBITXOR
    (105) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (106) exprBITXOR -> . exprBITAND
    (107) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (108) exprBITAND -> . exprEQ
    (109) exprEQ -> . exprEQ EQ exprRELOP
    (110) exprEQ -> . exprEQ NE exprRELOP
    (111) exprEQ -> . exprRELOP
    (112) exprRELOP -> . exprRELOP relop exprSHIFT
    (113) exprRELOP -> . exprSHIFT
    (118) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (119) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (120) exprSHIFT -> . exprOP
    (121) exprOP -> . exprOP PLUS term
    (122) exprOP -> . exprOP MINUS term
    (123) exprOP -> . term
    (124) term -> . term MULTIPLY factor
    (125) term -> . term DIVIDE factor
    (126) term -> . term MOD factor
    (127) term -> . factor
    (128) factor -> . NOT factor
    (129) factor -> . PLUS factor
    (130) factor -> . MINUS factor
    (131) factor -> . PLUS_PLUS factor
    (132) factor -> . MINUS_MINUS factor
    (133) factor -> . cast brace
    (134) factor -> . brace
    (135) cast -> . L_PAREN TYPE R_PAREN
    (136) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (137) brace -> . L_PAREN expr R_PAREN
    (138) brace -> . brace PLUS_PLUS
    (139) brace -> . brace MINUS_MINUS
    (140) brace -> . NUM
    (141) brace -> . STRING
    (142) brace -> . MULTIPLY ID
    (143) brace -> . BIT_AND ID
    (144) brace -> . ID
    (145) brace -> . CHAR
    (146) brace -> . function_call
    (147) brace -> . ID narrayindex
    (148) NUM -> . INT_NUM
    (149) NUM -> . FLOAT_NUM
    (64) function_call -> . ID L_PAREN call_params R_PAREN

    SEMICOLON       shift and go to state 13
    RETURN          shift and go to state 17
    HASH            shift and go to state 20
    TYPE            shift and go to state 22
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    simple                         shift and go to state 124
    expr                           shift and go to state 12
    header                         shift and go to state 14
    declaration                    shift and go to state 15
    function                       shift and go to state 16
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 56

    (54) simple -> expr SEMICOLON .

    IF              reduce using rule 54 (simple -> expr SEMICOLON .)
    WHILE           reduce using rule 54 (simple -> expr SEMICOLON .)
    FOR             reduce using rule 54 (simple -> expr SEMICOLON .)
    SEMICOLON       reduce using rule 54 (simple -> expr SEMICOLON .)
    RETURN          reduce using rule 54 (simple -> expr SEMICOLON .)
    HASH            reduce using rule 54 (simple -> expr SEMICOLON .)
    TYPE            reduce using rule 54 (simple -> expr SEMICOLON .)
    L_FLOWBRACE     reduce using rule 54 (simple -> expr SEMICOLON .)
    NOT             reduce using rule 54 (simple -> expr SEMICOLON .)
    PLUS            reduce using rule 54 (simple -> expr SEMICOLON .)
    MINUS           reduce using rule 54 (simple -> expr SEMICOLON .)
    PLUS_PLUS       reduce using rule 54 (simple -> expr SEMICOLON .)
    MINUS_MINUS     reduce using rule 54 (simple -> expr SEMICOLON .)
    L_PAREN         reduce using rule 54 (simple -> expr SEMICOLON .)
    STRING          reduce using rule 54 (simple -> expr SEMICOLON .)
    MULTIPLY        reduce using rule 54 (simple -> expr SEMICOLON .)
    BIT_AND         reduce using rule 54 (simple -> expr SEMICOLON .)
    ID              reduce using rule 54 (simple -> expr SEMICOLON .)
    CHAR            reduce using rule 54 (simple -> expr SEMICOLON .)
    INT_NUM         reduce using rule 54 (simple -> expr SEMICOLON .)
    FLOAT_NUM       reduce using rule 54 (simple -> expr SEMICOLON .)
    $end            reduce using rule 54 (simple -> expr SEMICOLON .)
    R_FLOWBRACE     reduce using rule 54 (simple -> expr SEMICOLON .)
    ELSE            reduce using rule 54 (simple -> expr SEMICOLON .)
    R_PAREN         reduce using rule 54 (simple -> expr SEMICOLON .)


state 57

    (86) expr -> expr assignment . exprOR
    (99) exprOR -> . exprOR OR exprAND
    (100) exprOR -> . exprAND
    (101) exprAND -> . exprAND AND exprBITOR
    (102) exprAND -> . exprBITOR
    (103) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (104) exprBITOR -> . exprBITXOR
    (105) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (106) exprBITXOR -> . exprBITAND
    (107) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (108) exprBITAND -> . exprEQ
    (109) exprEQ -> . exprEQ EQ exprRELOP
    (110) exprEQ -> . exprEQ NE exprRELOP
    (111) exprEQ -> . exprRELOP
    (112) exprRELOP -> . exprRELOP relop exprSHIFT
    (113) exprRELOP -> . exprSHIFT
    (118) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (119) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (120) exprSHIFT -> . exprOP
    (121) exprOP -> . exprOP PLUS term
    (122) exprOP -> . exprOP MINUS term
    (123) exprOP -> . term
    (124) term -> . term MULTIPLY factor
    (125) term -> . term DIVIDE factor
    (126) term -> . term MOD factor
    (127) term -> . factor
    (128) factor -> . NOT factor
    (129) factor -> . PLUS factor
    (130) factor -> . MINUS factor
    (131) factor -> . PLUS_PLUS factor
    (132) factor -> . MINUS_MINUS factor
    (133) factor -> . cast brace
    (134) factor -> . brace
    (135) cast -> . L_PAREN TYPE R_PAREN
    (136) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (137) brace -> . L_PAREN expr R_PAREN
    (138) brace -> . brace PLUS_PLUS
    (139) brace -> . brace MINUS_MINUS
    (140) brace -> . NUM
    (141) brace -> . STRING
    (142) brace -> . MULTIPLY ID
    (143) brace -> . BIT_AND ID
    (144) brace -> . ID
    (145) brace -> . CHAR
    (146) brace -> . function_call
    (147) brace -> . ID narrayindex
    (148) NUM -> . INT_NUM
    (149) NUM -> . FLOAT_NUM
    (64) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    exprOR                         shift and go to state 125
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 58

    (88) assignment -> ASSIGN .

    NOT             reduce using rule 88 (assignment -> ASSIGN .)
    PLUS            reduce using rule 88 (assignment -> ASSIGN .)
    MINUS           reduce using rule 88 (assignment -> ASSIGN .)
    PLUS_PLUS       reduce using rule 88 (assignment -> ASSIGN .)
    MINUS_MINUS     reduce using rule 88 (assignment -> ASSIGN .)
    L_PAREN         reduce using rule 88 (assignment -> ASSIGN .)
    STRING          reduce using rule 88 (assignment -> ASSIGN .)
    MULTIPLY        reduce using rule 88 (assignment -> ASSIGN .)
    BIT_AND         reduce using rule 88 (assignment -> ASSIGN .)
    ID              reduce using rule 88 (assignment -> ASSIGN .)
    CHAR            reduce using rule 88 (assignment -> ASSIGN .)
    INT_NUM         reduce using rule 88 (assignment -> ASSIGN .)
    FLOAT_NUM       reduce using rule 88 (assignment -> ASSIGN .)


state 59

    (89) assignment -> PLUS_ASSIGN .

    NOT             reduce using rule 89 (assignment -> PLUS_ASSIGN .)
    PLUS            reduce using rule 89 (assignment -> PLUS_ASSIGN .)
    MINUS           reduce using rule 89 (assignment -> PLUS_ASSIGN .)
    PLUS_PLUS       reduce using rule 89 (assignment -> PLUS_ASSIGN .)
    MINUS_MINUS     reduce using rule 89 (assignment -> PLUS_ASSIGN .)
    L_PAREN         reduce using rule 89 (assignment -> PLUS_ASSIGN .)
    STRING          reduce using rule 89 (assignment -> PLUS_ASSIGN .)
    MULTIPLY        reduce using rule 89 (assignment -> PLUS_ASSIGN .)
    BIT_AND         reduce using rule 89 (assignment -> PLUS_ASSIGN .)
    ID              reduce using rule 89 (assignment -> PLUS_ASSIGN .)
    CHAR            reduce using rule 89 (assignment -> PLUS_ASSIGN .)
    INT_NUM         reduce using rule 89 (assignment -> PLUS_ASSIGN .)
    FLOAT_NUM       reduce using rule 89 (assignment -> PLUS_ASSIGN .)


state 60

    (90) assignment -> MINUS_ASSIGN .

    NOT             reduce using rule 90 (assignment -> MINUS_ASSIGN .)
    PLUS            reduce using rule 90 (assignment -> MINUS_ASSIGN .)
    MINUS           reduce using rule 90 (assignment -> MINUS_ASSIGN .)
    PLUS_PLUS       reduce using rule 90 (assignment -> MINUS_ASSIGN .)
    MINUS_MINUS     reduce using rule 90 (assignment -> MINUS_ASSIGN .)
    L_PAREN         reduce using rule 90 (assignment -> MINUS_ASSIGN .)
    STRING          reduce using rule 90 (assignment -> MINUS_ASSIGN .)
    MULTIPLY        reduce using rule 90 (assignment -> MINUS_ASSIGN .)
    BIT_AND         reduce using rule 90 (assignment -> MINUS_ASSIGN .)
    ID              reduce using rule 90 (assignment -> MINUS_ASSIGN .)
    CHAR            reduce using rule 90 (assignment -> MINUS_ASSIGN .)
    INT_NUM         reduce using rule 90 (assignment -> MINUS_ASSIGN .)
    FLOAT_NUM       reduce using rule 90 (assignment -> MINUS_ASSIGN .)


state 61

    (91) assignment -> MUL_ASSIGN .

    NOT             reduce using rule 91 (assignment -> MUL_ASSIGN .)
    PLUS            reduce using rule 91 (assignment -> MUL_ASSIGN .)
    MINUS           reduce using rule 91 (assignment -> MUL_ASSIGN .)
    PLUS_PLUS       reduce using rule 91 (assignment -> MUL_ASSIGN .)
    MINUS_MINUS     reduce using rule 91 (assignment -> MUL_ASSIGN .)
    L_PAREN         reduce using rule 91 (assignment -> MUL_ASSIGN .)
    STRING          reduce using rule 91 (assignment -> MUL_ASSIGN .)
    MULTIPLY        reduce using rule 91 (assignment -> MUL_ASSIGN .)
    BIT_AND         reduce using rule 91 (assignment -> MUL_ASSIGN .)
    ID              reduce using rule 91 (assignment -> MUL_ASSIGN .)
    CHAR            reduce using rule 91 (assignment -> MUL_ASSIGN .)
    INT_NUM         reduce using rule 91 (assignment -> MUL_ASSIGN .)
    FLOAT_NUM       reduce using rule 91 (assignment -> MUL_ASSIGN .)


state 62

    (92) assignment -> DIV_ASSIGN .

    NOT             reduce using rule 92 (assignment -> DIV_ASSIGN .)
    PLUS            reduce using rule 92 (assignment -> DIV_ASSIGN .)
    MINUS           reduce using rule 92 (assignment -> DIV_ASSIGN .)
    PLUS_PLUS       reduce using rule 92 (assignment -> DIV_ASSIGN .)
    MINUS_MINUS     reduce using rule 92 (assignment -> DIV_ASSIGN .)
    L_PAREN         reduce using rule 92 (assignment -> DIV_ASSIGN .)
    STRING          reduce using rule 92 (assignment -> DIV_ASSIGN .)
    MULTIPLY        reduce using rule 92 (assignment -> DIV_ASSIGN .)
    BIT_AND         reduce using rule 92 (assignment -> DIV_ASSIGN .)
    ID              reduce using rule 92 (assignment -> DIV_ASSIGN .)
    CHAR            reduce using rule 92 (assignment -> DIV_ASSIGN .)
    INT_NUM         reduce using rule 92 (assignment -> DIV_ASSIGN .)
    FLOAT_NUM       reduce using rule 92 (assignment -> DIV_ASSIGN .)


state 63

    (93) assignment -> AND_ASSIGN .

    NOT             reduce using rule 93 (assignment -> AND_ASSIGN .)
    PLUS            reduce using rule 93 (assignment -> AND_ASSIGN .)
    MINUS           reduce using rule 93 (assignment -> AND_ASSIGN .)
    PLUS_PLUS       reduce using rule 93 (assignment -> AND_ASSIGN .)
    MINUS_MINUS     reduce using rule 93 (assignment -> AND_ASSIGN .)
    L_PAREN         reduce using rule 93 (assignment -> AND_ASSIGN .)
    STRING          reduce using rule 93 (assignment -> AND_ASSIGN .)
    MULTIPLY        reduce using rule 93 (assignment -> AND_ASSIGN .)
    BIT_AND         reduce using rule 93 (assignment -> AND_ASSIGN .)
    ID              reduce using rule 93 (assignment -> AND_ASSIGN .)
    CHAR            reduce using rule 93 (assignment -> AND_ASSIGN .)
    INT_NUM         reduce using rule 93 (assignment -> AND_ASSIGN .)
    FLOAT_NUM       reduce using rule 93 (assignment -> AND_ASSIGN .)


state 64

    (94) assignment -> OR_ASSIGN .

    NOT             reduce using rule 94 (assignment -> OR_ASSIGN .)
    PLUS            reduce using rule 94 (assignment -> OR_ASSIGN .)
    MINUS           reduce using rule 94 (assignment -> OR_ASSIGN .)
    PLUS_PLUS       reduce using rule 94 (assignment -> OR_ASSIGN .)
    MINUS_MINUS     reduce using rule 94 (assignment -> OR_ASSIGN .)
    L_PAREN         reduce using rule 94 (assignment -> OR_ASSIGN .)
    STRING          reduce using rule 94 (assignment -> OR_ASSIGN .)
    MULTIPLY        reduce using rule 94 (assignment -> OR_ASSIGN .)
    BIT_AND         reduce using rule 94 (assignment -> OR_ASSIGN .)
    ID              reduce using rule 94 (assignment -> OR_ASSIGN .)
    CHAR            reduce using rule 94 (assignment -> OR_ASSIGN .)
    INT_NUM         reduce using rule 94 (assignment -> OR_ASSIGN .)
    FLOAT_NUM       reduce using rule 94 (assignment -> OR_ASSIGN .)


state 65

    (95) assignment -> XOR_ASSIGN .

    NOT             reduce using rule 95 (assignment -> XOR_ASSIGN .)
    PLUS            reduce using rule 95 (assignment -> XOR_ASSIGN .)
    MINUS           reduce using rule 95 (assignment -> XOR_ASSIGN .)
    PLUS_PLUS       reduce using rule 95 (assignment -> XOR_ASSIGN .)
    MINUS_MINUS     reduce using rule 95 (assignment -> XOR_ASSIGN .)
    L_PAREN         reduce using rule 95 (assignment -> XOR_ASSIGN .)
    STRING          reduce using rule 95 (assignment -> XOR_ASSIGN .)
    MULTIPLY        reduce using rule 95 (assignment -> XOR_ASSIGN .)
    BIT_AND         reduce using rule 95 (assignment -> XOR_ASSIGN .)
    ID              reduce using rule 95 (assignment -> XOR_ASSIGN .)
    CHAR            reduce using rule 95 (assignment -> XOR_ASSIGN .)
    INT_NUM         reduce using rule 95 (assignment -> XOR_ASSIGN .)
    FLOAT_NUM       reduce using rule 95 (assignment -> XOR_ASSIGN .)


state 66

    (96) assignment -> MOD_ASSIGN .

    NOT             reduce using rule 96 (assignment -> MOD_ASSIGN .)
    PLUS            reduce using rule 96 (assignment -> MOD_ASSIGN .)
    MINUS           reduce using rule 96 (assignment -> MOD_ASSIGN .)
    PLUS_PLUS       reduce using rule 96 (assignment -> MOD_ASSIGN .)
    MINUS_MINUS     reduce using rule 96 (assignment -> MOD_ASSIGN .)
    L_PAREN         reduce using rule 96 (assignment -> MOD_ASSIGN .)
    STRING          reduce using rule 96 (assignment -> MOD_ASSIGN .)
    MULTIPLY        reduce using rule 96 (assignment -> MOD_ASSIGN .)
    BIT_AND         reduce using rule 96 (assignment -> MOD_ASSIGN .)
    ID              reduce using rule 96 (assignment -> MOD_ASSIGN .)
    CHAR            reduce using rule 96 (assignment -> MOD_ASSIGN .)
    INT_NUM         reduce using rule 96 (assignment -> MOD_ASSIGN .)
    FLOAT_NUM       reduce using rule 96 (assignment -> MOD_ASSIGN .)


state 67

    (97) assignment -> L_SHIFT_ASSIGN .

    NOT             reduce using rule 97 (assignment -> L_SHIFT_ASSIGN .)
    PLUS            reduce using rule 97 (assignment -> L_SHIFT_ASSIGN .)
    MINUS           reduce using rule 97 (assignment -> L_SHIFT_ASSIGN .)
    PLUS_PLUS       reduce using rule 97 (assignment -> L_SHIFT_ASSIGN .)
    MINUS_MINUS     reduce using rule 97 (assignment -> L_SHIFT_ASSIGN .)
    L_PAREN         reduce using rule 97 (assignment -> L_SHIFT_ASSIGN .)
    STRING          reduce using rule 97 (assignment -> L_SHIFT_ASSIGN .)
    MULTIPLY        reduce using rule 97 (assignment -> L_SHIFT_ASSIGN .)
    BIT_AND         reduce using rule 97 (assignment -> L_SHIFT_ASSIGN .)
    ID              reduce using rule 97 (assignment -> L_SHIFT_ASSIGN .)
    CHAR            reduce using rule 97 (assignment -> L_SHIFT_ASSIGN .)
    INT_NUM         reduce using rule 97 (assignment -> L_SHIFT_ASSIGN .)
    FLOAT_NUM       reduce using rule 97 (assignment -> L_SHIFT_ASSIGN .)


state 68

    (98) assignment -> R_SHIFT_ASSIGN .

    NOT             reduce using rule 98 (assignment -> R_SHIFT_ASSIGN .)
    PLUS            reduce using rule 98 (assignment -> R_SHIFT_ASSIGN .)
    MINUS           reduce using rule 98 (assignment -> R_SHIFT_ASSIGN .)
    PLUS_PLUS       reduce using rule 98 (assignment -> R_SHIFT_ASSIGN .)
    MINUS_MINUS     reduce using rule 98 (assignment -> R_SHIFT_ASSIGN .)
    L_PAREN         reduce using rule 98 (assignment -> R_SHIFT_ASSIGN .)
    STRING          reduce using rule 98 (assignment -> R_SHIFT_ASSIGN .)
    MULTIPLY        reduce using rule 98 (assignment -> R_SHIFT_ASSIGN .)
    BIT_AND         reduce using rule 98 (assignment -> R_SHIFT_ASSIGN .)
    ID              reduce using rule 98 (assignment -> R_SHIFT_ASSIGN .)
    CHAR            reduce using rule 98 (assignment -> R_SHIFT_ASSIGN .)
    INT_NUM         reduce using rule 98 (assignment -> R_SHIFT_ASSIGN .)
    FLOAT_NUM       reduce using rule 98 (assignment -> R_SHIFT_ASSIGN .)


state 69

    (59) simple -> RETURN expr . SEMICOLON
    (86) expr -> expr . assignment exprOR
    (88) assignment -> . ASSIGN
    (89) assignment -> . PLUS_ASSIGN
    (90) assignment -> . MINUS_ASSIGN
    (91) assignment -> . MUL_ASSIGN
    (92) assignment -> . DIV_ASSIGN
    (93) assignment -> . AND_ASSIGN
    (94) assignment -> . OR_ASSIGN
    (95) assignment -> . XOR_ASSIGN
    (96) assignment -> . MOD_ASSIGN
    (97) assignment -> . L_SHIFT_ASSIGN
    (98) assignment -> . R_SHIFT_ASSIGN

    SEMICOLON       shift and go to state 126
    ASSIGN          shift and go to state 58
    PLUS_ASSIGN     shift and go to state 59
    MINUS_ASSIGN    shift and go to state 60
    MUL_ASSIGN      shift and go to state 61
    DIV_ASSIGN      shift and go to state 62
    AND_ASSIGN      shift and go to state 63
    OR_ASSIGN       shift and go to state 64
    XOR_ASSIGN      shift and go to state 65
    MOD_ASSIGN      shift and go to state 66
    L_SHIFT_ASSIGN  shift and go to state 67
    R_SHIFT_ASSIGN  shift and go to state 68

    assignment                     shift and go to state 57

state 70

    (60) simple -> RETURN SEMICOLON .

    IF              reduce using rule 60 (simple -> RETURN SEMICOLON .)
    WHILE           reduce using rule 60 (simple -> RETURN SEMICOLON .)
    FOR             reduce using rule 60 (simple -> RETURN SEMICOLON .)
    SEMICOLON       reduce using rule 60 (simple -> RETURN SEMICOLON .)
    RETURN          reduce using rule 60 (simple -> RETURN SEMICOLON .)
    HASH            reduce using rule 60 (simple -> RETURN SEMICOLON .)
    TYPE            reduce using rule 60 (simple -> RETURN SEMICOLON .)
    L_FLOWBRACE     reduce using rule 60 (simple -> RETURN SEMICOLON .)
    NOT             reduce using rule 60 (simple -> RETURN SEMICOLON .)
    PLUS            reduce using rule 60 (simple -> RETURN SEMICOLON .)
    MINUS           reduce using rule 60 (simple -> RETURN SEMICOLON .)
    PLUS_PLUS       reduce using rule 60 (simple -> RETURN SEMICOLON .)
    MINUS_MINUS     reduce using rule 60 (simple -> RETURN SEMICOLON .)
    L_PAREN         reduce using rule 60 (simple -> RETURN SEMICOLON .)
    STRING          reduce using rule 60 (simple -> RETURN SEMICOLON .)
    MULTIPLY        reduce using rule 60 (simple -> RETURN SEMICOLON .)
    BIT_AND         reduce using rule 60 (simple -> RETURN SEMICOLON .)
    ID              reduce using rule 60 (simple -> RETURN SEMICOLON .)
    CHAR            reduce using rule 60 (simple -> RETURN SEMICOLON .)
    INT_NUM         reduce using rule 60 (simple -> RETURN SEMICOLON .)
    FLOAT_NUM       reduce using rule 60 (simple -> RETURN SEMICOLON .)
    $end            reduce using rule 60 (simple -> RETURN SEMICOLON .)
    R_FLOWBRACE     reduce using rule 60 (simple -> RETURN SEMICOLON .)
    ELSE            reduce using rule 60 (simple -> RETURN SEMICOLON .)
    R_PAREN         reduce using rule 60 (simple -> RETURN SEMICOLON .)


state 71

    (50) block -> left_flower multiple_statements . right_flower
    (2) multiple_statements -> multiple_statements . statement
    (53) right_flower -> . R_FLOWBRACE
    (4) statement -> . open
    (5) statement -> . closed
    (7) open -> . IF condition statement
    (8) open -> . IF condition closed else open
    (9) open -> . WHILE condition open
    (10) open -> . for for_condition open
    (12) closed -> . simple
    (13) closed -> . block
    (14) closed -> . IF condition closed else closed
    (15) closed -> . WHILE condition closed
    (16) closed -> . for for_condition closed
    (11) for -> . FOR
    (54) simple -> . expr SEMICOLON
    (55) simple -> . header
    (56) simple -> . declaration
    (57) simple -> . SEMICOLON
    (58) simple -> . function
    (59) simple -> . RETURN expr SEMICOLON
    (60) simple -> . RETURN SEMICOLON
    (50) block -> . left_flower multiple_statements right_flower
    (51) block -> . left_flower right_flower
    (86) expr -> . expr assignment exprOR
    (87) expr -> . exprOR
    (61) header -> . HASH INCLUDE STRING
    (62) header -> . HASH INCLUDE HEADER_FILE
    (35) declaration -> . TYPE ID SEMICOLON
    (36) declaration -> . TYPE MULTIPLY ID SEMICOLON
    (37) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (38) declaration -> . TYPE MULTIPLY ID ASSIGN expr SEMICOLON
    (39) declaration -> . TYPE multi_declaration stop
    (40) declaration -> . TYPE ID narrayindex SEMICOLON
    (41) declaration -> . TYPE ID narrayindex ASSIGN init_list SEMICOLON
    (83) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (52) left_flower -> . L_FLOWBRACE
    (99) exprOR -> . exprOR OR exprAND
    (100) exprOR -> . exprAND
    (101) exprAND -> . exprAND AND exprBITOR
    (102) exprAND -> . exprBITOR
    (103) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (104) exprBITOR -> . exprBITXOR
    (105) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (106) exprBITXOR -> . exprBITAND
    (107) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (108) exprBITAND -> . exprEQ
    (109) exprEQ -> . exprEQ EQ exprRELOP
    (110) exprEQ -> . exprEQ NE exprRELOP
    (111) exprEQ -> . exprRELOP
    (112) exprRELOP -> . exprRELOP relop exprSHIFT
    (113) exprRELOP -> . exprSHIFT
    (118) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (119) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (120) exprSHIFT -> . exprOP
    (121) exprOP -> . exprOP PLUS term
    (122) exprOP -> . exprOP MINUS term
    (123) exprOP -> . term
    (124) term -> . term MULTIPLY factor
    (125) term -> . term DIVIDE factor
    (126) term -> . term MOD factor
    (127) term -> . factor
    (128) factor -> . NOT factor
    (129) factor -> . PLUS factor
    (130) factor -> . MINUS factor
    (131) factor -> . PLUS_PLUS factor
    (132) factor -> . MINUS_MINUS factor
    (133) factor -> . cast brace
    (134) factor -> . brace
    (135) cast -> . L_PAREN TYPE R_PAREN
    (136) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (137) brace -> . L_PAREN expr R_PAREN
    (138) brace -> . brace PLUS_PLUS
    (139) brace -> . brace MINUS_MINUS
    (140) brace -> . NUM
    (141) brace -> . STRING
    (142) brace -> . MULTIPLY ID
    (143) brace -> . BIT_AND ID
    (144) brace -> . ID
    (145) brace -> . CHAR
    (146) brace -> . function_call
    (147) brace -> . ID narrayindex
    (148) NUM -> . INT_NUM
    (149) NUM -> . FLOAT_NUM
    (64) function_call -> . ID L_PAREN call_params R_PAREN

    R_FLOWBRACE     shift and go to state 73
    IF              shift and go to state 6
    WHILE           shift and go to state 7
    FOR             shift and go to state 11
    SEMICOLON       shift and go to state 13
    RETURN          shift and go to state 17
    HASH            shift and go to state 20
    TYPE            shift and go to state 22
    L_FLOWBRACE     shift and go to state 26
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    left_flower                    shift and go to state 18
    right_flower                   shift and go to state 127
    statement                      shift and go to state 50
    open                           shift and go to state 4
    closed                         shift and go to state 5
    for                            shift and go to state 8
    simple                         shift and go to state 9
    block                          shift and go to state 10
    expr                           shift and go to state 12
    header                         shift and go to state 14
    declaration                    shift and go to state 15
    function                       shift and go to state 16
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 72

    (51) block -> left_flower right_flower .

    IF              reduce using rule 51 (block -> left_flower right_flower .)
    WHILE           reduce using rule 51 (block -> left_flower right_flower .)
    FOR             reduce using rule 51 (block -> left_flower right_flower .)
    SEMICOLON       reduce using rule 51 (block -> left_flower right_flower .)
    RETURN          reduce using rule 51 (block -> left_flower right_flower .)
    HASH            reduce using rule 51 (block -> left_flower right_flower .)
    TYPE            reduce using rule 51 (block -> left_flower right_flower .)
    L_FLOWBRACE     reduce using rule 51 (block -> left_flower right_flower .)
    NOT             reduce using rule 51 (block -> left_flower right_flower .)
    PLUS            reduce using rule 51 (block -> left_flower right_flower .)
    MINUS           reduce using rule 51 (block -> left_flower right_flower .)
    PLUS_PLUS       reduce using rule 51 (block -> left_flower right_flower .)
    MINUS_MINUS     reduce using rule 51 (block -> left_flower right_flower .)
    L_PAREN         reduce using rule 51 (block -> left_flower right_flower .)
    STRING          reduce using rule 51 (block -> left_flower right_flower .)
    MULTIPLY        reduce using rule 51 (block -> left_flower right_flower .)
    BIT_AND         reduce using rule 51 (block -> left_flower right_flower .)
    ID              reduce using rule 51 (block -> left_flower right_flower .)
    CHAR            reduce using rule 51 (block -> left_flower right_flower .)
    INT_NUM         reduce using rule 51 (block -> left_flower right_flower .)
    FLOAT_NUM       reduce using rule 51 (block -> left_flower right_flower .)
    $end            reduce using rule 51 (block -> left_flower right_flower .)
    R_FLOWBRACE     reduce using rule 51 (block -> left_flower right_flower .)
    ELSE            reduce using rule 51 (block -> left_flower right_flower .)
    R_PAREN         reduce using rule 51 (block -> left_flower right_flower .)


state 73

    (53) right_flower -> R_FLOWBRACE .

    IF              reduce using rule 53 (right_flower -> R_FLOWBRACE .)
    WHILE           reduce using rule 53 (right_flower -> R_FLOWBRACE .)
    FOR             reduce using rule 53 (right_flower -> R_FLOWBRACE .)
    SEMICOLON       reduce using rule 53 (right_flower -> R_FLOWBRACE .)
    RETURN          reduce using rule 53 (right_flower -> R_FLOWBRACE .)
    HASH            reduce using rule 53 (right_flower -> R_FLOWBRACE .)
    TYPE            reduce using rule 53 (right_flower -> R_FLOWBRACE .)
    L_FLOWBRACE     reduce using rule 53 (right_flower -> R_FLOWBRACE .)
    NOT             reduce using rule 53 (right_flower -> R_FLOWBRACE .)
    PLUS            reduce using rule 53 (right_flower -> R_FLOWBRACE .)
    MINUS           reduce using rule 53 (right_flower -> R_FLOWBRACE .)
    PLUS_PLUS       reduce using rule 53 (right_flower -> R_FLOWBRACE .)
    MINUS_MINUS     reduce using rule 53 (right_flower -> R_FLOWBRACE .)
    L_PAREN         reduce using rule 53 (right_flower -> R_FLOWBRACE .)
    STRING          reduce using rule 53 (right_flower -> R_FLOWBRACE .)
    MULTIPLY        reduce using rule 53 (right_flower -> R_FLOWBRACE .)
    BIT_AND         reduce using rule 53 (right_flower -> R_FLOWBRACE .)
    ID              reduce using rule 53 (right_flower -> R_FLOWBRACE .)
    CHAR            reduce using rule 53 (right_flower -> R_FLOWBRACE .)
    INT_NUM         reduce using rule 53 (right_flower -> R_FLOWBRACE .)
    FLOAT_NUM       reduce using rule 53 (right_flower -> R_FLOWBRACE .)
    $end            reduce using rule 53 (right_flower -> R_FLOWBRACE .)
    R_FLOWBRACE     reduce using rule 53 (right_flower -> R_FLOWBRACE .)
    ELSE            reduce using rule 53 (right_flower -> R_FLOWBRACE .)
    R_PAREN         reduce using rule 53 (right_flower -> R_FLOWBRACE .)


state 74

    (99) exprOR -> exprOR OR . exprAND
    (101) exprAND -> . exprAND AND exprBITOR
    (102) exprAND -> . exprBITOR
    (103) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (104) exprBITOR -> . exprBITXOR
    (105) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (106) exprBITXOR -> . exprBITAND
    (107) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (108) exprBITAND -> . exprEQ
    (109) exprEQ -> . exprEQ EQ exprRELOP
    (110) exprEQ -> . exprEQ NE exprRELOP
    (111) exprEQ -> . exprRELOP
    (112) exprRELOP -> . exprRELOP relop exprSHIFT
    (113) exprRELOP -> . exprSHIFT
    (118) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (119) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (120) exprSHIFT -> . exprOP
    (121) exprOP -> . exprOP PLUS term
    (122) exprOP -> . exprOP MINUS term
    (123) exprOP -> . term
    (124) term -> . term MULTIPLY factor
    (125) term -> . term DIVIDE factor
    (126) term -> . term MOD factor
    (127) term -> . factor
    (128) factor -> . NOT factor
    (129) factor -> . PLUS factor
    (130) factor -> . MINUS factor
    (131) factor -> . PLUS_PLUS factor
    (132) factor -> . MINUS_MINUS factor
    (133) factor -> . cast brace
    (134) factor -> . brace
    (135) cast -> . L_PAREN TYPE R_PAREN
    (136) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (137) brace -> . L_PAREN expr R_PAREN
    (138) brace -> . brace PLUS_PLUS
    (139) brace -> . brace MINUS_MINUS
    (140) brace -> . NUM
    (141) brace -> . STRING
    (142) brace -> . MULTIPLY ID
    (143) brace -> . BIT_AND ID
    (144) brace -> . ID
    (145) brace -> . CHAR
    (146) brace -> . function_call
    (147) brace -> . ID narrayindex
    (148) NUM -> . INT_NUM
    (149) NUM -> . FLOAT_NUM
    (64) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    exprAND                        shift and go to state 128
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 75

    (61) header -> HASH INCLUDE . STRING
    (62) header -> HASH INCLUDE . HEADER_FILE

    STRING          shift and go to state 129
    HEADER_FILE     shift and go to state 130


state 76

    (35) declaration -> TYPE ID . SEMICOLON
    (37) declaration -> TYPE ID . ASSIGN expr SEMICOLON
    (40) declaration -> TYPE ID . narrayindex SEMICOLON
    (41) declaration -> TYPE ID . narrayindex ASSIGN init_list SEMICOLON
    (83) function -> TYPE ID . L_PAREN dec_params R_PAREN function_2
    (24) multi_declaration -> ID . COMMA
    (25) multi_declaration -> ID . ASSIGN expr COMMA
    (33) narrayindex -> . narrayindex arrayindex
    (34) narrayindex -> . arrayindex
    (32) arrayindex -> . L_SQBRACE index R_SQBRACE

    SEMICOLON       shift and go to state 131
    ASSIGN          shift and go to state 132
    L_PAREN         shift and go to state 134
    COMMA           shift and go to state 135
    L_SQBRACE       shift and go to state 82

    narrayindex                    shift and go to state 133
    arrayindex                     shift and go to state 81

state 77

    (36) declaration -> TYPE MULTIPLY . ID SEMICOLON
    (38) declaration -> TYPE MULTIPLY . ID ASSIGN expr SEMICOLON
    (26) multi_declaration -> MULTIPLY . ID COMMA
    (27) multi_declaration -> MULTIPLY . ID ASSIGN expr COMMA

    ID              shift and go to state 136


state 78

    (39) declaration -> TYPE multi_declaration . stop
    (20) multi_declaration -> multi_declaration . ID COMMA
    (21) multi_declaration -> multi_declaration . MULTIPLY ID COMMA
    (22) multi_declaration -> multi_declaration . ID ASSIGN expr COMMA
    (23) multi_declaration -> multi_declaration . MULTIPLY ID ASSIGN expr COMMA
    (28) stop -> . ID SEMICOLON
    (29) stop -> . MULTIPLY ID SEMICOLON
    (30) stop -> . ID ASSIGN expr SEMICOLON
    (31) stop -> . MULTIPLY ID ASSIGN expr SEMICOLON

    ID              shift and go to state 138
    MULTIPLY        shift and go to state 139

    stop                           shift and go to state 137

state 79

    (147) brace -> ID narrayindex .
    (33) narrayindex -> narrayindex . arrayindex
    (32) arrayindex -> . L_SQBRACE index R_SQBRACE

    PLUS_PLUS       reduce using rule 147 (brace -> ID narrayindex .)
    MINUS_MINUS     reduce using rule 147 (brace -> ID narrayindex .)
    MULTIPLY        reduce using rule 147 (brace -> ID narrayindex .)
    DIVIDE          reduce using rule 147 (brace -> ID narrayindex .)
    MOD             reduce using rule 147 (brace -> ID narrayindex .)
    PLUS            reduce using rule 147 (brace -> ID narrayindex .)
    MINUS           reduce using rule 147 (brace -> ID narrayindex .)
    L_SHIFT         reduce using rule 147 (brace -> ID narrayindex .)
    R_SHIFT         reduce using rule 147 (brace -> ID narrayindex .)
    LE              reduce using rule 147 (brace -> ID narrayindex .)
    LT              reduce using rule 147 (brace -> ID narrayindex .)
    GE              reduce using rule 147 (brace -> ID narrayindex .)
    GT              reduce using rule 147 (brace -> ID narrayindex .)
    EQ              reduce using rule 147 (brace -> ID narrayindex .)
    NE              reduce using rule 147 (brace -> ID narrayindex .)
    BIT_AND         reduce using rule 147 (brace -> ID narrayindex .)
    BIT_XOR         reduce using rule 147 (brace -> ID narrayindex .)
    BIT_OR          reduce using rule 147 (brace -> ID narrayindex .)
    AND             reduce using rule 147 (brace -> ID narrayindex .)
    OR              reduce using rule 147 (brace -> ID narrayindex .)
    SEMICOLON       reduce using rule 147 (brace -> ID narrayindex .)
    ASSIGN          reduce using rule 147 (brace -> ID narrayindex .)
    PLUS_ASSIGN     reduce using rule 147 (brace -> ID narrayindex .)
    MINUS_ASSIGN    reduce using rule 147 (brace -> ID narrayindex .)
    MUL_ASSIGN      reduce using rule 147 (brace -> ID narrayindex .)
    DIV_ASSIGN      reduce using rule 147 (brace -> ID narrayindex .)
    AND_ASSIGN      reduce using rule 147 (brace -> ID narrayindex .)
    OR_ASSIGN       reduce using rule 147 (brace -> ID narrayindex .)
    XOR_ASSIGN      reduce using rule 147 (brace -> ID narrayindex .)
    MOD_ASSIGN      reduce using rule 147 (brace -> ID narrayindex .)
    L_SHIFT_ASSIGN  reduce using rule 147 (brace -> ID narrayindex .)
    R_SHIFT_ASSIGN  reduce using rule 147 (brace -> ID narrayindex .)
    R_PAREN         reduce using rule 147 (brace -> ID narrayindex .)
    COMMA           reduce using rule 147 (brace -> ID narrayindex .)
    R_SQBRACE       reduce using rule 147 (brace -> ID narrayindex .)
    R_FLOWBRACE     reduce using rule 147 (brace -> ID narrayindex .)
    L_SQBRACE       shift and go to state 82

    arrayindex                     shift and go to state 140

state 80

    (64) function_call -> ID L_PAREN . call_params R_PAREN
    (65) call_params -> . empty
    (66) call_params -> . yes_call_params end_call_params
    (67) call_params -> . end_call_params
    (63) empty -> .
    (68) yes_call_params -> . yes_call_params expr COMMA
    (69) yes_call_params -> . expr COMMA
    (70) end_call_params -> . expr
    (86) expr -> . expr assignment exprOR
    (87) expr -> . exprOR
    (99) exprOR -> . exprOR OR exprAND
    (100) exprOR -> . exprAND
    (101) exprAND -> . exprAND AND exprBITOR
    (102) exprAND -> . exprBITOR
    (103) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (104) exprBITOR -> . exprBITXOR
    (105) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (106) exprBITXOR -> . exprBITAND
    (107) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (108) exprBITAND -> . exprEQ
    (109) exprEQ -> . exprEQ EQ exprRELOP
    (110) exprEQ -> . exprEQ NE exprRELOP
    (111) exprEQ -> . exprRELOP
    (112) exprRELOP -> . exprRELOP relop exprSHIFT
    (113) exprRELOP -> . exprSHIFT
    (118) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (119) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (120) exprSHIFT -> . exprOP
    (121) exprOP -> . exprOP PLUS term
    (122) exprOP -> . exprOP MINUS term
    (123) exprOP -> . term
    (124) term -> . term MULTIPLY factor
    (125) term -> . term DIVIDE factor
    (126) term -> . term MOD factor
    (127) term -> . factor
    (128) factor -> . NOT factor
    (129) factor -> . PLUS factor
    (130) factor -> . MINUS factor
    (131) factor -> . PLUS_PLUS factor
    (132) factor -> . MINUS_MINUS factor
    (133) factor -> . cast brace
    (134) factor -> . brace
    (135) cast -> . L_PAREN TYPE R_PAREN
    (136) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (137) brace -> . L_PAREN expr R_PAREN
    (138) brace -> . brace PLUS_PLUS
    (139) brace -> . brace MINUS_MINUS
    (140) brace -> . NUM
    (141) brace -> . STRING
    (142) brace -> . MULTIPLY ID
    (143) brace -> . BIT_AND ID
    (144) brace -> . ID
    (145) brace -> . CHAR
    (146) brace -> . function_call
    (147) brace -> . ID narrayindex
    (148) NUM -> . INT_NUM
    (149) NUM -> . FLOAT_NUM
    (64) function_call -> . ID L_PAREN call_params R_PAREN

    R_PAREN         reduce using rule 63 (empty -> .)
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    call_params                    shift and go to state 141
    empty                          shift and go to state 142
    yes_call_params                shift and go to state 143
    end_call_params                shift and go to state 144
    expr                           shift and go to state 145
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 81

    (34) narrayindex -> arrayindex .

    L_SQBRACE       reduce using rule 34 (narrayindex -> arrayindex .)
    PLUS_PLUS       reduce using rule 34 (narrayindex -> arrayindex .)
    MINUS_MINUS     reduce using rule 34 (narrayindex -> arrayindex .)
    MULTIPLY        reduce using rule 34 (narrayindex -> arrayindex .)
    DIVIDE          reduce using rule 34 (narrayindex -> arrayindex .)
    MOD             reduce using rule 34 (narrayindex -> arrayindex .)
    PLUS            reduce using rule 34 (narrayindex -> arrayindex .)
    MINUS           reduce using rule 34 (narrayindex -> arrayindex .)
    L_SHIFT         reduce using rule 34 (narrayindex -> arrayindex .)
    R_SHIFT         reduce using rule 34 (narrayindex -> arrayindex .)
    LE              reduce using rule 34 (narrayindex -> arrayindex .)
    LT              reduce using rule 34 (narrayindex -> arrayindex .)
    GE              reduce using rule 34 (narrayindex -> arrayindex .)
    GT              reduce using rule 34 (narrayindex -> arrayindex .)
    EQ              reduce using rule 34 (narrayindex -> arrayindex .)
    NE              reduce using rule 34 (narrayindex -> arrayindex .)
    BIT_AND         reduce using rule 34 (narrayindex -> arrayindex .)
    BIT_XOR         reduce using rule 34 (narrayindex -> arrayindex .)
    BIT_OR          reduce using rule 34 (narrayindex -> arrayindex .)
    AND             reduce using rule 34 (narrayindex -> arrayindex .)
    OR              reduce using rule 34 (narrayindex -> arrayindex .)
    SEMICOLON       reduce using rule 34 (narrayindex -> arrayindex .)
    ASSIGN          reduce using rule 34 (narrayindex -> arrayindex .)
    PLUS_ASSIGN     reduce using rule 34 (narrayindex -> arrayindex .)
    MINUS_ASSIGN    reduce using rule 34 (narrayindex -> arrayindex .)
    MUL_ASSIGN      reduce using rule 34 (narrayindex -> arrayindex .)
    DIV_ASSIGN      reduce using rule 34 (narrayindex -> arrayindex .)
    AND_ASSIGN      reduce using rule 34 (narrayindex -> arrayindex .)
    OR_ASSIGN       reduce using rule 34 (narrayindex -> arrayindex .)
    XOR_ASSIGN      reduce using rule 34 (narrayindex -> arrayindex .)
    MOD_ASSIGN      reduce using rule 34 (narrayindex -> arrayindex .)
    L_SHIFT_ASSIGN  reduce using rule 34 (narrayindex -> arrayindex .)
    R_SHIFT_ASSIGN  reduce using rule 34 (narrayindex -> arrayindex .)
    R_PAREN         reduce using rule 34 (narrayindex -> arrayindex .)
    COMMA           reduce using rule 34 (narrayindex -> arrayindex .)
    R_SQBRACE       reduce using rule 34 (narrayindex -> arrayindex .)
    R_FLOWBRACE     reduce using rule 34 (narrayindex -> arrayindex .)


state 82

    (32) arrayindex -> L_SQBRACE . index R_SQBRACE
    (48) index -> . expr
    (49) index -> . empty
    (86) expr -> . expr assignment exprOR
    (87) expr -> . exprOR
    (63) empty -> .
    (99) exprOR -> . exprOR OR exprAND
    (100) exprOR -> . exprAND
    (101) exprAND -> . exprAND AND exprBITOR
    (102) exprAND -> . exprBITOR
    (103) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (104) exprBITOR -> . exprBITXOR
    (105) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (106) exprBITXOR -> . exprBITAND
    (107) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (108) exprBITAND -> . exprEQ
    (109) exprEQ -> . exprEQ EQ exprRELOP
    (110) exprEQ -> . exprEQ NE exprRELOP
    (111) exprEQ -> . exprRELOP
    (112) exprRELOP -> . exprRELOP relop exprSHIFT
    (113) exprRELOP -> . exprSHIFT
    (118) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (119) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (120) exprSHIFT -> . exprOP
    (121) exprOP -> . exprOP PLUS term
    (122) exprOP -> . exprOP MINUS term
    (123) exprOP -> . term
    (124) term -> . term MULTIPLY factor
    (125) term -> . term DIVIDE factor
    (126) term -> . term MOD factor
    (127) term -> . factor
    (128) factor -> . NOT factor
    (129) factor -> . PLUS factor
    (130) factor -> . MINUS factor
    (131) factor -> . PLUS_PLUS factor
    (132) factor -> . MINUS_MINUS factor
    (133) factor -> . cast brace
    (134) factor -> . brace
    (135) cast -> . L_PAREN TYPE R_PAREN
    (136) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (137) brace -> . L_PAREN expr R_PAREN
    (138) brace -> . brace PLUS_PLUS
    (139) brace -> . brace MINUS_MINUS
    (140) brace -> . NUM
    (141) brace -> . STRING
    (142) brace -> . MULTIPLY ID
    (143) brace -> . BIT_AND ID
    (144) brace -> . ID
    (145) brace -> . CHAR
    (146) brace -> . function_call
    (147) brace -> . ID narrayindex
    (148) NUM -> . INT_NUM
    (149) NUM -> . FLOAT_NUM
    (64) function_call -> . ID L_PAREN call_params R_PAREN

    R_SQBRACE       reduce using rule 63 (empty -> .)
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    index                          shift and go to state 146
    expr                           shift and go to state 147
    empty                          shift and go to state 148
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 83

    (142) brace -> MULTIPLY ID .

    PLUS_PLUS       reduce using rule 142 (brace -> MULTIPLY ID .)
    MINUS_MINUS     reduce using rule 142 (brace -> MULTIPLY ID .)
    MULTIPLY        reduce using rule 142 (brace -> MULTIPLY ID .)
    DIVIDE          reduce using rule 142 (brace -> MULTIPLY ID .)
    MOD             reduce using rule 142 (brace -> MULTIPLY ID .)
    PLUS            reduce using rule 142 (brace -> MULTIPLY ID .)
    MINUS           reduce using rule 142 (brace -> MULTIPLY ID .)
    L_SHIFT         reduce using rule 142 (brace -> MULTIPLY ID .)
    R_SHIFT         reduce using rule 142 (brace -> MULTIPLY ID .)
    LE              reduce using rule 142 (brace -> MULTIPLY ID .)
    LT              reduce using rule 142 (brace -> MULTIPLY ID .)
    GE              reduce using rule 142 (brace -> MULTIPLY ID .)
    GT              reduce using rule 142 (brace -> MULTIPLY ID .)
    EQ              reduce using rule 142 (brace -> MULTIPLY ID .)
    NE              reduce using rule 142 (brace -> MULTIPLY ID .)
    BIT_AND         reduce using rule 142 (brace -> MULTIPLY ID .)
    BIT_XOR         reduce using rule 142 (brace -> MULTIPLY ID .)
    BIT_OR          reduce using rule 142 (brace -> MULTIPLY ID .)
    AND             reduce using rule 142 (brace -> MULTIPLY ID .)
    OR              reduce using rule 142 (brace -> MULTIPLY ID .)
    SEMICOLON       reduce using rule 142 (brace -> MULTIPLY ID .)
    ASSIGN          reduce using rule 142 (brace -> MULTIPLY ID .)
    PLUS_ASSIGN     reduce using rule 142 (brace -> MULTIPLY ID .)
    MINUS_ASSIGN    reduce using rule 142 (brace -> MULTIPLY ID .)
    MUL_ASSIGN      reduce using rule 142 (brace -> MULTIPLY ID .)
    DIV_ASSIGN      reduce using rule 142 (brace -> MULTIPLY ID .)
    AND_ASSIGN      reduce using rule 142 (brace -> MULTIPLY ID .)
    OR_ASSIGN       reduce using rule 142 (brace -> MULTIPLY ID .)
    XOR_ASSIGN      reduce using rule 142 (brace -> MULTIPLY ID .)
    MOD_ASSIGN      reduce using rule 142 (brace -> MULTIPLY ID .)
    L_SHIFT_ASSIGN  reduce using rule 142 (brace -> MULTIPLY ID .)
    R_SHIFT_ASSIGN  reduce using rule 142 (brace -> MULTIPLY ID .)
    R_PAREN         reduce using rule 142 (brace -> MULTIPLY ID .)
    COMMA           reduce using rule 142 (brace -> MULTIPLY ID .)
    R_SQBRACE       reduce using rule 142 (brace -> MULTIPLY ID .)
    R_FLOWBRACE     reduce using rule 142 (brace -> MULTIPLY ID .)


state 84

    (135) cast -> L_PAREN TYPE . R_PAREN
    (136) cast -> L_PAREN TYPE . MULTIPLY R_PAREN

    R_PAREN         shift and go to state 149
    MULTIPLY        shift and go to state 150


state 85

    (137) brace -> L_PAREN expr . R_PAREN
    (86) expr -> expr . assignment exprOR
    (88) assignment -> . ASSIGN
    (89) assignment -> . PLUS_ASSIGN
    (90) assignment -> . MINUS_ASSIGN
    (91) assignment -> . MUL_ASSIGN
    (92) assignment -> . DIV_ASSIGN
    (93) assignment -> . AND_ASSIGN
    (94) assignment -> . OR_ASSIGN
    (95) assignment -> . XOR_ASSIGN
    (96) assignment -> . MOD_ASSIGN
    (97) assignment -> . L_SHIFT_ASSIGN
    (98) assignment -> . R_SHIFT_ASSIGN

    R_PAREN         shift and go to state 151
    ASSIGN          shift and go to state 58
    PLUS_ASSIGN     shift and go to state 59
    MINUS_ASSIGN    shift and go to state 60
    MUL_ASSIGN      shift and go to state 61
    DIV_ASSIGN      shift and go to state 62
    AND_ASSIGN      shift and go to state 63
    OR_ASSIGN       shift and go to state 64
    XOR_ASSIGN      shift and go to state 65
    MOD_ASSIGN      shift and go to state 66
    L_SHIFT_ASSIGN  shift and go to state 67
    R_SHIFT_ASSIGN  shift and go to state 68

    assignment                     shift and go to state 57

state 86

    (101) exprAND -> exprAND AND . exprBITOR
    (103) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (104) exprBITOR -> . exprBITXOR
    (105) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (106) exprBITXOR -> . exprBITAND
    (107) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (108) exprBITAND -> . exprEQ
    (109) exprEQ -> . exprEQ EQ exprRELOP
    (110) exprEQ -> . exprEQ NE exprRELOP
    (111) exprEQ -> . exprRELOP
    (112) exprRELOP -> . exprRELOP relop exprSHIFT
    (113) exprRELOP -> . exprSHIFT
    (118) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (119) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (120) exprSHIFT -> . exprOP
    (121) exprOP -> . exprOP PLUS term
    (122) exprOP -> . exprOP MINUS term
    (123) exprOP -> . term
    (124) term -> . term MULTIPLY factor
    (125) term -> . term DIVIDE factor
    (126) term -> . term MOD factor
    (127) term -> . factor
    (128) factor -> . NOT factor
    (129) factor -> . PLUS factor
    (130) factor -> . MINUS factor
    (131) factor -> . PLUS_PLUS factor
    (132) factor -> . MINUS_MINUS factor
    (133) factor -> . cast brace
    (134) factor -> . brace
    (135) cast -> . L_PAREN TYPE R_PAREN
    (136) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (137) brace -> . L_PAREN expr R_PAREN
    (138) brace -> . brace PLUS_PLUS
    (139) brace -> . brace MINUS_MINUS
    (140) brace -> . NUM
    (141) brace -> . STRING
    (142) brace -> . MULTIPLY ID
    (143) brace -> . BIT_AND ID
    (144) brace -> . ID
    (145) brace -> . CHAR
    (146) brace -> . function_call
    (147) brace -> . ID narrayindex
    (148) NUM -> . INT_NUM
    (149) NUM -> . FLOAT_NUM
    (64) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    exprBITOR                      shift and go to state 152
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 87

    (103) exprBITOR -> exprBITOR BIT_OR . exprBITXOR
    (105) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (106) exprBITXOR -> . exprBITAND
    (107) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (108) exprBITAND -> . exprEQ
    (109) exprEQ -> . exprEQ EQ exprRELOP
    (110) exprEQ -> . exprEQ NE exprRELOP
    (111) exprEQ -> . exprRELOP
    (112) exprRELOP -> . exprRELOP relop exprSHIFT
    (113) exprRELOP -> . exprSHIFT
    (118) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (119) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (120) exprSHIFT -> . exprOP
    (121) exprOP -> . exprOP PLUS term
    (122) exprOP -> . exprOP MINUS term
    (123) exprOP -> . term
    (124) term -> . term MULTIPLY factor
    (125) term -> . term DIVIDE factor
    (126) term -> . term MOD factor
    (127) term -> . factor
    (128) factor -> . NOT factor
    (129) factor -> . PLUS factor
    (130) factor -> . MINUS factor
    (131) factor -> . PLUS_PLUS factor
    (132) factor -> . MINUS_MINUS factor
    (133) factor -> . cast brace
    (134) factor -> . brace
    (135) cast -> . L_PAREN TYPE R_PAREN
    (136) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (137) brace -> . L_PAREN expr R_PAREN
    (138) brace -> . brace PLUS_PLUS
    (139) brace -> . brace MINUS_MINUS
    (140) brace -> . NUM
    (141) brace -> . STRING
    (142) brace -> . MULTIPLY ID
    (143) brace -> . BIT_AND ID
    (144) brace -> . ID
    (145) brace -> . CHAR
    (146) brace -> . function_call
    (147) brace -> . ID narrayindex
    (148) NUM -> . INT_NUM
    (149) NUM -> . FLOAT_NUM
    (64) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    exprBITXOR                     shift and go to state 153
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 88

    (105) exprBITXOR -> exprBITXOR BIT_XOR . exprBITAND
    (107) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (108) exprBITAND -> . exprEQ
    (109) exprEQ -> . exprEQ EQ exprRELOP
    (110) exprEQ -> . exprEQ NE exprRELOP
    (111) exprEQ -> . exprRELOP
    (112) exprRELOP -> . exprRELOP relop exprSHIFT
    (113) exprRELOP -> . exprSHIFT
    (118) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (119) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (120) exprSHIFT -> . exprOP
    (121) exprOP -> . exprOP PLUS term
    (122) exprOP -> . exprOP MINUS term
    (123) exprOP -> . term
    (124) term -> . term MULTIPLY factor
    (125) term -> . term DIVIDE factor
    (126) term -> . term MOD factor
    (127) term -> . factor
    (128) factor -> . NOT factor
    (129) factor -> . PLUS factor
    (130) factor -> . MINUS factor
    (131) factor -> . PLUS_PLUS factor
    (132) factor -> . MINUS_MINUS factor
    (133) factor -> . cast brace
    (134) factor -> . brace
    (135) cast -> . L_PAREN TYPE R_PAREN
    (136) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (137) brace -> . L_PAREN expr R_PAREN
    (138) brace -> . brace PLUS_PLUS
    (139) brace -> . brace MINUS_MINUS
    (140) brace -> . NUM
    (141) brace -> . STRING
    (142) brace -> . MULTIPLY ID
    (143) brace -> . BIT_AND ID
    (144) brace -> . ID
    (145) brace -> . CHAR
    (146) brace -> . function_call
    (147) brace -> . ID narrayindex
    (148) NUM -> . INT_NUM
    (149) NUM -> . FLOAT_NUM
    (64) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    exprBITAND                     shift and go to state 154
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 89

    (107) exprBITAND -> exprBITAND BIT_AND . exprEQ
    (109) exprEQ -> . exprEQ EQ exprRELOP
    (110) exprEQ -> . exprEQ NE exprRELOP
    (111) exprEQ -> . exprRELOP
    (112) exprRELOP -> . exprRELOP relop exprSHIFT
    (113) exprRELOP -> . exprSHIFT
    (118) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (119) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (120) exprSHIFT -> . exprOP
    (121) exprOP -> . exprOP PLUS term
    (122) exprOP -> . exprOP MINUS term
    (123) exprOP -> . term
    (124) term -> . term MULTIPLY factor
    (125) term -> . term DIVIDE factor
    (126) term -> . term MOD factor
    (127) term -> . factor
    (128) factor -> . NOT factor
    (129) factor -> . PLUS factor
    (130) factor -> . MINUS factor
    (131) factor -> . PLUS_PLUS factor
    (132) factor -> . MINUS_MINUS factor
    (133) factor -> . cast brace
    (134) factor -> . brace
    (135) cast -> . L_PAREN TYPE R_PAREN
    (136) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (137) brace -> . L_PAREN expr R_PAREN
    (138) brace -> . brace PLUS_PLUS
    (139) brace -> . brace MINUS_MINUS
    (140) brace -> . NUM
    (141) brace -> . STRING
    (142) brace -> . MULTIPLY ID
    (143) brace -> . BIT_AND ID
    (144) brace -> . ID
    (145) brace -> . CHAR
    (146) brace -> . function_call
    (147) brace -> . ID narrayindex
    (148) NUM -> . INT_NUM
    (149) NUM -> . FLOAT_NUM
    (64) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    exprEQ                         shift and go to state 155
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 90

    (143) brace -> BIT_AND ID .

    PLUS_PLUS       reduce using rule 143 (brace -> BIT_AND ID .)
    MINUS_MINUS     reduce using rule 143 (brace -> BIT_AND ID .)
    MULTIPLY        reduce using rule 143 (brace -> BIT_AND ID .)
    DIVIDE          reduce using rule 143 (brace -> BIT_AND ID .)
    MOD             reduce using rule 143 (brace -> BIT_AND ID .)
    PLUS            reduce using rule 143 (brace -> BIT_AND ID .)
    MINUS           reduce using rule 143 (brace -> BIT_AND ID .)
    L_SHIFT         reduce using rule 143 (brace -> BIT_AND ID .)
    R_SHIFT         reduce using rule 143 (brace -> BIT_AND ID .)
    LE              reduce using rule 143 (brace -> BIT_AND ID .)
    LT              reduce using rule 143 (brace -> BIT_AND ID .)
    GE              reduce using rule 143 (brace -> BIT_AND ID .)
    GT              reduce using rule 143 (brace -> BIT_AND ID .)
    EQ              reduce using rule 143 (brace -> BIT_AND ID .)
    NE              reduce using rule 143 (brace -> BIT_AND ID .)
    BIT_AND         reduce using rule 143 (brace -> BIT_AND ID .)
    BIT_XOR         reduce using rule 143 (brace -> BIT_AND ID .)
    BIT_OR          reduce using rule 143 (brace -> BIT_AND ID .)
    AND             reduce using rule 143 (brace -> BIT_AND ID .)
    OR              reduce using rule 143 (brace -> BIT_AND ID .)
    SEMICOLON       reduce using rule 143 (brace -> BIT_AND ID .)
    ASSIGN          reduce using rule 143 (brace -> BIT_AND ID .)
    PLUS_ASSIGN     reduce using rule 143 (brace -> BIT_AND ID .)
    MINUS_ASSIGN    reduce using rule 143 (brace -> BIT_AND ID .)
    MUL_ASSIGN      reduce using rule 143 (brace -> BIT_AND ID .)
    DIV_ASSIGN      reduce using rule 143 (brace -> BIT_AND ID .)
    AND_ASSIGN      reduce using rule 143 (brace -> BIT_AND ID .)
    OR_ASSIGN       reduce using rule 143 (brace -> BIT_AND ID .)
    XOR_ASSIGN      reduce using rule 143 (brace -> BIT_AND ID .)
    MOD_ASSIGN      reduce using rule 143 (brace -> BIT_AND ID .)
    L_SHIFT_ASSIGN  reduce using rule 143 (brace -> BIT_AND ID .)
    R_SHIFT_ASSIGN  reduce using rule 143 (brace -> BIT_AND ID .)
    R_PAREN         reduce using rule 143 (brace -> BIT_AND ID .)
    COMMA           reduce using rule 143 (brace -> BIT_AND ID .)
    R_SQBRACE       reduce using rule 143 (brace -> BIT_AND ID .)
    R_FLOWBRACE     reduce using rule 143 (brace -> BIT_AND ID .)


state 91

    (109) exprEQ -> exprEQ EQ . exprRELOP
    (112) exprRELOP -> . exprRELOP relop exprSHIFT
    (113) exprRELOP -> . exprSHIFT
    (118) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (119) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (120) exprSHIFT -> . exprOP
    (121) exprOP -> . exprOP PLUS term
    (122) exprOP -> . exprOP MINUS term
    (123) exprOP -> . term
    (124) term -> . term MULTIPLY factor
    (125) term -> . term DIVIDE factor
    (126) term -> . term MOD factor
    (127) term -> . factor
    (128) factor -> . NOT factor
    (129) factor -> . PLUS factor
    (130) factor -> . MINUS factor
    (131) factor -> . PLUS_PLUS factor
    (132) factor -> . MINUS_MINUS factor
    (133) factor -> . cast brace
    (134) factor -> . brace
    (135) cast -> . L_PAREN TYPE R_PAREN
    (136) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (137) brace -> . L_PAREN expr R_PAREN
    (138) brace -> . brace PLUS_PLUS
    (139) brace -> . brace MINUS_MINUS
    (140) brace -> . NUM
    (141) brace -> . STRING
    (142) brace -> . MULTIPLY ID
    (143) brace -> . BIT_AND ID
    (144) brace -> . ID
    (145) brace -> . CHAR
    (146) brace -> . function_call
    (147) brace -> . ID narrayindex
    (148) NUM -> . INT_NUM
    (149) NUM -> . FLOAT_NUM
    (64) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    exprRELOP                      shift and go to state 156
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 92

    (110) exprEQ -> exprEQ NE . exprRELOP
    (112) exprRELOP -> . exprRELOP relop exprSHIFT
    (113) exprRELOP -> . exprSHIFT
    (118) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (119) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (120) exprSHIFT -> . exprOP
    (121) exprOP -> . exprOP PLUS term
    (122) exprOP -> . exprOP MINUS term
    (123) exprOP -> . term
    (124) term -> . term MULTIPLY factor
    (125) term -> . term DIVIDE factor
    (126) term -> . term MOD factor
    (127) term -> . factor
    (128) factor -> . NOT factor
    (129) factor -> . PLUS factor
    (130) factor -> . MINUS factor
    (131) factor -> . PLUS_PLUS factor
    (132) factor -> . MINUS_MINUS factor
    (133) factor -> . cast brace
    (134) factor -> . brace
    (135) cast -> . L_PAREN TYPE R_PAREN
    (136) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (137) brace -> . L_PAREN expr R_PAREN
    (138) brace -> . brace PLUS_PLUS
    (139) brace -> . brace MINUS_MINUS
    (140) brace -> . NUM
    (141) brace -> . STRING
    (142) brace -> . MULTIPLY ID
    (143) brace -> . BIT_AND ID
    (144) brace -> . ID
    (145) brace -> . CHAR
    (146) brace -> . function_call
    (147) brace -> . ID narrayindex
    (148) NUM -> . INT_NUM
    (149) NUM -> . FLOAT_NUM
    (64) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    exprRELOP                      shift and go to state 157
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 93

    (112) exprRELOP -> exprRELOP relop . exprSHIFT
    (118) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (119) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (120) exprSHIFT -> . exprOP
    (121) exprOP -> . exprOP PLUS term
    (122) exprOP -> . exprOP MINUS term
    (123) exprOP -> . term
    (124) term -> . term MULTIPLY factor
    (125) term -> . term DIVIDE factor
    (126) term -> . term MOD factor
    (127) term -> . factor
    (128) factor -> . NOT factor
    (129) factor -> . PLUS factor
    (130) factor -> . MINUS factor
    (131) factor -> . PLUS_PLUS factor
    (132) factor -> . MINUS_MINUS factor
    (133) factor -> . cast brace
    (134) factor -> . brace
    (135) cast -> . L_PAREN TYPE R_PAREN
    (136) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (137) brace -> . L_PAREN expr R_PAREN
    (138) brace -> . brace PLUS_PLUS
    (139) brace -> . brace MINUS_MINUS
    (140) brace -> . NUM
    (141) brace -> . STRING
    (142) brace -> . MULTIPLY ID
    (143) brace -> . BIT_AND ID
    (144) brace -> . ID
    (145) brace -> . CHAR
    (146) brace -> . function_call
    (147) brace -> . ID narrayindex
    (148) NUM -> . INT_NUM
    (149) NUM -> . FLOAT_NUM
    (64) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    exprSHIFT                      shift and go to state 158
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 94

    (114) relop -> LE .

    NOT             reduce using rule 114 (relop -> LE .)
    PLUS            reduce using rule 114 (relop -> LE .)
    MINUS           reduce using rule 114 (relop -> LE .)
    PLUS_PLUS       reduce using rule 114 (relop -> LE .)
    MINUS_MINUS     reduce using rule 114 (relop -> LE .)
    L_PAREN         reduce using rule 114 (relop -> LE .)
    STRING          reduce using rule 114 (relop -> LE .)
    MULTIPLY        reduce using rule 114 (relop -> LE .)
    BIT_AND         reduce using rule 114 (relop -> LE .)
    ID              reduce using rule 114 (relop -> LE .)
    CHAR            reduce using rule 114 (relop -> LE .)
    INT_NUM         reduce using rule 114 (relop -> LE .)
    FLOAT_NUM       reduce using rule 114 (relop -> LE .)


state 95

    (115) relop -> LT .

    NOT             reduce using rule 115 (relop -> LT .)
    PLUS            reduce using rule 115 (relop -> LT .)
    MINUS           reduce using rule 115 (relop -> LT .)
    PLUS_PLUS       reduce using rule 115 (relop -> LT .)
    MINUS_MINUS     reduce using rule 115 (relop -> LT .)
    L_PAREN         reduce using rule 115 (relop -> LT .)
    STRING          reduce using rule 115 (relop -> LT .)
    MULTIPLY        reduce using rule 115 (relop -> LT .)
    BIT_AND         reduce using rule 115 (relop -> LT .)
    ID              reduce using rule 115 (relop -> LT .)
    CHAR            reduce using rule 115 (relop -> LT .)
    INT_NUM         reduce using rule 115 (relop -> LT .)
    FLOAT_NUM       reduce using rule 115 (relop -> LT .)


state 96

    (116) relop -> GE .

    NOT             reduce using rule 116 (relop -> GE .)
    PLUS            reduce using rule 116 (relop -> GE .)
    MINUS           reduce using rule 116 (relop -> GE .)
    PLUS_PLUS       reduce using rule 116 (relop -> GE .)
    MINUS_MINUS     reduce using rule 116 (relop -> GE .)
    L_PAREN         reduce using rule 116 (relop -> GE .)
    STRING          reduce using rule 116 (relop -> GE .)
    MULTIPLY        reduce using rule 116 (relop -> GE .)
    BIT_AND         reduce using rule 116 (relop -> GE .)
    ID              reduce using rule 116 (relop -> GE .)
    CHAR            reduce using rule 116 (relop -> GE .)
    INT_NUM         reduce using rule 116 (relop -> GE .)
    FLOAT_NUM       reduce using rule 116 (relop -> GE .)


state 97

    (117) relop -> GT .

    NOT             reduce using rule 117 (relop -> GT .)
    PLUS            reduce using rule 117 (relop -> GT .)
    MINUS           reduce using rule 117 (relop -> GT .)
    PLUS_PLUS       reduce using rule 117 (relop -> GT .)
    MINUS_MINUS     reduce using rule 117 (relop -> GT .)
    L_PAREN         reduce using rule 117 (relop -> GT .)
    STRING          reduce using rule 117 (relop -> GT .)
    MULTIPLY        reduce using rule 117 (relop -> GT .)
    BIT_AND         reduce using rule 117 (relop -> GT .)
    ID              reduce using rule 117 (relop -> GT .)
    CHAR            reduce using rule 117 (relop -> GT .)
    INT_NUM         reduce using rule 117 (relop -> GT .)
    FLOAT_NUM       reduce using rule 117 (relop -> GT .)


state 98

    (118) exprSHIFT -> exprSHIFT L_SHIFT . exprOP
    (121) exprOP -> . exprOP PLUS term
    (122) exprOP -> . exprOP MINUS term
    (123) exprOP -> . term
    (124) term -> . term MULTIPLY factor
    (125) term -> . term DIVIDE factor
    (126) term -> . term MOD factor
    (127) term -> . factor
    (128) factor -> . NOT factor
    (129) factor -> . PLUS factor
    (130) factor -> . MINUS factor
    (131) factor -> . PLUS_PLUS factor
    (132) factor -> . MINUS_MINUS factor
    (133) factor -> . cast brace
    (134) factor -> . brace
    (135) cast -> . L_PAREN TYPE R_PAREN
    (136) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (137) brace -> . L_PAREN expr R_PAREN
    (138) brace -> . brace PLUS_PLUS
    (139) brace -> . brace MINUS_MINUS
    (140) brace -> . NUM
    (141) brace -> . STRING
    (142) brace -> . MULTIPLY ID
    (143) brace -> . BIT_AND ID
    (144) brace -> . ID
    (145) brace -> . CHAR
    (146) brace -> . function_call
    (147) brace -> . ID narrayindex
    (148) NUM -> . INT_NUM
    (149) NUM -> . FLOAT_NUM
    (64) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    exprOP                         shift and go to state 159
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 99

    (119) exprSHIFT -> exprSHIFT R_SHIFT . exprOP
    (121) exprOP -> . exprOP PLUS term
    (122) exprOP -> . exprOP MINUS term
    (123) exprOP -> . term
    (124) term -> . term MULTIPLY factor
    (125) term -> . term DIVIDE factor
    (126) term -> . term MOD factor
    (127) term -> . factor
    (128) factor -> . NOT factor
    (129) factor -> . PLUS factor
    (130) factor -> . MINUS factor
    (131) factor -> . PLUS_PLUS factor
    (132) factor -> . MINUS_MINUS factor
    (133) factor -> . cast brace
    (134) factor -> . brace
    (135) cast -> . L_PAREN TYPE R_PAREN
    (136) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (137) brace -> . L_PAREN expr R_PAREN
    (138) brace -> . brace PLUS_PLUS
    (139) brace -> . brace MINUS_MINUS
    (140) brace -> . NUM
    (141) brace -> . STRING
    (142) brace -> . MULTIPLY ID
    (143) brace -> . BIT_AND ID
    (144) brace -> . ID
    (145) brace -> . CHAR
    (146) brace -> . function_call
    (147) brace -> . ID narrayindex
    (148) NUM -> . INT_NUM
    (149) NUM -> . FLOAT_NUM
    (64) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    exprOP                         shift and go to state 160
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 100

    (121) exprOP -> exprOP PLUS . term
    (124) term -> . term MULTIPLY factor
    (125) term -> . term DIVIDE factor
    (126) term -> . term MOD factor
    (127) term -> . factor
    (128) factor -> . NOT factor
    (129) factor -> . PLUS factor
    (130) factor -> . MINUS factor
    (131) factor -> . PLUS_PLUS factor
    (132) factor -> . MINUS_MINUS factor
    (133) factor -> . cast brace
    (134) factor -> . brace
    (135) cast -> . L_PAREN TYPE R_PAREN
    (136) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (137) brace -> . L_PAREN expr R_PAREN
    (138) brace -> . brace PLUS_PLUS
    (139) brace -> . brace MINUS_MINUS
    (140) brace -> . NUM
    (141) brace -> . STRING
    (142) brace -> . MULTIPLY ID
    (143) brace -> . BIT_AND ID
    (144) brace -> . ID
    (145) brace -> . CHAR
    (146) brace -> . function_call
    (147) brace -> . ID narrayindex
    (148) NUM -> . INT_NUM
    (149) NUM -> . FLOAT_NUM
    (64) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    term                           shift and go to state 161
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 101

    (122) exprOP -> exprOP MINUS . term
    (124) term -> . term MULTIPLY factor
    (125) term -> . term DIVIDE factor
    (126) term -> . term MOD factor
    (127) term -> . factor
    (128) factor -> . NOT factor
    (129) factor -> . PLUS factor
    (130) factor -> . MINUS factor
    (131) factor -> . PLUS_PLUS factor
    (132) factor -> . MINUS_MINUS factor
    (133) factor -> . cast brace
    (134) factor -> . brace
    (135) cast -> . L_PAREN TYPE R_PAREN
    (136) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (137) brace -> . L_PAREN expr R_PAREN
    (138) brace -> . brace PLUS_PLUS
    (139) brace -> . brace MINUS_MINUS
    (140) brace -> . NUM
    (141) brace -> . STRING
    (142) brace -> . MULTIPLY ID
    (143) brace -> . BIT_AND ID
    (144) brace -> . ID
    (145) brace -> . CHAR
    (146) brace -> . function_call
    (147) brace -> . ID narrayindex
    (148) NUM -> . INT_NUM
    (149) NUM -> . FLOAT_NUM
    (64) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    term                           shift and go to state 162
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 102

    (129) factor -> PLUS factor .

    MULTIPLY        reduce using rule 129 (factor -> PLUS factor .)
    DIVIDE          reduce using rule 129 (factor -> PLUS factor .)
    MOD             reduce using rule 129 (factor -> PLUS factor .)
    PLUS            reduce using rule 129 (factor -> PLUS factor .)
    MINUS           reduce using rule 129 (factor -> PLUS factor .)
    L_SHIFT         reduce using rule 129 (factor -> PLUS factor .)
    R_SHIFT         reduce using rule 129 (factor -> PLUS factor .)
    LE              reduce using rule 129 (factor -> PLUS factor .)
    LT              reduce using rule 129 (factor -> PLUS factor .)
    GE              reduce using rule 129 (factor -> PLUS factor .)
    GT              reduce using rule 129 (factor -> PLUS factor .)
    EQ              reduce using rule 129 (factor -> PLUS factor .)
    NE              reduce using rule 129 (factor -> PLUS factor .)
    BIT_AND         reduce using rule 129 (factor -> PLUS factor .)
    BIT_XOR         reduce using rule 129 (factor -> PLUS factor .)
    BIT_OR          reduce using rule 129 (factor -> PLUS factor .)
    AND             reduce using rule 129 (factor -> PLUS factor .)
    OR              reduce using rule 129 (factor -> PLUS factor .)
    SEMICOLON       reduce using rule 129 (factor -> PLUS factor .)
    ASSIGN          reduce using rule 129 (factor -> PLUS factor .)
    PLUS_ASSIGN     reduce using rule 129 (factor -> PLUS factor .)
    MINUS_ASSIGN    reduce using rule 129 (factor -> PLUS factor .)
    MUL_ASSIGN      reduce using rule 129 (factor -> PLUS factor .)
    DIV_ASSIGN      reduce using rule 129 (factor -> PLUS factor .)
    AND_ASSIGN      reduce using rule 129 (factor -> PLUS factor .)
    OR_ASSIGN       reduce using rule 129 (factor -> PLUS factor .)
    XOR_ASSIGN      reduce using rule 129 (factor -> PLUS factor .)
    MOD_ASSIGN      reduce using rule 129 (factor -> PLUS factor .)
    L_SHIFT_ASSIGN  reduce using rule 129 (factor -> PLUS factor .)
    R_SHIFT_ASSIGN  reduce using rule 129 (factor -> PLUS factor .)
    R_PAREN         reduce using rule 129 (factor -> PLUS factor .)
    COMMA           reduce using rule 129 (factor -> PLUS factor .)
    R_SQBRACE       reduce using rule 129 (factor -> PLUS factor .)
    R_FLOWBRACE     reduce using rule 129 (factor -> PLUS factor .)


state 103

    (124) term -> term MULTIPLY . factor
    (128) factor -> . NOT factor
    (129) factor -> . PLUS factor
    (130) factor -> . MINUS factor
    (131) factor -> . PLUS_PLUS factor
    (132) factor -> . MINUS_MINUS factor
    (133) factor -> . cast brace
    (134) factor -> . brace
    (135) cast -> . L_PAREN TYPE R_PAREN
    (136) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (137) brace -> . L_PAREN expr R_PAREN
    (138) brace -> . brace PLUS_PLUS
    (139) brace -> . brace MINUS_MINUS
    (140) brace -> . NUM
    (141) brace -> . STRING
    (142) brace -> . MULTIPLY ID
    (143) brace -> . BIT_AND ID
    (144) brace -> . ID
    (145) brace -> . CHAR
    (146) brace -> . function_call
    (147) brace -> . ID narrayindex
    (148) NUM -> . INT_NUM
    (149) NUM -> . FLOAT_NUM
    (64) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    factor                         shift and go to state 163
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 104

    (125) term -> term DIVIDE . factor
    (128) factor -> . NOT factor
    (129) factor -> . PLUS factor
    (130) factor -> . MINUS factor
    (131) factor -> . PLUS_PLUS factor
    (132) factor -> . MINUS_MINUS factor
    (133) factor -> . cast brace
    (134) factor -> . brace
    (135) cast -> . L_PAREN TYPE R_PAREN
    (136) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (137) brace -> . L_PAREN expr R_PAREN
    (138) brace -> . brace PLUS_PLUS
    (139) brace -> . brace MINUS_MINUS
    (140) brace -> . NUM
    (141) brace -> . STRING
    (142) brace -> . MULTIPLY ID
    (143) brace -> . BIT_AND ID
    (144) brace -> . ID
    (145) brace -> . CHAR
    (146) brace -> . function_call
    (147) brace -> . ID narrayindex
    (148) NUM -> . INT_NUM
    (149) NUM -> . FLOAT_NUM
    (64) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    factor                         shift and go to state 164
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 105

    (126) term -> term MOD . factor
    (128) factor -> . NOT factor
    (129) factor -> . PLUS factor
    (130) factor -> . MINUS factor
    (131) factor -> . PLUS_PLUS factor
    (132) factor -> . MINUS_MINUS factor
    (133) factor -> . cast brace
    (134) factor -> . brace
    (135) cast -> . L_PAREN TYPE R_PAREN
    (136) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (137) brace -> . L_PAREN expr R_PAREN
    (138) brace -> . brace PLUS_PLUS
    (139) brace -> . brace MINUS_MINUS
    (140) brace -> . NUM
    (141) brace -> . STRING
    (142) brace -> . MULTIPLY ID
    (143) brace -> . BIT_AND ID
    (144) brace -> . ID
    (145) brace -> . CHAR
    (146) brace -> . function_call
    (147) brace -> . ID narrayindex
    (148) NUM -> . INT_NUM
    (149) NUM -> . FLOAT_NUM
    (64) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    factor                         shift and go to state 165
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 106

    (130) factor -> MINUS factor .

    MULTIPLY        reduce using rule 130 (factor -> MINUS factor .)
    DIVIDE          reduce using rule 130 (factor -> MINUS factor .)
    MOD             reduce using rule 130 (factor -> MINUS factor .)
    PLUS            reduce using rule 130 (factor -> MINUS factor .)
    MINUS           reduce using rule 130 (factor -> MINUS factor .)
    L_SHIFT         reduce using rule 130 (factor -> MINUS factor .)
    R_SHIFT         reduce using rule 130 (factor -> MINUS factor .)
    LE              reduce using rule 130 (factor -> MINUS factor .)
    LT              reduce using rule 130 (factor -> MINUS factor .)
    GE              reduce using rule 130 (factor -> MINUS factor .)
    GT              reduce using rule 130 (factor -> MINUS factor .)
    EQ              reduce using rule 130 (factor -> MINUS factor .)
    NE              reduce using rule 130 (factor -> MINUS factor .)
    BIT_AND         reduce using rule 130 (factor -> MINUS factor .)
    BIT_XOR         reduce using rule 130 (factor -> MINUS factor .)
    BIT_OR          reduce using rule 130 (factor -> MINUS factor .)
    AND             reduce using rule 130 (factor -> MINUS factor .)
    OR              reduce using rule 130 (factor -> MINUS factor .)
    SEMICOLON       reduce using rule 130 (factor -> MINUS factor .)
    ASSIGN          reduce using rule 130 (factor -> MINUS factor .)
    PLUS_ASSIGN     reduce using rule 130 (factor -> MINUS factor .)
    MINUS_ASSIGN    reduce using rule 130 (factor -> MINUS factor .)
    MUL_ASSIGN      reduce using rule 130 (factor -> MINUS factor .)
    DIV_ASSIGN      reduce using rule 130 (factor -> MINUS factor .)
    AND_ASSIGN      reduce using rule 130 (factor -> MINUS factor .)
    OR_ASSIGN       reduce using rule 130 (factor -> MINUS factor .)
    XOR_ASSIGN      reduce using rule 130 (factor -> MINUS factor .)
    MOD_ASSIGN      reduce using rule 130 (factor -> MINUS factor .)
    L_SHIFT_ASSIGN  reduce using rule 130 (factor -> MINUS factor .)
    R_SHIFT_ASSIGN  reduce using rule 130 (factor -> MINUS factor .)
    R_PAREN         reduce using rule 130 (factor -> MINUS factor .)
    COMMA           reduce using rule 130 (factor -> MINUS factor .)
    R_SQBRACE       reduce using rule 130 (factor -> MINUS factor .)
    R_FLOWBRACE     reduce using rule 130 (factor -> MINUS factor .)


state 107

    (128) factor -> NOT factor .

    MULTIPLY        reduce using rule 128 (factor -> NOT factor .)
    DIVIDE          reduce using rule 128 (factor -> NOT factor .)
    MOD             reduce using rule 128 (factor -> NOT factor .)
    PLUS            reduce using rule 128 (factor -> NOT factor .)
    MINUS           reduce using rule 128 (factor -> NOT factor .)
    L_SHIFT         reduce using rule 128 (factor -> NOT factor .)
    R_SHIFT         reduce using rule 128 (factor -> NOT factor .)
    LE              reduce using rule 128 (factor -> NOT factor .)
    LT              reduce using rule 128 (factor -> NOT factor .)
    GE              reduce using rule 128 (factor -> NOT factor .)
    GT              reduce using rule 128 (factor -> NOT factor .)
    EQ              reduce using rule 128 (factor -> NOT factor .)
    NE              reduce using rule 128 (factor -> NOT factor .)
    BIT_AND         reduce using rule 128 (factor -> NOT factor .)
    BIT_XOR         reduce using rule 128 (factor -> NOT factor .)
    BIT_OR          reduce using rule 128 (factor -> NOT factor .)
    AND             reduce using rule 128 (factor -> NOT factor .)
    OR              reduce using rule 128 (factor -> NOT factor .)
    SEMICOLON       reduce using rule 128 (factor -> NOT factor .)
    ASSIGN          reduce using rule 128 (factor -> NOT factor .)
    PLUS_ASSIGN     reduce using rule 128 (factor -> NOT factor .)
    MINUS_ASSIGN    reduce using rule 128 (factor -> NOT factor .)
    MUL_ASSIGN      reduce using rule 128 (factor -> NOT factor .)
    DIV_ASSIGN      reduce using rule 128 (factor -> NOT factor .)
    AND_ASSIGN      reduce using rule 128 (factor -> NOT factor .)
    OR_ASSIGN       reduce using rule 128 (factor -> NOT factor .)
    XOR_ASSIGN      reduce using rule 128 (factor -> NOT factor .)
    MOD_ASSIGN      reduce using rule 128 (factor -> NOT factor .)
    L_SHIFT_ASSIGN  reduce using rule 128 (factor -> NOT factor .)
    R_SHIFT_ASSIGN  reduce using rule 128 (factor -> NOT factor .)
    R_PAREN         reduce using rule 128 (factor -> NOT factor .)
    COMMA           reduce using rule 128 (factor -> NOT factor .)
    R_SQBRACE       reduce using rule 128 (factor -> NOT factor .)
    R_FLOWBRACE     reduce using rule 128 (factor -> NOT factor .)


state 108

    (131) factor -> PLUS_PLUS factor .

    MULTIPLY        reduce using rule 131 (factor -> PLUS_PLUS factor .)
    DIVIDE          reduce using rule 131 (factor -> PLUS_PLUS factor .)
    MOD             reduce using rule 131 (factor -> PLUS_PLUS factor .)
    PLUS            reduce using rule 131 (factor -> PLUS_PLUS factor .)
    MINUS           reduce using rule 131 (factor -> PLUS_PLUS factor .)
    L_SHIFT         reduce using rule 131 (factor -> PLUS_PLUS factor .)
    R_SHIFT         reduce using rule 131 (factor -> PLUS_PLUS factor .)
    LE              reduce using rule 131 (factor -> PLUS_PLUS factor .)
    LT              reduce using rule 131 (factor -> PLUS_PLUS factor .)
    GE              reduce using rule 131 (factor -> PLUS_PLUS factor .)
    GT              reduce using rule 131 (factor -> PLUS_PLUS factor .)
    EQ              reduce using rule 131 (factor -> PLUS_PLUS factor .)
    NE              reduce using rule 131 (factor -> PLUS_PLUS factor .)
    BIT_AND         reduce using rule 131 (factor -> PLUS_PLUS factor .)
    BIT_XOR         reduce using rule 131 (factor -> PLUS_PLUS factor .)
    BIT_OR          reduce using rule 131 (factor -> PLUS_PLUS factor .)
    AND             reduce using rule 131 (factor -> PLUS_PLUS factor .)
    OR              reduce using rule 131 (factor -> PLUS_PLUS factor .)
    SEMICOLON       reduce using rule 131 (factor -> PLUS_PLUS factor .)
    ASSIGN          reduce using rule 131 (factor -> PLUS_PLUS factor .)
    PLUS_ASSIGN     reduce using rule 131 (factor -> PLUS_PLUS factor .)
    MINUS_ASSIGN    reduce using rule 131 (factor -> PLUS_PLUS factor .)
    MUL_ASSIGN      reduce using rule 131 (factor -> PLUS_PLUS factor .)
    DIV_ASSIGN      reduce using rule 131 (factor -> PLUS_PLUS factor .)
    AND_ASSIGN      reduce using rule 131 (factor -> PLUS_PLUS factor .)
    OR_ASSIGN       reduce using rule 131 (factor -> PLUS_PLUS factor .)
    XOR_ASSIGN      reduce using rule 131 (factor -> PLUS_PLUS factor .)
    MOD_ASSIGN      reduce using rule 131 (factor -> PLUS_PLUS factor .)
    L_SHIFT_ASSIGN  reduce using rule 131 (factor -> PLUS_PLUS factor .)
    R_SHIFT_ASSIGN  reduce using rule 131 (factor -> PLUS_PLUS factor .)
    R_PAREN         reduce using rule 131 (factor -> PLUS_PLUS factor .)
    COMMA           reduce using rule 131 (factor -> PLUS_PLUS factor .)
    R_SQBRACE       reduce using rule 131 (factor -> PLUS_PLUS factor .)
    R_FLOWBRACE     reduce using rule 131 (factor -> PLUS_PLUS factor .)


state 109

    (132) factor -> MINUS_MINUS factor .

    MULTIPLY        reduce using rule 132 (factor -> MINUS_MINUS factor .)
    DIVIDE          reduce using rule 132 (factor -> MINUS_MINUS factor .)
    MOD             reduce using rule 132 (factor -> MINUS_MINUS factor .)
    PLUS            reduce using rule 132 (factor -> MINUS_MINUS factor .)
    MINUS           reduce using rule 132 (factor -> MINUS_MINUS factor .)
    L_SHIFT         reduce using rule 132 (factor -> MINUS_MINUS factor .)
    R_SHIFT         reduce using rule 132 (factor -> MINUS_MINUS factor .)
    LE              reduce using rule 132 (factor -> MINUS_MINUS factor .)
    LT              reduce using rule 132 (factor -> MINUS_MINUS factor .)
    GE              reduce using rule 132 (factor -> MINUS_MINUS factor .)
    GT              reduce using rule 132 (factor -> MINUS_MINUS factor .)
    EQ              reduce using rule 132 (factor -> MINUS_MINUS factor .)
    NE              reduce using rule 132 (factor -> MINUS_MINUS factor .)
    BIT_AND         reduce using rule 132 (factor -> MINUS_MINUS factor .)
    BIT_XOR         reduce using rule 132 (factor -> MINUS_MINUS factor .)
    BIT_OR          reduce using rule 132 (factor -> MINUS_MINUS factor .)
    AND             reduce using rule 132 (factor -> MINUS_MINUS factor .)
    OR              reduce using rule 132 (factor -> MINUS_MINUS factor .)
    SEMICOLON       reduce using rule 132 (factor -> MINUS_MINUS factor .)
    ASSIGN          reduce using rule 132 (factor -> MINUS_MINUS factor .)
    PLUS_ASSIGN     reduce using rule 132 (factor -> MINUS_MINUS factor .)
    MINUS_ASSIGN    reduce using rule 132 (factor -> MINUS_MINUS factor .)
    MUL_ASSIGN      reduce using rule 132 (factor -> MINUS_MINUS factor .)
    DIV_ASSIGN      reduce using rule 132 (factor -> MINUS_MINUS factor .)
    AND_ASSIGN      reduce using rule 132 (factor -> MINUS_MINUS factor .)
    OR_ASSIGN       reduce using rule 132 (factor -> MINUS_MINUS factor .)
    XOR_ASSIGN      reduce using rule 132 (factor -> MINUS_MINUS factor .)
    MOD_ASSIGN      reduce using rule 132 (factor -> MINUS_MINUS factor .)
    L_SHIFT_ASSIGN  reduce using rule 132 (factor -> MINUS_MINUS factor .)
    R_SHIFT_ASSIGN  reduce using rule 132 (factor -> MINUS_MINUS factor .)
    R_PAREN         reduce using rule 132 (factor -> MINUS_MINUS factor .)
    COMMA           reduce using rule 132 (factor -> MINUS_MINUS factor .)
    R_SQBRACE       reduce using rule 132 (factor -> MINUS_MINUS factor .)
    R_FLOWBRACE     reduce using rule 132 (factor -> MINUS_MINUS factor .)


state 110

    (133) factor -> cast brace .
    (138) brace -> brace . PLUS_PLUS
    (139) brace -> brace . MINUS_MINUS

    MULTIPLY        reduce using rule 133 (factor -> cast brace .)
    DIVIDE          reduce using rule 133 (factor -> cast brace .)
    MOD             reduce using rule 133 (factor -> cast brace .)
    PLUS            reduce using rule 133 (factor -> cast brace .)
    MINUS           reduce using rule 133 (factor -> cast brace .)
    L_SHIFT         reduce using rule 133 (factor -> cast brace .)
    R_SHIFT         reduce using rule 133 (factor -> cast brace .)
    LE              reduce using rule 133 (factor -> cast brace .)
    LT              reduce using rule 133 (factor -> cast brace .)
    GE              reduce using rule 133 (factor -> cast brace .)
    GT              reduce using rule 133 (factor -> cast brace .)
    EQ              reduce using rule 133 (factor -> cast brace .)
    NE              reduce using rule 133 (factor -> cast brace .)
    BIT_AND         reduce using rule 133 (factor -> cast brace .)
    BIT_XOR         reduce using rule 133 (factor -> cast brace .)
    BIT_OR          reduce using rule 133 (factor -> cast brace .)
    AND             reduce using rule 133 (factor -> cast brace .)
    OR              reduce using rule 133 (factor -> cast brace .)
    SEMICOLON       reduce using rule 133 (factor -> cast brace .)
    ASSIGN          reduce using rule 133 (factor -> cast brace .)
    PLUS_ASSIGN     reduce using rule 133 (factor -> cast brace .)
    MINUS_ASSIGN    reduce using rule 133 (factor -> cast brace .)
    MUL_ASSIGN      reduce using rule 133 (factor -> cast brace .)
    DIV_ASSIGN      reduce using rule 133 (factor -> cast brace .)
    AND_ASSIGN      reduce using rule 133 (factor -> cast brace .)
    OR_ASSIGN       reduce using rule 133 (factor -> cast brace .)
    XOR_ASSIGN      reduce using rule 133 (factor -> cast brace .)
    MOD_ASSIGN      reduce using rule 133 (factor -> cast brace .)
    L_SHIFT_ASSIGN  reduce using rule 133 (factor -> cast brace .)
    R_SHIFT_ASSIGN  reduce using rule 133 (factor -> cast brace .)
    R_PAREN         reduce using rule 133 (factor -> cast brace .)
    COMMA           reduce using rule 133 (factor -> cast brace .)
    R_SQBRACE       reduce using rule 133 (factor -> cast brace .)
    R_FLOWBRACE     reduce using rule 133 (factor -> cast brace .)
    PLUS_PLUS       shift and go to state 112
    MINUS_MINUS     shift and go to state 113


state 111

    (137) brace -> L_PAREN . expr R_PAREN
    (86) expr -> . expr assignment exprOR
    (87) expr -> . exprOR
    (99) exprOR -> . exprOR OR exprAND
    (100) exprOR -> . exprAND
    (101) exprAND -> . exprAND AND exprBITOR
    (102) exprAND -> . exprBITOR
    (103) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (104) exprBITOR -> . exprBITXOR
    (105) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (106) exprBITXOR -> . exprBITAND
    (107) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (108) exprBITAND -> . exprEQ
    (109) exprEQ -> . exprEQ EQ exprRELOP
    (110) exprEQ -> . exprEQ NE exprRELOP
    (111) exprEQ -> . exprRELOP
    (112) exprRELOP -> . exprRELOP relop exprSHIFT
    (113) exprRELOP -> . exprSHIFT
    (118) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (119) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (120) exprSHIFT -> . exprOP
    (121) exprOP -> . exprOP PLUS term
    (122) exprOP -> . exprOP MINUS term
    (123) exprOP -> . term
    (124) term -> . term MULTIPLY factor
    (125) term -> . term DIVIDE factor
    (126) term -> . term MOD factor
    (127) term -> . factor
    (128) factor -> . NOT factor
    (129) factor -> . PLUS factor
    (130) factor -> . MINUS factor
    (131) factor -> . PLUS_PLUS factor
    (132) factor -> . MINUS_MINUS factor
    (133) factor -> . cast brace
    (134) factor -> . brace
    (135) cast -> . L_PAREN TYPE R_PAREN
    (136) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (137) brace -> . L_PAREN expr R_PAREN
    (138) brace -> . brace PLUS_PLUS
    (139) brace -> . brace MINUS_MINUS
    (140) brace -> . NUM
    (141) brace -> . STRING
    (142) brace -> . MULTIPLY ID
    (143) brace -> . BIT_AND ID
    (144) brace -> . ID
    (145) brace -> . CHAR
    (146) brace -> . function_call
    (147) brace -> . ID narrayindex
    (148) NUM -> . INT_NUM
    (149) NUM -> . FLOAT_NUM
    (64) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    expr                           shift and go to state 85
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 112

    (138) brace -> brace PLUS_PLUS .

    PLUS_PLUS       reduce using rule 138 (brace -> brace PLUS_PLUS .)
    MINUS_MINUS     reduce using rule 138 (brace -> brace PLUS_PLUS .)
    MULTIPLY        reduce using rule 138 (brace -> brace PLUS_PLUS .)
    DIVIDE          reduce using rule 138 (brace -> brace PLUS_PLUS .)
    MOD             reduce using rule 138 (brace -> brace PLUS_PLUS .)
    PLUS            reduce using rule 138 (brace -> brace PLUS_PLUS .)
    MINUS           reduce using rule 138 (brace -> brace PLUS_PLUS .)
    L_SHIFT         reduce using rule 138 (brace -> brace PLUS_PLUS .)
    R_SHIFT         reduce using rule 138 (brace -> brace PLUS_PLUS .)
    LE              reduce using rule 138 (brace -> brace PLUS_PLUS .)
    LT              reduce using rule 138 (brace -> brace PLUS_PLUS .)
    GE              reduce using rule 138 (brace -> brace PLUS_PLUS .)
    GT              reduce using rule 138 (brace -> brace PLUS_PLUS .)
    EQ              reduce using rule 138 (brace -> brace PLUS_PLUS .)
    NE              reduce using rule 138 (brace -> brace PLUS_PLUS .)
    BIT_AND         reduce using rule 138 (brace -> brace PLUS_PLUS .)
    BIT_XOR         reduce using rule 138 (brace -> brace PLUS_PLUS .)
    BIT_OR          reduce using rule 138 (brace -> brace PLUS_PLUS .)
    AND             reduce using rule 138 (brace -> brace PLUS_PLUS .)
    OR              reduce using rule 138 (brace -> brace PLUS_PLUS .)
    SEMICOLON       reduce using rule 138 (brace -> brace PLUS_PLUS .)
    ASSIGN          reduce using rule 138 (brace -> brace PLUS_PLUS .)
    PLUS_ASSIGN     reduce using rule 138 (brace -> brace PLUS_PLUS .)
    MINUS_ASSIGN    reduce using rule 138 (brace -> brace PLUS_PLUS .)
    MUL_ASSIGN      reduce using rule 138 (brace -> brace PLUS_PLUS .)
    DIV_ASSIGN      reduce using rule 138 (brace -> brace PLUS_PLUS .)
    AND_ASSIGN      reduce using rule 138 (brace -> brace PLUS_PLUS .)
    OR_ASSIGN       reduce using rule 138 (brace -> brace PLUS_PLUS .)
    XOR_ASSIGN      reduce using rule 138 (brace -> brace PLUS_PLUS .)
    MOD_ASSIGN      reduce using rule 138 (brace -> brace PLUS_PLUS .)
    L_SHIFT_ASSIGN  reduce using rule 138 (brace -> brace PLUS_PLUS .)
    R_SHIFT_ASSIGN  reduce using rule 138 (brace -> brace PLUS_PLUS .)
    R_PAREN         reduce using rule 138 (brace -> brace PLUS_PLUS .)
    COMMA           reduce using rule 138 (brace -> brace PLUS_PLUS .)
    R_SQBRACE       reduce using rule 138 (brace -> brace PLUS_PLUS .)
    R_FLOWBRACE     reduce using rule 138 (brace -> brace PLUS_PLUS .)


state 113

    (139) brace -> brace MINUS_MINUS .

    PLUS_PLUS       reduce using rule 139 (brace -> brace MINUS_MINUS .)
    MINUS_MINUS     reduce using rule 139 (brace -> brace MINUS_MINUS .)
    MULTIPLY        reduce using rule 139 (brace -> brace MINUS_MINUS .)
    DIVIDE          reduce using rule 139 (brace -> brace MINUS_MINUS .)
    MOD             reduce using rule 139 (brace -> brace MINUS_MINUS .)
    PLUS            reduce using rule 139 (brace -> brace MINUS_MINUS .)
    MINUS           reduce using rule 139 (brace -> brace MINUS_MINUS .)
    L_SHIFT         reduce using rule 139 (brace -> brace MINUS_MINUS .)
    R_SHIFT         reduce using rule 139 (brace -> brace MINUS_MINUS .)
    LE              reduce using rule 139 (brace -> brace MINUS_MINUS .)
    LT              reduce using rule 139 (brace -> brace MINUS_MINUS .)
    GE              reduce using rule 139 (brace -> brace MINUS_MINUS .)
    GT              reduce using rule 139 (brace -> brace MINUS_MINUS .)
    EQ              reduce using rule 139 (brace -> brace MINUS_MINUS .)
    NE              reduce using rule 139 (brace -> brace MINUS_MINUS .)
    BIT_AND         reduce using rule 139 (brace -> brace MINUS_MINUS .)
    BIT_XOR         reduce using rule 139 (brace -> brace MINUS_MINUS .)
    BIT_OR          reduce using rule 139 (brace -> brace MINUS_MINUS .)
    AND             reduce using rule 139 (brace -> brace MINUS_MINUS .)
    OR              reduce using rule 139 (brace -> brace MINUS_MINUS .)
    SEMICOLON       reduce using rule 139 (brace -> brace MINUS_MINUS .)
    ASSIGN          reduce using rule 139 (brace -> brace MINUS_MINUS .)
    PLUS_ASSIGN     reduce using rule 139 (brace -> brace MINUS_MINUS .)
    MINUS_ASSIGN    reduce using rule 139 (brace -> brace MINUS_MINUS .)
    MUL_ASSIGN      reduce using rule 139 (brace -> brace MINUS_MINUS .)
    DIV_ASSIGN      reduce using rule 139 (brace -> brace MINUS_MINUS .)
    AND_ASSIGN      reduce using rule 139 (brace -> brace MINUS_MINUS .)
    OR_ASSIGN       reduce using rule 139 (brace -> brace MINUS_MINUS .)
    XOR_ASSIGN      reduce using rule 139 (brace -> brace MINUS_MINUS .)
    MOD_ASSIGN      reduce using rule 139 (brace -> brace MINUS_MINUS .)
    L_SHIFT_ASSIGN  reduce using rule 139 (brace -> brace MINUS_MINUS .)
    R_SHIFT_ASSIGN  reduce using rule 139 (brace -> brace MINUS_MINUS .)
    R_PAREN         reduce using rule 139 (brace -> brace MINUS_MINUS .)
    COMMA           reduce using rule 139 (brace -> brace MINUS_MINUS .)
    R_SQBRACE       reduce using rule 139 (brace -> brace MINUS_MINUS .)
    R_FLOWBRACE     reduce using rule 139 (brace -> brace MINUS_MINUS .)


state 114

    (14) closed -> IF . condition closed else closed
    (7) open -> IF . condition statement
    (8) open -> IF . condition closed else open
    (17) condition -> . L_PAREN expr R_PAREN

    L_PAREN         shift and go to state 52

    condition                      shift and go to state 166

state 115

    (7) open -> IF condition statement .

    IF              reduce using rule 7 (open -> IF condition statement .)
    WHILE           reduce using rule 7 (open -> IF condition statement .)
    FOR             reduce using rule 7 (open -> IF condition statement .)
    SEMICOLON       reduce using rule 7 (open -> IF condition statement .)
    RETURN          reduce using rule 7 (open -> IF condition statement .)
    HASH            reduce using rule 7 (open -> IF condition statement .)
    TYPE            reduce using rule 7 (open -> IF condition statement .)
    L_FLOWBRACE     reduce using rule 7 (open -> IF condition statement .)
    NOT             reduce using rule 7 (open -> IF condition statement .)
    PLUS            reduce using rule 7 (open -> IF condition statement .)
    MINUS           reduce using rule 7 (open -> IF condition statement .)
    PLUS_PLUS       reduce using rule 7 (open -> IF condition statement .)
    MINUS_MINUS     reduce using rule 7 (open -> IF condition statement .)
    L_PAREN         reduce using rule 7 (open -> IF condition statement .)
    STRING          reduce using rule 7 (open -> IF condition statement .)
    MULTIPLY        reduce using rule 7 (open -> IF condition statement .)
    BIT_AND         reduce using rule 7 (open -> IF condition statement .)
    ID              reduce using rule 7 (open -> IF condition statement .)
    CHAR            reduce using rule 7 (open -> IF condition statement .)
    INT_NUM         reduce using rule 7 (open -> IF condition statement .)
    FLOAT_NUM       reduce using rule 7 (open -> IF condition statement .)
    $end            reduce using rule 7 (open -> IF condition statement .)
    R_FLOWBRACE     reduce using rule 7 (open -> IF condition statement .)


state 116

    (8) open -> IF condition closed . else open
    (14) closed -> IF condition closed . else closed
    (5) statement -> closed .
    (6) else -> . ELSE

    IF              reduce using rule 5 (statement -> closed .)
    WHILE           reduce using rule 5 (statement -> closed .)
    FOR             reduce using rule 5 (statement -> closed .)
    SEMICOLON       reduce using rule 5 (statement -> closed .)
    RETURN          reduce using rule 5 (statement -> closed .)
    HASH            reduce using rule 5 (statement -> closed .)
    TYPE            reduce using rule 5 (statement -> closed .)
    L_FLOWBRACE     reduce using rule 5 (statement -> closed .)
    NOT             reduce using rule 5 (statement -> closed .)
    PLUS            reduce using rule 5 (statement -> closed .)
    MINUS           reduce using rule 5 (statement -> closed .)
    PLUS_PLUS       reduce using rule 5 (statement -> closed .)
    MINUS_MINUS     reduce using rule 5 (statement -> closed .)
    L_PAREN         reduce using rule 5 (statement -> closed .)
    STRING          reduce using rule 5 (statement -> closed .)
    MULTIPLY        reduce using rule 5 (statement -> closed .)
    BIT_AND         reduce using rule 5 (statement -> closed .)
    ID              reduce using rule 5 (statement -> closed .)
    CHAR            reduce using rule 5 (statement -> closed .)
    INT_NUM         reduce using rule 5 (statement -> closed .)
    FLOAT_NUM       reduce using rule 5 (statement -> closed .)
    $end            reduce using rule 5 (statement -> closed .)
    R_FLOWBRACE     reduce using rule 5 (statement -> closed .)
    ELSE            shift and go to state 168

    else                           shift and go to state 167

state 117

    (15) closed -> WHILE . condition closed
    (9) open -> WHILE . condition open
    (17) condition -> . L_PAREN expr R_PAREN

    L_PAREN         shift and go to state 52

    condition                      shift and go to state 169

state 118

    (16) closed -> for . for_condition closed
    (10) open -> for . for_condition open
    (18) for_condition -> . L_PAREN simple simple expr R_PAREN
    (19) for_condition -> . L_PAREN simple simple R_PAREN

    L_PAREN         shift and go to state 55

    for_condition                  shift and go to state 170

state 119

    (17) condition -> L_PAREN expr . R_PAREN
    (86) expr -> expr . assignment exprOR
    (88) assignment -> . ASSIGN
    (89) assignment -> . PLUS_ASSIGN
    (90) assignment -> . MINUS_ASSIGN
    (91) assignment -> . MUL_ASSIGN
    (92) assignment -> . DIV_ASSIGN
    (93) assignment -> . AND_ASSIGN
    (94) assignment -> . OR_ASSIGN
    (95) assignment -> . XOR_ASSIGN
    (96) assignment -> . MOD_ASSIGN
    (97) assignment -> . L_SHIFT_ASSIGN
    (98) assignment -> . R_SHIFT_ASSIGN

    R_PAREN         shift and go to state 171
    ASSIGN          shift and go to state 58
    PLUS_ASSIGN     shift and go to state 59
    MINUS_ASSIGN    shift and go to state 60
    MUL_ASSIGN      shift and go to state 61
    DIV_ASSIGN      shift and go to state 62
    AND_ASSIGN      shift and go to state 63
    OR_ASSIGN       shift and go to state 64
    XOR_ASSIGN      shift and go to state 65
    MOD_ASSIGN      shift and go to state 66
    L_SHIFT_ASSIGN  shift and go to state 67
    R_SHIFT_ASSIGN  shift and go to state 68

    assignment                     shift and go to state 57

state 120

    (9) open -> WHILE condition open .

    IF              reduce using rule 9 (open -> WHILE condition open .)
    WHILE           reduce using rule 9 (open -> WHILE condition open .)
    FOR             reduce using rule 9 (open -> WHILE condition open .)
    SEMICOLON       reduce using rule 9 (open -> WHILE condition open .)
    RETURN          reduce using rule 9 (open -> WHILE condition open .)
    HASH            reduce using rule 9 (open -> WHILE condition open .)
    TYPE            reduce using rule 9 (open -> WHILE condition open .)
    L_FLOWBRACE     reduce using rule 9 (open -> WHILE condition open .)
    NOT             reduce using rule 9 (open -> WHILE condition open .)
    PLUS            reduce using rule 9 (open -> WHILE condition open .)
    MINUS           reduce using rule 9 (open -> WHILE condition open .)
    PLUS_PLUS       reduce using rule 9 (open -> WHILE condition open .)
    MINUS_MINUS     reduce using rule 9 (open -> WHILE condition open .)
    L_PAREN         reduce using rule 9 (open -> WHILE condition open .)
    STRING          reduce using rule 9 (open -> WHILE condition open .)
    MULTIPLY        reduce using rule 9 (open -> WHILE condition open .)
    BIT_AND         reduce using rule 9 (open -> WHILE condition open .)
    ID              reduce using rule 9 (open -> WHILE condition open .)
    CHAR            reduce using rule 9 (open -> WHILE condition open .)
    INT_NUM         reduce using rule 9 (open -> WHILE condition open .)
    FLOAT_NUM       reduce using rule 9 (open -> WHILE condition open .)
    $end            reduce using rule 9 (open -> WHILE condition open .)
    R_FLOWBRACE     reduce using rule 9 (open -> WHILE condition open .)


state 121

    (15) closed -> WHILE condition closed .

    IF              reduce using rule 15 (closed -> WHILE condition closed .)
    WHILE           reduce using rule 15 (closed -> WHILE condition closed .)
    FOR             reduce using rule 15 (closed -> WHILE condition closed .)
    SEMICOLON       reduce using rule 15 (closed -> WHILE condition closed .)
    RETURN          reduce using rule 15 (closed -> WHILE condition closed .)
    HASH            reduce using rule 15 (closed -> WHILE condition closed .)
    TYPE            reduce using rule 15 (closed -> WHILE condition closed .)
    L_FLOWBRACE     reduce using rule 15 (closed -> WHILE condition closed .)
    NOT             reduce using rule 15 (closed -> WHILE condition closed .)
    PLUS            reduce using rule 15 (closed -> WHILE condition closed .)
    MINUS           reduce using rule 15 (closed -> WHILE condition closed .)
    PLUS_PLUS       reduce using rule 15 (closed -> WHILE condition closed .)
    MINUS_MINUS     reduce using rule 15 (closed -> WHILE condition closed .)
    L_PAREN         reduce using rule 15 (closed -> WHILE condition closed .)
    STRING          reduce using rule 15 (closed -> WHILE condition closed .)
    MULTIPLY        reduce using rule 15 (closed -> WHILE condition closed .)
    BIT_AND         reduce using rule 15 (closed -> WHILE condition closed .)
    ID              reduce using rule 15 (closed -> WHILE condition closed .)
    CHAR            reduce using rule 15 (closed -> WHILE condition closed .)
    INT_NUM         reduce using rule 15 (closed -> WHILE condition closed .)
    FLOAT_NUM       reduce using rule 15 (closed -> WHILE condition closed .)
    $end            reduce using rule 15 (closed -> WHILE condition closed .)
    R_FLOWBRACE     reduce using rule 15 (closed -> WHILE condition closed .)
    ELSE            reduce using rule 15 (closed -> WHILE condition closed .)


state 122

    (10) open -> for for_condition open .

    IF              reduce using rule 10 (open -> for for_condition open .)
    WHILE           reduce using rule 10 (open -> for for_condition open .)
    FOR             reduce using rule 10 (open -> for for_condition open .)
    SEMICOLON       reduce using rule 10 (open -> for for_condition open .)
    RETURN          reduce using rule 10 (open -> for for_condition open .)
    HASH            reduce using rule 10 (open -> for for_condition open .)
    TYPE            reduce using rule 10 (open -> for for_condition open .)
    L_FLOWBRACE     reduce using rule 10 (open -> for for_condition open .)
    NOT             reduce using rule 10 (open -> for for_condition open .)
    PLUS            reduce using rule 10 (open -> for for_condition open .)
    MINUS           reduce using rule 10 (open -> for for_condition open .)
    PLUS_PLUS       reduce using rule 10 (open -> for for_condition open .)
    MINUS_MINUS     reduce using rule 10 (open -> for for_condition open .)
    L_PAREN         reduce using rule 10 (open -> for for_condition open .)
    STRING          reduce using rule 10 (open -> for for_condition open .)
    MULTIPLY        reduce using rule 10 (open -> for for_condition open .)
    BIT_AND         reduce using rule 10 (open -> for for_condition open .)
    ID              reduce using rule 10 (open -> for for_condition open .)
    CHAR            reduce using rule 10 (open -> for for_condition open .)
    INT_NUM         reduce using rule 10 (open -> for for_condition open .)
    FLOAT_NUM       reduce using rule 10 (open -> for for_condition open .)
    $end            reduce using rule 10 (open -> for for_condition open .)
    R_FLOWBRACE     reduce using rule 10 (open -> for for_condition open .)


state 123

    (16) closed -> for for_condition closed .

    IF              reduce using rule 16 (closed -> for for_condition closed .)
    WHILE           reduce using rule 16 (closed -> for for_condition closed .)
    FOR             reduce using rule 16 (closed -> for for_condition closed .)
    SEMICOLON       reduce using rule 16 (closed -> for for_condition closed .)
    RETURN          reduce using rule 16 (closed -> for for_condition closed .)
    HASH            reduce using rule 16 (closed -> for for_condition closed .)
    TYPE            reduce using rule 16 (closed -> for for_condition closed .)
    L_FLOWBRACE     reduce using rule 16 (closed -> for for_condition closed .)
    NOT             reduce using rule 16 (closed -> for for_condition closed .)
    PLUS            reduce using rule 16 (closed -> for for_condition closed .)
    MINUS           reduce using rule 16 (closed -> for for_condition closed .)
    PLUS_PLUS       reduce using rule 16 (closed -> for for_condition closed .)
    MINUS_MINUS     reduce using rule 16 (closed -> for for_condition closed .)
    L_PAREN         reduce using rule 16 (closed -> for for_condition closed .)
    STRING          reduce using rule 16 (closed -> for for_condition closed .)
    MULTIPLY        reduce using rule 16 (closed -> for for_condition closed .)
    BIT_AND         reduce using rule 16 (closed -> for for_condition closed .)
    ID              reduce using rule 16 (closed -> for for_condition closed .)
    CHAR            reduce using rule 16 (closed -> for for_condition closed .)
    INT_NUM         reduce using rule 16 (closed -> for for_condition closed .)
    FLOAT_NUM       reduce using rule 16 (closed -> for for_condition closed .)
    $end            reduce using rule 16 (closed -> for for_condition closed .)
    R_FLOWBRACE     reduce using rule 16 (closed -> for for_condition closed .)
    ELSE            reduce using rule 16 (closed -> for for_condition closed .)


state 124

    (18) for_condition -> L_PAREN simple . simple expr R_PAREN
    (19) for_condition -> L_PAREN simple . simple R_PAREN
    (54) simple -> . expr SEMICOLON
    (55) simple -> . header
    (56) simple -> . declaration
    (57) simple -> . SEMICOLON
    (58) simple -> . function
    (59) simple -> . RETURN expr SEMICOLON
    (60) simple -> . RETURN SEMICOLON
    (86) expr -> . expr assignment exprOR
    (87) expr -> . exprOR
    (61) header -> . HASH INCLUDE STRING
    (62) header -> . HASH INCLUDE HEADER_FILE
    (35) declaration -> . TYPE ID SEMICOLON
    (36) declaration -> . TYPE MULTIPLY ID SEMICOLON
    (37) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (38) declaration -> . TYPE MULTIPLY ID ASSIGN expr SEMICOLON
    (39) declaration -> . TYPE multi_declaration stop
    (40) declaration -> . TYPE ID narrayindex SEMICOLON
    (41) declaration -> . TYPE ID narrayindex ASSIGN init_list SEMICOLON
    (83) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (99) exprOR -> . exprOR OR exprAND
    (100) exprOR -> . exprAND
    (101) exprAND -> . exprAND AND exprBITOR
    (102) exprAND -> . exprBITOR
    (103) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (104) exprBITOR -> . exprBITXOR
    (105) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (106) exprBITXOR -> . exprBITAND
    (107) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (108) exprBITAND -> . exprEQ
    (109) exprEQ -> . exprEQ EQ exprRELOP
    (110) exprEQ -> . exprEQ NE exprRELOP
    (111) exprEQ -> . exprRELOP
    (112) exprRELOP -> . exprRELOP relop exprSHIFT
    (113) exprRELOP -> . exprSHIFT
    (118) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (119) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (120) exprSHIFT -> . exprOP
    (121) exprOP -> . exprOP PLUS term
    (122) exprOP -> . exprOP MINUS term
    (123) exprOP -> . term
    (124) term -> . term MULTIPLY factor
    (125) term -> . term DIVIDE factor
    (126) term -> . term MOD factor
    (127) term -> . factor
    (128) factor -> . NOT factor
    (129) factor -> . PLUS factor
    (130) factor -> . MINUS factor
    (131) factor -> . PLUS_PLUS factor
    (132) factor -> . MINUS_MINUS factor
    (133) factor -> . cast brace
    (134) factor -> . brace
    (135) cast -> . L_PAREN TYPE R_PAREN
    (136) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (137) brace -> . L_PAREN expr R_PAREN
    (138) brace -> . brace PLUS_PLUS
    (139) brace -> . brace MINUS_MINUS
    (140) brace -> . NUM
    (141) brace -> . STRING
    (142) brace -> . MULTIPLY ID
    (143) brace -> . BIT_AND ID
    (144) brace -> . ID
    (145) brace -> . CHAR
    (146) brace -> . function_call
    (147) brace -> . ID narrayindex
    (148) NUM -> . INT_NUM
    (149) NUM -> . FLOAT_NUM
    (64) function_call -> . ID L_PAREN call_params R_PAREN

    SEMICOLON       shift and go to state 13
    RETURN          shift and go to state 17
    HASH            shift and go to state 20
    TYPE            shift and go to state 22
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    simple                         shift and go to state 172
    expr                           shift and go to state 12
    header                         shift and go to state 14
    declaration                    shift and go to state 15
    function                       shift and go to state 16
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 125

    (86) expr -> expr assignment exprOR .
    (99) exprOR -> exprOR . OR exprAND

    SEMICOLON       reduce using rule 86 (expr -> expr assignment exprOR .)
    ASSIGN          reduce using rule 86 (expr -> expr assignment exprOR .)
    PLUS_ASSIGN     reduce using rule 86 (expr -> expr assignment exprOR .)
    MINUS_ASSIGN    reduce using rule 86 (expr -> expr assignment exprOR .)
    MUL_ASSIGN      reduce using rule 86 (expr -> expr assignment exprOR .)
    DIV_ASSIGN      reduce using rule 86 (expr -> expr assignment exprOR .)
    AND_ASSIGN      reduce using rule 86 (expr -> expr assignment exprOR .)
    OR_ASSIGN       reduce using rule 86 (expr -> expr assignment exprOR .)
    XOR_ASSIGN      reduce using rule 86 (expr -> expr assignment exprOR .)
    MOD_ASSIGN      reduce using rule 86 (expr -> expr assignment exprOR .)
    L_SHIFT_ASSIGN  reduce using rule 86 (expr -> expr assignment exprOR .)
    R_SHIFT_ASSIGN  reduce using rule 86 (expr -> expr assignment exprOR .)
    R_PAREN         reduce using rule 86 (expr -> expr assignment exprOR .)
    COMMA           reduce using rule 86 (expr -> expr assignment exprOR .)
    R_SQBRACE       reduce using rule 86 (expr -> expr assignment exprOR .)
    R_FLOWBRACE     reduce using rule 86 (expr -> expr assignment exprOR .)
    OR              shift and go to state 74


state 126

    (59) simple -> RETURN expr SEMICOLON .

    IF              reduce using rule 59 (simple -> RETURN expr SEMICOLON .)
    WHILE           reduce using rule 59 (simple -> RETURN expr SEMICOLON .)
    FOR             reduce using rule 59 (simple -> RETURN expr SEMICOLON .)
    SEMICOLON       reduce using rule 59 (simple -> RETURN expr SEMICOLON .)
    RETURN          reduce using rule 59 (simple -> RETURN expr SEMICOLON .)
    HASH            reduce using rule 59 (simple -> RETURN expr SEMICOLON .)
    TYPE            reduce using rule 59 (simple -> RETURN expr SEMICOLON .)
    L_FLOWBRACE     reduce using rule 59 (simple -> RETURN expr SEMICOLON .)
    NOT             reduce using rule 59 (simple -> RETURN expr SEMICOLON .)
    PLUS            reduce using rule 59 (simple -> RETURN expr SEMICOLON .)
    MINUS           reduce using rule 59 (simple -> RETURN expr SEMICOLON .)
    PLUS_PLUS       reduce using rule 59 (simple -> RETURN expr SEMICOLON .)
    MINUS_MINUS     reduce using rule 59 (simple -> RETURN expr SEMICOLON .)
    L_PAREN         reduce using rule 59 (simple -> RETURN expr SEMICOLON .)
    STRING          reduce using rule 59 (simple -> RETURN expr SEMICOLON .)
    MULTIPLY        reduce using rule 59 (simple -> RETURN expr SEMICOLON .)
    BIT_AND         reduce using rule 59 (simple -> RETURN expr SEMICOLON .)
    ID              reduce using rule 59 (simple -> RETURN expr SEMICOLON .)
    CHAR            reduce using rule 59 (simple -> RETURN expr SEMICOLON .)
    INT_NUM         reduce using rule 59 (simple -> RETURN expr SEMICOLON .)
    FLOAT_NUM       reduce using rule 59 (simple -> RETURN expr SEMICOLON .)
    $end            reduce using rule 59 (simple -> RETURN expr SEMICOLON .)
    R_FLOWBRACE     reduce using rule 59 (simple -> RETURN expr SEMICOLON .)
    ELSE            reduce using rule 59 (simple -> RETURN expr SEMICOLON .)
    R_PAREN         reduce using rule 59 (simple -> RETURN expr SEMICOLON .)


state 127

    (50) block -> left_flower multiple_statements right_flower .

    IF              reduce using rule 50 (block -> left_flower multiple_statements right_flower .)
    WHILE           reduce using rule 50 (block -> left_flower multiple_statements right_flower .)
    FOR             reduce using rule 50 (block -> left_flower multiple_statements right_flower .)
    SEMICOLON       reduce using rule 50 (block -> left_flower multiple_statements right_flower .)
    RETURN          reduce using rule 50 (block -> left_flower multiple_statements right_flower .)
    HASH            reduce using rule 50 (block -> left_flower multiple_statements right_flower .)
    TYPE            reduce using rule 50 (block -> left_flower multiple_statements right_flower .)
    L_FLOWBRACE     reduce using rule 50 (block -> left_flower multiple_statements right_flower .)
    NOT             reduce using rule 50 (block -> left_flower multiple_statements right_flower .)
    PLUS            reduce using rule 50 (block -> left_flower multiple_statements right_flower .)
    MINUS           reduce using rule 50 (block -> left_flower multiple_statements right_flower .)
    PLUS_PLUS       reduce using rule 50 (block -> left_flower multiple_statements right_flower .)
    MINUS_MINUS     reduce using rule 50 (block -> left_flower multiple_statements right_flower .)
    L_PAREN         reduce using rule 50 (block -> left_flower multiple_statements right_flower .)
    STRING          reduce using rule 50 (block -> left_flower multiple_statements right_flower .)
    MULTIPLY        reduce using rule 50 (block -> left_flower multiple_statements right_flower .)
    BIT_AND         reduce using rule 50 (block -> left_flower multiple_statements right_flower .)
    ID              reduce using rule 50 (block -> left_flower multiple_statements right_flower .)
    CHAR            reduce using rule 50 (block -> left_flower multiple_statements right_flower .)
    INT_NUM         reduce using rule 50 (block -> left_flower multiple_statements right_flower .)
    FLOAT_NUM       reduce using rule 50 (block -> left_flower multiple_statements right_flower .)
    $end            reduce using rule 50 (block -> left_flower multiple_statements right_flower .)
    R_FLOWBRACE     reduce using rule 50 (block -> left_flower multiple_statements right_flower .)
    ELSE            reduce using rule 50 (block -> left_flower multiple_statements right_flower .)
    R_PAREN         reduce using rule 50 (block -> left_flower multiple_statements right_flower .)


state 128

    (99) exprOR -> exprOR OR exprAND .
    (101) exprAND -> exprAND . AND exprBITOR

    OR              reduce using rule 99 (exprOR -> exprOR OR exprAND .)
    SEMICOLON       reduce using rule 99 (exprOR -> exprOR OR exprAND .)
    ASSIGN          reduce using rule 99 (exprOR -> exprOR OR exprAND .)
    PLUS_ASSIGN     reduce using rule 99 (exprOR -> exprOR OR exprAND .)
    MINUS_ASSIGN    reduce using rule 99 (exprOR -> exprOR OR exprAND .)
    MUL_ASSIGN      reduce using rule 99 (exprOR -> exprOR OR exprAND .)
    DIV_ASSIGN      reduce using rule 99 (exprOR -> exprOR OR exprAND .)
    AND_ASSIGN      reduce using rule 99 (exprOR -> exprOR OR exprAND .)
    OR_ASSIGN       reduce using rule 99 (exprOR -> exprOR OR exprAND .)
    XOR_ASSIGN      reduce using rule 99 (exprOR -> exprOR OR exprAND .)
    MOD_ASSIGN      reduce using rule 99 (exprOR -> exprOR OR exprAND .)
    L_SHIFT_ASSIGN  reduce using rule 99 (exprOR -> exprOR OR exprAND .)
    R_SHIFT_ASSIGN  reduce using rule 99 (exprOR -> exprOR OR exprAND .)
    R_PAREN         reduce using rule 99 (exprOR -> exprOR OR exprAND .)
    COMMA           reduce using rule 99 (exprOR -> exprOR OR exprAND .)
    R_SQBRACE       reduce using rule 99 (exprOR -> exprOR OR exprAND .)
    R_FLOWBRACE     reduce using rule 99 (exprOR -> exprOR OR exprAND .)
    AND             shift and go to state 86


state 129

    (61) header -> HASH INCLUDE STRING .

    IF              reduce using rule 61 (header -> HASH INCLUDE STRING .)
    WHILE           reduce using rule 61 (header -> HASH INCLUDE STRING .)
    FOR             reduce using rule 61 (header -> HASH INCLUDE STRING .)
    SEMICOLON       reduce using rule 61 (header -> HASH INCLUDE STRING .)
    RETURN          reduce using rule 61 (header -> HASH INCLUDE STRING .)
    HASH            reduce using rule 61 (header -> HASH INCLUDE STRING .)
    TYPE            reduce using rule 61 (header -> HASH INCLUDE STRING .)
    L_FLOWBRACE     reduce using rule 61 (header -> HASH INCLUDE STRING .)
    NOT             reduce using rule 61 (header -> HASH INCLUDE STRING .)
    PLUS            reduce using rule 61 (header -> HASH INCLUDE STRING .)
    MINUS           reduce using rule 61 (header -> HASH INCLUDE STRING .)
    PLUS_PLUS       reduce using rule 61 (header -> HASH INCLUDE STRING .)
    MINUS_MINUS     reduce using rule 61 (header -> HASH INCLUDE STRING .)
    L_PAREN         reduce using rule 61 (header -> HASH INCLUDE STRING .)
    STRING          reduce using rule 61 (header -> HASH INCLUDE STRING .)
    MULTIPLY        reduce using rule 61 (header -> HASH INCLUDE STRING .)
    BIT_AND         reduce using rule 61 (header -> HASH INCLUDE STRING .)
    ID              reduce using rule 61 (header -> HASH INCLUDE STRING .)
    CHAR            reduce using rule 61 (header -> HASH INCLUDE STRING .)
    INT_NUM         reduce using rule 61 (header -> HASH INCLUDE STRING .)
    FLOAT_NUM       reduce using rule 61 (header -> HASH INCLUDE STRING .)
    $end            reduce using rule 61 (header -> HASH INCLUDE STRING .)
    R_FLOWBRACE     reduce using rule 61 (header -> HASH INCLUDE STRING .)
    ELSE            reduce using rule 61 (header -> HASH INCLUDE STRING .)
    R_PAREN         reduce using rule 61 (header -> HASH INCLUDE STRING .)


state 130

    (62) header -> HASH INCLUDE HEADER_FILE .

    IF              reduce using rule 62 (header -> HASH INCLUDE HEADER_FILE .)
    WHILE           reduce using rule 62 (header -> HASH INCLUDE HEADER_FILE .)
    FOR             reduce using rule 62 (header -> HASH INCLUDE HEADER_FILE .)
    SEMICOLON       reduce using rule 62 (header -> HASH INCLUDE HEADER_FILE .)
    RETURN          reduce using rule 62 (header -> HASH INCLUDE HEADER_FILE .)
    HASH            reduce using rule 62 (header -> HASH INCLUDE HEADER_FILE .)
    TYPE            reduce using rule 62 (header -> HASH INCLUDE HEADER_FILE .)
    L_FLOWBRACE     reduce using rule 62 (header -> HASH INCLUDE HEADER_FILE .)
    NOT             reduce using rule 62 (header -> HASH INCLUDE HEADER_FILE .)
    PLUS            reduce using rule 62 (header -> HASH INCLUDE HEADER_FILE .)
    MINUS           reduce using rule 62 (header -> HASH INCLUDE HEADER_FILE .)
    PLUS_PLUS       reduce using rule 62 (header -> HASH INCLUDE HEADER_FILE .)
    MINUS_MINUS     reduce using rule 62 (header -> HASH INCLUDE HEADER_FILE .)
    L_PAREN         reduce using rule 62 (header -> HASH INCLUDE HEADER_FILE .)
    STRING          reduce using rule 62 (header -> HASH INCLUDE HEADER_FILE .)
    MULTIPLY        reduce using rule 62 (header -> HASH INCLUDE HEADER_FILE .)
    BIT_AND         reduce using rule 62 (header -> HASH INCLUDE HEADER_FILE .)
    ID              reduce using rule 62 (header -> HASH INCLUDE HEADER_FILE .)
    CHAR            reduce using rule 62 (header -> HASH INCLUDE HEADER_FILE .)
    INT_NUM         reduce using rule 62 (header -> HASH INCLUDE HEADER_FILE .)
    FLOAT_NUM       reduce using rule 62 (header -> HASH INCLUDE HEADER_FILE .)
    $end            reduce using rule 62 (header -> HASH INCLUDE HEADER_FILE .)
    R_FLOWBRACE     reduce using rule 62 (header -> HASH INCLUDE HEADER_FILE .)
    ELSE            reduce using rule 62 (header -> HASH INCLUDE HEADER_FILE .)
    R_PAREN         reduce using rule 62 (header -> HASH INCLUDE HEADER_FILE .)


state 131

    (35) declaration -> TYPE ID SEMICOLON .

    IF              reduce using rule 35 (declaration -> TYPE ID SEMICOLON .)
    WHILE           reduce using rule 35 (declaration -> TYPE ID SEMICOLON .)
    FOR             reduce using rule 35 (declaration -> TYPE ID SEMICOLON .)
    SEMICOLON       reduce using rule 35 (declaration -> TYPE ID SEMICOLON .)
    RETURN          reduce using rule 35 (declaration -> TYPE ID SEMICOLON .)
    HASH            reduce using rule 35 (declaration -> TYPE ID SEMICOLON .)
    TYPE            reduce using rule 35 (declaration -> TYPE ID SEMICOLON .)
    L_FLOWBRACE     reduce using rule 35 (declaration -> TYPE ID SEMICOLON .)
    NOT             reduce using rule 35 (declaration -> TYPE ID SEMICOLON .)
    PLUS            reduce using rule 35 (declaration -> TYPE ID SEMICOLON .)
    MINUS           reduce using rule 35 (declaration -> TYPE ID SEMICOLON .)
    PLUS_PLUS       reduce using rule 35 (declaration -> TYPE ID SEMICOLON .)
    MINUS_MINUS     reduce using rule 35 (declaration -> TYPE ID SEMICOLON .)
    L_PAREN         reduce using rule 35 (declaration -> TYPE ID SEMICOLON .)
    STRING          reduce using rule 35 (declaration -> TYPE ID SEMICOLON .)
    MULTIPLY        reduce using rule 35 (declaration -> TYPE ID SEMICOLON .)
    BIT_AND         reduce using rule 35 (declaration -> TYPE ID SEMICOLON .)
    ID              reduce using rule 35 (declaration -> TYPE ID SEMICOLON .)
    CHAR            reduce using rule 35 (declaration -> TYPE ID SEMICOLON .)
    INT_NUM         reduce using rule 35 (declaration -> TYPE ID SEMICOLON .)
    FLOAT_NUM       reduce using rule 35 (declaration -> TYPE ID SEMICOLON .)
    $end            reduce using rule 35 (declaration -> TYPE ID SEMICOLON .)
    R_FLOWBRACE     reduce using rule 35 (declaration -> TYPE ID SEMICOLON .)
    ELSE            reduce using rule 35 (declaration -> TYPE ID SEMICOLON .)
    R_PAREN         reduce using rule 35 (declaration -> TYPE ID SEMICOLON .)


state 132

    (37) declaration -> TYPE ID ASSIGN . expr SEMICOLON
    (25) multi_declaration -> ID ASSIGN . expr COMMA
    (86) expr -> . expr assignment exprOR
    (87) expr -> . exprOR
    (99) exprOR -> . exprOR OR exprAND
    (100) exprOR -> . exprAND
    (101) exprAND -> . exprAND AND exprBITOR
    (102) exprAND -> . exprBITOR
    (103) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (104) exprBITOR -> . exprBITXOR
    (105) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (106) exprBITXOR -> . exprBITAND
    (107) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (108) exprBITAND -> . exprEQ
    (109) exprEQ -> . exprEQ EQ exprRELOP
    (110) exprEQ -> . exprEQ NE exprRELOP
    (111) exprEQ -> . exprRELOP
    (112) exprRELOP -> . exprRELOP relop exprSHIFT
    (113) exprRELOP -> . exprSHIFT
    (118) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (119) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (120) exprSHIFT -> . exprOP
    (121) exprOP -> . exprOP PLUS term
    (122) exprOP -> . exprOP MINUS term
    (123) exprOP -> . term
    (124) term -> . term MULTIPLY factor
    (125) term -> . term DIVIDE factor
    (126) term -> . term MOD factor
    (127) term -> . factor
    (128) factor -> . NOT factor
    (129) factor -> . PLUS factor
    (130) factor -> . MINUS factor
    (131) factor -> . PLUS_PLUS factor
    (132) factor -> . MINUS_MINUS factor
    (133) factor -> . cast brace
    (134) factor -> . brace
    (135) cast -> . L_PAREN TYPE R_PAREN
    (136) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (137) brace -> . L_PAREN expr R_PAREN
    (138) brace -> . brace PLUS_PLUS
    (139) brace -> . brace MINUS_MINUS
    (140) brace -> . NUM
    (141) brace -> . STRING
    (142) brace -> . MULTIPLY ID
    (143) brace -> . BIT_AND ID
    (144) brace -> . ID
    (145) brace -> . CHAR
    (146) brace -> . function_call
    (147) brace -> . ID narrayindex
    (148) NUM -> . INT_NUM
    (149) NUM -> . FLOAT_NUM
    (64) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    expr                           shift and go to state 173
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 133

    (40) declaration -> TYPE ID narrayindex . SEMICOLON
    (41) declaration -> TYPE ID narrayindex . ASSIGN init_list SEMICOLON
    (33) narrayindex -> narrayindex . arrayindex
    (32) arrayindex -> . L_SQBRACE index R_SQBRACE

    SEMICOLON       shift and go to state 174
    ASSIGN          shift and go to state 175
    L_SQBRACE       shift and go to state 82

    arrayindex                     shift and go to state 140

state 134

    (83) function -> TYPE ID L_PAREN . dec_params R_PAREN function_2
    (80) dec_params -> . empty
    (81) dec_params -> . yes_dec_params end_dec_params
    (82) dec_params -> . end_dec_params
    (63) empty -> .
    (71) yes_dec_params -> . yes_dec_params TYPE expr COMMA
    (72) yes_dec_params -> . yes_dec_params TYPE COMMA
    (73) yes_dec_params -> . yes_dec_params TYPE MULTIPLY COMMA
    (74) yes_dec_params -> . TYPE expr COMMA
    (75) yes_dec_params -> . TYPE COMMA
    (76) yes_dec_params -> . TYPE MULTIPLY COMMA
    (77) end_dec_params -> . TYPE expr
    (78) end_dec_params -> . TYPE
    (79) end_dec_params -> . TYPE MULTIPLY

    R_PAREN         reduce using rule 63 (empty -> .)
    TYPE            shift and go to state 176

    dec_params                     shift and go to state 177
    empty                          shift and go to state 178
    yes_dec_params                 shift and go to state 179
    end_dec_params                 shift and go to state 180

state 135

    (24) multi_declaration -> ID COMMA .

    ID              reduce using rule 24 (multi_declaration -> ID COMMA .)
    MULTIPLY        reduce using rule 24 (multi_declaration -> ID COMMA .)


state 136

    (36) declaration -> TYPE MULTIPLY ID . SEMICOLON
    (38) declaration -> TYPE MULTIPLY ID . ASSIGN expr SEMICOLON
    (26) multi_declaration -> MULTIPLY ID . COMMA
    (27) multi_declaration -> MULTIPLY ID . ASSIGN expr COMMA

    SEMICOLON       shift and go to state 181
    ASSIGN          shift and go to state 182
    COMMA           shift and go to state 183


state 137

    (39) declaration -> TYPE multi_declaration stop .

    IF              reduce using rule 39 (declaration -> TYPE multi_declaration stop .)
    WHILE           reduce using rule 39 (declaration -> TYPE multi_declaration stop .)
    FOR             reduce using rule 39 (declaration -> TYPE multi_declaration stop .)
    SEMICOLON       reduce using rule 39 (declaration -> TYPE multi_declaration stop .)
    RETURN          reduce using rule 39 (declaration -> TYPE multi_declaration stop .)
    HASH            reduce using rule 39 (declaration -> TYPE multi_declaration stop .)
    TYPE            reduce using rule 39 (declaration -> TYPE multi_declaration stop .)
    L_FLOWBRACE     reduce using rule 39 (declaration -> TYPE multi_declaration stop .)
    NOT             reduce using rule 39 (declaration -> TYPE multi_declaration stop .)
    PLUS            reduce using rule 39 (declaration -> TYPE multi_declaration stop .)
    MINUS           reduce using rule 39 (declaration -> TYPE multi_declaration stop .)
    PLUS_PLUS       reduce using rule 39 (declaration -> TYPE multi_declaration stop .)
    MINUS_MINUS     reduce using rule 39 (declaration -> TYPE multi_declaration stop .)
    L_PAREN         reduce using rule 39 (declaration -> TYPE multi_declaration stop .)
    STRING          reduce using rule 39 (declaration -> TYPE multi_declaration stop .)
    MULTIPLY        reduce using rule 39 (declaration -> TYPE multi_declaration stop .)
    BIT_AND         reduce using rule 39 (declaration -> TYPE multi_declaration stop .)
    ID              reduce using rule 39 (declaration -> TYPE multi_declaration stop .)
    CHAR            reduce using rule 39 (declaration -> TYPE multi_declaration stop .)
    INT_NUM         reduce using rule 39 (declaration -> TYPE multi_declaration stop .)
    FLOAT_NUM       reduce using rule 39 (declaration -> TYPE multi_declaration stop .)
    $end            reduce using rule 39 (declaration -> TYPE multi_declaration stop .)
    R_FLOWBRACE     reduce using rule 39 (declaration -> TYPE multi_declaration stop .)
    ELSE            reduce using rule 39 (declaration -> TYPE multi_declaration stop .)
    R_PAREN         reduce using rule 39 (declaration -> TYPE multi_declaration stop .)


state 138

    (20) multi_declaration -> multi_declaration ID . COMMA
    (22) multi_declaration -> multi_declaration ID . ASSIGN expr COMMA
    (28) stop -> ID . SEMICOLON
    (30) stop -> ID . ASSIGN expr SEMICOLON

    COMMA           shift and go to state 184
    ASSIGN          shift and go to state 185
    SEMICOLON       shift and go to state 186


state 139

    (21) multi_declaration -> multi_declaration MULTIPLY . ID COMMA
    (23) multi_declaration -> multi_declaration MULTIPLY . ID ASSIGN expr COMMA
    (29) stop -> MULTIPLY . ID SEMICOLON
    (31) stop -> MULTIPLY . ID ASSIGN expr SEMICOLON

    ID              shift and go to state 187


state 140

    (33) narrayindex -> narrayindex arrayindex .

    L_SQBRACE       reduce using rule 33 (narrayindex -> narrayindex arrayindex .)
    PLUS_PLUS       reduce using rule 33 (narrayindex -> narrayindex arrayindex .)
    MINUS_MINUS     reduce using rule 33 (narrayindex -> narrayindex arrayindex .)
    MULTIPLY        reduce using rule 33 (narrayindex -> narrayindex arrayindex .)
    DIVIDE          reduce using rule 33 (narrayindex -> narrayindex arrayindex .)
    MOD             reduce using rule 33 (narrayindex -> narrayindex arrayindex .)
    PLUS            reduce using rule 33 (narrayindex -> narrayindex arrayindex .)
    MINUS           reduce using rule 33 (narrayindex -> narrayindex arrayindex .)
    L_SHIFT         reduce using rule 33 (narrayindex -> narrayindex arrayindex .)
    R_SHIFT         reduce using rule 33 (narrayindex -> narrayindex arrayindex .)
    LE              reduce using rule 33 (narrayindex -> narrayindex arrayindex .)
    LT              reduce using rule 33 (narrayindex -> narrayindex arrayindex .)
    GE              reduce using rule 33 (narrayindex -> narrayindex arrayindex .)
    GT              reduce using rule 33 (narrayindex -> narrayindex arrayindex .)
    EQ              reduce using rule 33 (narrayindex -> narrayindex arrayindex .)
    NE              reduce using rule 33 (narrayindex -> narrayindex arrayindex .)
    BIT_AND         reduce using rule 33 (narrayindex -> narrayindex arrayindex .)
    BIT_XOR         reduce using rule 33 (narrayindex -> narrayindex arrayindex .)
    BIT_OR          reduce using rule 33 (narrayindex -> narrayindex arrayindex .)
    AND             reduce using rule 33 (narrayindex -> narrayindex arrayindex .)
    OR              reduce using rule 33 (narrayindex -> narrayindex arrayindex .)
    SEMICOLON       reduce using rule 33 (narrayindex -> narrayindex arrayindex .)
    ASSIGN          reduce using rule 33 (narrayindex -> narrayindex arrayindex .)
    PLUS_ASSIGN     reduce using rule 33 (narrayindex -> narrayindex arrayindex .)
    MINUS_ASSIGN    reduce using rule 33 (narrayindex -> narrayindex arrayindex .)
    MUL_ASSIGN      reduce using rule 33 (narrayindex -> narrayindex arrayindex .)
    DIV_ASSIGN      reduce using rule 33 (narrayindex -> narrayindex arrayindex .)
    AND_ASSIGN      reduce using rule 33 (narrayindex -> narrayindex arrayindex .)
    OR_ASSIGN       reduce using rule 33 (narrayindex -> narrayindex arrayindex .)
    XOR_ASSIGN      reduce using rule 33 (narrayindex -> narrayindex arrayindex .)
    MOD_ASSIGN      reduce using rule 33 (narrayindex -> narrayindex arrayindex .)
    L_SHIFT_ASSIGN  reduce using rule 33 (narrayindex -> narrayindex arrayindex .)
    R_SHIFT_ASSIGN  reduce using rule 33 (narrayindex -> narrayindex arrayindex .)
    R_PAREN         reduce using rule 33 (narrayindex -> narrayindex arrayindex .)
    COMMA           reduce using rule 33 (narrayindex -> narrayindex arrayindex .)
    R_SQBRACE       reduce using rule 33 (narrayindex -> narrayindex arrayindex .)
    R_FLOWBRACE     reduce using rule 33 (narrayindex -> narrayindex arrayindex .)


state 141

    (64) function_call -> ID L_PAREN call_params . R_PAREN

    R_PAREN         shift and go to state 188


state 142

    (65) call_params -> empty .

    R_PAREN         reduce using rule 65 (call_params -> empty .)


state 143

    (66) call_params -> yes_call_params . end_call_params
    (68) yes_call_params -> yes_call_params . expr COMMA
    (70) end_call_params -> . expr
    (86) expr -> . expr assignment exprOR
    (87) expr -> . exprOR
    (99) exprOR -> . exprOR OR exprAND
    (100) exprOR -> . exprAND
    (101) exprAND -> . exprAND AND exprBITOR
    (102) exprAND -> . exprBITOR
    (103) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (104) exprBITOR -> . exprBITXOR
    (105) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (106) exprBITXOR -> . exprBITAND
    (107) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (108) exprBITAND -> . exprEQ
    (109) exprEQ -> . exprEQ EQ exprRELOP
    (110) exprEQ -> . exprEQ NE exprRELOP
    (111) exprEQ -> . exprRELOP
    (112) exprRELOP -> . exprRELOP relop exprSHIFT
    (113) exprRELOP -> . exprSHIFT
    (118) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (119) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (120) exprSHIFT -> . exprOP
    (121) exprOP -> . exprOP PLUS term
    (122) exprOP -> . exprOP MINUS term
    (123) exprOP -> . term
    (124) term -> . term MULTIPLY factor
    (125) term -> . term DIVIDE factor
    (126) term -> . term MOD factor
    (127) term -> . factor
    (128) factor -> . NOT factor
    (129) factor -> . PLUS factor
    (130) factor -> . MINUS factor
    (131) factor -> . PLUS_PLUS factor
    (132) factor -> . MINUS_MINUS factor
    (133) factor -> . cast brace
    (134) factor -> . brace
    (135) cast -> . L_PAREN TYPE R_PAREN
    (136) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (137) brace -> . L_PAREN expr R_PAREN
    (138) brace -> . brace PLUS_PLUS
    (139) brace -> . brace MINUS_MINUS
    (140) brace -> . NUM
    (141) brace -> . STRING
    (142) brace -> . MULTIPLY ID
    (143) brace -> . BIT_AND ID
    (144) brace -> . ID
    (145) brace -> . CHAR
    (146) brace -> . function_call
    (147) brace -> . ID narrayindex
    (148) NUM -> . INT_NUM
    (149) NUM -> . FLOAT_NUM
    (64) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    end_call_params                shift and go to state 189
    expr                           shift and go to state 190
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 144

    (67) call_params -> end_call_params .

    R_PAREN         reduce using rule 67 (call_params -> end_call_params .)


state 145

    (69) yes_call_params -> expr . COMMA
    (70) end_call_params -> expr .
    (86) expr -> expr . assignment exprOR
    (88) assignment -> . ASSIGN
    (89) assignment -> . PLUS_ASSIGN
    (90) assignment -> . MINUS_ASSIGN
    (91) assignment -> . MUL_ASSIGN
    (92) assignment -> . DIV_ASSIGN
    (93) assignment -> . AND_ASSIGN
    (94) assignment -> . OR_ASSIGN
    (95) assignment -> . XOR_ASSIGN
    (96) assignment -> . MOD_ASSIGN
    (97) assignment -> . L_SHIFT_ASSIGN
    (98) assignment -> . R_SHIFT_ASSIGN

    COMMA           shift and go to state 191
    R_PAREN         reduce using rule 70 (end_call_params -> expr .)
    ASSIGN          shift and go to state 58
    PLUS_ASSIGN     shift and go to state 59
    MINUS_ASSIGN    shift and go to state 60
    MUL_ASSIGN      shift and go to state 61
    DIV_ASSIGN      shift and go to state 62
    AND_ASSIGN      shift and go to state 63
    OR_ASSIGN       shift and go to state 64
    XOR_ASSIGN      shift and go to state 65
    MOD_ASSIGN      shift and go to state 66
    L_SHIFT_ASSIGN  shift and go to state 67
    R_SHIFT_ASSIGN  shift and go to state 68

    assignment                     shift and go to state 57

state 146

    (32) arrayindex -> L_SQBRACE index . R_SQBRACE

    R_SQBRACE       shift and go to state 192


state 147

    (48) index -> expr .
    (86) expr -> expr . assignment exprOR
    (88) assignment -> . ASSIGN
    (89) assignment -> . PLUS_ASSIGN
    (90) assignment -> . MINUS_ASSIGN
    (91) assignment -> . MUL_ASSIGN
    (92) assignment -> . DIV_ASSIGN
    (93) assignment -> . AND_ASSIGN
    (94) assignment -> . OR_ASSIGN
    (95) assignment -> . XOR_ASSIGN
    (96) assignment -> . MOD_ASSIGN
    (97) assignment -> . L_SHIFT_ASSIGN
    (98) assignment -> . R_SHIFT_ASSIGN

    R_SQBRACE       reduce using rule 48 (index -> expr .)
    ASSIGN          shift and go to state 58
    PLUS_ASSIGN     shift and go to state 59
    MINUS_ASSIGN    shift and go to state 60
    MUL_ASSIGN      shift and go to state 61
    DIV_ASSIGN      shift and go to state 62
    AND_ASSIGN      shift and go to state 63
    OR_ASSIGN       shift and go to state 64
    XOR_ASSIGN      shift and go to state 65
    MOD_ASSIGN      shift and go to state 66
    L_SHIFT_ASSIGN  shift and go to state 67
    R_SHIFT_ASSIGN  shift and go to state 68

    assignment                     shift and go to state 57

state 148

    (49) index -> empty .

    R_SQBRACE       reduce using rule 49 (index -> empty .)


state 149

    (135) cast -> L_PAREN TYPE R_PAREN .

    L_PAREN         reduce using rule 135 (cast -> L_PAREN TYPE R_PAREN .)
    STRING          reduce using rule 135 (cast -> L_PAREN TYPE R_PAREN .)
    MULTIPLY        reduce using rule 135 (cast -> L_PAREN TYPE R_PAREN .)
    BIT_AND         reduce using rule 135 (cast -> L_PAREN TYPE R_PAREN .)
    ID              reduce using rule 135 (cast -> L_PAREN TYPE R_PAREN .)
    CHAR            reduce using rule 135 (cast -> L_PAREN TYPE R_PAREN .)
    INT_NUM         reduce using rule 135 (cast -> L_PAREN TYPE R_PAREN .)
    FLOAT_NUM       reduce using rule 135 (cast -> L_PAREN TYPE R_PAREN .)


state 150

    (136) cast -> L_PAREN TYPE MULTIPLY . R_PAREN

    R_PAREN         shift and go to state 193


state 151

    (137) brace -> L_PAREN expr R_PAREN .

    PLUS_PLUS       reduce using rule 137 (brace -> L_PAREN expr R_PAREN .)
    MINUS_MINUS     reduce using rule 137 (brace -> L_PAREN expr R_PAREN .)
    MULTIPLY        reduce using rule 137 (brace -> L_PAREN expr R_PAREN .)
    DIVIDE          reduce using rule 137 (brace -> L_PAREN expr R_PAREN .)
    MOD             reduce using rule 137 (brace -> L_PAREN expr R_PAREN .)
    PLUS            reduce using rule 137 (brace -> L_PAREN expr R_PAREN .)
    MINUS           reduce using rule 137 (brace -> L_PAREN expr R_PAREN .)
    L_SHIFT         reduce using rule 137 (brace -> L_PAREN expr R_PAREN .)
    R_SHIFT         reduce using rule 137 (brace -> L_PAREN expr R_PAREN .)
    LE              reduce using rule 137 (brace -> L_PAREN expr R_PAREN .)
    LT              reduce using rule 137 (brace -> L_PAREN expr R_PAREN .)
    GE              reduce using rule 137 (brace -> L_PAREN expr R_PAREN .)
    GT              reduce using rule 137 (brace -> L_PAREN expr R_PAREN .)
    EQ              reduce using rule 137 (brace -> L_PAREN expr R_PAREN .)
    NE              reduce using rule 137 (brace -> L_PAREN expr R_PAREN .)
    BIT_AND         reduce using rule 137 (brace -> L_PAREN expr R_PAREN .)
    BIT_XOR         reduce using rule 137 (brace -> L_PAREN expr R_PAREN .)
    BIT_OR          reduce using rule 137 (brace -> L_PAREN expr R_PAREN .)
    AND             reduce using rule 137 (brace -> L_PAREN expr R_PAREN .)
    OR              reduce using rule 137 (brace -> L_PAREN expr R_PAREN .)
    SEMICOLON       reduce using rule 137 (brace -> L_PAREN expr R_PAREN .)
    ASSIGN          reduce using rule 137 (brace -> L_PAREN expr R_PAREN .)
    PLUS_ASSIGN     reduce using rule 137 (brace -> L_PAREN expr R_PAREN .)
    MINUS_ASSIGN    reduce using rule 137 (brace -> L_PAREN expr R_PAREN .)
    MUL_ASSIGN      reduce using rule 137 (brace -> L_PAREN expr R_PAREN .)
    DIV_ASSIGN      reduce using rule 137 (brace -> L_PAREN expr R_PAREN .)
    AND_ASSIGN      reduce using rule 137 (brace -> L_PAREN expr R_PAREN .)
    OR_ASSIGN       reduce using rule 137 (brace -> L_PAREN expr R_PAREN .)
    XOR_ASSIGN      reduce using rule 137 (brace -> L_PAREN expr R_PAREN .)
    MOD_ASSIGN      reduce using rule 137 (brace -> L_PAREN expr R_PAREN .)
    L_SHIFT_ASSIGN  reduce using rule 137 (brace -> L_PAREN expr R_PAREN .)
    R_SHIFT_ASSIGN  reduce using rule 137 (brace -> L_PAREN expr R_PAREN .)
    R_PAREN         reduce using rule 137 (brace -> L_PAREN expr R_PAREN .)
    COMMA           reduce using rule 137 (brace -> L_PAREN expr R_PAREN .)
    R_SQBRACE       reduce using rule 137 (brace -> L_PAREN expr R_PAREN .)
    R_FLOWBRACE     reduce using rule 137 (brace -> L_PAREN expr R_PAREN .)


state 152

    (101) exprAND -> exprAND AND exprBITOR .
    (103) exprBITOR -> exprBITOR . BIT_OR exprBITXOR

    AND             reduce using rule 101 (exprAND -> exprAND AND exprBITOR .)
    OR              reduce using rule 101 (exprAND -> exprAND AND exprBITOR .)
    SEMICOLON       reduce using rule 101 (exprAND -> exprAND AND exprBITOR .)
    ASSIGN          reduce using rule 101 (exprAND -> exprAND AND exprBITOR .)
    PLUS_ASSIGN     reduce using rule 101 (exprAND -> exprAND AND exprBITOR .)
    MINUS_ASSIGN    reduce using rule 101 (exprAND -> exprAND AND exprBITOR .)
    MUL_ASSIGN      reduce using rule 101 (exprAND -> exprAND AND exprBITOR .)
    DIV_ASSIGN      reduce using rule 101 (exprAND -> exprAND AND exprBITOR .)
    AND_ASSIGN      reduce using rule 101 (exprAND -> exprAND AND exprBITOR .)
    OR_ASSIGN       reduce using rule 101 (exprAND -> exprAND AND exprBITOR .)
    XOR_ASSIGN      reduce using rule 101 (exprAND -> exprAND AND exprBITOR .)
    MOD_ASSIGN      reduce using rule 101 (exprAND -> exprAND AND exprBITOR .)
    L_SHIFT_ASSIGN  reduce using rule 101 (exprAND -> exprAND AND exprBITOR .)
    R_SHIFT_ASSIGN  reduce using rule 101 (exprAND -> exprAND AND exprBITOR .)
    R_PAREN         reduce using rule 101 (exprAND -> exprAND AND exprBITOR .)
    COMMA           reduce using rule 101 (exprAND -> exprAND AND exprBITOR .)
    R_SQBRACE       reduce using rule 101 (exprAND -> exprAND AND exprBITOR .)
    R_FLOWBRACE     reduce using rule 101 (exprAND -> exprAND AND exprBITOR .)
    BIT_OR          shift and go to state 87


state 153

    (103) exprBITOR -> exprBITOR BIT_OR exprBITXOR .
    (105) exprBITXOR -> exprBITXOR . BIT_XOR exprBITAND

    BIT_OR          reduce using rule 103 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    AND             reduce using rule 103 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    OR              reduce using rule 103 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    SEMICOLON       reduce using rule 103 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    ASSIGN          reduce using rule 103 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    PLUS_ASSIGN     reduce using rule 103 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    MINUS_ASSIGN    reduce using rule 103 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    MUL_ASSIGN      reduce using rule 103 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    DIV_ASSIGN      reduce using rule 103 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    AND_ASSIGN      reduce using rule 103 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    OR_ASSIGN       reduce using rule 103 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    XOR_ASSIGN      reduce using rule 103 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    MOD_ASSIGN      reduce using rule 103 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    L_SHIFT_ASSIGN  reduce using rule 103 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    R_SHIFT_ASSIGN  reduce using rule 103 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    R_PAREN         reduce using rule 103 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    COMMA           reduce using rule 103 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    R_SQBRACE       reduce using rule 103 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    R_FLOWBRACE     reduce using rule 103 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    BIT_XOR         shift and go to state 88


state 154

    (105) exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .
    (107) exprBITAND -> exprBITAND . BIT_AND exprEQ

    BIT_XOR         reduce using rule 105 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    BIT_OR          reduce using rule 105 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    AND             reduce using rule 105 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    OR              reduce using rule 105 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    SEMICOLON       reduce using rule 105 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    ASSIGN          reduce using rule 105 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    PLUS_ASSIGN     reduce using rule 105 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    MINUS_ASSIGN    reduce using rule 105 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    MUL_ASSIGN      reduce using rule 105 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    DIV_ASSIGN      reduce using rule 105 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    AND_ASSIGN      reduce using rule 105 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    OR_ASSIGN       reduce using rule 105 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    XOR_ASSIGN      reduce using rule 105 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    MOD_ASSIGN      reduce using rule 105 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    L_SHIFT_ASSIGN  reduce using rule 105 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    R_SHIFT_ASSIGN  reduce using rule 105 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    R_PAREN         reduce using rule 105 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    COMMA           reduce using rule 105 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    R_SQBRACE       reduce using rule 105 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    R_FLOWBRACE     reduce using rule 105 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    BIT_AND         shift and go to state 89


state 155

    (107) exprBITAND -> exprBITAND BIT_AND exprEQ .
    (109) exprEQ -> exprEQ . EQ exprRELOP
    (110) exprEQ -> exprEQ . NE exprRELOP

    BIT_AND         reduce using rule 107 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    BIT_XOR         reduce using rule 107 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    BIT_OR          reduce using rule 107 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    AND             reduce using rule 107 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    OR              reduce using rule 107 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    SEMICOLON       reduce using rule 107 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    ASSIGN          reduce using rule 107 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    PLUS_ASSIGN     reduce using rule 107 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    MINUS_ASSIGN    reduce using rule 107 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    MUL_ASSIGN      reduce using rule 107 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    DIV_ASSIGN      reduce using rule 107 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    AND_ASSIGN      reduce using rule 107 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    OR_ASSIGN       reduce using rule 107 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    XOR_ASSIGN      reduce using rule 107 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    MOD_ASSIGN      reduce using rule 107 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    L_SHIFT_ASSIGN  reduce using rule 107 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    R_SHIFT_ASSIGN  reduce using rule 107 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    R_PAREN         reduce using rule 107 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    COMMA           reduce using rule 107 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    R_SQBRACE       reduce using rule 107 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    R_FLOWBRACE     reduce using rule 107 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    EQ              shift and go to state 91
    NE              shift and go to state 92


state 156

    (109) exprEQ -> exprEQ EQ exprRELOP .
    (112) exprRELOP -> exprRELOP . relop exprSHIFT
    (114) relop -> . LE
    (115) relop -> . LT
    (116) relop -> . GE
    (117) relop -> . GT

    EQ              reduce using rule 109 (exprEQ -> exprEQ EQ exprRELOP .)
    NE              reduce using rule 109 (exprEQ -> exprEQ EQ exprRELOP .)
    BIT_AND         reduce using rule 109 (exprEQ -> exprEQ EQ exprRELOP .)
    BIT_XOR         reduce using rule 109 (exprEQ -> exprEQ EQ exprRELOP .)
    BIT_OR          reduce using rule 109 (exprEQ -> exprEQ EQ exprRELOP .)
    AND             reduce using rule 109 (exprEQ -> exprEQ EQ exprRELOP .)
    OR              reduce using rule 109 (exprEQ -> exprEQ EQ exprRELOP .)
    SEMICOLON       reduce using rule 109 (exprEQ -> exprEQ EQ exprRELOP .)
    ASSIGN          reduce using rule 109 (exprEQ -> exprEQ EQ exprRELOP .)
    PLUS_ASSIGN     reduce using rule 109 (exprEQ -> exprEQ EQ exprRELOP .)
    MINUS_ASSIGN    reduce using rule 109 (exprEQ -> exprEQ EQ exprRELOP .)
    MUL_ASSIGN      reduce using rule 109 (exprEQ -> exprEQ EQ exprRELOP .)
    DIV_ASSIGN      reduce using rule 109 (exprEQ -> exprEQ EQ exprRELOP .)
    AND_ASSIGN      reduce using rule 109 (exprEQ -> exprEQ EQ exprRELOP .)
    OR_ASSIGN       reduce using rule 109 (exprEQ -> exprEQ EQ exprRELOP .)
    XOR_ASSIGN      reduce using rule 109 (exprEQ -> exprEQ EQ exprRELOP .)
    MOD_ASSIGN      reduce using rule 109 (exprEQ -> exprEQ EQ exprRELOP .)
    L_SHIFT_ASSIGN  reduce using rule 109 (exprEQ -> exprEQ EQ exprRELOP .)
    R_SHIFT_ASSIGN  reduce using rule 109 (exprEQ -> exprEQ EQ exprRELOP .)
    R_PAREN         reduce using rule 109 (exprEQ -> exprEQ EQ exprRELOP .)
    COMMA           reduce using rule 109 (exprEQ -> exprEQ EQ exprRELOP .)
    R_SQBRACE       reduce using rule 109 (exprEQ -> exprEQ EQ exprRELOP .)
    R_FLOWBRACE     reduce using rule 109 (exprEQ -> exprEQ EQ exprRELOP .)
    LE              shift and go to state 94
    LT              shift and go to state 95
    GE              shift and go to state 96
    GT              shift and go to state 97

    relop                          shift and go to state 93

state 157

    (110) exprEQ -> exprEQ NE exprRELOP .
    (112) exprRELOP -> exprRELOP . relop exprSHIFT
    (114) relop -> . LE
    (115) relop -> . LT
    (116) relop -> . GE
    (117) relop -> . GT

    EQ              reduce using rule 110 (exprEQ -> exprEQ NE exprRELOP .)
    NE              reduce using rule 110 (exprEQ -> exprEQ NE exprRELOP .)
    BIT_AND         reduce using rule 110 (exprEQ -> exprEQ NE exprRELOP .)
    BIT_XOR         reduce using rule 110 (exprEQ -> exprEQ NE exprRELOP .)
    BIT_OR          reduce using rule 110 (exprEQ -> exprEQ NE exprRELOP .)
    AND             reduce using rule 110 (exprEQ -> exprEQ NE exprRELOP .)
    OR              reduce using rule 110 (exprEQ -> exprEQ NE exprRELOP .)
    SEMICOLON       reduce using rule 110 (exprEQ -> exprEQ NE exprRELOP .)
    ASSIGN          reduce using rule 110 (exprEQ -> exprEQ NE exprRELOP .)
    PLUS_ASSIGN     reduce using rule 110 (exprEQ -> exprEQ NE exprRELOP .)
    MINUS_ASSIGN    reduce using rule 110 (exprEQ -> exprEQ NE exprRELOP .)
    MUL_ASSIGN      reduce using rule 110 (exprEQ -> exprEQ NE exprRELOP .)
    DIV_ASSIGN      reduce using rule 110 (exprEQ -> exprEQ NE exprRELOP .)
    AND_ASSIGN      reduce using rule 110 (exprEQ -> exprEQ NE exprRELOP .)
    OR_ASSIGN       reduce using rule 110 (exprEQ -> exprEQ NE exprRELOP .)
    XOR_ASSIGN      reduce using rule 110 (exprEQ -> exprEQ NE exprRELOP .)
    MOD_ASSIGN      reduce using rule 110 (exprEQ -> exprEQ NE exprRELOP .)
    L_SHIFT_ASSIGN  reduce using rule 110 (exprEQ -> exprEQ NE exprRELOP .)
    R_SHIFT_ASSIGN  reduce using rule 110 (exprEQ -> exprEQ NE exprRELOP .)
    R_PAREN         reduce using rule 110 (exprEQ -> exprEQ NE exprRELOP .)
    COMMA           reduce using rule 110 (exprEQ -> exprEQ NE exprRELOP .)
    R_SQBRACE       reduce using rule 110 (exprEQ -> exprEQ NE exprRELOP .)
    R_FLOWBRACE     reduce using rule 110 (exprEQ -> exprEQ NE exprRELOP .)
    LE              shift and go to state 94
    LT              shift and go to state 95
    GE              shift and go to state 96
    GT              shift and go to state 97

    relop                          shift and go to state 93

state 158

    (112) exprRELOP -> exprRELOP relop exprSHIFT .
    (118) exprSHIFT -> exprSHIFT . L_SHIFT exprOP
    (119) exprSHIFT -> exprSHIFT . R_SHIFT exprOP

    LE              reduce using rule 112 (exprRELOP -> exprRELOP relop exprSHIFT .)
    LT              reduce using rule 112 (exprRELOP -> exprRELOP relop exprSHIFT .)
    GE              reduce using rule 112 (exprRELOP -> exprRELOP relop exprSHIFT .)
    GT              reduce using rule 112 (exprRELOP -> exprRELOP relop exprSHIFT .)
    EQ              reduce using rule 112 (exprRELOP -> exprRELOP relop exprSHIFT .)
    NE              reduce using rule 112 (exprRELOP -> exprRELOP relop exprSHIFT .)
    BIT_AND         reduce using rule 112 (exprRELOP -> exprRELOP relop exprSHIFT .)
    BIT_XOR         reduce using rule 112 (exprRELOP -> exprRELOP relop exprSHIFT .)
    BIT_OR          reduce using rule 112 (exprRELOP -> exprRELOP relop exprSHIFT .)
    AND             reduce using rule 112 (exprRELOP -> exprRELOP relop exprSHIFT .)
    OR              reduce using rule 112 (exprRELOP -> exprRELOP relop exprSHIFT .)
    SEMICOLON       reduce using rule 112 (exprRELOP -> exprRELOP relop exprSHIFT .)
    ASSIGN          reduce using rule 112 (exprRELOP -> exprRELOP relop exprSHIFT .)
    PLUS_ASSIGN     reduce using rule 112 (exprRELOP -> exprRELOP relop exprSHIFT .)
    MINUS_ASSIGN    reduce using rule 112 (exprRELOP -> exprRELOP relop exprSHIFT .)
    MUL_ASSIGN      reduce using rule 112 (exprRELOP -> exprRELOP relop exprSHIFT .)
    DIV_ASSIGN      reduce using rule 112 (exprRELOP -> exprRELOP relop exprSHIFT .)
    AND_ASSIGN      reduce using rule 112 (exprRELOP -> exprRELOP relop exprSHIFT .)
    OR_ASSIGN       reduce using rule 112 (exprRELOP -> exprRELOP relop exprSHIFT .)
    XOR_ASSIGN      reduce using rule 112 (exprRELOP -> exprRELOP relop exprSHIFT .)
    MOD_ASSIGN      reduce using rule 112 (exprRELOP -> exprRELOP relop exprSHIFT .)
    L_SHIFT_ASSIGN  reduce using rule 112 (exprRELOP -> exprRELOP relop exprSHIFT .)
    R_SHIFT_ASSIGN  reduce using rule 112 (exprRELOP -> exprRELOP relop exprSHIFT .)
    R_PAREN         reduce using rule 112 (exprRELOP -> exprRELOP relop exprSHIFT .)
    COMMA           reduce using rule 112 (exprRELOP -> exprRELOP relop exprSHIFT .)
    R_SQBRACE       reduce using rule 112 (exprRELOP -> exprRELOP relop exprSHIFT .)
    R_FLOWBRACE     reduce using rule 112 (exprRELOP -> exprRELOP relop exprSHIFT .)
    L_SHIFT         shift and go to state 98
    R_SHIFT         shift and go to state 99


state 159

    (118) exprSHIFT -> exprSHIFT L_SHIFT exprOP .
    (121) exprOP -> exprOP . PLUS term
    (122) exprOP -> exprOP . MINUS term

    L_SHIFT         reduce using rule 118 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    R_SHIFT         reduce using rule 118 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    LE              reduce using rule 118 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    LT              reduce using rule 118 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    GE              reduce using rule 118 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    GT              reduce using rule 118 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    EQ              reduce using rule 118 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    NE              reduce using rule 118 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    BIT_AND         reduce using rule 118 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    BIT_XOR         reduce using rule 118 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    BIT_OR          reduce using rule 118 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    AND             reduce using rule 118 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    OR              reduce using rule 118 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    SEMICOLON       reduce using rule 118 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    ASSIGN          reduce using rule 118 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    PLUS_ASSIGN     reduce using rule 118 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    MINUS_ASSIGN    reduce using rule 118 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    MUL_ASSIGN      reduce using rule 118 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    DIV_ASSIGN      reduce using rule 118 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    AND_ASSIGN      reduce using rule 118 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    OR_ASSIGN       reduce using rule 118 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    XOR_ASSIGN      reduce using rule 118 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    MOD_ASSIGN      reduce using rule 118 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    L_SHIFT_ASSIGN  reduce using rule 118 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    R_SHIFT_ASSIGN  reduce using rule 118 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    R_PAREN         reduce using rule 118 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    COMMA           reduce using rule 118 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    R_SQBRACE       reduce using rule 118 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    R_FLOWBRACE     reduce using rule 118 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101


state 160

    (119) exprSHIFT -> exprSHIFT R_SHIFT exprOP .
    (121) exprOP -> exprOP . PLUS term
    (122) exprOP -> exprOP . MINUS term

    L_SHIFT         reduce using rule 119 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    R_SHIFT         reduce using rule 119 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    LE              reduce using rule 119 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    LT              reduce using rule 119 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    GE              reduce using rule 119 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    GT              reduce using rule 119 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    EQ              reduce using rule 119 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    NE              reduce using rule 119 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    BIT_AND         reduce using rule 119 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    BIT_XOR         reduce using rule 119 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    BIT_OR          reduce using rule 119 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    AND             reduce using rule 119 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    OR              reduce using rule 119 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    SEMICOLON       reduce using rule 119 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    ASSIGN          reduce using rule 119 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    PLUS_ASSIGN     reduce using rule 119 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    MINUS_ASSIGN    reduce using rule 119 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    MUL_ASSIGN      reduce using rule 119 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    DIV_ASSIGN      reduce using rule 119 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    AND_ASSIGN      reduce using rule 119 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    OR_ASSIGN       reduce using rule 119 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    XOR_ASSIGN      reduce using rule 119 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    MOD_ASSIGN      reduce using rule 119 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    L_SHIFT_ASSIGN  reduce using rule 119 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    R_SHIFT_ASSIGN  reduce using rule 119 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    R_PAREN         reduce using rule 119 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    COMMA           reduce using rule 119 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    R_SQBRACE       reduce using rule 119 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    R_FLOWBRACE     reduce using rule 119 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101


state 161

    (121) exprOP -> exprOP PLUS term .
    (124) term -> term . MULTIPLY factor
    (125) term -> term . DIVIDE factor
    (126) term -> term . MOD factor

    PLUS            reduce using rule 121 (exprOP -> exprOP PLUS term .)
    MINUS           reduce using rule 121 (exprOP -> exprOP PLUS term .)
    L_SHIFT         reduce using rule 121 (exprOP -> exprOP PLUS term .)
    R_SHIFT         reduce using rule 121 (exprOP -> exprOP PLUS term .)
    LE              reduce using rule 121 (exprOP -> exprOP PLUS term .)
    LT              reduce using rule 121 (exprOP -> exprOP PLUS term .)
    GE              reduce using rule 121 (exprOP -> exprOP PLUS term .)
    GT              reduce using rule 121 (exprOP -> exprOP PLUS term .)
    EQ              reduce using rule 121 (exprOP -> exprOP PLUS term .)
    NE              reduce using rule 121 (exprOP -> exprOP PLUS term .)
    BIT_AND         reduce using rule 121 (exprOP -> exprOP PLUS term .)
    BIT_XOR         reduce using rule 121 (exprOP -> exprOP PLUS term .)
    BIT_OR          reduce using rule 121 (exprOP -> exprOP PLUS term .)
    AND             reduce using rule 121 (exprOP -> exprOP PLUS term .)
    OR              reduce using rule 121 (exprOP -> exprOP PLUS term .)
    SEMICOLON       reduce using rule 121 (exprOP -> exprOP PLUS term .)
    ASSIGN          reduce using rule 121 (exprOP -> exprOP PLUS term .)
    PLUS_ASSIGN     reduce using rule 121 (exprOP -> exprOP PLUS term .)
    MINUS_ASSIGN    reduce using rule 121 (exprOP -> exprOP PLUS term .)
    MUL_ASSIGN      reduce using rule 121 (exprOP -> exprOP PLUS term .)
    DIV_ASSIGN      reduce using rule 121 (exprOP -> exprOP PLUS term .)
    AND_ASSIGN      reduce using rule 121 (exprOP -> exprOP PLUS term .)
    OR_ASSIGN       reduce using rule 121 (exprOP -> exprOP PLUS term .)
    XOR_ASSIGN      reduce using rule 121 (exprOP -> exprOP PLUS term .)
    MOD_ASSIGN      reduce using rule 121 (exprOP -> exprOP PLUS term .)
    L_SHIFT_ASSIGN  reduce using rule 121 (exprOP -> exprOP PLUS term .)
    R_SHIFT_ASSIGN  reduce using rule 121 (exprOP -> exprOP PLUS term .)
    R_PAREN         reduce using rule 121 (exprOP -> exprOP PLUS term .)
    COMMA           reduce using rule 121 (exprOP -> exprOP PLUS term .)
    R_SQBRACE       reduce using rule 121 (exprOP -> exprOP PLUS term .)
    R_FLOWBRACE     reduce using rule 121 (exprOP -> exprOP PLUS term .)
    MULTIPLY        shift and go to state 103
    DIVIDE          shift and go to state 104
    MOD             shift and go to state 105


state 162

    (122) exprOP -> exprOP MINUS term .
    (124) term -> term . MULTIPLY factor
    (125) term -> term . DIVIDE factor
    (126) term -> term . MOD factor

    PLUS            reduce using rule 122 (exprOP -> exprOP MINUS term .)
    MINUS           reduce using rule 122 (exprOP -> exprOP MINUS term .)
    L_SHIFT         reduce using rule 122 (exprOP -> exprOP MINUS term .)
    R_SHIFT         reduce using rule 122 (exprOP -> exprOP MINUS term .)
    LE              reduce using rule 122 (exprOP -> exprOP MINUS term .)
    LT              reduce using rule 122 (exprOP -> exprOP MINUS term .)
    GE              reduce using rule 122 (exprOP -> exprOP MINUS term .)
    GT              reduce using rule 122 (exprOP -> exprOP MINUS term .)
    EQ              reduce using rule 122 (exprOP -> exprOP MINUS term .)
    NE              reduce using rule 122 (exprOP -> exprOP MINUS term .)
    BIT_AND         reduce using rule 122 (exprOP -> exprOP MINUS term .)
    BIT_XOR         reduce using rule 122 (exprOP -> exprOP MINUS term .)
    BIT_OR          reduce using rule 122 (exprOP -> exprOP MINUS term .)
    AND             reduce using rule 122 (exprOP -> exprOP MINUS term .)
    OR              reduce using rule 122 (exprOP -> exprOP MINUS term .)
    SEMICOLON       reduce using rule 122 (exprOP -> exprOP MINUS term .)
    ASSIGN          reduce using rule 122 (exprOP -> exprOP MINUS term .)
    PLUS_ASSIGN     reduce using rule 122 (exprOP -> exprOP MINUS term .)
    MINUS_ASSIGN    reduce using rule 122 (exprOP -> exprOP MINUS term .)
    MUL_ASSIGN      reduce using rule 122 (exprOP -> exprOP MINUS term .)
    DIV_ASSIGN      reduce using rule 122 (exprOP -> exprOP MINUS term .)
    AND_ASSIGN      reduce using rule 122 (exprOP -> exprOP MINUS term .)
    OR_ASSIGN       reduce using rule 122 (exprOP -> exprOP MINUS term .)
    XOR_ASSIGN      reduce using rule 122 (exprOP -> exprOP MINUS term .)
    MOD_ASSIGN      reduce using rule 122 (exprOP -> exprOP MINUS term .)
    L_SHIFT_ASSIGN  reduce using rule 122 (exprOP -> exprOP MINUS term .)
    R_SHIFT_ASSIGN  reduce using rule 122 (exprOP -> exprOP MINUS term .)
    R_PAREN         reduce using rule 122 (exprOP -> exprOP MINUS term .)
    COMMA           reduce using rule 122 (exprOP -> exprOP MINUS term .)
    R_SQBRACE       reduce using rule 122 (exprOP -> exprOP MINUS term .)
    R_FLOWBRACE     reduce using rule 122 (exprOP -> exprOP MINUS term .)
    MULTIPLY        shift and go to state 103
    DIVIDE          shift and go to state 104
    MOD             shift and go to state 105


state 163

    (124) term -> term MULTIPLY factor .

    MULTIPLY        reduce using rule 124 (term -> term MULTIPLY factor .)
    DIVIDE          reduce using rule 124 (term -> term MULTIPLY factor .)
    MOD             reduce using rule 124 (term -> term MULTIPLY factor .)
    PLUS            reduce using rule 124 (term -> term MULTIPLY factor .)
    MINUS           reduce using rule 124 (term -> term MULTIPLY factor .)
    L_SHIFT         reduce using rule 124 (term -> term MULTIPLY factor .)
    R_SHIFT         reduce using rule 124 (term -> term MULTIPLY factor .)
    LE              reduce using rule 124 (term -> term MULTIPLY factor .)
    LT              reduce using rule 124 (term -> term MULTIPLY factor .)
    GE              reduce using rule 124 (term -> term MULTIPLY factor .)
    GT              reduce using rule 124 (term -> term MULTIPLY factor .)
    EQ              reduce using rule 124 (term -> term MULTIPLY factor .)
    NE              reduce using rule 124 (term -> term MULTIPLY factor .)
    BIT_AND         reduce using rule 124 (term -> term MULTIPLY factor .)
    BIT_XOR         reduce using rule 124 (term -> term MULTIPLY factor .)
    BIT_OR          reduce using rule 124 (term -> term MULTIPLY factor .)
    AND             reduce using rule 124 (term -> term MULTIPLY factor .)
    OR              reduce using rule 124 (term -> term MULTIPLY factor .)
    SEMICOLON       reduce using rule 124 (term -> term MULTIPLY factor .)
    ASSIGN          reduce using rule 124 (term -> term MULTIPLY factor .)
    PLUS_ASSIGN     reduce using rule 124 (term -> term MULTIPLY factor .)
    MINUS_ASSIGN    reduce using rule 124 (term -> term MULTIPLY factor .)
    MUL_ASSIGN      reduce using rule 124 (term -> term MULTIPLY factor .)
    DIV_ASSIGN      reduce using rule 124 (term -> term MULTIPLY factor .)
    AND_ASSIGN      reduce using rule 124 (term -> term MULTIPLY factor .)
    OR_ASSIGN       reduce using rule 124 (term -> term MULTIPLY factor .)
    XOR_ASSIGN      reduce using rule 124 (term -> term MULTIPLY factor .)
    MOD_ASSIGN      reduce using rule 124 (term -> term MULTIPLY factor .)
    L_SHIFT_ASSIGN  reduce using rule 124 (term -> term MULTIPLY factor .)
    R_SHIFT_ASSIGN  reduce using rule 124 (term -> term MULTIPLY factor .)
    R_PAREN         reduce using rule 124 (term -> term MULTIPLY factor .)
    COMMA           reduce using rule 124 (term -> term MULTIPLY factor .)
    R_SQBRACE       reduce using rule 124 (term -> term MULTIPLY factor .)
    R_FLOWBRACE     reduce using rule 124 (term -> term MULTIPLY factor .)


state 164

    (125) term -> term DIVIDE factor .

    MULTIPLY        reduce using rule 125 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 125 (term -> term DIVIDE factor .)
    MOD             reduce using rule 125 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 125 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 125 (term -> term DIVIDE factor .)
    L_SHIFT         reduce using rule 125 (term -> term DIVIDE factor .)
    R_SHIFT         reduce using rule 125 (term -> term DIVIDE factor .)
    LE              reduce using rule 125 (term -> term DIVIDE factor .)
    LT              reduce using rule 125 (term -> term DIVIDE factor .)
    GE              reduce using rule 125 (term -> term DIVIDE factor .)
    GT              reduce using rule 125 (term -> term DIVIDE factor .)
    EQ              reduce using rule 125 (term -> term DIVIDE factor .)
    NE              reduce using rule 125 (term -> term DIVIDE factor .)
    BIT_AND         reduce using rule 125 (term -> term DIVIDE factor .)
    BIT_XOR         reduce using rule 125 (term -> term DIVIDE factor .)
    BIT_OR          reduce using rule 125 (term -> term DIVIDE factor .)
    AND             reduce using rule 125 (term -> term DIVIDE factor .)
    OR              reduce using rule 125 (term -> term DIVIDE factor .)
    SEMICOLON       reduce using rule 125 (term -> term DIVIDE factor .)
    ASSIGN          reduce using rule 125 (term -> term DIVIDE factor .)
    PLUS_ASSIGN     reduce using rule 125 (term -> term DIVIDE factor .)
    MINUS_ASSIGN    reduce using rule 125 (term -> term DIVIDE factor .)
    MUL_ASSIGN      reduce using rule 125 (term -> term DIVIDE factor .)
    DIV_ASSIGN      reduce using rule 125 (term -> term DIVIDE factor .)
    AND_ASSIGN      reduce using rule 125 (term -> term DIVIDE factor .)
    OR_ASSIGN       reduce using rule 125 (term -> term DIVIDE factor .)
    XOR_ASSIGN      reduce using rule 125 (term -> term DIVIDE factor .)
    MOD_ASSIGN      reduce using rule 125 (term -> term DIVIDE factor .)
    L_SHIFT_ASSIGN  reduce using rule 125 (term -> term DIVIDE factor .)
    R_SHIFT_ASSIGN  reduce using rule 125 (term -> term DIVIDE factor .)
    R_PAREN         reduce using rule 125 (term -> term DIVIDE factor .)
    COMMA           reduce using rule 125 (term -> term DIVIDE factor .)
    R_SQBRACE       reduce using rule 125 (term -> term DIVIDE factor .)
    R_FLOWBRACE     reduce using rule 125 (term -> term DIVIDE factor .)


state 165

    (126) term -> term MOD factor .

    MULTIPLY        reduce using rule 126 (term -> term MOD factor .)
    DIVIDE          reduce using rule 126 (term -> term MOD factor .)
    MOD             reduce using rule 126 (term -> term MOD factor .)
    PLUS            reduce using rule 126 (term -> term MOD factor .)
    MINUS           reduce using rule 126 (term -> term MOD factor .)
    L_SHIFT         reduce using rule 126 (term -> term MOD factor .)
    R_SHIFT         reduce using rule 126 (term -> term MOD factor .)
    LE              reduce using rule 126 (term -> term MOD factor .)
    LT              reduce using rule 126 (term -> term MOD factor .)
    GE              reduce using rule 126 (term -> term MOD factor .)
    GT              reduce using rule 126 (term -> term MOD factor .)
    EQ              reduce using rule 126 (term -> term MOD factor .)
    NE              reduce using rule 126 (term -> term MOD factor .)
    BIT_AND         reduce using rule 126 (term -> term MOD factor .)
    BIT_XOR         reduce using rule 126 (term -> term MOD factor .)
    BIT_OR          reduce using rule 126 (term -> term MOD factor .)
    AND             reduce using rule 126 (term -> term MOD factor .)
    OR              reduce using rule 126 (term -> term MOD factor .)
    SEMICOLON       reduce using rule 126 (term -> term MOD factor .)
    ASSIGN          reduce using rule 126 (term -> term MOD factor .)
    PLUS_ASSIGN     reduce using rule 126 (term -> term MOD factor .)
    MINUS_ASSIGN    reduce using rule 126 (term -> term MOD factor .)
    MUL_ASSIGN      reduce using rule 126 (term -> term MOD factor .)
    DIV_ASSIGN      reduce using rule 126 (term -> term MOD factor .)
    AND_ASSIGN      reduce using rule 126 (term -> term MOD factor .)
    OR_ASSIGN       reduce using rule 126 (term -> term MOD factor .)
    XOR_ASSIGN      reduce using rule 126 (term -> term MOD factor .)
    MOD_ASSIGN      reduce using rule 126 (term -> term MOD factor .)
    L_SHIFT_ASSIGN  reduce using rule 126 (term -> term MOD factor .)
    R_SHIFT_ASSIGN  reduce using rule 126 (term -> term MOD factor .)
    R_PAREN         reduce using rule 126 (term -> term MOD factor .)
    COMMA           reduce using rule 126 (term -> term MOD factor .)
    R_SQBRACE       reduce using rule 126 (term -> term MOD factor .)
    R_FLOWBRACE     reduce using rule 126 (term -> term MOD factor .)


state 166

    (14) closed -> IF condition . closed else closed
    (7) open -> IF condition . statement
    (8) open -> IF condition . closed else open
    (12) closed -> . simple
    (13) closed -> . block
    (14) closed -> . IF condition closed else closed
    (15) closed -> . WHILE condition closed
    (16) closed -> . for for_condition closed
    (4) statement -> . open
    (5) statement -> . closed
    (54) simple -> . expr SEMICOLON
    (55) simple -> . header
    (56) simple -> . declaration
    (57) simple -> . SEMICOLON
    (58) simple -> . function
    (59) simple -> . RETURN expr SEMICOLON
    (60) simple -> . RETURN SEMICOLON
    (50) block -> . left_flower multiple_statements right_flower
    (51) block -> . left_flower right_flower
    (11) for -> . FOR
    (7) open -> . IF condition statement
    (8) open -> . IF condition closed else open
    (9) open -> . WHILE condition open
    (10) open -> . for for_condition open
    (86) expr -> . expr assignment exprOR
    (87) expr -> . exprOR
    (61) header -> . HASH INCLUDE STRING
    (62) header -> . HASH INCLUDE HEADER_FILE
    (35) declaration -> . TYPE ID SEMICOLON
    (36) declaration -> . TYPE MULTIPLY ID SEMICOLON
    (37) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (38) declaration -> . TYPE MULTIPLY ID ASSIGN expr SEMICOLON
    (39) declaration -> . TYPE multi_declaration stop
    (40) declaration -> . TYPE ID narrayindex SEMICOLON
    (41) declaration -> . TYPE ID narrayindex ASSIGN init_list SEMICOLON
    (83) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (52) left_flower -> . L_FLOWBRACE
    (99) exprOR -> . exprOR OR exprAND
    (100) exprOR -> . exprAND
    (101) exprAND -> . exprAND AND exprBITOR
    (102) exprAND -> . exprBITOR
    (103) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (104) exprBITOR -> . exprBITXOR
    (105) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (106) exprBITXOR -> . exprBITAND
    (107) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (108) exprBITAND -> . exprEQ
    (109) exprEQ -> . exprEQ EQ exprRELOP
    (110) exprEQ -> . exprEQ NE exprRELOP
    (111) exprEQ -> . exprRELOP
    (112) exprRELOP -> . exprRELOP relop exprSHIFT
    (113) exprRELOP -> . exprSHIFT
    (118) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (119) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (120) exprSHIFT -> . exprOP
    (121) exprOP -> . exprOP PLUS term
    (122) exprOP -> . exprOP MINUS term
    (123) exprOP -> . term
    (124) term -> . term MULTIPLY factor
    (125) term -> . term DIVIDE factor
    (126) term -> . term MOD factor
    (127) term -> . factor
    (128) factor -> . NOT factor
    (129) factor -> . PLUS factor
    (130) factor -> . MINUS factor
    (131) factor -> . PLUS_PLUS factor
    (132) factor -> . MINUS_MINUS factor
    (133) factor -> . cast brace
    (134) factor -> . brace
    (135) cast -> . L_PAREN TYPE R_PAREN
    (136) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (137) brace -> . L_PAREN expr R_PAREN
    (138) brace -> . brace PLUS_PLUS
    (139) brace -> . brace MINUS_MINUS
    (140) brace -> . NUM
    (141) brace -> . STRING
    (142) brace -> . MULTIPLY ID
    (143) brace -> . BIT_AND ID
    (144) brace -> . ID
    (145) brace -> . CHAR
    (146) brace -> . function_call
    (147) brace -> . ID narrayindex
    (148) NUM -> . INT_NUM
    (149) NUM -> . FLOAT_NUM
    (64) function_call -> . ID L_PAREN call_params R_PAREN

    IF              shift and go to state 114
    WHILE           shift and go to state 117
    SEMICOLON       shift and go to state 13
    RETURN          shift and go to state 17
    FOR             shift and go to state 11
    HASH            shift and go to state 20
    TYPE            shift and go to state 22
    L_FLOWBRACE     shift and go to state 26
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    closed                         shift and go to state 194
    statement                      shift and go to state 115
    open                           shift and go to state 4
    simple                         shift and go to state 9
    block                          shift and go to state 10
    for                            shift and go to state 118
    expr                           shift and go to state 12
    header                         shift and go to state 14
    declaration                    shift and go to state 15
    function                       shift and go to state 16
    left_flower                    shift and go to state 18
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 167

    (8) open -> IF condition closed else . open
    (14) closed -> IF condition closed else . closed
    (7) open -> . IF condition statement
    (8) open -> . IF condition closed else open
    (9) open -> . WHILE condition open
    (10) open -> . for for_condition open
    (12) closed -> . simple
    (13) closed -> . block
    (14) closed -> . IF condition closed else closed
    (15) closed -> . WHILE condition closed
    (16) closed -> . for for_condition closed
    (11) for -> . FOR
    (54) simple -> . expr SEMICOLON
    (55) simple -> . header
    (56) simple -> . declaration
    (57) simple -> . SEMICOLON
    (58) simple -> . function
    (59) simple -> . RETURN expr SEMICOLON
    (60) simple -> . RETURN SEMICOLON
    (50) block -> . left_flower multiple_statements right_flower
    (51) block -> . left_flower right_flower
    (86) expr -> . expr assignment exprOR
    (87) expr -> . exprOR
    (61) header -> . HASH INCLUDE STRING
    (62) header -> . HASH INCLUDE HEADER_FILE
    (35) declaration -> . TYPE ID SEMICOLON
    (36) declaration -> . TYPE MULTIPLY ID SEMICOLON
    (37) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (38) declaration -> . TYPE MULTIPLY ID ASSIGN expr SEMICOLON
    (39) declaration -> . TYPE multi_declaration stop
    (40) declaration -> . TYPE ID narrayindex SEMICOLON
    (41) declaration -> . TYPE ID narrayindex ASSIGN init_list SEMICOLON
    (83) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (52) left_flower -> . L_FLOWBRACE
    (99) exprOR -> . exprOR OR exprAND
    (100) exprOR -> . exprAND
    (101) exprAND -> . exprAND AND exprBITOR
    (102) exprAND -> . exprBITOR
    (103) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (104) exprBITOR -> . exprBITXOR
    (105) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (106) exprBITXOR -> . exprBITAND
    (107) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (108) exprBITAND -> . exprEQ
    (109) exprEQ -> . exprEQ EQ exprRELOP
    (110) exprEQ -> . exprEQ NE exprRELOP
    (111) exprEQ -> . exprRELOP
    (112) exprRELOP -> . exprRELOP relop exprSHIFT
    (113) exprRELOP -> . exprSHIFT
    (118) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (119) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (120) exprSHIFT -> . exprOP
    (121) exprOP -> . exprOP PLUS term
    (122) exprOP -> . exprOP MINUS term
    (123) exprOP -> . term
    (124) term -> . term MULTIPLY factor
    (125) term -> . term DIVIDE factor
    (126) term -> . term MOD factor
    (127) term -> . factor
    (128) factor -> . NOT factor
    (129) factor -> . PLUS factor
    (130) factor -> . MINUS factor
    (131) factor -> . PLUS_PLUS factor
    (132) factor -> . MINUS_MINUS factor
    (133) factor -> . cast brace
    (134) factor -> . brace
    (135) cast -> . L_PAREN TYPE R_PAREN
    (136) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (137) brace -> . L_PAREN expr R_PAREN
    (138) brace -> . brace PLUS_PLUS
    (139) brace -> . brace MINUS_MINUS
    (140) brace -> . NUM
    (141) brace -> . STRING
    (142) brace -> . MULTIPLY ID
    (143) brace -> . BIT_AND ID
    (144) brace -> . ID
    (145) brace -> . CHAR
    (146) brace -> . function_call
    (147) brace -> . ID narrayindex
    (148) NUM -> . INT_NUM
    (149) NUM -> . FLOAT_NUM
    (64) function_call -> . ID L_PAREN call_params R_PAREN

    IF              shift and go to state 6
    WHILE           shift and go to state 7
    FOR             shift and go to state 11
    SEMICOLON       shift and go to state 13
    RETURN          shift and go to state 17
    HASH            shift and go to state 20
    TYPE            shift and go to state 22
    L_FLOWBRACE     shift and go to state 26
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    closed                         shift and go to state 195
    open                           shift and go to state 196
    for                            shift and go to state 8
    simple                         shift and go to state 9
    block                          shift and go to state 10
    expr                           shift and go to state 12
    header                         shift and go to state 14
    declaration                    shift and go to state 15
    function                       shift and go to state 16
    left_flower                    shift and go to state 18
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 168

    (6) else -> ELSE .

    IF              reduce using rule 6 (else -> ELSE .)
    WHILE           reduce using rule 6 (else -> ELSE .)
    FOR             reduce using rule 6 (else -> ELSE .)
    SEMICOLON       reduce using rule 6 (else -> ELSE .)
    RETURN          reduce using rule 6 (else -> ELSE .)
    HASH            reduce using rule 6 (else -> ELSE .)
    TYPE            reduce using rule 6 (else -> ELSE .)
    L_FLOWBRACE     reduce using rule 6 (else -> ELSE .)
    NOT             reduce using rule 6 (else -> ELSE .)
    PLUS            reduce using rule 6 (else -> ELSE .)
    MINUS           reduce using rule 6 (else -> ELSE .)
    PLUS_PLUS       reduce using rule 6 (else -> ELSE .)
    MINUS_MINUS     reduce using rule 6 (else -> ELSE .)
    L_PAREN         reduce using rule 6 (else -> ELSE .)
    STRING          reduce using rule 6 (else -> ELSE .)
    MULTIPLY        reduce using rule 6 (else -> ELSE .)
    BIT_AND         reduce using rule 6 (else -> ELSE .)
    ID              reduce using rule 6 (else -> ELSE .)
    CHAR            reduce using rule 6 (else -> ELSE .)
    INT_NUM         reduce using rule 6 (else -> ELSE .)
    FLOAT_NUM       reduce using rule 6 (else -> ELSE .)


state 169

    (15) closed -> WHILE condition . closed
    (9) open -> WHILE condition . open
    (12) closed -> . simple
    (13) closed -> . block
    (14) closed -> . IF condition closed else closed
    (15) closed -> . WHILE condition closed
    (16) closed -> . for for_condition closed
    (7) open -> . IF condition statement
    (8) open -> . IF condition closed else open
    (9) open -> . WHILE condition open
    (10) open -> . for for_condition open
    (54) simple -> . expr SEMICOLON
    (55) simple -> . header
    (56) simple -> . declaration
    (57) simple -> . SEMICOLON
    (58) simple -> . function
    (59) simple -> . RETURN expr SEMICOLON
    (60) simple -> . RETURN SEMICOLON
    (50) block -> . left_flower multiple_statements right_flower
    (51) block -> . left_flower right_flower
    (11) for -> . FOR
    (86) expr -> . expr assignment exprOR
    (87) expr -> . exprOR
    (61) header -> . HASH INCLUDE STRING
    (62) header -> . HASH INCLUDE HEADER_FILE
    (35) declaration -> . TYPE ID SEMICOLON
    (36) declaration -> . TYPE MULTIPLY ID SEMICOLON
    (37) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (38) declaration -> . TYPE MULTIPLY ID ASSIGN expr SEMICOLON
    (39) declaration -> . TYPE multi_declaration stop
    (40) declaration -> . TYPE ID narrayindex SEMICOLON
    (41) declaration -> . TYPE ID narrayindex ASSIGN init_list SEMICOLON
    (83) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (52) left_flower -> . L_FLOWBRACE
    (99) exprOR -> . exprOR OR exprAND
    (100) exprOR -> . exprAND
    (101) exprAND -> . exprAND AND exprBITOR
    (102) exprAND -> . exprBITOR
    (103) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (104) exprBITOR -> . exprBITXOR
    (105) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (106) exprBITXOR -> . exprBITAND
    (107) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (108) exprBITAND -> . exprEQ
    (109) exprEQ -> . exprEQ EQ exprRELOP
    (110) exprEQ -> . exprEQ NE exprRELOP
    (111) exprEQ -> . exprRELOP
    (112) exprRELOP -> . exprRELOP relop exprSHIFT
    (113) exprRELOP -> . exprSHIFT
    (118) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (119) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (120) exprSHIFT -> . exprOP
    (121) exprOP -> . exprOP PLUS term
    (122) exprOP -> . exprOP MINUS term
    (123) exprOP -> . term
    (124) term -> . term MULTIPLY factor
    (125) term -> . term DIVIDE factor
    (126) term -> . term MOD factor
    (127) term -> . factor
    (128) factor -> . NOT factor
    (129) factor -> . PLUS factor
    (130) factor -> . MINUS factor
    (131) factor -> . PLUS_PLUS factor
    (132) factor -> . MINUS_MINUS factor
    (133) factor -> . cast brace
    (134) factor -> . brace
    (135) cast -> . L_PAREN TYPE R_PAREN
    (136) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (137) brace -> . L_PAREN expr R_PAREN
    (138) brace -> . brace PLUS_PLUS
    (139) brace -> . brace MINUS_MINUS
    (140) brace -> . NUM
    (141) brace -> . STRING
    (142) brace -> . MULTIPLY ID
    (143) brace -> . BIT_AND ID
    (144) brace -> . ID
    (145) brace -> . CHAR
    (146) brace -> . function_call
    (147) brace -> . ID narrayindex
    (148) NUM -> . INT_NUM
    (149) NUM -> . FLOAT_NUM
    (64) function_call -> . ID L_PAREN call_params R_PAREN

    IF              shift and go to state 114
    WHILE           shift and go to state 117
    SEMICOLON       shift and go to state 13
    RETURN          shift and go to state 17
    FOR             shift and go to state 11
    HASH            shift and go to state 20
    TYPE            shift and go to state 22
    L_FLOWBRACE     shift and go to state 26
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    closed                         shift and go to state 121
    open                           shift and go to state 120
    simple                         shift and go to state 9
    block                          shift and go to state 10
    for                            shift and go to state 118
    expr                           shift and go to state 12
    header                         shift and go to state 14
    declaration                    shift and go to state 15
    function                       shift and go to state 16
    left_flower                    shift and go to state 18
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 170

    (16) closed -> for for_condition . closed
    (10) open -> for for_condition . open
    (12) closed -> . simple
    (13) closed -> . block
    (14) closed -> . IF condition closed else closed
    (15) closed -> . WHILE condition closed
    (16) closed -> . for for_condition closed
    (7) open -> . IF condition statement
    (8) open -> . IF condition closed else open
    (9) open -> . WHILE condition open
    (10) open -> . for for_condition open
    (54) simple -> . expr SEMICOLON
    (55) simple -> . header
    (56) simple -> . declaration
    (57) simple -> . SEMICOLON
    (58) simple -> . function
    (59) simple -> . RETURN expr SEMICOLON
    (60) simple -> . RETURN SEMICOLON
    (50) block -> . left_flower multiple_statements right_flower
    (51) block -> . left_flower right_flower
    (11) for -> . FOR
    (86) expr -> . expr assignment exprOR
    (87) expr -> . exprOR
    (61) header -> . HASH INCLUDE STRING
    (62) header -> . HASH INCLUDE HEADER_FILE
    (35) declaration -> . TYPE ID SEMICOLON
    (36) declaration -> . TYPE MULTIPLY ID SEMICOLON
    (37) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (38) declaration -> . TYPE MULTIPLY ID ASSIGN expr SEMICOLON
    (39) declaration -> . TYPE multi_declaration stop
    (40) declaration -> . TYPE ID narrayindex SEMICOLON
    (41) declaration -> . TYPE ID narrayindex ASSIGN init_list SEMICOLON
    (83) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (52) left_flower -> . L_FLOWBRACE
    (99) exprOR -> . exprOR OR exprAND
    (100) exprOR -> . exprAND
    (101) exprAND -> . exprAND AND exprBITOR
    (102) exprAND -> . exprBITOR
    (103) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (104) exprBITOR -> . exprBITXOR
    (105) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (106) exprBITXOR -> . exprBITAND
    (107) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (108) exprBITAND -> . exprEQ
    (109) exprEQ -> . exprEQ EQ exprRELOP
    (110) exprEQ -> . exprEQ NE exprRELOP
    (111) exprEQ -> . exprRELOP
    (112) exprRELOP -> . exprRELOP relop exprSHIFT
    (113) exprRELOP -> . exprSHIFT
    (118) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (119) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (120) exprSHIFT -> . exprOP
    (121) exprOP -> . exprOP PLUS term
    (122) exprOP -> . exprOP MINUS term
    (123) exprOP -> . term
    (124) term -> . term MULTIPLY factor
    (125) term -> . term DIVIDE factor
    (126) term -> . term MOD factor
    (127) term -> . factor
    (128) factor -> . NOT factor
    (129) factor -> . PLUS factor
    (130) factor -> . MINUS factor
    (131) factor -> . PLUS_PLUS factor
    (132) factor -> . MINUS_MINUS factor
    (133) factor -> . cast brace
    (134) factor -> . brace
    (135) cast -> . L_PAREN TYPE R_PAREN
    (136) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (137) brace -> . L_PAREN expr R_PAREN
    (138) brace -> . brace PLUS_PLUS
    (139) brace -> . brace MINUS_MINUS
    (140) brace -> . NUM
    (141) brace -> . STRING
    (142) brace -> . MULTIPLY ID
    (143) brace -> . BIT_AND ID
    (144) brace -> . ID
    (145) brace -> . CHAR
    (146) brace -> . function_call
    (147) brace -> . ID narrayindex
    (148) NUM -> . INT_NUM
    (149) NUM -> . FLOAT_NUM
    (64) function_call -> . ID L_PAREN call_params R_PAREN

    IF              shift and go to state 114
    WHILE           shift and go to state 117
    SEMICOLON       shift and go to state 13
    RETURN          shift and go to state 17
    FOR             shift and go to state 11
    HASH            shift and go to state 20
    TYPE            shift and go to state 22
    L_FLOWBRACE     shift and go to state 26
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    for                            shift and go to state 118
    closed                         shift and go to state 123
    open                           shift and go to state 122
    simple                         shift and go to state 9
    block                          shift and go to state 10
    expr                           shift and go to state 12
    header                         shift and go to state 14
    declaration                    shift and go to state 15
    function                       shift and go to state 16
    left_flower                    shift and go to state 18
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 171

    (17) condition -> L_PAREN expr R_PAREN .

    IF              reduce using rule 17 (condition -> L_PAREN expr R_PAREN .)
    WHILE           reduce using rule 17 (condition -> L_PAREN expr R_PAREN .)
    SEMICOLON       reduce using rule 17 (condition -> L_PAREN expr R_PAREN .)
    RETURN          reduce using rule 17 (condition -> L_PAREN expr R_PAREN .)
    FOR             reduce using rule 17 (condition -> L_PAREN expr R_PAREN .)
    HASH            reduce using rule 17 (condition -> L_PAREN expr R_PAREN .)
    TYPE            reduce using rule 17 (condition -> L_PAREN expr R_PAREN .)
    L_FLOWBRACE     reduce using rule 17 (condition -> L_PAREN expr R_PAREN .)
    NOT             reduce using rule 17 (condition -> L_PAREN expr R_PAREN .)
    PLUS            reduce using rule 17 (condition -> L_PAREN expr R_PAREN .)
    MINUS           reduce using rule 17 (condition -> L_PAREN expr R_PAREN .)
    PLUS_PLUS       reduce using rule 17 (condition -> L_PAREN expr R_PAREN .)
    MINUS_MINUS     reduce using rule 17 (condition -> L_PAREN expr R_PAREN .)
    L_PAREN         reduce using rule 17 (condition -> L_PAREN expr R_PAREN .)
    STRING          reduce using rule 17 (condition -> L_PAREN expr R_PAREN .)
    MULTIPLY        reduce using rule 17 (condition -> L_PAREN expr R_PAREN .)
    BIT_AND         reduce using rule 17 (condition -> L_PAREN expr R_PAREN .)
    ID              reduce using rule 17 (condition -> L_PAREN expr R_PAREN .)
    CHAR            reduce using rule 17 (condition -> L_PAREN expr R_PAREN .)
    INT_NUM         reduce using rule 17 (condition -> L_PAREN expr R_PAREN .)
    FLOAT_NUM       reduce using rule 17 (condition -> L_PAREN expr R_PAREN .)


state 172

    (18) for_condition -> L_PAREN simple simple . expr R_PAREN
    (19) for_condition -> L_PAREN simple simple . R_PAREN
    (86) expr -> . expr assignment exprOR
    (87) expr -> . exprOR
    (99) exprOR -> . exprOR OR exprAND
    (100) exprOR -> . exprAND
    (101) exprAND -> . exprAND AND exprBITOR
    (102) exprAND -> . exprBITOR
    (103) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (104) exprBITOR -> . exprBITXOR
    (105) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (106) exprBITXOR -> . exprBITAND
    (107) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (108) exprBITAND -> . exprEQ
    (109) exprEQ -> . exprEQ EQ exprRELOP
    (110) exprEQ -> . exprEQ NE exprRELOP
    (111) exprEQ -> . exprRELOP
    (112) exprRELOP -> . exprRELOP relop exprSHIFT
    (113) exprRELOP -> . exprSHIFT
    (118) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (119) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (120) exprSHIFT -> . exprOP
    (121) exprOP -> . exprOP PLUS term
    (122) exprOP -> . exprOP MINUS term
    (123) exprOP -> . term
    (124) term -> . term MULTIPLY factor
    (125) term -> . term DIVIDE factor
    (126) term -> . term MOD factor
    (127) term -> . factor
    (128) factor -> . NOT factor
    (129) factor -> . PLUS factor
    (130) factor -> . MINUS factor
    (131) factor -> . PLUS_PLUS factor
    (132) factor -> . MINUS_MINUS factor
    (133) factor -> . cast brace
    (134) factor -> . brace
    (135) cast -> . L_PAREN TYPE R_PAREN
    (136) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (137) brace -> . L_PAREN expr R_PAREN
    (138) brace -> . brace PLUS_PLUS
    (139) brace -> . brace MINUS_MINUS
    (140) brace -> . NUM
    (141) brace -> . STRING
    (142) brace -> . MULTIPLY ID
    (143) brace -> . BIT_AND ID
    (144) brace -> . ID
    (145) brace -> . CHAR
    (146) brace -> . function_call
    (147) brace -> . ID narrayindex
    (148) NUM -> . INT_NUM
    (149) NUM -> . FLOAT_NUM
    (64) function_call -> . ID L_PAREN call_params R_PAREN

    R_PAREN         shift and go to state 198
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    expr                           shift and go to state 197
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 173

    (37) declaration -> TYPE ID ASSIGN expr . SEMICOLON
    (25) multi_declaration -> ID ASSIGN expr . COMMA
    (86) expr -> expr . assignment exprOR
    (88) assignment -> . ASSIGN
    (89) assignment -> . PLUS_ASSIGN
    (90) assignment -> . MINUS_ASSIGN
    (91) assignment -> . MUL_ASSIGN
    (92) assignment -> . DIV_ASSIGN
    (93) assignment -> . AND_ASSIGN
    (94) assignment -> . OR_ASSIGN
    (95) assignment -> . XOR_ASSIGN
    (96) assignment -> . MOD_ASSIGN
    (97) assignment -> . L_SHIFT_ASSIGN
    (98) assignment -> . R_SHIFT_ASSIGN

    SEMICOLON       shift and go to state 199
    COMMA           shift and go to state 200
    ASSIGN          shift and go to state 58
    PLUS_ASSIGN     shift and go to state 59
    MINUS_ASSIGN    shift and go to state 60
    MUL_ASSIGN      shift and go to state 61
    DIV_ASSIGN      shift and go to state 62
    AND_ASSIGN      shift and go to state 63
    OR_ASSIGN       shift and go to state 64
    XOR_ASSIGN      shift and go to state 65
    MOD_ASSIGN      shift and go to state 66
    L_SHIFT_ASSIGN  shift and go to state 67
    R_SHIFT_ASSIGN  shift and go to state 68

    assignment                     shift and go to state 57

state 174

    (40) declaration -> TYPE ID narrayindex SEMICOLON .

    IF              reduce using rule 40 (declaration -> TYPE ID narrayindex SEMICOLON .)
    WHILE           reduce using rule 40 (declaration -> TYPE ID narrayindex SEMICOLON .)
    FOR             reduce using rule 40 (declaration -> TYPE ID narrayindex SEMICOLON .)
    SEMICOLON       reduce using rule 40 (declaration -> TYPE ID narrayindex SEMICOLON .)
    RETURN          reduce using rule 40 (declaration -> TYPE ID narrayindex SEMICOLON .)
    HASH            reduce using rule 40 (declaration -> TYPE ID narrayindex SEMICOLON .)
    TYPE            reduce using rule 40 (declaration -> TYPE ID narrayindex SEMICOLON .)
    L_FLOWBRACE     reduce using rule 40 (declaration -> TYPE ID narrayindex SEMICOLON .)
    NOT             reduce using rule 40 (declaration -> TYPE ID narrayindex SEMICOLON .)
    PLUS            reduce using rule 40 (declaration -> TYPE ID narrayindex SEMICOLON .)
    MINUS           reduce using rule 40 (declaration -> TYPE ID narrayindex SEMICOLON .)
    PLUS_PLUS       reduce using rule 40 (declaration -> TYPE ID narrayindex SEMICOLON .)
    MINUS_MINUS     reduce using rule 40 (declaration -> TYPE ID narrayindex SEMICOLON .)
    L_PAREN         reduce using rule 40 (declaration -> TYPE ID narrayindex SEMICOLON .)
    STRING          reduce using rule 40 (declaration -> TYPE ID narrayindex SEMICOLON .)
    MULTIPLY        reduce using rule 40 (declaration -> TYPE ID narrayindex SEMICOLON .)
    BIT_AND         reduce using rule 40 (declaration -> TYPE ID narrayindex SEMICOLON .)
    ID              reduce using rule 40 (declaration -> TYPE ID narrayindex SEMICOLON .)
    CHAR            reduce using rule 40 (declaration -> TYPE ID narrayindex SEMICOLON .)
    INT_NUM         reduce using rule 40 (declaration -> TYPE ID narrayindex SEMICOLON .)
    FLOAT_NUM       reduce using rule 40 (declaration -> TYPE ID narrayindex SEMICOLON .)
    $end            reduce using rule 40 (declaration -> TYPE ID narrayindex SEMICOLON .)
    R_FLOWBRACE     reduce using rule 40 (declaration -> TYPE ID narrayindex SEMICOLON .)
    ELSE            reduce using rule 40 (declaration -> TYPE ID narrayindex SEMICOLON .)
    R_PAREN         reduce using rule 40 (declaration -> TYPE ID narrayindex SEMICOLON .)


state 175

    (41) declaration -> TYPE ID narrayindex ASSIGN . init_list SEMICOLON
    (44) init_list -> . L_FLOWBRACE init_list R_FLOWBRACE COMMA init_list
    (45) init_list -> . L_FLOWBRACE init R_FLOWBRACE COMMA init_list
    (46) init_list -> . L_FLOWBRACE init R_FLOWBRACE
    (47) init_list -> . L_FLOWBRACE init_list R_FLOWBRACE

    L_FLOWBRACE     shift and go to state 202

    init_list                      shift and go to state 201

state 176

    (74) yes_dec_params -> TYPE . expr COMMA
    (75) yes_dec_params -> TYPE . COMMA
    (76) yes_dec_params -> TYPE . MULTIPLY COMMA
    (77) end_dec_params -> TYPE . expr
    (78) end_dec_params -> TYPE .
    (79) end_dec_params -> TYPE . MULTIPLY
    (86) expr -> . expr assignment exprOR
    (87) expr -> . exprOR
    (99) exprOR -> . exprOR OR exprAND
    (100) exprOR -> . exprAND
    (101) exprAND -> . exprAND AND exprBITOR
    (102) exprAND -> . exprBITOR
    (103) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (104) exprBITOR -> . exprBITXOR
    (105) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (106) exprBITXOR -> . exprBITAND
    (107) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (108) exprBITAND -> . exprEQ
    (109) exprEQ -> . exprEQ EQ exprRELOP
    (110) exprEQ -> . exprEQ NE exprRELOP
    (111) exprEQ -> . exprRELOP
    (112) exprRELOP -> . exprRELOP relop exprSHIFT
    (113) exprRELOP -> . exprSHIFT
    (118) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (119) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (120) exprSHIFT -> . exprOP
    (121) exprOP -> . exprOP PLUS term
    (122) exprOP -> . exprOP MINUS term
    (123) exprOP -> . term
    (124) term -> . term MULTIPLY factor
    (125) term -> . term DIVIDE factor
    (126) term -> . term MOD factor
    (127) term -> . factor
    (128) factor -> . NOT factor
    (129) factor -> . PLUS factor
    (130) factor -> . MINUS factor
    (131) factor -> . PLUS_PLUS factor
    (132) factor -> . MINUS_MINUS factor
    (133) factor -> . cast brace
    (134) factor -> . brace
    (135) cast -> . L_PAREN TYPE R_PAREN
    (136) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (137) brace -> . L_PAREN expr R_PAREN
    (138) brace -> . brace PLUS_PLUS
    (139) brace -> . brace MINUS_MINUS
    (140) brace -> . NUM
    (141) brace -> . STRING
    (142) brace -> . MULTIPLY ID
    (143) brace -> . BIT_AND ID
    (144) brace -> . ID
    (145) brace -> . CHAR
    (146) brace -> . function_call
    (147) brace -> . ID narrayindex
    (148) NUM -> . INT_NUM
    (149) NUM -> . FLOAT_NUM
    (64) function_call -> . ID L_PAREN call_params R_PAREN

    COMMA           shift and go to state 204
    MULTIPLY        shift and go to state 205
    R_PAREN         reduce using rule 78 (end_dec_params -> TYPE .)
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    expr                           shift and go to state 203
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 177

    (83) function -> TYPE ID L_PAREN dec_params . R_PAREN function_2

    R_PAREN         shift and go to state 206


state 178

    (80) dec_params -> empty .

    R_PAREN         reduce using rule 80 (dec_params -> empty .)


state 179

    (81) dec_params -> yes_dec_params . end_dec_params
    (71) yes_dec_params -> yes_dec_params . TYPE expr COMMA
    (72) yes_dec_params -> yes_dec_params . TYPE COMMA
    (73) yes_dec_params -> yes_dec_params . TYPE MULTIPLY COMMA
    (77) end_dec_params -> . TYPE expr
    (78) end_dec_params -> . TYPE
    (79) end_dec_params -> . TYPE MULTIPLY

    TYPE            shift and go to state 208

    end_dec_params                 shift and go to state 207

state 180

    (82) dec_params -> end_dec_params .

    R_PAREN         reduce using rule 82 (dec_params -> end_dec_params .)


state 181

    (36) declaration -> TYPE MULTIPLY ID SEMICOLON .

    IF              reduce using rule 36 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    WHILE           reduce using rule 36 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    FOR             reduce using rule 36 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    SEMICOLON       reduce using rule 36 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    RETURN          reduce using rule 36 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    HASH            reduce using rule 36 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    TYPE            reduce using rule 36 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    L_FLOWBRACE     reduce using rule 36 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    NOT             reduce using rule 36 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    PLUS            reduce using rule 36 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    MINUS           reduce using rule 36 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    PLUS_PLUS       reduce using rule 36 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    MINUS_MINUS     reduce using rule 36 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    L_PAREN         reduce using rule 36 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    STRING          reduce using rule 36 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    MULTIPLY        reduce using rule 36 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    BIT_AND         reduce using rule 36 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    ID              reduce using rule 36 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    CHAR            reduce using rule 36 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    INT_NUM         reduce using rule 36 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    FLOAT_NUM       reduce using rule 36 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    $end            reduce using rule 36 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    R_FLOWBRACE     reduce using rule 36 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    ELSE            reduce using rule 36 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    R_PAREN         reduce using rule 36 (declaration -> TYPE MULTIPLY ID SEMICOLON .)


state 182

    (38) declaration -> TYPE MULTIPLY ID ASSIGN . expr SEMICOLON
    (27) multi_declaration -> MULTIPLY ID ASSIGN . expr COMMA
    (86) expr -> . expr assignment exprOR
    (87) expr -> . exprOR
    (99) exprOR -> . exprOR OR exprAND
    (100) exprOR -> . exprAND
    (101) exprAND -> . exprAND AND exprBITOR
    (102) exprAND -> . exprBITOR
    (103) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (104) exprBITOR -> . exprBITXOR
    (105) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (106) exprBITXOR -> . exprBITAND
    (107) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (108) exprBITAND -> . exprEQ
    (109) exprEQ -> . exprEQ EQ exprRELOP
    (110) exprEQ -> . exprEQ NE exprRELOP
    (111) exprEQ -> . exprRELOP
    (112) exprRELOP -> . exprRELOP relop exprSHIFT
    (113) exprRELOP -> . exprSHIFT
    (118) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (119) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (120) exprSHIFT -> . exprOP
    (121) exprOP -> . exprOP PLUS term
    (122) exprOP -> . exprOP MINUS term
    (123) exprOP -> . term
    (124) term -> . term MULTIPLY factor
    (125) term -> . term DIVIDE factor
    (126) term -> . term MOD factor
    (127) term -> . factor
    (128) factor -> . NOT factor
    (129) factor -> . PLUS factor
    (130) factor -> . MINUS factor
    (131) factor -> . PLUS_PLUS factor
    (132) factor -> . MINUS_MINUS factor
    (133) factor -> . cast brace
    (134) factor -> . brace
    (135) cast -> . L_PAREN TYPE R_PAREN
    (136) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (137) brace -> . L_PAREN expr R_PAREN
    (138) brace -> . brace PLUS_PLUS
    (139) brace -> . brace MINUS_MINUS
    (140) brace -> . NUM
    (141) brace -> . STRING
    (142) brace -> . MULTIPLY ID
    (143) brace -> . BIT_AND ID
    (144) brace -> . ID
    (145) brace -> . CHAR
    (146) brace -> . function_call
    (147) brace -> . ID narrayindex
    (148) NUM -> . INT_NUM
    (149) NUM -> . FLOAT_NUM
    (64) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    expr                           shift and go to state 209
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 183

    (26) multi_declaration -> MULTIPLY ID COMMA .

    ID              reduce using rule 26 (multi_declaration -> MULTIPLY ID COMMA .)
    MULTIPLY        reduce using rule 26 (multi_declaration -> MULTIPLY ID COMMA .)


state 184

    (20) multi_declaration -> multi_declaration ID COMMA .

    ID              reduce using rule 20 (multi_declaration -> multi_declaration ID COMMA .)
    MULTIPLY        reduce using rule 20 (multi_declaration -> multi_declaration ID COMMA .)


state 185

    (22) multi_declaration -> multi_declaration ID ASSIGN . expr COMMA
    (30) stop -> ID ASSIGN . expr SEMICOLON
    (86) expr -> . expr assignment exprOR
    (87) expr -> . exprOR
    (99) exprOR -> . exprOR OR exprAND
    (100) exprOR -> . exprAND
    (101) exprAND -> . exprAND AND exprBITOR
    (102) exprAND -> . exprBITOR
    (103) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (104) exprBITOR -> . exprBITXOR
    (105) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (106) exprBITXOR -> . exprBITAND
    (107) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (108) exprBITAND -> . exprEQ
    (109) exprEQ -> . exprEQ EQ exprRELOP
    (110) exprEQ -> . exprEQ NE exprRELOP
    (111) exprEQ -> . exprRELOP
    (112) exprRELOP -> . exprRELOP relop exprSHIFT
    (113) exprRELOP -> . exprSHIFT
    (118) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (119) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (120) exprSHIFT -> . exprOP
    (121) exprOP -> . exprOP PLUS term
    (122) exprOP -> . exprOP MINUS term
    (123) exprOP -> . term
    (124) term -> . term MULTIPLY factor
    (125) term -> . term DIVIDE factor
    (126) term -> . term MOD factor
    (127) term -> . factor
    (128) factor -> . NOT factor
    (129) factor -> . PLUS factor
    (130) factor -> . MINUS factor
    (131) factor -> . PLUS_PLUS factor
    (132) factor -> . MINUS_MINUS factor
    (133) factor -> . cast brace
    (134) factor -> . brace
    (135) cast -> . L_PAREN TYPE R_PAREN
    (136) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (137) brace -> . L_PAREN expr R_PAREN
    (138) brace -> . brace PLUS_PLUS
    (139) brace -> . brace MINUS_MINUS
    (140) brace -> . NUM
    (141) brace -> . STRING
    (142) brace -> . MULTIPLY ID
    (143) brace -> . BIT_AND ID
    (144) brace -> . ID
    (145) brace -> . CHAR
    (146) brace -> . function_call
    (147) brace -> . ID narrayindex
    (148) NUM -> . INT_NUM
    (149) NUM -> . FLOAT_NUM
    (64) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    expr                           shift and go to state 210
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 186

    (28) stop -> ID SEMICOLON .

    IF              reduce using rule 28 (stop -> ID SEMICOLON .)
    WHILE           reduce using rule 28 (stop -> ID SEMICOLON .)
    FOR             reduce using rule 28 (stop -> ID SEMICOLON .)
    SEMICOLON       reduce using rule 28 (stop -> ID SEMICOLON .)
    RETURN          reduce using rule 28 (stop -> ID SEMICOLON .)
    HASH            reduce using rule 28 (stop -> ID SEMICOLON .)
    TYPE            reduce using rule 28 (stop -> ID SEMICOLON .)
    L_FLOWBRACE     reduce using rule 28 (stop -> ID SEMICOLON .)
    NOT             reduce using rule 28 (stop -> ID SEMICOLON .)
    PLUS            reduce using rule 28 (stop -> ID SEMICOLON .)
    MINUS           reduce using rule 28 (stop -> ID SEMICOLON .)
    PLUS_PLUS       reduce using rule 28 (stop -> ID SEMICOLON .)
    MINUS_MINUS     reduce using rule 28 (stop -> ID SEMICOLON .)
    L_PAREN         reduce using rule 28 (stop -> ID SEMICOLON .)
    STRING          reduce using rule 28 (stop -> ID SEMICOLON .)
    MULTIPLY        reduce using rule 28 (stop -> ID SEMICOLON .)
    BIT_AND         reduce using rule 28 (stop -> ID SEMICOLON .)
    ID              reduce using rule 28 (stop -> ID SEMICOLON .)
    CHAR            reduce using rule 28 (stop -> ID SEMICOLON .)
    INT_NUM         reduce using rule 28 (stop -> ID SEMICOLON .)
    FLOAT_NUM       reduce using rule 28 (stop -> ID SEMICOLON .)
    $end            reduce using rule 28 (stop -> ID SEMICOLON .)
    R_FLOWBRACE     reduce using rule 28 (stop -> ID SEMICOLON .)
    ELSE            reduce using rule 28 (stop -> ID SEMICOLON .)
    R_PAREN         reduce using rule 28 (stop -> ID SEMICOLON .)


state 187

    (21) multi_declaration -> multi_declaration MULTIPLY ID . COMMA
    (23) multi_declaration -> multi_declaration MULTIPLY ID . ASSIGN expr COMMA
    (29) stop -> MULTIPLY ID . SEMICOLON
    (31) stop -> MULTIPLY ID . ASSIGN expr SEMICOLON

    COMMA           shift and go to state 211
    ASSIGN          shift and go to state 212
    SEMICOLON       shift and go to state 213


state 188

    (64) function_call -> ID L_PAREN call_params R_PAREN .

    PLUS_PLUS       reduce using rule 64 (function_call -> ID L_PAREN call_params R_PAREN .)
    MINUS_MINUS     reduce using rule 64 (function_call -> ID L_PAREN call_params R_PAREN .)
    MULTIPLY        reduce using rule 64 (function_call -> ID L_PAREN call_params R_PAREN .)
    DIVIDE          reduce using rule 64 (function_call -> ID L_PAREN call_params R_PAREN .)
    MOD             reduce using rule 64 (function_call -> ID L_PAREN call_params R_PAREN .)
    PLUS            reduce using rule 64 (function_call -> ID L_PAREN call_params R_PAREN .)
    MINUS           reduce using rule 64 (function_call -> ID L_PAREN call_params R_PAREN .)
    L_SHIFT         reduce using rule 64 (function_call -> ID L_PAREN call_params R_PAREN .)
    R_SHIFT         reduce using rule 64 (function_call -> ID L_PAREN call_params R_PAREN .)
    LE              reduce using rule 64 (function_call -> ID L_PAREN call_params R_PAREN .)
    LT              reduce using rule 64 (function_call -> ID L_PAREN call_params R_PAREN .)
    GE              reduce using rule 64 (function_call -> ID L_PAREN call_params R_PAREN .)
    GT              reduce using rule 64 (function_call -> ID L_PAREN call_params R_PAREN .)
    EQ              reduce using rule 64 (function_call -> ID L_PAREN call_params R_PAREN .)
    NE              reduce using rule 64 (function_call -> ID L_PAREN call_params R_PAREN .)
    BIT_AND         reduce using rule 64 (function_call -> ID L_PAREN call_params R_PAREN .)
    BIT_XOR         reduce using rule 64 (function_call -> ID L_PAREN call_params R_PAREN .)
    BIT_OR          reduce using rule 64 (function_call -> ID L_PAREN call_params R_PAREN .)
    AND             reduce using rule 64 (function_call -> ID L_PAREN call_params R_PAREN .)
    OR              reduce using rule 64 (function_call -> ID L_PAREN call_params R_PAREN .)
    SEMICOLON       reduce using rule 64 (function_call -> ID L_PAREN call_params R_PAREN .)
    ASSIGN          reduce using rule 64 (function_call -> ID L_PAREN call_params R_PAREN .)
    PLUS_ASSIGN     reduce using rule 64 (function_call -> ID L_PAREN call_params R_PAREN .)
    MINUS_ASSIGN    reduce using rule 64 (function_call -> ID L_PAREN call_params R_PAREN .)
    MUL_ASSIGN      reduce using rule 64 (function_call -> ID L_PAREN call_params R_PAREN .)
    DIV_ASSIGN      reduce using rule 64 (function_call -> ID L_PAREN call_params R_PAREN .)
    AND_ASSIGN      reduce using rule 64 (function_call -> ID L_PAREN call_params R_PAREN .)
    OR_ASSIGN       reduce using rule 64 (function_call -> ID L_PAREN call_params R_PAREN .)
    XOR_ASSIGN      reduce using rule 64 (function_call -> ID L_PAREN call_params R_PAREN .)
    MOD_ASSIGN      reduce using rule 64 (function_call -> ID L_PAREN call_params R_PAREN .)
    L_SHIFT_ASSIGN  reduce using rule 64 (function_call -> ID L_PAREN call_params R_PAREN .)
    R_SHIFT_ASSIGN  reduce using rule 64 (function_call -> ID L_PAREN call_params R_PAREN .)
    R_PAREN         reduce using rule 64 (function_call -> ID L_PAREN call_params R_PAREN .)
    COMMA           reduce using rule 64 (function_call -> ID L_PAREN call_params R_PAREN .)
    R_SQBRACE       reduce using rule 64 (function_call -> ID L_PAREN call_params R_PAREN .)
    R_FLOWBRACE     reduce using rule 64 (function_call -> ID L_PAREN call_params R_PAREN .)


state 189

    (66) call_params -> yes_call_params end_call_params .

    R_PAREN         reduce using rule 66 (call_params -> yes_call_params end_call_params .)


state 190

    (68) yes_call_params -> yes_call_params expr . COMMA
    (70) end_call_params -> expr .
    (86) expr -> expr . assignment exprOR
    (88) assignment -> . ASSIGN
    (89) assignment -> . PLUS_ASSIGN
    (90) assignment -> . MINUS_ASSIGN
    (91) assignment -> . MUL_ASSIGN
    (92) assignment -> . DIV_ASSIGN
    (93) assignment -> . AND_ASSIGN
    (94) assignment -> . OR_ASSIGN
    (95) assignment -> . XOR_ASSIGN
    (96) assignment -> . MOD_ASSIGN
    (97) assignment -> . L_SHIFT_ASSIGN
    (98) assignment -> . R_SHIFT_ASSIGN

    COMMA           shift and go to state 214
    R_PAREN         reduce using rule 70 (end_call_params -> expr .)
    ASSIGN          shift and go to state 58
    PLUS_ASSIGN     shift and go to state 59
    MINUS_ASSIGN    shift and go to state 60
    MUL_ASSIGN      shift and go to state 61
    DIV_ASSIGN      shift and go to state 62
    AND_ASSIGN      shift and go to state 63
    OR_ASSIGN       shift and go to state 64
    XOR_ASSIGN      shift and go to state 65
    MOD_ASSIGN      shift and go to state 66
    L_SHIFT_ASSIGN  shift and go to state 67
    R_SHIFT_ASSIGN  shift and go to state 68

    assignment                     shift and go to state 57

state 191

    (69) yes_call_params -> expr COMMA .

    NOT             reduce using rule 69 (yes_call_params -> expr COMMA .)
    PLUS            reduce using rule 69 (yes_call_params -> expr COMMA .)
    MINUS           reduce using rule 69 (yes_call_params -> expr COMMA .)
    PLUS_PLUS       reduce using rule 69 (yes_call_params -> expr COMMA .)
    MINUS_MINUS     reduce using rule 69 (yes_call_params -> expr COMMA .)
    L_PAREN         reduce using rule 69 (yes_call_params -> expr COMMA .)
    STRING          reduce using rule 69 (yes_call_params -> expr COMMA .)
    MULTIPLY        reduce using rule 69 (yes_call_params -> expr COMMA .)
    BIT_AND         reduce using rule 69 (yes_call_params -> expr COMMA .)
    ID              reduce using rule 69 (yes_call_params -> expr COMMA .)
    CHAR            reduce using rule 69 (yes_call_params -> expr COMMA .)
    INT_NUM         reduce using rule 69 (yes_call_params -> expr COMMA .)
    FLOAT_NUM       reduce using rule 69 (yes_call_params -> expr COMMA .)


state 192

    (32) arrayindex -> L_SQBRACE index R_SQBRACE .

    L_SQBRACE       reduce using rule 32 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    PLUS_PLUS       reduce using rule 32 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    MINUS_MINUS     reduce using rule 32 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    MULTIPLY        reduce using rule 32 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    DIVIDE          reduce using rule 32 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    MOD             reduce using rule 32 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    PLUS            reduce using rule 32 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    MINUS           reduce using rule 32 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    L_SHIFT         reduce using rule 32 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    R_SHIFT         reduce using rule 32 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    LE              reduce using rule 32 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    LT              reduce using rule 32 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    GE              reduce using rule 32 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    GT              reduce using rule 32 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    EQ              reduce using rule 32 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    NE              reduce using rule 32 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    BIT_AND         reduce using rule 32 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    BIT_XOR         reduce using rule 32 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    BIT_OR          reduce using rule 32 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    AND             reduce using rule 32 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    OR              reduce using rule 32 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    SEMICOLON       reduce using rule 32 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    ASSIGN          reduce using rule 32 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    PLUS_ASSIGN     reduce using rule 32 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    MINUS_ASSIGN    reduce using rule 32 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    MUL_ASSIGN      reduce using rule 32 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    DIV_ASSIGN      reduce using rule 32 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    AND_ASSIGN      reduce using rule 32 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    OR_ASSIGN       reduce using rule 32 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    XOR_ASSIGN      reduce using rule 32 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    MOD_ASSIGN      reduce using rule 32 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    L_SHIFT_ASSIGN  reduce using rule 32 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    R_SHIFT_ASSIGN  reduce using rule 32 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    R_PAREN         reduce using rule 32 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    COMMA           reduce using rule 32 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    R_SQBRACE       reduce using rule 32 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    R_FLOWBRACE     reduce using rule 32 (arrayindex -> L_SQBRACE index R_SQBRACE .)


state 193

    (136) cast -> L_PAREN TYPE MULTIPLY R_PAREN .

    L_PAREN         reduce using rule 136 (cast -> L_PAREN TYPE MULTIPLY R_PAREN .)
    STRING          reduce using rule 136 (cast -> L_PAREN TYPE MULTIPLY R_PAREN .)
    MULTIPLY        reduce using rule 136 (cast -> L_PAREN TYPE MULTIPLY R_PAREN .)
    BIT_AND         reduce using rule 136 (cast -> L_PAREN TYPE MULTIPLY R_PAREN .)
    ID              reduce using rule 136 (cast -> L_PAREN TYPE MULTIPLY R_PAREN .)
    CHAR            reduce using rule 136 (cast -> L_PAREN TYPE MULTIPLY R_PAREN .)
    INT_NUM         reduce using rule 136 (cast -> L_PAREN TYPE MULTIPLY R_PAREN .)
    FLOAT_NUM       reduce using rule 136 (cast -> L_PAREN TYPE MULTIPLY R_PAREN .)


state 194

    (14) closed -> IF condition closed . else closed
    (8) open -> IF condition closed . else open
    (5) statement -> closed .
    (6) else -> . ELSE

    IF              reduce using rule 5 (statement -> closed .)
    WHILE           reduce using rule 5 (statement -> closed .)
    FOR             reduce using rule 5 (statement -> closed .)
    SEMICOLON       reduce using rule 5 (statement -> closed .)
    RETURN          reduce using rule 5 (statement -> closed .)
    HASH            reduce using rule 5 (statement -> closed .)
    TYPE            reduce using rule 5 (statement -> closed .)
    L_FLOWBRACE     reduce using rule 5 (statement -> closed .)
    NOT             reduce using rule 5 (statement -> closed .)
    PLUS            reduce using rule 5 (statement -> closed .)
    MINUS           reduce using rule 5 (statement -> closed .)
    PLUS_PLUS       reduce using rule 5 (statement -> closed .)
    MINUS_MINUS     reduce using rule 5 (statement -> closed .)
    L_PAREN         reduce using rule 5 (statement -> closed .)
    STRING          reduce using rule 5 (statement -> closed .)
    MULTIPLY        reduce using rule 5 (statement -> closed .)
    BIT_AND         reduce using rule 5 (statement -> closed .)
    ID              reduce using rule 5 (statement -> closed .)
    CHAR            reduce using rule 5 (statement -> closed .)
    INT_NUM         reduce using rule 5 (statement -> closed .)
    FLOAT_NUM       reduce using rule 5 (statement -> closed .)
    $end            reduce using rule 5 (statement -> closed .)
    R_FLOWBRACE     reduce using rule 5 (statement -> closed .)
    ELSE            shift and go to state 168

    else                           shift and go to state 215

state 195

    (14) closed -> IF condition closed else closed .

    IF              reduce using rule 14 (closed -> IF condition closed else closed .)
    WHILE           reduce using rule 14 (closed -> IF condition closed else closed .)
    FOR             reduce using rule 14 (closed -> IF condition closed else closed .)
    SEMICOLON       reduce using rule 14 (closed -> IF condition closed else closed .)
    RETURN          reduce using rule 14 (closed -> IF condition closed else closed .)
    HASH            reduce using rule 14 (closed -> IF condition closed else closed .)
    TYPE            reduce using rule 14 (closed -> IF condition closed else closed .)
    L_FLOWBRACE     reduce using rule 14 (closed -> IF condition closed else closed .)
    NOT             reduce using rule 14 (closed -> IF condition closed else closed .)
    PLUS            reduce using rule 14 (closed -> IF condition closed else closed .)
    MINUS           reduce using rule 14 (closed -> IF condition closed else closed .)
    PLUS_PLUS       reduce using rule 14 (closed -> IF condition closed else closed .)
    MINUS_MINUS     reduce using rule 14 (closed -> IF condition closed else closed .)
    L_PAREN         reduce using rule 14 (closed -> IF condition closed else closed .)
    STRING          reduce using rule 14 (closed -> IF condition closed else closed .)
    MULTIPLY        reduce using rule 14 (closed -> IF condition closed else closed .)
    BIT_AND         reduce using rule 14 (closed -> IF condition closed else closed .)
    ID              reduce using rule 14 (closed -> IF condition closed else closed .)
    CHAR            reduce using rule 14 (closed -> IF condition closed else closed .)
    INT_NUM         reduce using rule 14 (closed -> IF condition closed else closed .)
    FLOAT_NUM       reduce using rule 14 (closed -> IF condition closed else closed .)
    $end            reduce using rule 14 (closed -> IF condition closed else closed .)
    R_FLOWBRACE     reduce using rule 14 (closed -> IF condition closed else closed .)
    ELSE            reduce using rule 14 (closed -> IF condition closed else closed .)


state 196

    (8) open -> IF condition closed else open .

    IF              reduce using rule 8 (open -> IF condition closed else open .)
    WHILE           reduce using rule 8 (open -> IF condition closed else open .)
    FOR             reduce using rule 8 (open -> IF condition closed else open .)
    SEMICOLON       reduce using rule 8 (open -> IF condition closed else open .)
    RETURN          reduce using rule 8 (open -> IF condition closed else open .)
    HASH            reduce using rule 8 (open -> IF condition closed else open .)
    TYPE            reduce using rule 8 (open -> IF condition closed else open .)
    L_FLOWBRACE     reduce using rule 8 (open -> IF condition closed else open .)
    NOT             reduce using rule 8 (open -> IF condition closed else open .)
    PLUS            reduce using rule 8 (open -> IF condition closed else open .)
    MINUS           reduce using rule 8 (open -> IF condition closed else open .)
    PLUS_PLUS       reduce using rule 8 (open -> IF condition closed else open .)
    MINUS_MINUS     reduce using rule 8 (open -> IF condition closed else open .)
    L_PAREN         reduce using rule 8 (open -> IF condition closed else open .)
    STRING          reduce using rule 8 (open -> IF condition closed else open .)
    MULTIPLY        reduce using rule 8 (open -> IF condition closed else open .)
    BIT_AND         reduce using rule 8 (open -> IF condition closed else open .)
    ID              reduce using rule 8 (open -> IF condition closed else open .)
    CHAR            reduce using rule 8 (open -> IF condition closed else open .)
    INT_NUM         reduce using rule 8 (open -> IF condition closed else open .)
    FLOAT_NUM       reduce using rule 8 (open -> IF condition closed else open .)
    $end            reduce using rule 8 (open -> IF condition closed else open .)
    R_FLOWBRACE     reduce using rule 8 (open -> IF condition closed else open .)


state 197

    (18) for_condition -> L_PAREN simple simple expr . R_PAREN
    (86) expr -> expr . assignment exprOR
    (88) assignment -> . ASSIGN
    (89) assignment -> . PLUS_ASSIGN
    (90) assignment -> . MINUS_ASSIGN
    (91) assignment -> . MUL_ASSIGN
    (92) assignment -> . DIV_ASSIGN
    (93) assignment -> . AND_ASSIGN
    (94) assignment -> . OR_ASSIGN
    (95) assignment -> . XOR_ASSIGN
    (96) assignment -> . MOD_ASSIGN
    (97) assignment -> . L_SHIFT_ASSIGN
    (98) assignment -> . R_SHIFT_ASSIGN

    R_PAREN         shift and go to state 216
    ASSIGN          shift and go to state 58
    PLUS_ASSIGN     shift and go to state 59
    MINUS_ASSIGN    shift and go to state 60
    MUL_ASSIGN      shift and go to state 61
    DIV_ASSIGN      shift and go to state 62
    AND_ASSIGN      shift and go to state 63
    OR_ASSIGN       shift and go to state 64
    XOR_ASSIGN      shift and go to state 65
    MOD_ASSIGN      shift and go to state 66
    L_SHIFT_ASSIGN  shift and go to state 67
    R_SHIFT_ASSIGN  shift and go to state 68

    assignment                     shift and go to state 57

state 198

    (19) for_condition -> L_PAREN simple simple R_PAREN .

    IF              reduce using rule 19 (for_condition -> L_PAREN simple simple R_PAREN .)
    WHILE           reduce using rule 19 (for_condition -> L_PAREN simple simple R_PAREN .)
    FOR             reduce using rule 19 (for_condition -> L_PAREN simple simple R_PAREN .)
    SEMICOLON       reduce using rule 19 (for_condition -> L_PAREN simple simple R_PAREN .)
    RETURN          reduce using rule 19 (for_condition -> L_PAREN simple simple R_PAREN .)
    HASH            reduce using rule 19 (for_condition -> L_PAREN simple simple R_PAREN .)
    TYPE            reduce using rule 19 (for_condition -> L_PAREN simple simple R_PAREN .)
    L_FLOWBRACE     reduce using rule 19 (for_condition -> L_PAREN simple simple R_PAREN .)
    NOT             reduce using rule 19 (for_condition -> L_PAREN simple simple R_PAREN .)
    PLUS            reduce using rule 19 (for_condition -> L_PAREN simple simple R_PAREN .)
    MINUS           reduce using rule 19 (for_condition -> L_PAREN simple simple R_PAREN .)
    PLUS_PLUS       reduce using rule 19 (for_condition -> L_PAREN simple simple R_PAREN .)
    MINUS_MINUS     reduce using rule 19 (for_condition -> L_PAREN simple simple R_PAREN .)
    L_PAREN         reduce using rule 19 (for_condition -> L_PAREN simple simple R_PAREN .)
    STRING          reduce using rule 19 (for_condition -> L_PAREN simple simple R_PAREN .)
    MULTIPLY        reduce using rule 19 (for_condition -> L_PAREN simple simple R_PAREN .)
    BIT_AND         reduce using rule 19 (for_condition -> L_PAREN simple simple R_PAREN .)
    ID              reduce using rule 19 (for_condition -> L_PAREN simple simple R_PAREN .)
    CHAR            reduce using rule 19 (for_condition -> L_PAREN simple simple R_PAREN .)
    INT_NUM         reduce using rule 19 (for_condition -> L_PAREN simple simple R_PAREN .)
    FLOAT_NUM       reduce using rule 19 (for_condition -> L_PAREN simple simple R_PAREN .)


state 199

    (37) declaration -> TYPE ID ASSIGN expr SEMICOLON .

    IF              reduce using rule 37 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    WHILE           reduce using rule 37 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    FOR             reduce using rule 37 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    SEMICOLON       reduce using rule 37 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    RETURN          reduce using rule 37 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    HASH            reduce using rule 37 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    TYPE            reduce using rule 37 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    L_FLOWBRACE     reduce using rule 37 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    NOT             reduce using rule 37 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    PLUS            reduce using rule 37 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    MINUS           reduce using rule 37 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    PLUS_PLUS       reduce using rule 37 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    MINUS_MINUS     reduce using rule 37 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    L_PAREN         reduce using rule 37 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    STRING          reduce using rule 37 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    MULTIPLY        reduce using rule 37 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    BIT_AND         reduce using rule 37 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    ID              reduce using rule 37 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    CHAR            reduce using rule 37 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    INT_NUM         reduce using rule 37 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    FLOAT_NUM       reduce using rule 37 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    $end            reduce using rule 37 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    R_FLOWBRACE     reduce using rule 37 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    ELSE            reduce using rule 37 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    R_PAREN         reduce using rule 37 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)


state 200

    (25) multi_declaration -> ID ASSIGN expr COMMA .

    ID              reduce using rule 25 (multi_declaration -> ID ASSIGN expr COMMA .)
    MULTIPLY        reduce using rule 25 (multi_declaration -> ID ASSIGN expr COMMA .)


state 201

    (41) declaration -> TYPE ID narrayindex ASSIGN init_list . SEMICOLON

    SEMICOLON       shift and go to state 217


state 202

    (44) init_list -> L_FLOWBRACE . init_list R_FLOWBRACE COMMA init_list
    (45) init_list -> L_FLOWBRACE . init R_FLOWBRACE COMMA init_list
    (46) init_list -> L_FLOWBRACE . init R_FLOWBRACE
    (47) init_list -> L_FLOWBRACE . init_list R_FLOWBRACE
    (44) init_list -> . L_FLOWBRACE init_list R_FLOWBRACE COMMA init_list
    (45) init_list -> . L_FLOWBRACE init R_FLOWBRACE COMMA init_list
    (46) init_list -> . L_FLOWBRACE init R_FLOWBRACE
    (47) init_list -> . L_FLOWBRACE init_list R_FLOWBRACE
    (42) init -> . expr COMMA init
    (43) init -> . expr
    (86) expr -> . expr assignment exprOR
    (87) expr -> . exprOR
    (99) exprOR -> . exprOR OR exprAND
    (100) exprOR -> . exprAND
    (101) exprAND -> . exprAND AND exprBITOR
    (102) exprAND -> . exprBITOR
    (103) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (104) exprBITOR -> . exprBITXOR
    (105) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (106) exprBITXOR -> . exprBITAND
    (107) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (108) exprBITAND -> . exprEQ
    (109) exprEQ -> . exprEQ EQ exprRELOP
    (110) exprEQ -> . exprEQ NE exprRELOP
    (111) exprEQ -> . exprRELOP
    (112) exprRELOP -> . exprRELOP relop exprSHIFT
    (113) exprRELOP -> . exprSHIFT
    (118) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (119) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (120) exprSHIFT -> . exprOP
    (121) exprOP -> . exprOP PLUS term
    (122) exprOP -> . exprOP MINUS term
    (123) exprOP -> . term
    (124) term -> . term MULTIPLY factor
    (125) term -> . term DIVIDE factor
    (126) term -> . term MOD factor
    (127) term -> . factor
    (128) factor -> . NOT factor
    (129) factor -> . PLUS factor
    (130) factor -> . MINUS factor
    (131) factor -> . PLUS_PLUS factor
    (132) factor -> . MINUS_MINUS factor
    (133) factor -> . cast brace
    (134) factor -> . brace
    (135) cast -> . L_PAREN TYPE R_PAREN
    (136) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (137) brace -> . L_PAREN expr R_PAREN
    (138) brace -> . brace PLUS_PLUS
    (139) brace -> . brace MINUS_MINUS
    (140) brace -> . NUM
    (141) brace -> . STRING
    (142) brace -> . MULTIPLY ID
    (143) brace -> . BIT_AND ID
    (144) brace -> . ID
    (145) brace -> . CHAR
    (146) brace -> . function_call
    (147) brace -> . ID narrayindex
    (148) NUM -> . INT_NUM
    (149) NUM -> . FLOAT_NUM
    (64) function_call -> . ID L_PAREN call_params R_PAREN

    L_FLOWBRACE     shift and go to state 202
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    init_list                      shift and go to state 218
    init                           shift and go to state 219
    expr                           shift and go to state 220
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 203

    (74) yes_dec_params -> TYPE expr . COMMA
    (77) end_dec_params -> TYPE expr .
    (86) expr -> expr . assignment exprOR
    (88) assignment -> . ASSIGN
    (89) assignment -> . PLUS_ASSIGN
    (90) assignment -> . MINUS_ASSIGN
    (91) assignment -> . MUL_ASSIGN
    (92) assignment -> . DIV_ASSIGN
    (93) assignment -> . AND_ASSIGN
    (94) assignment -> . OR_ASSIGN
    (95) assignment -> . XOR_ASSIGN
    (96) assignment -> . MOD_ASSIGN
    (97) assignment -> . L_SHIFT_ASSIGN
    (98) assignment -> . R_SHIFT_ASSIGN

    COMMA           shift and go to state 221
    R_PAREN         reduce using rule 77 (end_dec_params -> TYPE expr .)
    ASSIGN          shift and go to state 58
    PLUS_ASSIGN     shift and go to state 59
    MINUS_ASSIGN    shift and go to state 60
    MUL_ASSIGN      shift and go to state 61
    DIV_ASSIGN      shift and go to state 62
    AND_ASSIGN      shift and go to state 63
    OR_ASSIGN       shift and go to state 64
    XOR_ASSIGN      shift and go to state 65
    MOD_ASSIGN      shift and go to state 66
    L_SHIFT_ASSIGN  shift and go to state 67
    R_SHIFT_ASSIGN  shift and go to state 68

    assignment                     shift and go to state 57

state 204

    (75) yes_dec_params -> TYPE COMMA .

    TYPE            reduce using rule 75 (yes_dec_params -> TYPE COMMA .)


state 205

    (76) yes_dec_params -> TYPE MULTIPLY . COMMA
    (79) end_dec_params -> TYPE MULTIPLY .
    (142) brace -> MULTIPLY . ID

    COMMA           shift and go to state 222
    R_PAREN         reduce using rule 79 (end_dec_params -> TYPE MULTIPLY .)
    ID              shift and go to state 83


state 206

    (83) function -> TYPE ID L_PAREN dec_params R_PAREN . function_2
    (84) function_2 -> . SEMICOLON
    (85) function_2 -> . block
    (50) block -> . left_flower multiple_statements right_flower
    (51) block -> . left_flower right_flower
    (52) left_flower -> . L_FLOWBRACE

    SEMICOLON       shift and go to state 224
    L_FLOWBRACE     shift and go to state 26

    function_2                     shift and go to state 223
    block                          shift and go to state 225
    left_flower                    shift and go to state 18

state 207

    (81) dec_params -> yes_dec_params end_dec_params .

    R_PAREN         reduce using rule 81 (dec_params -> yes_dec_params end_dec_params .)


state 208

    (71) yes_dec_params -> yes_dec_params TYPE . expr COMMA
    (72) yes_dec_params -> yes_dec_params TYPE . COMMA
    (73) yes_dec_params -> yes_dec_params TYPE . MULTIPLY COMMA
    (77) end_dec_params -> TYPE . expr
    (78) end_dec_params -> TYPE .
    (79) end_dec_params -> TYPE . MULTIPLY
    (86) expr -> . expr assignment exprOR
    (87) expr -> . exprOR
    (99) exprOR -> . exprOR OR exprAND
    (100) exprOR -> . exprAND
    (101) exprAND -> . exprAND AND exprBITOR
    (102) exprAND -> . exprBITOR
    (103) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (104) exprBITOR -> . exprBITXOR
    (105) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (106) exprBITXOR -> . exprBITAND
    (107) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (108) exprBITAND -> . exprEQ
    (109) exprEQ -> . exprEQ EQ exprRELOP
    (110) exprEQ -> . exprEQ NE exprRELOP
    (111) exprEQ -> . exprRELOP
    (112) exprRELOP -> . exprRELOP relop exprSHIFT
    (113) exprRELOP -> . exprSHIFT
    (118) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (119) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (120) exprSHIFT -> . exprOP
    (121) exprOP -> . exprOP PLUS term
    (122) exprOP -> . exprOP MINUS term
    (123) exprOP -> . term
    (124) term -> . term MULTIPLY factor
    (125) term -> . term DIVIDE factor
    (126) term -> . term MOD factor
    (127) term -> . factor
    (128) factor -> . NOT factor
    (129) factor -> . PLUS factor
    (130) factor -> . MINUS factor
    (131) factor -> . PLUS_PLUS factor
    (132) factor -> . MINUS_MINUS factor
    (133) factor -> . cast brace
    (134) factor -> . brace
    (135) cast -> . L_PAREN TYPE R_PAREN
    (136) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (137) brace -> . L_PAREN expr R_PAREN
    (138) brace -> . brace PLUS_PLUS
    (139) brace -> . brace MINUS_MINUS
    (140) brace -> . NUM
    (141) brace -> . STRING
    (142) brace -> . MULTIPLY ID
    (143) brace -> . BIT_AND ID
    (144) brace -> . ID
    (145) brace -> . CHAR
    (146) brace -> . function_call
    (147) brace -> . ID narrayindex
    (148) NUM -> . INT_NUM
    (149) NUM -> . FLOAT_NUM
    (64) function_call -> . ID L_PAREN call_params R_PAREN

    COMMA           shift and go to state 227
    MULTIPLY        shift and go to state 228
    R_PAREN         reduce using rule 78 (end_dec_params -> TYPE .)
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    expr                           shift and go to state 226
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 209

    (38) declaration -> TYPE MULTIPLY ID ASSIGN expr . SEMICOLON
    (27) multi_declaration -> MULTIPLY ID ASSIGN expr . COMMA
    (86) expr -> expr . assignment exprOR
    (88) assignment -> . ASSIGN
    (89) assignment -> . PLUS_ASSIGN
    (90) assignment -> . MINUS_ASSIGN
    (91) assignment -> . MUL_ASSIGN
    (92) assignment -> . DIV_ASSIGN
    (93) assignment -> . AND_ASSIGN
    (94) assignment -> . OR_ASSIGN
    (95) assignment -> . XOR_ASSIGN
    (96) assignment -> . MOD_ASSIGN
    (97) assignment -> . L_SHIFT_ASSIGN
    (98) assignment -> . R_SHIFT_ASSIGN

    SEMICOLON       shift and go to state 229
    COMMA           shift and go to state 230
    ASSIGN          shift and go to state 58
    PLUS_ASSIGN     shift and go to state 59
    MINUS_ASSIGN    shift and go to state 60
    MUL_ASSIGN      shift and go to state 61
    DIV_ASSIGN      shift and go to state 62
    AND_ASSIGN      shift and go to state 63
    OR_ASSIGN       shift and go to state 64
    XOR_ASSIGN      shift and go to state 65
    MOD_ASSIGN      shift and go to state 66
    L_SHIFT_ASSIGN  shift and go to state 67
    R_SHIFT_ASSIGN  shift and go to state 68

    assignment                     shift and go to state 57

state 210

    (22) multi_declaration -> multi_declaration ID ASSIGN expr . COMMA
    (30) stop -> ID ASSIGN expr . SEMICOLON
    (86) expr -> expr . assignment exprOR
    (88) assignment -> . ASSIGN
    (89) assignment -> . PLUS_ASSIGN
    (90) assignment -> . MINUS_ASSIGN
    (91) assignment -> . MUL_ASSIGN
    (92) assignment -> . DIV_ASSIGN
    (93) assignment -> . AND_ASSIGN
    (94) assignment -> . OR_ASSIGN
    (95) assignment -> . XOR_ASSIGN
    (96) assignment -> . MOD_ASSIGN
    (97) assignment -> . L_SHIFT_ASSIGN
    (98) assignment -> . R_SHIFT_ASSIGN

    COMMA           shift and go to state 231
    SEMICOLON       shift and go to state 232
    ASSIGN          shift and go to state 58
    PLUS_ASSIGN     shift and go to state 59
    MINUS_ASSIGN    shift and go to state 60
    MUL_ASSIGN      shift and go to state 61
    DIV_ASSIGN      shift and go to state 62
    AND_ASSIGN      shift and go to state 63
    OR_ASSIGN       shift and go to state 64
    XOR_ASSIGN      shift and go to state 65
    MOD_ASSIGN      shift and go to state 66
    L_SHIFT_ASSIGN  shift and go to state 67
    R_SHIFT_ASSIGN  shift and go to state 68

    assignment                     shift and go to state 57

state 211

    (21) multi_declaration -> multi_declaration MULTIPLY ID COMMA .

    ID              reduce using rule 21 (multi_declaration -> multi_declaration MULTIPLY ID COMMA .)
    MULTIPLY        reduce using rule 21 (multi_declaration -> multi_declaration MULTIPLY ID COMMA .)


state 212

    (23) multi_declaration -> multi_declaration MULTIPLY ID ASSIGN . expr COMMA
    (31) stop -> MULTIPLY ID ASSIGN . expr SEMICOLON
    (86) expr -> . expr assignment exprOR
    (87) expr -> . exprOR
    (99) exprOR -> . exprOR OR exprAND
    (100) exprOR -> . exprAND
    (101) exprAND -> . exprAND AND exprBITOR
    (102) exprAND -> . exprBITOR
    (103) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (104) exprBITOR -> . exprBITXOR
    (105) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (106) exprBITXOR -> . exprBITAND
    (107) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (108) exprBITAND -> . exprEQ
    (109) exprEQ -> . exprEQ EQ exprRELOP
    (110) exprEQ -> . exprEQ NE exprRELOP
    (111) exprEQ -> . exprRELOP
    (112) exprRELOP -> . exprRELOP relop exprSHIFT
    (113) exprRELOP -> . exprSHIFT
    (118) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (119) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (120) exprSHIFT -> . exprOP
    (121) exprOP -> . exprOP PLUS term
    (122) exprOP -> . exprOP MINUS term
    (123) exprOP -> . term
    (124) term -> . term MULTIPLY factor
    (125) term -> . term DIVIDE factor
    (126) term -> . term MOD factor
    (127) term -> . factor
    (128) factor -> . NOT factor
    (129) factor -> . PLUS factor
    (130) factor -> . MINUS factor
    (131) factor -> . PLUS_PLUS factor
    (132) factor -> . MINUS_MINUS factor
    (133) factor -> . cast brace
    (134) factor -> . brace
    (135) cast -> . L_PAREN TYPE R_PAREN
    (136) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (137) brace -> . L_PAREN expr R_PAREN
    (138) brace -> . brace PLUS_PLUS
    (139) brace -> . brace MINUS_MINUS
    (140) brace -> . NUM
    (141) brace -> . STRING
    (142) brace -> . MULTIPLY ID
    (143) brace -> . BIT_AND ID
    (144) brace -> . ID
    (145) brace -> . CHAR
    (146) brace -> . function_call
    (147) brace -> . ID narrayindex
    (148) NUM -> . INT_NUM
    (149) NUM -> . FLOAT_NUM
    (64) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    expr                           shift and go to state 233
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 213

    (29) stop -> MULTIPLY ID SEMICOLON .

    IF              reduce using rule 29 (stop -> MULTIPLY ID SEMICOLON .)
    WHILE           reduce using rule 29 (stop -> MULTIPLY ID SEMICOLON .)
    FOR             reduce using rule 29 (stop -> MULTIPLY ID SEMICOLON .)
    SEMICOLON       reduce using rule 29 (stop -> MULTIPLY ID SEMICOLON .)
    RETURN          reduce using rule 29 (stop -> MULTIPLY ID SEMICOLON .)
    HASH            reduce using rule 29 (stop -> MULTIPLY ID SEMICOLON .)
    TYPE            reduce using rule 29 (stop -> MULTIPLY ID SEMICOLON .)
    L_FLOWBRACE     reduce using rule 29 (stop -> MULTIPLY ID SEMICOLON .)
    NOT             reduce using rule 29 (stop -> MULTIPLY ID SEMICOLON .)
    PLUS            reduce using rule 29 (stop -> MULTIPLY ID SEMICOLON .)
    MINUS           reduce using rule 29 (stop -> MULTIPLY ID SEMICOLON .)
    PLUS_PLUS       reduce using rule 29 (stop -> MULTIPLY ID SEMICOLON .)
    MINUS_MINUS     reduce using rule 29 (stop -> MULTIPLY ID SEMICOLON .)
    L_PAREN         reduce using rule 29 (stop -> MULTIPLY ID SEMICOLON .)
    STRING          reduce using rule 29 (stop -> MULTIPLY ID SEMICOLON .)
    MULTIPLY        reduce using rule 29 (stop -> MULTIPLY ID SEMICOLON .)
    BIT_AND         reduce using rule 29 (stop -> MULTIPLY ID SEMICOLON .)
    ID              reduce using rule 29 (stop -> MULTIPLY ID SEMICOLON .)
    CHAR            reduce using rule 29 (stop -> MULTIPLY ID SEMICOLON .)
    INT_NUM         reduce using rule 29 (stop -> MULTIPLY ID SEMICOLON .)
    FLOAT_NUM       reduce using rule 29 (stop -> MULTIPLY ID SEMICOLON .)
    $end            reduce using rule 29 (stop -> MULTIPLY ID SEMICOLON .)
    R_FLOWBRACE     reduce using rule 29 (stop -> MULTIPLY ID SEMICOLON .)
    ELSE            reduce using rule 29 (stop -> MULTIPLY ID SEMICOLON .)
    R_PAREN         reduce using rule 29 (stop -> MULTIPLY ID SEMICOLON .)


state 214

    (68) yes_call_params -> yes_call_params expr COMMA .

    NOT             reduce using rule 68 (yes_call_params -> yes_call_params expr COMMA .)
    PLUS            reduce using rule 68 (yes_call_params -> yes_call_params expr COMMA .)
    MINUS           reduce using rule 68 (yes_call_params -> yes_call_params expr COMMA .)
    PLUS_PLUS       reduce using rule 68 (yes_call_params -> yes_call_params expr COMMA .)
    MINUS_MINUS     reduce using rule 68 (yes_call_params -> yes_call_params expr COMMA .)
    L_PAREN         reduce using rule 68 (yes_call_params -> yes_call_params expr COMMA .)
    STRING          reduce using rule 68 (yes_call_params -> yes_call_params expr COMMA .)
    MULTIPLY        reduce using rule 68 (yes_call_params -> yes_call_params expr COMMA .)
    BIT_AND         reduce using rule 68 (yes_call_params -> yes_call_params expr COMMA .)
    ID              reduce using rule 68 (yes_call_params -> yes_call_params expr COMMA .)
    CHAR            reduce using rule 68 (yes_call_params -> yes_call_params expr COMMA .)
    INT_NUM         reduce using rule 68 (yes_call_params -> yes_call_params expr COMMA .)
    FLOAT_NUM       reduce using rule 68 (yes_call_params -> yes_call_params expr COMMA .)


state 215

    (14) closed -> IF condition closed else . closed
    (8) open -> IF condition closed else . open
    (12) closed -> . simple
    (13) closed -> . block
    (14) closed -> . IF condition closed else closed
    (15) closed -> . WHILE condition closed
    (16) closed -> . for for_condition closed
    (7) open -> . IF condition statement
    (8) open -> . IF condition closed else open
    (9) open -> . WHILE condition open
    (10) open -> . for for_condition open
    (54) simple -> . expr SEMICOLON
    (55) simple -> . header
    (56) simple -> . declaration
    (57) simple -> . SEMICOLON
    (58) simple -> . function
    (59) simple -> . RETURN expr SEMICOLON
    (60) simple -> . RETURN SEMICOLON
    (50) block -> . left_flower multiple_statements right_flower
    (51) block -> . left_flower right_flower
    (11) for -> . FOR
    (86) expr -> . expr assignment exprOR
    (87) expr -> . exprOR
    (61) header -> . HASH INCLUDE STRING
    (62) header -> . HASH INCLUDE HEADER_FILE
    (35) declaration -> . TYPE ID SEMICOLON
    (36) declaration -> . TYPE MULTIPLY ID SEMICOLON
    (37) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (38) declaration -> . TYPE MULTIPLY ID ASSIGN expr SEMICOLON
    (39) declaration -> . TYPE multi_declaration stop
    (40) declaration -> . TYPE ID narrayindex SEMICOLON
    (41) declaration -> . TYPE ID narrayindex ASSIGN init_list SEMICOLON
    (83) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (52) left_flower -> . L_FLOWBRACE
    (99) exprOR -> . exprOR OR exprAND
    (100) exprOR -> . exprAND
    (101) exprAND -> . exprAND AND exprBITOR
    (102) exprAND -> . exprBITOR
    (103) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (104) exprBITOR -> . exprBITXOR
    (105) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (106) exprBITXOR -> . exprBITAND
    (107) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (108) exprBITAND -> . exprEQ
    (109) exprEQ -> . exprEQ EQ exprRELOP
    (110) exprEQ -> . exprEQ NE exprRELOP
    (111) exprEQ -> . exprRELOP
    (112) exprRELOP -> . exprRELOP relop exprSHIFT
    (113) exprRELOP -> . exprSHIFT
    (118) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (119) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (120) exprSHIFT -> . exprOP
    (121) exprOP -> . exprOP PLUS term
    (122) exprOP -> . exprOP MINUS term
    (123) exprOP -> . term
    (124) term -> . term MULTIPLY factor
    (125) term -> . term DIVIDE factor
    (126) term -> . term MOD factor
    (127) term -> . factor
    (128) factor -> . NOT factor
    (129) factor -> . PLUS factor
    (130) factor -> . MINUS factor
    (131) factor -> . PLUS_PLUS factor
    (132) factor -> . MINUS_MINUS factor
    (133) factor -> . cast brace
    (134) factor -> . brace
    (135) cast -> . L_PAREN TYPE R_PAREN
    (136) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (137) brace -> . L_PAREN expr R_PAREN
    (138) brace -> . brace PLUS_PLUS
    (139) brace -> . brace MINUS_MINUS
    (140) brace -> . NUM
    (141) brace -> . STRING
    (142) brace -> . MULTIPLY ID
    (143) brace -> . BIT_AND ID
    (144) brace -> . ID
    (145) brace -> . CHAR
    (146) brace -> . function_call
    (147) brace -> . ID narrayindex
    (148) NUM -> . INT_NUM
    (149) NUM -> . FLOAT_NUM
    (64) function_call -> . ID L_PAREN call_params R_PAREN

    IF              shift and go to state 114
    WHILE           shift and go to state 117
    SEMICOLON       shift and go to state 13
    RETURN          shift and go to state 17
    FOR             shift and go to state 11
    HASH            shift and go to state 20
    TYPE            shift and go to state 22
    L_FLOWBRACE     shift and go to state 26
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    closed                         shift and go to state 195
    open                           shift and go to state 196
    simple                         shift and go to state 9
    block                          shift and go to state 10
    for                            shift and go to state 118
    expr                           shift and go to state 12
    header                         shift and go to state 14
    declaration                    shift and go to state 15
    function                       shift and go to state 16
    left_flower                    shift and go to state 18
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 216

    (18) for_condition -> L_PAREN simple simple expr R_PAREN .

    IF              reduce using rule 18 (for_condition -> L_PAREN simple simple expr R_PAREN .)
    WHILE           reduce using rule 18 (for_condition -> L_PAREN simple simple expr R_PAREN .)
    FOR             reduce using rule 18 (for_condition -> L_PAREN simple simple expr R_PAREN .)
    SEMICOLON       reduce using rule 18 (for_condition -> L_PAREN simple simple expr R_PAREN .)
    RETURN          reduce using rule 18 (for_condition -> L_PAREN simple simple expr R_PAREN .)
    HASH            reduce using rule 18 (for_condition -> L_PAREN simple simple expr R_PAREN .)
    TYPE            reduce using rule 18 (for_condition -> L_PAREN simple simple expr R_PAREN .)
    L_FLOWBRACE     reduce using rule 18 (for_condition -> L_PAREN simple simple expr R_PAREN .)
    NOT             reduce using rule 18 (for_condition -> L_PAREN simple simple expr R_PAREN .)
    PLUS            reduce using rule 18 (for_condition -> L_PAREN simple simple expr R_PAREN .)
    MINUS           reduce using rule 18 (for_condition -> L_PAREN simple simple expr R_PAREN .)
    PLUS_PLUS       reduce using rule 18 (for_condition -> L_PAREN simple simple expr R_PAREN .)
    MINUS_MINUS     reduce using rule 18 (for_condition -> L_PAREN simple simple expr R_PAREN .)
    L_PAREN         reduce using rule 18 (for_condition -> L_PAREN simple simple expr R_PAREN .)
    STRING          reduce using rule 18 (for_condition -> L_PAREN simple simple expr R_PAREN .)
    MULTIPLY        reduce using rule 18 (for_condition -> L_PAREN simple simple expr R_PAREN .)
    BIT_AND         reduce using rule 18 (for_condition -> L_PAREN simple simple expr R_PAREN .)
    ID              reduce using rule 18 (for_condition -> L_PAREN simple simple expr R_PAREN .)
    CHAR            reduce using rule 18 (for_condition -> L_PAREN simple simple expr R_PAREN .)
    INT_NUM         reduce using rule 18 (for_condition -> L_PAREN simple simple expr R_PAREN .)
    FLOAT_NUM       reduce using rule 18 (for_condition -> L_PAREN simple simple expr R_PAREN .)


state 217

    (41) declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .

    IF              reduce using rule 41 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    WHILE           reduce using rule 41 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    FOR             reduce using rule 41 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    SEMICOLON       reduce using rule 41 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    RETURN          reduce using rule 41 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    HASH            reduce using rule 41 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    TYPE            reduce using rule 41 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    L_FLOWBRACE     reduce using rule 41 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    NOT             reduce using rule 41 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    PLUS            reduce using rule 41 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    MINUS           reduce using rule 41 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    PLUS_PLUS       reduce using rule 41 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    MINUS_MINUS     reduce using rule 41 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    L_PAREN         reduce using rule 41 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    STRING          reduce using rule 41 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    MULTIPLY        reduce using rule 41 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    BIT_AND         reduce using rule 41 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    ID              reduce using rule 41 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    CHAR            reduce using rule 41 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    INT_NUM         reduce using rule 41 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    FLOAT_NUM       reduce using rule 41 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    $end            reduce using rule 41 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    R_FLOWBRACE     reduce using rule 41 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    ELSE            reduce using rule 41 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    R_PAREN         reduce using rule 41 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)


state 218

    (44) init_list -> L_FLOWBRACE init_list . R_FLOWBRACE COMMA init_list
    (47) init_list -> L_FLOWBRACE init_list . R_FLOWBRACE

    R_FLOWBRACE     shift and go to state 234


state 219

    (45) init_list -> L_FLOWBRACE init . R_FLOWBRACE COMMA init_list
    (46) init_list -> L_FLOWBRACE init . R_FLOWBRACE

    R_FLOWBRACE     shift and go to state 235


state 220

    (42) init -> expr . COMMA init
    (43) init -> expr .
    (86) expr -> expr . assignment exprOR
    (88) assignment -> . ASSIGN
    (89) assignment -> . PLUS_ASSIGN
    (90) assignment -> . MINUS_ASSIGN
    (91) assignment -> . MUL_ASSIGN
    (92) assignment -> . DIV_ASSIGN
    (93) assignment -> . AND_ASSIGN
    (94) assignment -> . OR_ASSIGN
    (95) assignment -> . XOR_ASSIGN
    (96) assignment -> . MOD_ASSIGN
    (97) assignment -> . L_SHIFT_ASSIGN
    (98) assignment -> . R_SHIFT_ASSIGN

    COMMA           shift and go to state 236
    R_FLOWBRACE     reduce using rule 43 (init -> expr .)
    ASSIGN          shift and go to state 58
    PLUS_ASSIGN     shift and go to state 59
    MINUS_ASSIGN    shift and go to state 60
    MUL_ASSIGN      shift and go to state 61
    DIV_ASSIGN      shift and go to state 62
    AND_ASSIGN      shift and go to state 63
    OR_ASSIGN       shift and go to state 64
    XOR_ASSIGN      shift and go to state 65
    MOD_ASSIGN      shift and go to state 66
    L_SHIFT_ASSIGN  shift and go to state 67
    R_SHIFT_ASSIGN  shift and go to state 68

    assignment                     shift and go to state 57

state 221

    (74) yes_dec_params -> TYPE expr COMMA .

    TYPE            reduce using rule 74 (yes_dec_params -> TYPE expr COMMA .)


state 222

    (76) yes_dec_params -> TYPE MULTIPLY COMMA .

    TYPE            reduce using rule 76 (yes_dec_params -> TYPE MULTIPLY COMMA .)


state 223

    (83) function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .

    IF              reduce using rule 83 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    WHILE           reduce using rule 83 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    FOR             reduce using rule 83 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    SEMICOLON       reduce using rule 83 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    RETURN          reduce using rule 83 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    HASH            reduce using rule 83 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    TYPE            reduce using rule 83 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    L_FLOWBRACE     reduce using rule 83 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    NOT             reduce using rule 83 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    PLUS            reduce using rule 83 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    MINUS           reduce using rule 83 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    PLUS_PLUS       reduce using rule 83 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    MINUS_MINUS     reduce using rule 83 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    L_PAREN         reduce using rule 83 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    STRING          reduce using rule 83 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    MULTIPLY        reduce using rule 83 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    BIT_AND         reduce using rule 83 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    ID              reduce using rule 83 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    CHAR            reduce using rule 83 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    INT_NUM         reduce using rule 83 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    FLOAT_NUM       reduce using rule 83 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    $end            reduce using rule 83 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    R_FLOWBRACE     reduce using rule 83 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    ELSE            reduce using rule 83 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    R_PAREN         reduce using rule 83 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)


state 224

    (84) function_2 -> SEMICOLON .

    IF              reduce using rule 84 (function_2 -> SEMICOLON .)
    WHILE           reduce using rule 84 (function_2 -> SEMICOLON .)
    FOR             reduce using rule 84 (function_2 -> SEMICOLON .)
    SEMICOLON       reduce using rule 84 (function_2 -> SEMICOLON .)
    RETURN          reduce using rule 84 (function_2 -> SEMICOLON .)
    HASH            reduce using rule 84 (function_2 -> SEMICOLON .)
    TYPE            reduce using rule 84 (function_2 -> SEMICOLON .)
    L_FLOWBRACE     reduce using rule 84 (function_2 -> SEMICOLON .)
    NOT             reduce using rule 84 (function_2 -> SEMICOLON .)
    PLUS            reduce using rule 84 (function_2 -> SEMICOLON .)
    MINUS           reduce using rule 84 (function_2 -> SEMICOLON .)
    PLUS_PLUS       reduce using rule 84 (function_2 -> SEMICOLON .)
    MINUS_MINUS     reduce using rule 84 (function_2 -> SEMICOLON .)
    L_PAREN         reduce using rule 84 (function_2 -> SEMICOLON .)
    STRING          reduce using rule 84 (function_2 -> SEMICOLON .)
    MULTIPLY        reduce using rule 84 (function_2 -> SEMICOLON .)
    BIT_AND         reduce using rule 84 (function_2 -> SEMICOLON .)
    ID              reduce using rule 84 (function_2 -> SEMICOLON .)
    CHAR            reduce using rule 84 (function_2 -> SEMICOLON .)
    INT_NUM         reduce using rule 84 (function_2 -> SEMICOLON .)
    FLOAT_NUM       reduce using rule 84 (function_2 -> SEMICOLON .)
    $end            reduce using rule 84 (function_2 -> SEMICOLON .)
    R_FLOWBRACE     reduce using rule 84 (function_2 -> SEMICOLON .)
    ELSE            reduce using rule 84 (function_2 -> SEMICOLON .)
    R_PAREN         reduce using rule 84 (function_2 -> SEMICOLON .)


state 225

    (85) function_2 -> block .

    IF              reduce using rule 85 (function_2 -> block .)
    WHILE           reduce using rule 85 (function_2 -> block .)
    FOR             reduce using rule 85 (function_2 -> block .)
    SEMICOLON       reduce using rule 85 (function_2 -> block .)
    RETURN          reduce using rule 85 (function_2 -> block .)
    HASH            reduce using rule 85 (function_2 -> block .)
    TYPE            reduce using rule 85 (function_2 -> block .)
    L_FLOWBRACE     reduce using rule 85 (function_2 -> block .)
    NOT             reduce using rule 85 (function_2 -> block .)
    PLUS            reduce using rule 85 (function_2 -> block .)
    MINUS           reduce using rule 85 (function_2 -> block .)
    PLUS_PLUS       reduce using rule 85 (function_2 -> block .)
    MINUS_MINUS     reduce using rule 85 (function_2 -> block .)
    L_PAREN         reduce using rule 85 (function_2 -> block .)
    STRING          reduce using rule 85 (function_2 -> block .)
    MULTIPLY        reduce using rule 85 (function_2 -> block .)
    BIT_AND         reduce using rule 85 (function_2 -> block .)
    ID              reduce using rule 85 (function_2 -> block .)
    CHAR            reduce using rule 85 (function_2 -> block .)
    INT_NUM         reduce using rule 85 (function_2 -> block .)
    FLOAT_NUM       reduce using rule 85 (function_2 -> block .)
    $end            reduce using rule 85 (function_2 -> block .)
    R_FLOWBRACE     reduce using rule 85 (function_2 -> block .)
    ELSE            reduce using rule 85 (function_2 -> block .)
    R_PAREN         reduce using rule 85 (function_2 -> block .)


state 226

    (71) yes_dec_params -> yes_dec_params TYPE expr . COMMA
    (77) end_dec_params -> TYPE expr .
    (86) expr -> expr . assignment exprOR
    (88) assignment -> . ASSIGN
    (89) assignment -> . PLUS_ASSIGN
    (90) assignment -> . MINUS_ASSIGN
    (91) assignment -> . MUL_ASSIGN
    (92) assignment -> . DIV_ASSIGN
    (93) assignment -> . AND_ASSIGN
    (94) assignment -> . OR_ASSIGN
    (95) assignment -> . XOR_ASSIGN
    (96) assignment -> . MOD_ASSIGN
    (97) assignment -> . L_SHIFT_ASSIGN
    (98) assignment -> . R_SHIFT_ASSIGN

    COMMA           shift and go to state 237
    R_PAREN         reduce using rule 77 (end_dec_params -> TYPE expr .)
    ASSIGN          shift and go to state 58
    PLUS_ASSIGN     shift and go to state 59
    MINUS_ASSIGN    shift and go to state 60
    MUL_ASSIGN      shift and go to state 61
    DIV_ASSIGN      shift and go to state 62
    AND_ASSIGN      shift and go to state 63
    OR_ASSIGN       shift and go to state 64
    XOR_ASSIGN      shift and go to state 65
    MOD_ASSIGN      shift and go to state 66
    L_SHIFT_ASSIGN  shift and go to state 67
    R_SHIFT_ASSIGN  shift and go to state 68

    assignment                     shift and go to state 57

state 227

    (72) yes_dec_params -> yes_dec_params TYPE COMMA .

    TYPE            reduce using rule 72 (yes_dec_params -> yes_dec_params TYPE COMMA .)


state 228

    (73) yes_dec_params -> yes_dec_params TYPE MULTIPLY . COMMA
    (79) end_dec_params -> TYPE MULTIPLY .
    (142) brace -> MULTIPLY . ID

    COMMA           shift and go to state 238
    R_PAREN         reduce using rule 79 (end_dec_params -> TYPE MULTIPLY .)
    ID              shift and go to state 83


state 229

    (38) declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .

    IF              reduce using rule 38 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    WHILE           reduce using rule 38 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    FOR             reduce using rule 38 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    SEMICOLON       reduce using rule 38 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    RETURN          reduce using rule 38 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    HASH            reduce using rule 38 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    TYPE            reduce using rule 38 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    L_FLOWBRACE     reduce using rule 38 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    NOT             reduce using rule 38 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    PLUS            reduce using rule 38 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    MINUS           reduce using rule 38 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    PLUS_PLUS       reduce using rule 38 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    MINUS_MINUS     reduce using rule 38 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    L_PAREN         reduce using rule 38 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    STRING          reduce using rule 38 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    MULTIPLY        reduce using rule 38 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    BIT_AND         reduce using rule 38 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    ID              reduce using rule 38 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    CHAR            reduce using rule 38 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    INT_NUM         reduce using rule 38 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    FLOAT_NUM       reduce using rule 38 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    $end            reduce using rule 38 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    R_FLOWBRACE     reduce using rule 38 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    ELSE            reduce using rule 38 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    R_PAREN         reduce using rule 38 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)


state 230

    (27) multi_declaration -> MULTIPLY ID ASSIGN expr COMMA .

    ID              reduce using rule 27 (multi_declaration -> MULTIPLY ID ASSIGN expr COMMA .)
    MULTIPLY        reduce using rule 27 (multi_declaration -> MULTIPLY ID ASSIGN expr COMMA .)


state 231

    (22) multi_declaration -> multi_declaration ID ASSIGN expr COMMA .

    ID              reduce using rule 22 (multi_declaration -> multi_declaration ID ASSIGN expr COMMA .)
    MULTIPLY        reduce using rule 22 (multi_declaration -> multi_declaration ID ASSIGN expr COMMA .)


state 232

    (30) stop -> ID ASSIGN expr SEMICOLON .

    IF              reduce using rule 30 (stop -> ID ASSIGN expr SEMICOLON .)
    WHILE           reduce using rule 30 (stop -> ID ASSIGN expr SEMICOLON .)
    FOR             reduce using rule 30 (stop -> ID ASSIGN expr SEMICOLON .)
    SEMICOLON       reduce using rule 30 (stop -> ID ASSIGN expr SEMICOLON .)
    RETURN          reduce using rule 30 (stop -> ID ASSIGN expr SEMICOLON .)
    HASH            reduce using rule 30 (stop -> ID ASSIGN expr SEMICOLON .)
    TYPE            reduce using rule 30 (stop -> ID ASSIGN expr SEMICOLON .)
    L_FLOWBRACE     reduce using rule 30 (stop -> ID ASSIGN expr SEMICOLON .)
    NOT             reduce using rule 30 (stop -> ID ASSIGN expr SEMICOLON .)
    PLUS            reduce using rule 30 (stop -> ID ASSIGN expr SEMICOLON .)
    MINUS           reduce using rule 30 (stop -> ID ASSIGN expr SEMICOLON .)
    PLUS_PLUS       reduce using rule 30 (stop -> ID ASSIGN expr SEMICOLON .)
    MINUS_MINUS     reduce using rule 30 (stop -> ID ASSIGN expr SEMICOLON .)
    L_PAREN         reduce using rule 30 (stop -> ID ASSIGN expr SEMICOLON .)
    STRING          reduce using rule 30 (stop -> ID ASSIGN expr SEMICOLON .)
    MULTIPLY        reduce using rule 30 (stop -> ID ASSIGN expr SEMICOLON .)
    BIT_AND         reduce using rule 30 (stop -> ID ASSIGN expr SEMICOLON .)
    ID              reduce using rule 30 (stop -> ID ASSIGN expr SEMICOLON .)
    CHAR            reduce using rule 30 (stop -> ID ASSIGN expr SEMICOLON .)
    INT_NUM         reduce using rule 30 (stop -> ID ASSIGN expr SEMICOLON .)
    FLOAT_NUM       reduce using rule 30 (stop -> ID ASSIGN expr SEMICOLON .)
    $end            reduce using rule 30 (stop -> ID ASSIGN expr SEMICOLON .)
    R_FLOWBRACE     reduce using rule 30 (stop -> ID ASSIGN expr SEMICOLON .)
    ELSE            reduce using rule 30 (stop -> ID ASSIGN expr SEMICOLON .)
    R_PAREN         reduce using rule 30 (stop -> ID ASSIGN expr SEMICOLON .)


state 233

    (23) multi_declaration -> multi_declaration MULTIPLY ID ASSIGN expr . COMMA
    (31) stop -> MULTIPLY ID ASSIGN expr . SEMICOLON
    (86) expr -> expr . assignment exprOR
    (88) assignment -> . ASSIGN
    (89) assignment -> . PLUS_ASSIGN
    (90) assignment -> . MINUS_ASSIGN
    (91) assignment -> . MUL_ASSIGN
    (92) assignment -> . DIV_ASSIGN
    (93) assignment -> . AND_ASSIGN
    (94) assignment -> . OR_ASSIGN
    (95) assignment -> . XOR_ASSIGN
    (96) assignment -> . MOD_ASSIGN
    (97) assignment -> . L_SHIFT_ASSIGN
    (98) assignment -> . R_SHIFT_ASSIGN

    COMMA           shift and go to state 239
    SEMICOLON       shift and go to state 240
    ASSIGN          shift and go to state 58
    PLUS_ASSIGN     shift and go to state 59
    MINUS_ASSIGN    shift and go to state 60
    MUL_ASSIGN      shift and go to state 61
    DIV_ASSIGN      shift and go to state 62
    AND_ASSIGN      shift and go to state 63
    OR_ASSIGN       shift and go to state 64
    XOR_ASSIGN      shift and go to state 65
    MOD_ASSIGN      shift and go to state 66
    L_SHIFT_ASSIGN  shift and go to state 67
    R_SHIFT_ASSIGN  shift and go to state 68

    assignment                     shift and go to state 57

state 234

    (44) init_list -> L_FLOWBRACE init_list R_FLOWBRACE . COMMA init_list
    (47) init_list -> L_FLOWBRACE init_list R_FLOWBRACE .

    COMMA           shift and go to state 241
    SEMICOLON       reduce using rule 47 (init_list -> L_FLOWBRACE init_list R_FLOWBRACE .)
    R_FLOWBRACE     reduce using rule 47 (init_list -> L_FLOWBRACE init_list R_FLOWBRACE .)


state 235

    (45) init_list -> L_FLOWBRACE init R_FLOWBRACE . COMMA init_list
    (46) init_list -> L_FLOWBRACE init R_FLOWBRACE .

    COMMA           shift and go to state 242
    SEMICOLON       reduce using rule 46 (init_list -> L_FLOWBRACE init R_FLOWBRACE .)
    R_FLOWBRACE     reduce using rule 46 (init_list -> L_FLOWBRACE init R_FLOWBRACE .)


state 236

    (42) init -> expr COMMA . init
    (42) init -> . expr COMMA init
    (43) init -> . expr
    (86) expr -> . expr assignment exprOR
    (87) expr -> . exprOR
    (99) exprOR -> . exprOR OR exprAND
    (100) exprOR -> . exprAND
    (101) exprAND -> . exprAND AND exprBITOR
    (102) exprAND -> . exprBITOR
    (103) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (104) exprBITOR -> . exprBITXOR
    (105) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (106) exprBITXOR -> . exprBITAND
    (107) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (108) exprBITAND -> . exprEQ
    (109) exprEQ -> . exprEQ EQ exprRELOP
    (110) exprEQ -> . exprEQ NE exprRELOP
    (111) exprEQ -> . exprRELOP
    (112) exprRELOP -> . exprRELOP relop exprSHIFT
    (113) exprRELOP -> . exprSHIFT
    (118) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (119) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (120) exprSHIFT -> . exprOP
    (121) exprOP -> . exprOP PLUS term
    (122) exprOP -> . exprOP MINUS term
    (123) exprOP -> . term
    (124) term -> . term MULTIPLY factor
    (125) term -> . term DIVIDE factor
    (126) term -> . term MOD factor
    (127) term -> . factor
    (128) factor -> . NOT factor
    (129) factor -> . PLUS factor
    (130) factor -> . MINUS factor
    (131) factor -> . PLUS_PLUS factor
    (132) factor -> . MINUS_MINUS factor
    (133) factor -> . cast brace
    (134) factor -> . brace
    (135) cast -> . L_PAREN TYPE R_PAREN
    (136) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (137) brace -> . L_PAREN expr R_PAREN
    (138) brace -> . brace PLUS_PLUS
    (139) brace -> . brace MINUS_MINUS
    (140) brace -> . NUM
    (141) brace -> . STRING
    (142) brace -> . MULTIPLY ID
    (143) brace -> . BIT_AND ID
    (144) brace -> . ID
    (145) brace -> . CHAR
    (146) brace -> . function_call
    (147) brace -> . ID narrayindex
    (148) NUM -> . INT_NUM
    (149) NUM -> . FLOAT_NUM
    (64) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    expr                           shift and go to state 220
    init                           shift and go to state 243
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 237

    (71) yes_dec_params -> yes_dec_params TYPE expr COMMA .

    TYPE            reduce using rule 71 (yes_dec_params -> yes_dec_params TYPE expr COMMA .)


state 238

    (73) yes_dec_params -> yes_dec_params TYPE MULTIPLY COMMA .

    TYPE            reduce using rule 73 (yes_dec_params -> yes_dec_params TYPE MULTIPLY COMMA .)


state 239

    (23) multi_declaration -> multi_declaration MULTIPLY ID ASSIGN expr COMMA .

    ID              reduce using rule 23 (multi_declaration -> multi_declaration MULTIPLY ID ASSIGN expr COMMA .)
    MULTIPLY        reduce using rule 23 (multi_declaration -> multi_declaration MULTIPLY ID ASSIGN expr COMMA .)


state 240

    (31) stop -> MULTIPLY ID ASSIGN expr SEMICOLON .

    IF              reduce using rule 31 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    WHILE           reduce using rule 31 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    FOR             reduce using rule 31 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    SEMICOLON       reduce using rule 31 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    RETURN          reduce using rule 31 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    HASH            reduce using rule 31 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    TYPE            reduce using rule 31 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    L_FLOWBRACE     reduce using rule 31 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    NOT             reduce using rule 31 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    PLUS            reduce using rule 31 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    MINUS           reduce using rule 31 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    PLUS_PLUS       reduce using rule 31 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    MINUS_MINUS     reduce using rule 31 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    L_PAREN         reduce using rule 31 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    STRING          reduce using rule 31 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    MULTIPLY        reduce using rule 31 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    BIT_AND         reduce using rule 31 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    ID              reduce using rule 31 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    CHAR            reduce using rule 31 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    INT_NUM         reduce using rule 31 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    FLOAT_NUM       reduce using rule 31 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    $end            reduce using rule 31 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    R_FLOWBRACE     reduce using rule 31 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    ELSE            reduce using rule 31 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    R_PAREN         reduce using rule 31 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)


state 241

    (44) init_list -> L_FLOWBRACE init_list R_FLOWBRACE COMMA . init_list
    (44) init_list -> . L_FLOWBRACE init_list R_FLOWBRACE COMMA init_list
    (45) init_list -> . L_FLOWBRACE init R_FLOWBRACE COMMA init_list
    (46) init_list -> . L_FLOWBRACE init R_FLOWBRACE
    (47) init_list -> . L_FLOWBRACE init_list R_FLOWBRACE

    L_FLOWBRACE     shift and go to state 202

    init_list                      shift and go to state 244

state 242

    (45) init_list -> L_FLOWBRACE init R_FLOWBRACE COMMA . init_list
    (44) init_list -> . L_FLOWBRACE init_list R_FLOWBRACE COMMA init_list
    (45) init_list -> . L_FLOWBRACE init R_FLOWBRACE COMMA init_list
    (46) init_list -> . L_FLOWBRACE init R_FLOWBRACE
    (47) init_list -> . L_FLOWBRACE init_list R_FLOWBRACE

    L_FLOWBRACE     shift and go to state 202

    init_list                      shift and go to state 245

state 243

    (42) init -> expr COMMA init .

    R_FLOWBRACE     reduce using rule 42 (init -> expr COMMA init .)


state 244

    (44) init_list -> L_FLOWBRACE init_list R_FLOWBRACE COMMA init_list .

    SEMICOLON       reduce using rule 44 (init_list -> L_FLOWBRACE init_list R_FLOWBRACE COMMA init_list .)
    R_FLOWBRACE     reduce using rule 44 (init_list -> L_FLOWBRACE init_list R_FLOWBRACE COMMA init_list .)


state 245

    (45) init_list -> L_FLOWBRACE init R_FLOWBRACE COMMA init_list .

    SEMICOLON       reduce using rule 45 (init_list -> L_FLOWBRACE init R_FLOWBRACE COMMA init_list .)
    R_FLOWBRACE     reduce using rule 45 (init_list -> L_FLOWBRACE init R_FLOWBRACE COMMA init_list .)

