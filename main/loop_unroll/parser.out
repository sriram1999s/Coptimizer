Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> start
Rule 1     start -> multiple_statements
Rule 2     multiple_statements -> multiple_statements statement
Rule 3     multiple_statements -> statement
Rule 4     statement -> open
Rule 5     statement -> closed
Rule 6     open -> IF condition statement
Rule 7     open -> IF condition closed ELSE open
Rule 8     open -> WHILE condition open
Rule 9     open -> FOR for_condition open
Rule 10    closed -> simple
Rule 11    closed -> block
Rule 12    closed -> IF condition closed ELSE closed
Rule 13    closed -> WHILE condition closed
Rule 14    closed -> FOR for_condition closed
Rule 15    condition -> L_PAREN expr R_PAREN
Rule 16    for_condition -> L_PAREN declaration expr SEMICOLON expr R_PAREN
Rule 17    multi_declaration -> multi_declaration ID COMMA
Rule 18    multi_declaration -> multi_declaration ID ASSIGN expr COMMA
Rule 19    multi_declaration -> ID COMMA
Rule 20    multi_declaration -> ID ASSIGN expr COMMA
Rule 21    stop -> ID SEMICOLON
Rule 22    stop -> ID ASSIGN expr SEMICOLON
Rule 23    declaration -> TYPE ID SEMICOLON
Rule 24    declaration -> TYPE ID ASSIGN expr SEMICOLON
Rule 25    declaration -> TYPE multi_declaration stop
Rule 26    block -> L_FLOWBRACE multiple_statements R_FLOWBRACE
Rule 27    simple -> expr SEMICOLON
Rule 28    simple -> declaration
Rule 29    simple -> SEMICOLON
Rule 30    simple -> function
Rule 31    function -> TYPE ID L_PAREN R_PAREN function_2
Rule 32    function_2 -> SEMICOLON
Rule 33    function_2 -> block
Rule 34    expr -> expr assignment exprOR
Rule 35    expr -> exprOR
Rule 36    assignment -> ASSIGN
Rule 37    assignment -> PLUS_ASSIGN
Rule 38    assignment -> MINUS_ASSIGN
Rule 39    assignment -> MUL_ASSIGN
Rule 40    assignment -> DIV_ASSIGN
Rule 41    assignment -> AND_ASSIGN
Rule 42    assignment -> OR_ASSIGN
Rule 43    assignment -> XOR_ASSIGN
Rule 44    assignment -> MOD_ASSIGN
Rule 45    assignment -> L_SHIFT_ASSIGN
Rule 46    assignment -> R_SHIFT_ASSIGN
Rule 47    exprOR -> exprOR OR exprAND
Rule 48    exprOR -> exprAND
Rule 49    exprAND -> exprAND AND exprBITOR
Rule 50    exprAND -> exprBITOR
Rule 51    exprBITOR -> exprBITOR BIT_OR exprBITXOR
Rule 52    exprBITOR -> exprBITXOR
Rule 53    exprBITXOR -> exprBITXOR BIT_XOR exprBITAND
Rule 54    exprBITXOR -> exprBITAND
Rule 55    exprBITAND -> exprBITAND BIT_AND exprEQ
Rule 56    exprBITAND -> exprEQ
Rule 57    exprEQ -> exprEQ EQ exprRELOP
Rule 58    exprEQ -> exprEQ NE exprRELOP
Rule 59    exprEQ -> exprRELOP
Rule 60    exprRELOP -> exprRELOP relop exprSHIFT
Rule 61    exprRELOP -> exprSHIFT
Rule 62    relop -> LE
Rule 63    relop -> LT
Rule 64    relop -> GE
Rule 65    relop -> GT
Rule 66    exprSHIFT -> exprSHIFT L_SHIFT exprOP
Rule 67    exprSHIFT -> exprSHIFT R_SHIFT exprOP
Rule 68    exprSHIFT -> exprOP
Rule 69    exprOP -> exprOP PLUS term
Rule 70    exprOP -> exprOP MINUS term
Rule 71    exprOP -> term
Rule 72    term -> term MULTIPLY factor
Rule 73    term -> term DIVIDE factor
Rule 74    term -> term MOD factor
Rule 75    term -> factor
Rule 76    factor -> NOT factor
Rule 77    factor -> PLUS factor
Rule 78    factor -> MINUS factor
Rule 79    factor -> PLUS_PLUS factor
Rule 80    factor -> MINUS_MINUS factor
Rule 81    factor -> brace
Rule 82    brace -> L_PAREN expr R_PAREN
Rule 83    brace -> brace PLUS_PLUS
Rule 84    brace -> brace MINUS_MINUS
Rule 85    brace -> INT_NUM
Rule 86    brace -> FLOAT_NUM
Rule 87    brace -> ID

Terminals, with rules where they appear

AND                  : 49
AND_ASSIGN           : 41
ASSIGN               : 18 20 22 24 36
BIT_AND              : 55
BIT_OR               : 51
BIT_XOR              : 53
COMMA                : 17 18 19 20
DIVIDE               : 73
DIV_ASSIGN           : 40
ELSE                 : 7 12
EQ                   : 57
FLOAT_NUM            : 86
FOR                  : 9 14
GE                   : 64
GT                   : 65
ID                   : 17 18 19 20 21 22 23 24 31 87
IF                   : 6 7 12
INT_NUM              : 85
LE                   : 62
LT                   : 63
L_FLOWBRACE          : 26
L_PAREN              : 15 16 31 82
L_SHIFT              : 66
L_SHIFT_ASSIGN       : 45
MINUS                : 70 78
MINUS_ASSIGN         : 38
MINUS_MINUS          : 80 84
MOD                  : 74
MOD_ASSIGN           : 44
MULTIPLY             : 72
MUL_ASSIGN           : 39
NE                   : 58
NOT                  : 76
OR                   : 47
OR_ASSIGN            : 42
PLUS                 : 69 77
PLUS_ASSIGN          : 37
PLUS_PLUS            : 79 83
R_FLOWBRACE          : 26
R_PAREN              : 15 16 31 82
R_SHIFT              : 67
R_SHIFT_ASSIGN       : 46
SEMICOLON            : 16 21 22 23 24 27 29 32
TYPE                 : 23 24 25 31
WHILE                : 8 13
XOR_ASSIGN           : 43
error                : 

Nonterminals, with rules where they appear

assignment           : 34
block                : 11 33
brace                : 81 83 84
closed               : 5 7 12 12 13 14
condition            : 6 7 8 12 13
declaration          : 16 28
expr                 : 15 16 16 18 20 22 24 27 34 82
exprAND              : 47 48 49
exprBITAND           : 53 54 55
exprBITOR            : 49 50 51
exprBITXOR           : 51 52 53
exprEQ               : 55 56 57 58
exprOP               : 66 67 68 69 70
exprOR               : 34 35 47
exprRELOP            : 57 58 59 60
exprSHIFT            : 60 61 66 67
factor               : 72 73 74 75 76 77 78 79 80
for_condition        : 9 14
function             : 30
function_2           : 31
multi_declaration    : 17 18 25
multiple_statements  : 1 2 26
open                 : 4 7 8 9
relop                : 60
simple               : 10
start                : 0
statement            : 2 3 6
stop                 : 25
term                 : 69 70 71 72 73 74

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . multiple_statements
    (2) multiple_statements -> . multiple_statements statement
    (3) multiple_statements -> . statement
    (4) statement -> . open
    (5) statement -> . closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) open -> . FOR for_condition open
    (10) closed -> . simple
    (11) closed -> . block
    (12) closed -> . IF condition closed ELSE closed
    (13) closed -> . WHILE condition closed
    (14) closed -> . FOR for_condition closed
    (27) simple -> . expr SEMICOLON
    (28) simple -> . declaration
    (29) simple -> . SEMICOLON
    (30) simple -> . function
    (26) block -> . L_FLOWBRACE multiple_statements R_FLOWBRACE
    (34) expr -> . expr assignment exprOR
    (35) expr -> . exprOR
    (23) declaration -> . TYPE ID SEMICOLON
    (24) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (25) declaration -> . TYPE multi_declaration stop
    (31) function -> . TYPE ID L_PAREN R_PAREN function_2
    (47) exprOR -> . exprOR OR exprAND
    (48) exprOR -> . exprAND
    (49) exprAND -> . exprAND AND exprBITOR
    (50) exprAND -> . exprBITOR
    (51) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (52) exprBITOR -> . exprBITXOR
    (53) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (54) exprBITXOR -> . exprBITAND
    (55) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (56) exprBITAND -> . exprEQ
    (57) exprEQ -> . exprEQ EQ exprRELOP
    (58) exprEQ -> . exprEQ NE exprRELOP
    (59) exprEQ -> . exprRELOP
    (60) exprRELOP -> . exprRELOP relop exprSHIFT
    (61) exprRELOP -> . exprSHIFT
    (66) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (67) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (68) exprSHIFT -> . exprOP
    (69) exprOP -> . exprOP PLUS term
    (70) exprOP -> . exprOP MINUS term
    (71) exprOP -> . term
    (72) term -> . term MULTIPLY factor
    (73) term -> . term DIVIDE factor
    (74) term -> . term MOD factor
    (75) term -> . factor
    (76) factor -> . NOT factor
    (77) factor -> . PLUS factor
    (78) factor -> . MINUS factor
    (79) factor -> . PLUS_PLUS factor
    (80) factor -> . MINUS_MINUS factor
    (81) factor -> . brace
    (82) brace -> . L_PAREN expr R_PAREN
    (83) brace -> . brace PLUS_PLUS
    (84) brace -> . brace MINUS_MINUS
    (85) brace -> . INT_NUM
    (86) brace -> . FLOAT_NUM
    (87) brace -> . ID

    IF              shift and go to state 6
    WHILE           shift and go to state 7
    FOR             shift and go to state 8
    SEMICOLON       shift and go to state 12
    L_FLOWBRACE     shift and go to state 15
    TYPE            shift and go to state 17
    NOT             shift and go to state 32
    PLUS            shift and go to state 28
    MINUS           shift and go to state 30
    PLUS_PLUS       shift and go to state 33
    MINUS_MINUS     shift and go to state 34
    L_PAREN         shift and go to state 19
    INT_NUM         shift and go to state 36
    FLOAT_NUM       shift and go to state 37
    ID              shift and go to state 18

    start                          shift and go to state 1
    multiple_statements            shift and go to state 2
    statement                      shift and go to state 3
    open                           shift and go to state 4
    closed                         shift and go to state 5
    simple                         shift and go to state 9
    block                          shift and go to state 10
    expr                           shift and go to state 11
    declaration                    shift and go to state 13
    function                       shift and go to state 14
    exprOR                         shift and go to state 16
    exprAND                        shift and go to state 20
    exprBITOR                      shift and go to state 21
    exprBITXOR                     shift and go to state 22
    exprBITAND                     shift and go to state 23
    exprEQ                         shift and go to state 24
    exprRELOP                      shift and go to state 25
    exprSHIFT                      shift and go to state 26
    exprOP                         shift and go to state 27
    term                           shift and go to state 29
    factor                         shift and go to state 31
    brace                          shift and go to state 35

state 1

    (0) S' -> start .



state 2

    (1) start -> multiple_statements .
    (2) multiple_statements -> multiple_statements . statement
    (4) statement -> . open
    (5) statement -> . closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) open -> . FOR for_condition open
    (10) closed -> . simple
    (11) closed -> . block
    (12) closed -> . IF condition closed ELSE closed
    (13) closed -> . WHILE condition closed
    (14) closed -> . FOR for_condition closed
    (27) simple -> . expr SEMICOLON
    (28) simple -> . declaration
    (29) simple -> . SEMICOLON
    (30) simple -> . function
    (26) block -> . L_FLOWBRACE multiple_statements R_FLOWBRACE
    (34) expr -> . expr assignment exprOR
    (35) expr -> . exprOR
    (23) declaration -> . TYPE ID SEMICOLON
    (24) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (25) declaration -> . TYPE multi_declaration stop
    (31) function -> . TYPE ID L_PAREN R_PAREN function_2
    (47) exprOR -> . exprOR OR exprAND
    (48) exprOR -> . exprAND
    (49) exprAND -> . exprAND AND exprBITOR
    (50) exprAND -> . exprBITOR
    (51) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (52) exprBITOR -> . exprBITXOR
    (53) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (54) exprBITXOR -> . exprBITAND
    (55) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (56) exprBITAND -> . exprEQ
    (57) exprEQ -> . exprEQ EQ exprRELOP
    (58) exprEQ -> . exprEQ NE exprRELOP
    (59) exprEQ -> . exprRELOP
    (60) exprRELOP -> . exprRELOP relop exprSHIFT
    (61) exprRELOP -> . exprSHIFT
    (66) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (67) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (68) exprSHIFT -> . exprOP
    (69) exprOP -> . exprOP PLUS term
    (70) exprOP -> . exprOP MINUS term
    (71) exprOP -> . term
    (72) term -> . term MULTIPLY factor
    (73) term -> . term DIVIDE factor
    (74) term -> . term MOD factor
    (75) term -> . factor
    (76) factor -> . NOT factor
    (77) factor -> . PLUS factor
    (78) factor -> . MINUS factor
    (79) factor -> . PLUS_PLUS factor
    (80) factor -> . MINUS_MINUS factor
    (81) factor -> . brace
    (82) brace -> . L_PAREN expr R_PAREN
    (83) brace -> . brace PLUS_PLUS
    (84) brace -> . brace MINUS_MINUS
    (85) brace -> . INT_NUM
    (86) brace -> . FLOAT_NUM
    (87) brace -> . ID

    $end            reduce using rule 1 (start -> multiple_statements .)
    IF              shift and go to state 6
    WHILE           shift and go to state 7
    FOR             shift and go to state 8
    SEMICOLON       shift and go to state 12
    L_FLOWBRACE     shift and go to state 15
    TYPE            shift and go to state 17
    NOT             shift and go to state 32
    PLUS            shift and go to state 28
    MINUS           shift and go to state 30
    PLUS_PLUS       shift and go to state 33
    MINUS_MINUS     shift and go to state 34
    L_PAREN         shift and go to state 19
    INT_NUM         shift and go to state 36
    FLOAT_NUM       shift and go to state 37
    ID              shift and go to state 18

    statement                      shift and go to state 38
    open                           shift and go to state 4
    closed                         shift and go to state 5
    simple                         shift and go to state 9
    block                          shift and go to state 10
    expr                           shift and go to state 11
    declaration                    shift and go to state 13
    function                       shift and go to state 14
    exprOR                         shift and go to state 16
    exprAND                        shift and go to state 20
    exprBITOR                      shift and go to state 21
    exprBITXOR                     shift and go to state 22
    exprBITAND                     shift and go to state 23
    exprEQ                         shift and go to state 24
    exprRELOP                      shift and go to state 25
    exprSHIFT                      shift and go to state 26
    exprOP                         shift and go to state 27
    term                           shift and go to state 29
    factor                         shift and go to state 31
    brace                          shift and go to state 35

state 3

    (3) multiple_statements -> statement .

    IF              reduce using rule 3 (multiple_statements -> statement .)
    WHILE           reduce using rule 3 (multiple_statements -> statement .)
    FOR             reduce using rule 3 (multiple_statements -> statement .)
    SEMICOLON       reduce using rule 3 (multiple_statements -> statement .)
    L_FLOWBRACE     reduce using rule 3 (multiple_statements -> statement .)
    TYPE            reduce using rule 3 (multiple_statements -> statement .)
    NOT             reduce using rule 3 (multiple_statements -> statement .)
    PLUS            reduce using rule 3 (multiple_statements -> statement .)
    MINUS           reduce using rule 3 (multiple_statements -> statement .)
    PLUS_PLUS       reduce using rule 3 (multiple_statements -> statement .)
    MINUS_MINUS     reduce using rule 3 (multiple_statements -> statement .)
    L_PAREN         reduce using rule 3 (multiple_statements -> statement .)
    INT_NUM         reduce using rule 3 (multiple_statements -> statement .)
    FLOAT_NUM       reduce using rule 3 (multiple_statements -> statement .)
    ID              reduce using rule 3 (multiple_statements -> statement .)
    $end            reduce using rule 3 (multiple_statements -> statement .)
    R_FLOWBRACE     reduce using rule 3 (multiple_statements -> statement .)


state 4

    (4) statement -> open .

    IF              reduce using rule 4 (statement -> open .)
    WHILE           reduce using rule 4 (statement -> open .)
    FOR             reduce using rule 4 (statement -> open .)
    SEMICOLON       reduce using rule 4 (statement -> open .)
    L_FLOWBRACE     reduce using rule 4 (statement -> open .)
    TYPE            reduce using rule 4 (statement -> open .)
    NOT             reduce using rule 4 (statement -> open .)
    PLUS            reduce using rule 4 (statement -> open .)
    MINUS           reduce using rule 4 (statement -> open .)
    PLUS_PLUS       reduce using rule 4 (statement -> open .)
    MINUS_MINUS     reduce using rule 4 (statement -> open .)
    L_PAREN         reduce using rule 4 (statement -> open .)
    INT_NUM         reduce using rule 4 (statement -> open .)
    FLOAT_NUM       reduce using rule 4 (statement -> open .)
    ID              reduce using rule 4 (statement -> open .)
    $end            reduce using rule 4 (statement -> open .)
    R_FLOWBRACE     reduce using rule 4 (statement -> open .)


state 5

    (5) statement -> closed .

    IF              reduce using rule 5 (statement -> closed .)
    WHILE           reduce using rule 5 (statement -> closed .)
    FOR             reduce using rule 5 (statement -> closed .)
    SEMICOLON       reduce using rule 5 (statement -> closed .)
    L_FLOWBRACE     reduce using rule 5 (statement -> closed .)
    TYPE            reduce using rule 5 (statement -> closed .)
    NOT             reduce using rule 5 (statement -> closed .)
    PLUS            reduce using rule 5 (statement -> closed .)
    MINUS           reduce using rule 5 (statement -> closed .)
    PLUS_PLUS       reduce using rule 5 (statement -> closed .)
    MINUS_MINUS     reduce using rule 5 (statement -> closed .)
    L_PAREN         reduce using rule 5 (statement -> closed .)
    INT_NUM         reduce using rule 5 (statement -> closed .)
    FLOAT_NUM       reduce using rule 5 (statement -> closed .)
    ID              reduce using rule 5 (statement -> closed .)
    $end            reduce using rule 5 (statement -> closed .)
    R_FLOWBRACE     reduce using rule 5 (statement -> closed .)


state 6

    (6) open -> IF . condition statement
    (7) open -> IF . condition closed ELSE open
    (12) closed -> IF . condition closed ELSE closed
    (15) condition -> . L_PAREN expr R_PAREN

    L_PAREN         shift and go to state 40

    condition                      shift and go to state 39

state 7

    (8) open -> WHILE . condition open
    (13) closed -> WHILE . condition closed
    (15) condition -> . L_PAREN expr R_PAREN

    L_PAREN         shift and go to state 40

    condition                      shift and go to state 41

state 8

    (9) open -> FOR . for_condition open
    (14) closed -> FOR . for_condition closed
    (16) for_condition -> . L_PAREN declaration expr SEMICOLON expr R_PAREN

    L_PAREN         shift and go to state 43

    for_condition                  shift and go to state 42

state 9

    (10) closed -> simple .

    IF              reduce using rule 10 (closed -> simple .)
    WHILE           reduce using rule 10 (closed -> simple .)
    FOR             reduce using rule 10 (closed -> simple .)
    SEMICOLON       reduce using rule 10 (closed -> simple .)
    L_FLOWBRACE     reduce using rule 10 (closed -> simple .)
    TYPE            reduce using rule 10 (closed -> simple .)
    NOT             reduce using rule 10 (closed -> simple .)
    PLUS            reduce using rule 10 (closed -> simple .)
    MINUS           reduce using rule 10 (closed -> simple .)
    PLUS_PLUS       reduce using rule 10 (closed -> simple .)
    MINUS_MINUS     reduce using rule 10 (closed -> simple .)
    L_PAREN         reduce using rule 10 (closed -> simple .)
    INT_NUM         reduce using rule 10 (closed -> simple .)
    FLOAT_NUM       reduce using rule 10 (closed -> simple .)
    ID              reduce using rule 10 (closed -> simple .)
    $end            reduce using rule 10 (closed -> simple .)
    R_FLOWBRACE     reduce using rule 10 (closed -> simple .)
    ELSE            reduce using rule 10 (closed -> simple .)


state 10

    (11) closed -> block .

    IF              reduce using rule 11 (closed -> block .)
    WHILE           reduce using rule 11 (closed -> block .)
    FOR             reduce using rule 11 (closed -> block .)
    SEMICOLON       reduce using rule 11 (closed -> block .)
    L_FLOWBRACE     reduce using rule 11 (closed -> block .)
    TYPE            reduce using rule 11 (closed -> block .)
    NOT             reduce using rule 11 (closed -> block .)
    PLUS            reduce using rule 11 (closed -> block .)
    MINUS           reduce using rule 11 (closed -> block .)
    PLUS_PLUS       reduce using rule 11 (closed -> block .)
    MINUS_MINUS     reduce using rule 11 (closed -> block .)
    L_PAREN         reduce using rule 11 (closed -> block .)
    INT_NUM         reduce using rule 11 (closed -> block .)
    FLOAT_NUM       reduce using rule 11 (closed -> block .)
    ID              reduce using rule 11 (closed -> block .)
    $end            reduce using rule 11 (closed -> block .)
    R_FLOWBRACE     reduce using rule 11 (closed -> block .)
    ELSE            reduce using rule 11 (closed -> block .)


state 11

    (27) simple -> expr . SEMICOLON
    (34) expr -> expr . assignment exprOR
    (36) assignment -> . ASSIGN
    (37) assignment -> . PLUS_ASSIGN
    (38) assignment -> . MINUS_ASSIGN
    (39) assignment -> . MUL_ASSIGN
    (40) assignment -> . DIV_ASSIGN
    (41) assignment -> . AND_ASSIGN
    (42) assignment -> . OR_ASSIGN
    (43) assignment -> . XOR_ASSIGN
    (44) assignment -> . MOD_ASSIGN
    (45) assignment -> . L_SHIFT_ASSIGN
    (46) assignment -> . R_SHIFT_ASSIGN

    SEMICOLON       shift and go to state 44
    ASSIGN          shift and go to state 46
    PLUS_ASSIGN     shift and go to state 47
    MINUS_ASSIGN    shift and go to state 48
    MUL_ASSIGN      shift and go to state 49
    DIV_ASSIGN      shift and go to state 50
    AND_ASSIGN      shift and go to state 51
    OR_ASSIGN       shift and go to state 52
    XOR_ASSIGN      shift and go to state 53
    MOD_ASSIGN      shift and go to state 54
    L_SHIFT_ASSIGN  shift and go to state 55
    R_SHIFT_ASSIGN  shift and go to state 56

    assignment                     shift and go to state 45

state 12

    (29) simple -> SEMICOLON .

    IF              reduce using rule 29 (simple -> SEMICOLON .)
    WHILE           reduce using rule 29 (simple -> SEMICOLON .)
    FOR             reduce using rule 29 (simple -> SEMICOLON .)
    SEMICOLON       reduce using rule 29 (simple -> SEMICOLON .)
    L_FLOWBRACE     reduce using rule 29 (simple -> SEMICOLON .)
    TYPE            reduce using rule 29 (simple -> SEMICOLON .)
    NOT             reduce using rule 29 (simple -> SEMICOLON .)
    PLUS            reduce using rule 29 (simple -> SEMICOLON .)
    MINUS           reduce using rule 29 (simple -> SEMICOLON .)
    PLUS_PLUS       reduce using rule 29 (simple -> SEMICOLON .)
    MINUS_MINUS     reduce using rule 29 (simple -> SEMICOLON .)
    L_PAREN         reduce using rule 29 (simple -> SEMICOLON .)
    INT_NUM         reduce using rule 29 (simple -> SEMICOLON .)
    FLOAT_NUM       reduce using rule 29 (simple -> SEMICOLON .)
    ID              reduce using rule 29 (simple -> SEMICOLON .)
    $end            reduce using rule 29 (simple -> SEMICOLON .)
    R_FLOWBRACE     reduce using rule 29 (simple -> SEMICOLON .)
    ELSE            reduce using rule 29 (simple -> SEMICOLON .)


state 13

    (28) simple -> declaration .

    IF              reduce using rule 28 (simple -> declaration .)
    WHILE           reduce using rule 28 (simple -> declaration .)
    FOR             reduce using rule 28 (simple -> declaration .)
    SEMICOLON       reduce using rule 28 (simple -> declaration .)
    L_FLOWBRACE     reduce using rule 28 (simple -> declaration .)
    TYPE            reduce using rule 28 (simple -> declaration .)
    NOT             reduce using rule 28 (simple -> declaration .)
    PLUS            reduce using rule 28 (simple -> declaration .)
    MINUS           reduce using rule 28 (simple -> declaration .)
    PLUS_PLUS       reduce using rule 28 (simple -> declaration .)
    MINUS_MINUS     reduce using rule 28 (simple -> declaration .)
    L_PAREN         reduce using rule 28 (simple -> declaration .)
    INT_NUM         reduce using rule 28 (simple -> declaration .)
    FLOAT_NUM       reduce using rule 28 (simple -> declaration .)
    ID              reduce using rule 28 (simple -> declaration .)
    $end            reduce using rule 28 (simple -> declaration .)
    R_FLOWBRACE     reduce using rule 28 (simple -> declaration .)
    ELSE            reduce using rule 28 (simple -> declaration .)


state 14

    (30) simple -> function .

    IF              reduce using rule 30 (simple -> function .)
    WHILE           reduce using rule 30 (simple -> function .)
    FOR             reduce using rule 30 (simple -> function .)
    SEMICOLON       reduce using rule 30 (simple -> function .)
    L_FLOWBRACE     reduce using rule 30 (simple -> function .)
    TYPE            reduce using rule 30 (simple -> function .)
    NOT             reduce using rule 30 (simple -> function .)
    PLUS            reduce using rule 30 (simple -> function .)
    MINUS           reduce using rule 30 (simple -> function .)
    PLUS_PLUS       reduce using rule 30 (simple -> function .)
    MINUS_MINUS     reduce using rule 30 (simple -> function .)
    L_PAREN         reduce using rule 30 (simple -> function .)
    INT_NUM         reduce using rule 30 (simple -> function .)
    FLOAT_NUM       reduce using rule 30 (simple -> function .)
    ID              reduce using rule 30 (simple -> function .)
    $end            reduce using rule 30 (simple -> function .)
    R_FLOWBRACE     reduce using rule 30 (simple -> function .)
    ELSE            reduce using rule 30 (simple -> function .)


state 15

    (26) block -> L_FLOWBRACE . multiple_statements R_FLOWBRACE
    (2) multiple_statements -> . multiple_statements statement
    (3) multiple_statements -> . statement
    (4) statement -> . open
    (5) statement -> . closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) open -> . FOR for_condition open
    (10) closed -> . simple
    (11) closed -> . block
    (12) closed -> . IF condition closed ELSE closed
    (13) closed -> . WHILE condition closed
    (14) closed -> . FOR for_condition closed
    (27) simple -> . expr SEMICOLON
    (28) simple -> . declaration
    (29) simple -> . SEMICOLON
    (30) simple -> . function
    (26) block -> . L_FLOWBRACE multiple_statements R_FLOWBRACE
    (34) expr -> . expr assignment exprOR
    (35) expr -> . exprOR
    (23) declaration -> . TYPE ID SEMICOLON
    (24) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (25) declaration -> . TYPE multi_declaration stop
    (31) function -> . TYPE ID L_PAREN R_PAREN function_2
    (47) exprOR -> . exprOR OR exprAND
    (48) exprOR -> . exprAND
    (49) exprAND -> . exprAND AND exprBITOR
    (50) exprAND -> . exprBITOR
    (51) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (52) exprBITOR -> . exprBITXOR
    (53) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (54) exprBITXOR -> . exprBITAND
    (55) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (56) exprBITAND -> . exprEQ
    (57) exprEQ -> . exprEQ EQ exprRELOP
    (58) exprEQ -> . exprEQ NE exprRELOP
    (59) exprEQ -> . exprRELOP
    (60) exprRELOP -> . exprRELOP relop exprSHIFT
    (61) exprRELOP -> . exprSHIFT
    (66) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (67) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (68) exprSHIFT -> . exprOP
    (69) exprOP -> . exprOP PLUS term
    (70) exprOP -> . exprOP MINUS term
    (71) exprOP -> . term
    (72) term -> . term MULTIPLY factor
    (73) term -> . term DIVIDE factor
    (74) term -> . term MOD factor
    (75) term -> . factor
    (76) factor -> . NOT factor
    (77) factor -> . PLUS factor
    (78) factor -> . MINUS factor
    (79) factor -> . PLUS_PLUS factor
    (80) factor -> . MINUS_MINUS factor
    (81) factor -> . brace
    (82) brace -> . L_PAREN expr R_PAREN
    (83) brace -> . brace PLUS_PLUS
    (84) brace -> . brace MINUS_MINUS
    (85) brace -> . INT_NUM
    (86) brace -> . FLOAT_NUM
    (87) brace -> . ID

    IF              shift and go to state 6
    WHILE           shift and go to state 7
    FOR             shift and go to state 8
    SEMICOLON       shift and go to state 12
    L_FLOWBRACE     shift and go to state 15
    TYPE            shift and go to state 17
    NOT             shift and go to state 32
    PLUS            shift and go to state 28
    MINUS           shift and go to state 30
    PLUS_PLUS       shift and go to state 33
    MINUS_MINUS     shift and go to state 34
    L_PAREN         shift and go to state 19
    INT_NUM         shift and go to state 36
    FLOAT_NUM       shift and go to state 37
    ID              shift and go to state 18

    multiple_statements            shift and go to state 57
    statement                      shift and go to state 3
    open                           shift and go to state 4
    closed                         shift and go to state 5
    simple                         shift and go to state 9
    block                          shift and go to state 10
    expr                           shift and go to state 11
    declaration                    shift and go to state 13
    function                       shift and go to state 14
    exprOR                         shift and go to state 16
    exprAND                        shift and go to state 20
    exprBITOR                      shift and go to state 21
    exprBITXOR                     shift and go to state 22
    exprBITAND                     shift and go to state 23
    exprEQ                         shift and go to state 24
    exprRELOP                      shift and go to state 25
    exprSHIFT                      shift and go to state 26
    exprOP                         shift and go to state 27
    term                           shift and go to state 29
    factor                         shift and go to state 31
    brace                          shift and go to state 35

state 16

    (35) expr -> exprOR .
    (47) exprOR -> exprOR . OR exprAND

    SEMICOLON       reduce using rule 35 (expr -> exprOR .)
    ASSIGN          reduce using rule 35 (expr -> exprOR .)
    PLUS_ASSIGN     reduce using rule 35 (expr -> exprOR .)
    MINUS_ASSIGN    reduce using rule 35 (expr -> exprOR .)
    MUL_ASSIGN      reduce using rule 35 (expr -> exprOR .)
    DIV_ASSIGN      reduce using rule 35 (expr -> exprOR .)
    AND_ASSIGN      reduce using rule 35 (expr -> exprOR .)
    OR_ASSIGN       reduce using rule 35 (expr -> exprOR .)
    XOR_ASSIGN      reduce using rule 35 (expr -> exprOR .)
    MOD_ASSIGN      reduce using rule 35 (expr -> exprOR .)
    L_SHIFT_ASSIGN  reduce using rule 35 (expr -> exprOR .)
    R_SHIFT_ASSIGN  reduce using rule 35 (expr -> exprOR .)
    R_PAREN         reduce using rule 35 (expr -> exprOR .)
    COMMA           reduce using rule 35 (expr -> exprOR .)
    OR              shift and go to state 58


state 17

    (23) declaration -> TYPE . ID SEMICOLON
    (24) declaration -> TYPE . ID ASSIGN expr SEMICOLON
    (25) declaration -> TYPE . multi_declaration stop
    (31) function -> TYPE . ID L_PAREN R_PAREN function_2
    (17) multi_declaration -> . multi_declaration ID COMMA
    (18) multi_declaration -> . multi_declaration ID ASSIGN expr COMMA
    (19) multi_declaration -> . ID COMMA
    (20) multi_declaration -> . ID ASSIGN expr COMMA

    ID              shift and go to state 59

    multi_declaration              shift and go to state 60

state 18

    (87) brace -> ID .

    PLUS_PLUS       reduce using rule 87 (brace -> ID .)
    MINUS_MINUS     reduce using rule 87 (brace -> ID .)
    MULTIPLY        reduce using rule 87 (brace -> ID .)
    DIVIDE          reduce using rule 87 (brace -> ID .)
    MOD             reduce using rule 87 (brace -> ID .)
    PLUS            reduce using rule 87 (brace -> ID .)
    MINUS           reduce using rule 87 (brace -> ID .)
    L_SHIFT         reduce using rule 87 (brace -> ID .)
    R_SHIFT         reduce using rule 87 (brace -> ID .)
    LE              reduce using rule 87 (brace -> ID .)
    LT              reduce using rule 87 (brace -> ID .)
    GE              reduce using rule 87 (brace -> ID .)
    GT              reduce using rule 87 (brace -> ID .)
    EQ              reduce using rule 87 (brace -> ID .)
    NE              reduce using rule 87 (brace -> ID .)
    BIT_AND         reduce using rule 87 (brace -> ID .)
    BIT_XOR         reduce using rule 87 (brace -> ID .)
    BIT_OR          reduce using rule 87 (brace -> ID .)
    AND             reduce using rule 87 (brace -> ID .)
    OR              reduce using rule 87 (brace -> ID .)
    SEMICOLON       reduce using rule 87 (brace -> ID .)
    ASSIGN          reduce using rule 87 (brace -> ID .)
    PLUS_ASSIGN     reduce using rule 87 (brace -> ID .)
    MINUS_ASSIGN    reduce using rule 87 (brace -> ID .)
    MUL_ASSIGN      reduce using rule 87 (brace -> ID .)
    DIV_ASSIGN      reduce using rule 87 (brace -> ID .)
    AND_ASSIGN      reduce using rule 87 (brace -> ID .)
    OR_ASSIGN       reduce using rule 87 (brace -> ID .)
    XOR_ASSIGN      reduce using rule 87 (brace -> ID .)
    MOD_ASSIGN      reduce using rule 87 (brace -> ID .)
    L_SHIFT_ASSIGN  reduce using rule 87 (brace -> ID .)
    R_SHIFT_ASSIGN  reduce using rule 87 (brace -> ID .)
    R_PAREN         reduce using rule 87 (brace -> ID .)
    COMMA           reduce using rule 87 (brace -> ID .)


state 19

    (82) brace -> L_PAREN . expr R_PAREN
    (34) expr -> . expr assignment exprOR
    (35) expr -> . exprOR
    (47) exprOR -> . exprOR OR exprAND
    (48) exprOR -> . exprAND
    (49) exprAND -> . exprAND AND exprBITOR
    (50) exprAND -> . exprBITOR
    (51) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (52) exprBITOR -> . exprBITXOR
    (53) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (54) exprBITXOR -> . exprBITAND
    (55) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (56) exprBITAND -> . exprEQ
    (57) exprEQ -> . exprEQ EQ exprRELOP
    (58) exprEQ -> . exprEQ NE exprRELOP
    (59) exprEQ -> . exprRELOP
    (60) exprRELOP -> . exprRELOP relop exprSHIFT
    (61) exprRELOP -> . exprSHIFT
    (66) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (67) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (68) exprSHIFT -> . exprOP
    (69) exprOP -> . exprOP PLUS term
    (70) exprOP -> . exprOP MINUS term
    (71) exprOP -> . term
    (72) term -> . term MULTIPLY factor
    (73) term -> . term DIVIDE factor
    (74) term -> . term MOD factor
    (75) term -> . factor
    (76) factor -> . NOT factor
    (77) factor -> . PLUS factor
    (78) factor -> . MINUS factor
    (79) factor -> . PLUS_PLUS factor
    (80) factor -> . MINUS_MINUS factor
    (81) factor -> . brace
    (82) brace -> . L_PAREN expr R_PAREN
    (83) brace -> . brace PLUS_PLUS
    (84) brace -> . brace MINUS_MINUS
    (85) brace -> . INT_NUM
    (86) brace -> . FLOAT_NUM
    (87) brace -> . ID

    NOT             shift and go to state 32
    PLUS            shift and go to state 28
    MINUS           shift and go to state 30
    PLUS_PLUS       shift and go to state 33
    MINUS_MINUS     shift and go to state 34
    L_PAREN         shift and go to state 19
    INT_NUM         shift and go to state 36
    FLOAT_NUM       shift and go to state 37
    ID              shift and go to state 18

    expr                           shift and go to state 61
    exprOR                         shift and go to state 16
    exprAND                        shift and go to state 20
    exprBITOR                      shift and go to state 21
    exprBITXOR                     shift and go to state 22
    exprBITAND                     shift and go to state 23
    exprEQ                         shift and go to state 24
    exprRELOP                      shift and go to state 25
    exprSHIFT                      shift and go to state 26
    exprOP                         shift and go to state 27
    term                           shift and go to state 29
    factor                         shift and go to state 31
    brace                          shift and go to state 35

state 20

    (48) exprOR -> exprAND .
    (49) exprAND -> exprAND . AND exprBITOR

    OR              reduce using rule 48 (exprOR -> exprAND .)
    SEMICOLON       reduce using rule 48 (exprOR -> exprAND .)
    ASSIGN          reduce using rule 48 (exprOR -> exprAND .)
    PLUS_ASSIGN     reduce using rule 48 (exprOR -> exprAND .)
    MINUS_ASSIGN    reduce using rule 48 (exprOR -> exprAND .)
    MUL_ASSIGN      reduce using rule 48 (exprOR -> exprAND .)
    DIV_ASSIGN      reduce using rule 48 (exprOR -> exprAND .)
    AND_ASSIGN      reduce using rule 48 (exprOR -> exprAND .)
    OR_ASSIGN       reduce using rule 48 (exprOR -> exprAND .)
    XOR_ASSIGN      reduce using rule 48 (exprOR -> exprAND .)
    MOD_ASSIGN      reduce using rule 48 (exprOR -> exprAND .)
    L_SHIFT_ASSIGN  reduce using rule 48 (exprOR -> exprAND .)
    R_SHIFT_ASSIGN  reduce using rule 48 (exprOR -> exprAND .)
    R_PAREN         reduce using rule 48 (exprOR -> exprAND .)
    COMMA           reduce using rule 48 (exprOR -> exprAND .)
    AND             shift and go to state 62


state 21

    (50) exprAND -> exprBITOR .
    (51) exprBITOR -> exprBITOR . BIT_OR exprBITXOR

    AND             reduce using rule 50 (exprAND -> exprBITOR .)
    OR              reduce using rule 50 (exprAND -> exprBITOR .)
    SEMICOLON       reduce using rule 50 (exprAND -> exprBITOR .)
    ASSIGN          reduce using rule 50 (exprAND -> exprBITOR .)
    PLUS_ASSIGN     reduce using rule 50 (exprAND -> exprBITOR .)
    MINUS_ASSIGN    reduce using rule 50 (exprAND -> exprBITOR .)
    MUL_ASSIGN      reduce using rule 50 (exprAND -> exprBITOR .)
    DIV_ASSIGN      reduce using rule 50 (exprAND -> exprBITOR .)
    AND_ASSIGN      reduce using rule 50 (exprAND -> exprBITOR .)
    OR_ASSIGN       reduce using rule 50 (exprAND -> exprBITOR .)
    XOR_ASSIGN      reduce using rule 50 (exprAND -> exprBITOR .)
    MOD_ASSIGN      reduce using rule 50 (exprAND -> exprBITOR .)
    L_SHIFT_ASSIGN  reduce using rule 50 (exprAND -> exprBITOR .)
    R_SHIFT_ASSIGN  reduce using rule 50 (exprAND -> exprBITOR .)
    R_PAREN         reduce using rule 50 (exprAND -> exprBITOR .)
    COMMA           reduce using rule 50 (exprAND -> exprBITOR .)
    BIT_OR          shift and go to state 63


state 22

    (52) exprBITOR -> exprBITXOR .
    (53) exprBITXOR -> exprBITXOR . BIT_XOR exprBITAND

    BIT_OR          reduce using rule 52 (exprBITOR -> exprBITXOR .)
    AND             reduce using rule 52 (exprBITOR -> exprBITXOR .)
    OR              reduce using rule 52 (exprBITOR -> exprBITXOR .)
    SEMICOLON       reduce using rule 52 (exprBITOR -> exprBITXOR .)
    ASSIGN          reduce using rule 52 (exprBITOR -> exprBITXOR .)
    PLUS_ASSIGN     reduce using rule 52 (exprBITOR -> exprBITXOR .)
    MINUS_ASSIGN    reduce using rule 52 (exprBITOR -> exprBITXOR .)
    MUL_ASSIGN      reduce using rule 52 (exprBITOR -> exprBITXOR .)
    DIV_ASSIGN      reduce using rule 52 (exprBITOR -> exprBITXOR .)
    AND_ASSIGN      reduce using rule 52 (exprBITOR -> exprBITXOR .)
    OR_ASSIGN       reduce using rule 52 (exprBITOR -> exprBITXOR .)
    XOR_ASSIGN      reduce using rule 52 (exprBITOR -> exprBITXOR .)
    MOD_ASSIGN      reduce using rule 52 (exprBITOR -> exprBITXOR .)
    L_SHIFT_ASSIGN  reduce using rule 52 (exprBITOR -> exprBITXOR .)
    R_SHIFT_ASSIGN  reduce using rule 52 (exprBITOR -> exprBITXOR .)
    R_PAREN         reduce using rule 52 (exprBITOR -> exprBITXOR .)
    COMMA           reduce using rule 52 (exprBITOR -> exprBITXOR .)
    BIT_XOR         shift and go to state 64


state 23

    (54) exprBITXOR -> exprBITAND .
    (55) exprBITAND -> exprBITAND . BIT_AND exprEQ

    BIT_XOR         reduce using rule 54 (exprBITXOR -> exprBITAND .)
    BIT_OR          reduce using rule 54 (exprBITXOR -> exprBITAND .)
    AND             reduce using rule 54 (exprBITXOR -> exprBITAND .)
    OR              reduce using rule 54 (exprBITXOR -> exprBITAND .)
    SEMICOLON       reduce using rule 54 (exprBITXOR -> exprBITAND .)
    ASSIGN          reduce using rule 54 (exprBITXOR -> exprBITAND .)
    PLUS_ASSIGN     reduce using rule 54 (exprBITXOR -> exprBITAND .)
    MINUS_ASSIGN    reduce using rule 54 (exprBITXOR -> exprBITAND .)
    MUL_ASSIGN      reduce using rule 54 (exprBITXOR -> exprBITAND .)
    DIV_ASSIGN      reduce using rule 54 (exprBITXOR -> exprBITAND .)
    AND_ASSIGN      reduce using rule 54 (exprBITXOR -> exprBITAND .)
    OR_ASSIGN       reduce using rule 54 (exprBITXOR -> exprBITAND .)
    XOR_ASSIGN      reduce using rule 54 (exprBITXOR -> exprBITAND .)
    MOD_ASSIGN      reduce using rule 54 (exprBITXOR -> exprBITAND .)
    L_SHIFT_ASSIGN  reduce using rule 54 (exprBITXOR -> exprBITAND .)
    R_SHIFT_ASSIGN  reduce using rule 54 (exprBITXOR -> exprBITAND .)
    R_PAREN         reduce using rule 54 (exprBITXOR -> exprBITAND .)
    COMMA           reduce using rule 54 (exprBITXOR -> exprBITAND .)
    BIT_AND         shift and go to state 65


state 24

    (56) exprBITAND -> exprEQ .
    (57) exprEQ -> exprEQ . EQ exprRELOP
    (58) exprEQ -> exprEQ . NE exprRELOP

    BIT_AND         reduce using rule 56 (exprBITAND -> exprEQ .)
    BIT_XOR         reduce using rule 56 (exprBITAND -> exprEQ .)
    BIT_OR          reduce using rule 56 (exprBITAND -> exprEQ .)
    AND             reduce using rule 56 (exprBITAND -> exprEQ .)
    OR              reduce using rule 56 (exprBITAND -> exprEQ .)
    SEMICOLON       reduce using rule 56 (exprBITAND -> exprEQ .)
    ASSIGN          reduce using rule 56 (exprBITAND -> exprEQ .)
    PLUS_ASSIGN     reduce using rule 56 (exprBITAND -> exprEQ .)
    MINUS_ASSIGN    reduce using rule 56 (exprBITAND -> exprEQ .)
    MUL_ASSIGN      reduce using rule 56 (exprBITAND -> exprEQ .)
    DIV_ASSIGN      reduce using rule 56 (exprBITAND -> exprEQ .)
    AND_ASSIGN      reduce using rule 56 (exprBITAND -> exprEQ .)
    OR_ASSIGN       reduce using rule 56 (exprBITAND -> exprEQ .)
    XOR_ASSIGN      reduce using rule 56 (exprBITAND -> exprEQ .)
    MOD_ASSIGN      reduce using rule 56 (exprBITAND -> exprEQ .)
    L_SHIFT_ASSIGN  reduce using rule 56 (exprBITAND -> exprEQ .)
    R_SHIFT_ASSIGN  reduce using rule 56 (exprBITAND -> exprEQ .)
    R_PAREN         reduce using rule 56 (exprBITAND -> exprEQ .)
    COMMA           reduce using rule 56 (exprBITAND -> exprEQ .)
    EQ              shift and go to state 66
    NE              shift and go to state 67


state 25

    (59) exprEQ -> exprRELOP .
    (60) exprRELOP -> exprRELOP . relop exprSHIFT
    (62) relop -> . LE
    (63) relop -> . LT
    (64) relop -> . GE
    (65) relop -> . GT

    EQ              reduce using rule 59 (exprEQ -> exprRELOP .)
    NE              reduce using rule 59 (exprEQ -> exprRELOP .)
    BIT_AND         reduce using rule 59 (exprEQ -> exprRELOP .)
    BIT_XOR         reduce using rule 59 (exprEQ -> exprRELOP .)
    BIT_OR          reduce using rule 59 (exprEQ -> exprRELOP .)
    AND             reduce using rule 59 (exprEQ -> exprRELOP .)
    OR              reduce using rule 59 (exprEQ -> exprRELOP .)
    SEMICOLON       reduce using rule 59 (exprEQ -> exprRELOP .)
    ASSIGN          reduce using rule 59 (exprEQ -> exprRELOP .)
    PLUS_ASSIGN     reduce using rule 59 (exprEQ -> exprRELOP .)
    MINUS_ASSIGN    reduce using rule 59 (exprEQ -> exprRELOP .)
    MUL_ASSIGN      reduce using rule 59 (exprEQ -> exprRELOP .)
    DIV_ASSIGN      reduce using rule 59 (exprEQ -> exprRELOP .)
    AND_ASSIGN      reduce using rule 59 (exprEQ -> exprRELOP .)
    OR_ASSIGN       reduce using rule 59 (exprEQ -> exprRELOP .)
    XOR_ASSIGN      reduce using rule 59 (exprEQ -> exprRELOP .)
    MOD_ASSIGN      reduce using rule 59 (exprEQ -> exprRELOP .)
    L_SHIFT_ASSIGN  reduce using rule 59 (exprEQ -> exprRELOP .)
    R_SHIFT_ASSIGN  reduce using rule 59 (exprEQ -> exprRELOP .)
    R_PAREN         reduce using rule 59 (exprEQ -> exprRELOP .)
    COMMA           reduce using rule 59 (exprEQ -> exprRELOP .)
    LE              shift and go to state 69
    LT              shift and go to state 70
    GE              shift and go to state 71
    GT              shift and go to state 72

    relop                          shift and go to state 68

state 26

    (61) exprRELOP -> exprSHIFT .
    (66) exprSHIFT -> exprSHIFT . L_SHIFT exprOP
    (67) exprSHIFT -> exprSHIFT . R_SHIFT exprOP

    LE              reduce using rule 61 (exprRELOP -> exprSHIFT .)
    LT              reduce using rule 61 (exprRELOP -> exprSHIFT .)
    GE              reduce using rule 61 (exprRELOP -> exprSHIFT .)
    GT              reduce using rule 61 (exprRELOP -> exprSHIFT .)
    EQ              reduce using rule 61 (exprRELOP -> exprSHIFT .)
    NE              reduce using rule 61 (exprRELOP -> exprSHIFT .)
    BIT_AND         reduce using rule 61 (exprRELOP -> exprSHIFT .)
    BIT_XOR         reduce using rule 61 (exprRELOP -> exprSHIFT .)
    BIT_OR          reduce using rule 61 (exprRELOP -> exprSHIFT .)
    AND             reduce using rule 61 (exprRELOP -> exprSHIFT .)
    OR              reduce using rule 61 (exprRELOP -> exprSHIFT .)
    SEMICOLON       reduce using rule 61 (exprRELOP -> exprSHIFT .)
    ASSIGN          reduce using rule 61 (exprRELOP -> exprSHIFT .)
    PLUS_ASSIGN     reduce using rule 61 (exprRELOP -> exprSHIFT .)
    MINUS_ASSIGN    reduce using rule 61 (exprRELOP -> exprSHIFT .)
    MUL_ASSIGN      reduce using rule 61 (exprRELOP -> exprSHIFT .)
    DIV_ASSIGN      reduce using rule 61 (exprRELOP -> exprSHIFT .)
    AND_ASSIGN      reduce using rule 61 (exprRELOP -> exprSHIFT .)
    OR_ASSIGN       reduce using rule 61 (exprRELOP -> exprSHIFT .)
    XOR_ASSIGN      reduce using rule 61 (exprRELOP -> exprSHIFT .)
    MOD_ASSIGN      reduce using rule 61 (exprRELOP -> exprSHIFT .)
    L_SHIFT_ASSIGN  reduce using rule 61 (exprRELOP -> exprSHIFT .)
    R_SHIFT_ASSIGN  reduce using rule 61 (exprRELOP -> exprSHIFT .)
    R_PAREN         reduce using rule 61 (exprRELOP -> exprSHIFT .)
    COMMA           reduce using rule 61 (exprRELOP -> exprSHIFT .)
    L_SHIFT         shift and go to state 73
    R_SHIFT         shift and go to state 74


state 27

    (68) exprSHIFT -> exprOP .
    (69) exprOP -> exprOP . PLUS term
    (70) exprOP -> exprOP . MINUS term

    L_SHIFT         reduce using rule 68 (exprSHIFT -> exprOP .)
    R_SHIFT         reduce using rule 68 (exprSHIFT -> exprOP .)
    LE              reduce using rule 68 (exprSHIFT -> exprOP .)
    LT              reduce using rule 68 (exprSHIFT -> exprOP .)
    GE              reduce using rule 68 (exprSHIFT -> exprOP .)
    GT              reduce using rule 68 (exprSHIFT -> exprOP .)
    EQ              reduce using rule 68 (exprSHIFT -> exprOP .)
    NE              reduce using rule 68 (exprSHIFT -> exprOP .)
    BIT_AND         reduce using rule 68 (exprSHIFT -> exprOP .)
    BIT_XOR         reduce using rule 68 (exprSHIFT -> exprOP .)
    BIT_OR          reduce using rule 68 (exprSHIFT -> exprOP .)
    AND             reduce using rule 68 (exprSHIFT -> exprOP .)
    OR              reduce using rule 68 (exprSHIFT -> exprOP .)
    SEMICOLON       reduce using rule 68 (exprSHIFT -> exprOP .)
    ASSIGN          reduce using rule 68 (exprSHIFT -> exprOP .)
    PLUS_ASSIGN     reduce using rule 68 (exprSHIFT -> exprOP .)
    MINUS_ASSIGN    reduce using rule 68 (exprSHIFT -> exprOP .)
    MUL_ASSIGN      reduce using rule 68 (exprSHIFT -> exprOP .)
    DIV_ASSIGN      reduce using rule 68 (exprSHIFT -> exprOP .)
    AND_ASSIGN      reduce using rule 68 (exprSHIFT -> exprOP .)
    OR_ASSIGN       reduce using rule 68 (exprSHIFT -> exprOP .)
    XOR_ASSIGN      reduce using rule 68 (exprSHIFT -> exprOP .)
    MOD_ASSIGN      reduce using rule 68 (exprSHIFT -> exprOP .)
    L_SHIFT_ASSIGN  reduce using rule 68 (exprSHIFT -> exprOP .)
    R_SHIFT_ASSIGN  reduce using rule 68 (exprSHIFT -> exprOP .)
    R_PAREN         reduce using rule 68 (exprSHIFT -> exprOP .)
    COMMA           reduce using rule 68 (exprSHIFT -> exprOP .)
    PLUS            shift and go to state 75
    MINUS           shift and go to state 76


state 28

    (77) factor -> PLUS . factor
    (76) factor -> . NOT factor
    (77) factor -> . PLUS factor
    (78) factor -> . MINUS factor
    (79) factor -> . PLUS_PLUS factor
    (80) factor -> . MINUS_MINUS factor
    (81) factor -> . brace
    (82) brace -> . L_PAREN expr R_PAREN
    (83) brace -> . brace PLUS_PLUS
    (84) brace -> . brace MINUS_MINUS
    (85) brace -> . INT_NUM
    (86) brace -> . FLOAT_NUM
    (87) brace -> . ID

    NOT             shift and go to state 32
    PLUS            shift and go to state 28
    MINUS           shift and go to state 30
    PLUS_PLUS       shift and go to state 33
    MINUS_MINUS     shift and go to state 34
    L_PAREN         shift and go to state 19
    INT_NUM         shift and go to state 36
    FLOAT_NUM       shift and go to state 37
    ID              shift and go to state 18

    factor                         shift and go to state 77
    brace                          shift and go to state 35

state 29

    (71) exprOP -> term .
    (72) term -> term . MULTIPLY factor
    (73) term -> term . DIVIDE factor
    (74) term -> term . MOD factor

    PLUS            reduce using rule 71 (exprOP -> term .)
    MINUS           reduce using rule 71 (exprOP -> term .)
    L_SHIFT         reduce using rule 71 (exprOP -> term .)
    R_SHIFT         reduce using rule 71 (exprOP -> term .)
    LE              reduce using rule 71 (exprOP -> term .)
    LT              reduce using rule 71 (exprOP -> term .)
    GE              reduce using rule 71 (exprOP -> term .)
    GT              reduce using rule 71 (exprOP -> term .)
    EQ              reduce using rule 71 (exprOP -> term .)
    NE              reduce using rule 71 (exprOP -> term .)
    BIT_AND         reduce using rule 71 (exprOP -> term .)
    BIT_XOR         reduce using rule 71 (exprOP -> term .)
    BIT_OR          reduce using rule 71 (exprOP -> term .)
    AND             reduce using rule 71 (exprOP -> term .)
    OR              reduce using rule 71 (exprOP -> term .)
    SEMICOLON       reduce using rule 71 (exprOP -> term .)
    ASSIGN          reduce using rule 71 (exprOP -> term .)
    PLUS_ASSIGN     reduce using rule 71 (exprOP -> term .)
    MINUS_ASSIGN    reduce using rule 71 (exprOP -> term .)
    MUL_ASSIGN      reduce using rule 71 (exprOP -> term .)
    DIV_ASSIGN      reduce using rule 71 (exprOP -> term .)
    AND_ASSIGN      reduce using rule 71 (exprOP -> term .)
    OR_ASSIGN       reduce using rule 71 (exprOP -> term .)
    XOR_ASSIGN      reduce using rule 71 (exprOP -> term .)
    MOD_ASSIGN      reduce using rule 71 (exprOP -> term .)
    L_SHIFT_ASSIGN  reduce using rule 71 (exprOP -> term .)
    R_SHIFT_ASSIGN  reduce using rule 71 (exprOP -> term .)
    R_PAREN         reduce using rule 71 (exprOP -> term .)
    COMMA           reduce using rule 71 (exprOP -> term .)
    MULTIPLY        shift and go to state 78
    DIVIDE          shift and go to state 79
    MOD             shift and go to state 80


state 30

    (78) factor -> MINUS . factor
    (76) factor -> . NOT factor
    (77) factor -> . PLUS factor
    (78) factor -> . MINUS factor
    (79) factor -> . PLUS_PLUS factor
    (80) factor -> . MINUS_MINUS factor
    (81) factor -> . brace
    (82) brace -> . L_PAREN expr R_PAREN
    (83) brace -> . brace PLUS_PLUS
    (84) brace -> . brace MINUS_MINUS
    (85) brace -> . INT_NUM
    (86) brace -> . FLOAT_NUM
    (87) brace -> . ID

    NOT             shift and go to state 32
    PLUS            shift and go to state 28
    MINUS           shift and go to state 30
    PLUS_PLUS       shift and go to state 33
    MINUS_MINUS     shift and go to state 34
    L_PAREN         shift and go to state 19
    INT_NUM         shift and go to state 36
    FLOAT_NUM       shift and go to state 37
    ID              shift and go to state 18

    factor                         shift and go to state 81
    brace                          shift and go to state 35

state 31

    (75) term -> factor .

    MULTIPLY        reduce using rule 75 (term -> factor .)
    DIVIDE          reduce using rule 75 (term -> factor .)
    MOD             reduce using rule 75 (term -> factor .)
    PLUS            reduce using rule 75 (term -> factor .)
    MINUS           reduce using rule 75 (term -> factor .)
    L_SHIFT         reduce using rule 75 (term -> factor .)
    R_SHIFT         reduce using rule 75 (term -> factor .)
    LE              reduce using rule 75 (term -> factor .)
    LT              reduce using rule 75 (term -> factor .)
    GE              reduce using rule 75 (term -> factor .)
    GT              reduce using rule 75 (term -> factor .)
    EQ              reduce using rule 75 (term -> factor .)
    NE              reduce using rule 75 (term -> factor .)
    BIT_AND         reduce using rule 75 (term -> factor .)
    BIT_XOR         reduce using rule 75 (term -> factor .)
    BIT_OR          reduce using rule 75 (term -> factor .)
    AND             reduce using rule 75 (term -> factor .)
    OR              reduce using rule 75 (term -> factor .)
    SEMICOLON       reduce using rule 75 (term -> factor .)
    ASSIGN          reduce using rule 75 (term -> factor .)
    PLUS_ASSIGN     reduce using rule 75 (term -> factor .)
    MINUS_ASSIGN    reduce using rule 75 (term -> factor .)
    MUL_ASSIGN      reduce using rule 75 (term -> factor .)
    DIV_ASSIGN      reduce using rule 75 (term -> factor .)
    AND_ASSIGN      reduce using rule 75 (term -> factor .)
    OR_ASSIGN       reduce using rule 75 (term -> factor .)
    XOR_ASSIGN      reduce using rule 75 (term -> factor .)
    MOD_ASSIGN      reduce using rule 75 (term -> factor .)
    L_SHIFT_ASSIGN  reduce using rule 75 (term -> factor .)
    R_SHIFT_ASSIGN  reduce using rule 75 (term -> factor .)
    R_PAREN         reduce using rule 75 (term -> factor .)
    COMMA           reduce using rule 75 (term -> factor .)


state 32

    (76) factor -> NOT . factor
    (76) factor -> . NOT factor
    (77) factor -> . PLUS factor
    (78) factor -> . MINUS factor
    (79) factor -> . PLUS_PLUS factor
    (80) factor -> . MINUS_MINUS factor
    (81) factor -> . brace
    (82) brace -> . L_PAREN expr R_PAREN
    (83) brace -> . brace PLUS_PLUS
    (84) brace -> . brace MINUS_MINUS
    (85) brace -> . INT_NUM
    (86) brace -> . FLOAT_NUM
    (87) brace -> . ID

    NOT             shift and go to state 32
    PLUS            shift and go to state 28
    MINUS           shift and go to state 30
    PLUS_PLUS       shift and go to state 33
    MINUS_MINUS     shift and go to state 34
    L_PAREN         shift and go to state 19
    INT_NUM         shift and go to state 36
    FLOAT_NUM       shift and go to state 37
    ID              shift and go to state 18

    factor                         shift and go to state 82
    brace                          shift and go to state 35

state 33

    (79) factor -> PLUS_PLUS . factor
    (76) factor -> . NOT factor
    (77) factor -> . PLUS factor
    (78) factor -> . MINUS factor
    (79) factor -> . PLUS_PLUS factor
    (80) factor -> . MINUS_MINUS factor
    (81) factor -> . brace
    (82) brace -> . L_PAREN expr R_PAREN
    (83) brace -> . brace PLUS_PLUS
    (84) brace -> . brace MINUS_MINUS
    (85) brace -> . INT_NUM
    (86) brace -> . FLOAT_NUM
    (87) brace -> . ID

    NOT             shift and go to state 32
    PLUS            shift and go to state 28
    MINUS           shift and go to state 30
    PLUS_PLUS       shift and go to state 33
    MINUS_MINUS     shift and go to state 34
    L_PAREN         shift and go to state 19
    INT_NUM         shift and go to state 36
    FLOAT_NUM       shift and go to state 37
    ID              shift and go to state 18

    factor                         shift and go to state 83
    brace                          shift and go to state 35

state 34

    (80) factor -> MINUS_MINUS . factor
    (76) factor -> . NOT factor
    (77) factor -> . PLUS factor
    (78) factor -> . MINUS factor
    (79) factor -> . PLUS_PLUS factor
    (80) factor -> . MINUS_MINUS factor
    (81) factor -> . brace
    (82) brace -> . L_PAREN expr R_PAREN
    (83) brace -> . brace PLUS_PLUS
    (84) brace -> . brace MINUS_MINUS
    (85) brace -> . INT_NUM
    (86) brace -> . FLOAT_NUM
    (87) brace -> . ID

    NOT             shift and go to state 32
    PLUS            shift and go to state 28
    MINUS           shift and go to state 30
    PLUS_PLUS       shift and go to state 33
    MINUS_MINUS     shift and go to state 34
    L_PAREN         shift and go to state 19
    INT_NUM         shift and go to state 36
    FLOAT_NUM       shift and go to state 37
    ID              shift and go to state 18

    factor                         shift and go to state 84
    brace                          shift and go to state 35

state 35

    (81) factor -> brace .
    (83) brace -> brace . PLUS_PLUS
    (84) brace -> brace . MINUS_MINUS

    MULTIPLY        reduce using rule 81 (factor -> brace .)
    DIVIDE          reduce using rule 81 (factor -> brace .)
    MOD             reduce using rule 81 (factor -> brace .)
    PLUS            reduce using rule 81 (factor -> brace .)
    MINUS           reduce using rule 81 (factor -> brace .)
    L_SHIFT         reduce using rule 81 (factor -> brace .)
    R_SHIFT         reduce using rule 81 (factor -> brace .)
    LE              reduce using rule 81 (factor -> brace .)
    LT              reduce using rule 81 (factor -> brace .)
    GE              reduce using rule 81 (factor -> brace .)
    GT              reduce using rule 81 (factor -> brace .)
    EQ              reduce using rule 81 (factor -> brace .)
    NE              reduce using rule 81 (factor -> brace .)
    BIT_AND         reduce using rule 81 (factor -> brace .)
    BIT_XOR         reduce using rule 81 (factor -> brace .)
    BIT_OR          reduce using rule 81 (factor -> brace .)
    AND             reduce using rule 81 (factor -> brace .)
    OR              reduce using rule 81 (factor -> brace .)
    SEMICOLON       reduce using rule 81 (factor -> brace .)
    ASSIGN          reduce using rule 81 (factor -> brace .)
    PLUS_ASSIGN     reduce using rule 81 (factor -> brace .)
    MINUS_ASSIGN    reduce using rule 81 (factor -> brace .)
    MUL_ASSIGN      reduce using rule 81 (factor -> brace .)
    DIV_ASSIGN      reduce using rule 81 (factor -> brace .)
    AND_ASSIGN      reduce using rule 81 (factor -> brace .)
    OR_ASSIGN       reduce using rule 81 (factor -> brace .)
    XOR_ASSIGN      reduce using rule 81 (factor -> brace .)
    MOD_ASSIGN      reduce using rule 81 (factor -> brace .)
    L_SHIFT_ASSIGN  reduce using rule 81 (factor -> brace .)
    R_SHIFT_ASSIGN  reduce using rule 81 (factor -> brace .)
    R_PAREN         reduce using rule 81 (factor -> brace .)
    COMMA           reduce using rule 81 (factor -> brace .)
    PLUS_PLUS       shift and go to state 85
    MINUS_MINUS     shift and go to state 86


state 36

    (85) brace -> INT_NUM .

    PLUS_PLUS       reduce using rule 85 (brace -> INT_NUM .)
    MINUS_MINUS     reduce using rule 85 (brace -> INT_NUM .)
    MULTIPLY        reduce using rule 85 (brace -> INT_NUM .)
    DIVIDE          reduce using rule 85 (brace -> INT_NUM .)
    MOD             reduce using rule 85 (brace -> INT_NUM .)
    PLUS            reduce using rule 85 (brace -> INT_NUM .)
    MINUS           reduce using rule 85 (brace -> INT_NUM .)
    L_SHIFT         reduce using rule 85 (brace -> INT_NUM .)
    R_SHIFT         reduce using rule 85 (brace -> INT_NUM .)
    LE              reduce using rule 85 (brace -> INT_NUM .)
    LT              reduce using rule 85 (brace -> INT_NUM .)
    GE              reduce using rule 85 (brace -> INT_NUM .)
    GT              reduce using rule 85 (brace -> INT_NUM .)
    EQ              reduce using rule 85 (brace -> INT_NUM .)
    NE              reduce using rule 85 (brace -> INT_NUM .)
    BIT_AND         reduce using rule 85 (brace -> INT_NUM .)
    BIT_XOR         reduce using rule 85 (brace -> INT_NUM .)
    BIT_OR          reduce using rule 85 (brace -> INT_NUM .)
    AND             reduce using rule 85 (brace -> INT_NUM .)
    OR              reduce using rule 85 (brace -> INT_NUM .)
    SEMICOLON       reduce using rule 85 (brace -> INT_NUM .)
    ASSIGN          reduce using rule 85 (brace -> INT_NUM .)
    PLUS_ASSIGN     reduce using rule 85 (brace -> INT_NUM .)
    MINUS_ASSIGN    reduce using rule 85 (brace -> INT_NUM .)
    MUL_ASSIGN      reduce using rule 85 (brace -> INT_NUM .)
    DIV_ASSIGN      reduce using rule 85 (brace -> INT_NUM .)
    AND_ASSIGN      reduce using rule 85 (brace -> INT_NUM .)
    OR_ASSIGN       reduce using rule 85 (brace -> INT_NUM .)
    XOR_ASSIGN      reduce using rule 85 (brace -> INT_NUM .)
    MOD_ASSIGN      reduce using rule 85 (brace -> INT_NUM .)
    L_SHIFT_ASSIGN  reduce using rule 85 (brace -> INT_NUM .)
    R_SHIFT_ASSIGN  reduce using rule 85 (brace -> INT_NUM .)
    R_PAREN         reduce using rule 85 (brace -> INT_NUM .)
    COMMA           reduce using rule 85 (brace -> INT_NUM .)


state 37

    (86) brace -> FLOAT_NUM .

    PLUS_PLUS       reduce using rule 86 (brace -> FLOAT_NUM .)
    MINUS_MINUS     reduce using rule 86 (brace -> FLOAT_NUM .)
    MULTIPLY        reduce using rule 86 (brace -> FLOAT_NUM .)
    DIVIDE          reduce using rule 86 (brace -> FLOAT_NUM .)
    MOD             reduce using rule 86 (brace -> FLOAT_NUM .)
    PLUS            reduce using rule 86 (brace -> FLOAT_NUM .)
    MINUS           reduce using rule 86 (brace -> FLOAT_NUM .)
    L_SHIFT         reduce using rule 86 (brace -> FLOAT_NUM .)
    R_SHIFT         reduce using rule 86 (brace -> FLOAT_NUM .)
    LE              reduce using rule 86 (brace -> FLOAT_NUM .)
    LT              reduce using rule 86 (brace -> FLOAT_NUM .)
    GE              reduce using rule 86 (brace -> FLOAT_NUM .)
    GT              reduce using rule 86 (brace -> FLOAT_NUM .)
    EQ              reduce using rule 86 (brace -> FLOAT_NUM .)
    NE              reduce using rule 86 (brace -> FLOAT_NUM .)
    BIT_AND         reduce using rule 86 (brace -> FLOAT_NUM .)
    BIT_XOR         reduce using rule 86 (brace -> FLOAT_NUM .)
    BIT_OR          reduce using rule 86 (brace -> FLOAT_NUM .)
    AND             reduce using rule 86 (brace -> FLOAT_NUM .)
    OR              reduce using rule 86 (brace -> FLOAT_NUM .)
    SEMICOLON       reduce using rule 86 (brace -> FLOAT_NUM .)
    ASSIGN          reduce using rule 86 (brace -> FLOAT_NUM .)
    PLUS_ASSIGN     reduce using rule 86 (brace -> FLOAT_NUM .)
    MINUS_ASSIGN    reduce using rule 86 (brace -> FLOAT_NUM .)
    MUL_ASSIGN      reduce using rule 86 (brace -> FLOAT_NUM .)
    DIV_ASSIGN      reduce using rule 86 (brace -> FLOAT_NUM .)
    AND_ASSIGN      reduce using rule 86 (brace -> FLOAT_NUM .)
    OR_ASSIGN       reduce using rule 86 (brace -> FLOAT_NUM .)
    XOR_ASSIGN      reduce using rule 86 (brace -> FLOAT_NUM .)
    MOD_ASSIGN      reduce using rule 86 (brace -> FLOAT_NUM .)
    L_SHIFT_ASSIGN  reduce using rule 86 (brace -> FLOAT_NUM .)
    R_SHIFT_ASSIGN  reduce using rule 86 (brace -> FLOAT_NUM .)
    R_PAREN         reduce using rule 86 (brace -> FLOAT_NUM .)
    COMMA           reduce using rule 86 (brace -> FLOAT_NUM .)


state 38

    (2) multiple_statements -> multiple_statements statement .

    IF              reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    WHILE           reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    FOR             reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    SEMICOLON       reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    L_FLOWBRACE     reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    TYPE            reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    NOT             reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    PLUS            reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    MINUS           reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    PLUS_PLUS       reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    MINUS_MINUS     reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    L_PAREN         reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    INT_NUM         reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    FLOAT_NUM       reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    ID              reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    $end            reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    R_FLOWBRACE     reduce using rule 2 (multiple_statements -> multiple_statements statement .)


state 39

    (6) open -> IF condition . statement
    (7) open -> IF condition . closed ELSE open
    (12) closed -> IF condition . closed ELSE closed
    (4) statement -> . open
    (5) statement -> . closed
    (10) closed -> . simple
    (11) closed -> . block
    (12) closed -> . IF condition closed ELSE closed
    (13) closed -> . WHILE condition closed
    (14) closed -> . FOR for_condition closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) open -> . FOR for_condition open
    (27) simple -> . expr SEMICOLON
    (28) simple -> . declaration
    (29) simple -> . SEMICOLON
    (30) simple -> . function
    (26) block -> . L_FLOWBRACE multiple_statements R_FLOWBRACE
    (34) expr -> . expr assignment exprOR
    (35) expr -> . exprOR
    (23) declaration -> . TYPE ID SEMICOLON
    (24) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (25) declaration -> . TYPE multi_declaration stop
    (31) function -> . TYPE ID L_PAREN R_PAREN function_2
    (47) exprOR -> . exprOR OR exprAND
    (48) exprOR -> . exprAND
    (49) exprAND -> . exprAND AND exprBITOR
    (50) exprAND -> . exprBITOR
    (51) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (52) exprBITOR -> . exprBITXOR
    (53) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (54) exprBITXOR -> . exprBITAND
    (55) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (56) exprBITAND -> . exprEQ
    (57) exprEQ -> . exprEQ EQ exprRELOP
    (58) exprEQ -> . exprEQ NE exprRELOP
    (59) exprEQ -> . exprRELOP
    (60) exprRELOP -> . exprRELOP relop exprSHIFT
    (61) exprRELOP -> . exprSHIFT
    (66) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (67) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (68) exprSHIFT -> . exprOP
    (69) exprOP -> . exprOP PLUS term
    (70) exprOP -> . exprOP MINUS term
    (71) exprOP -> . term
    (72) term -> . term MULTIPLY factor
    (73) term -> . term DIVIDE factor
    (74) term -> . term MOD factor
    (75) term -> . factor
    (76) factor -> . NOT factor
    (77) factor -> . PLUS factor
    (78) factor -> . MINUS factor
    (79) factor -> . PLUS_PLUS factor
    (80) factor -> . MINUS_MINUS factor
    (81) factor -> . brace
    (82) brace -> . L_PAREN expr R_PAREN
    (83) brace -> . brace PLUS_PLUS
    (84) brace -> . brace MINUS_MINUS
    (85) brace -> . INT_NUM
    (86) brace -> . FLOAT_NUM
    (87) brace -> . ID

    IF              shift and go to state 87
    WHILE           shift and go to state 90
    FOR             shift and go to state 91
    SEMICOLON       shift and go to state 12
    L_FLOWBRACE     shift and go to state 15
    TYPE            shift and go to state 17
    NOT             shift and go to state 32
    PLUS            shift and go to state 28
    MINUS           shift and go to state 30
    PLUS_PLUS       shift and go to state 33
    MINUS_MINUS     shift and go to state 34
    L_PAREN         shift and go to state 19
    INT_NUM         shift and go to state 36
    FLOAT_NUM       shift and go to state 37
    ID              shift and go to state 18

    statement                      shift and go to state 88
    closed                         shift and go to state 89
    open                           shift and go to state 4
    simple                         shift and go to state 9
    block                          shift and go to state 10
    expr                           shift and go to state 11
    declaration                    shift and go to state 13
    function                       shift and go to state 14
    exprOR                         shift and go to state 16
    exprAND                        shift and go to state 20
    exprBITOR                      shift and go to state 21
    exprBITXOR                     shift and go to state 22
    exprBITAND                     shift and go to state 23
    exprEQ                         shift and go to state 24
    exprRELOP                      shift and go to state 25
    exprSHIFT                      shift and go to state 26
    exprOP                         shift and go to state 27
    term                           shift and go to state 29
    factor                         shift and go to state 31
    brace                          shift and go to state 35

state 40

    (15) condition -> L_PAREN . expr R_PAREN
    (34) expr -> . expr assignment exprOR
    (35) expr -> . exprOR
    (47) exprOR -> . exprOR OR exprAND
    (48) exprOR -> . exprAND
    (49) exprAND -> . exprAND AND exprBITOR
    (50) exprAND -> . exprBITOR
    (51) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (52) exprBITOR -> . exprBITXOR
    (53) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (54) exprBITXOR -> . exprBITAND
    (55) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (56) exprBITAND -> . exprEQ
    (57) exprEQ -> . exprEQ EQ exprRELOP
    (58) exprEQ -> . exprEQ NE exprRELOP
    (59) exprEQ -> . exprRELOP
    (60) exprRELOP -> . exprRELOP relop exprSHIFT
    (61) exprRELOP -> . exprSHIFT
    (66) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (67) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (68) exprSHIFT -> . exprOP
    (69) exprOP -> . exprOP PLUS term
    (70) exprOP -> . exprOP MINUS term
    (71) exprOP -> . term
    (72) term -> . term MULTIPLY factor
    (73) term -> . term DIVIDE factor
    (74) term -> . term MOD factor
    (75) term -> . factor
    (76) factor -> . NOT factor
    (77) factor -> . PLUS factor
    (78) factor -> . MINUS factor
    (79) factor -> . PLUS_PLUS factor
    (80) factor -> . MINUS_MINUS factor
    (81) factor -> . brace
    (82) brace -> . L_PAREN expr R_PAREN
    (83) brace -> . brace PLUS_PLUS
    (84) brace -> . brace MINUS_MINUS
    (85) brace -> . INT_NUM
    (86) brace -> . FLOAT_NUM
    (87) brace -> . ID

    NOT             shift and go to state 32
    PLUS            shift and go to state 28
    MINUS           shift and go to state 30
    PLUS_PLUS       shift and go to state 33
    MINUS_MINUS     shift and go to state 34
    L_PAREN         shift and go to state 19
    INT_NUM         shift and go to state 36
    FLOAT_NUM       shift and go to state 37
    ID              shift and go to state 18

    expr                           shift and go to state 92
    exprOR                         shift and go to state 16
    exprAND                        shift and go to state 20
    exprBITOR                      shift and go to state 21
    exprBITXOR                     shift and go to state 22
    exprBITAND                     shift and go to state 23
    exprEQ                         shift and go to state 24
    exprRELOP                      shift and go to state 25
    exprSHIFT                      shift and go to state 26
    exprOP                         shift and go to state 27
    term                           shift and go to state 29
    factor                         shift and go to state 31
    brace                          shift and go to state 35

state 41

    (8) open -> WHILE condition . open
    (13) closed -> WHILE condition . closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) open -> . FOR for_condition open
    (10) closed -> . simple
    (11) closed -> . block
    (12) closed -> . IF condition closed ELSE closed
    (13) closed -> . WHILE condition closed
    (14) closed -> . FOR for_condition closed
    (27) simple -> . expr SEMICOLON
    (28) simple -> . declaration
    (29) simple -> . SEMICOLON
    (30) simple -> . function
    (26) block -> . L_FLOWBRACE multiple_statements R_FLOWBRACE
    (34) expr -> . expr assignment exprOR
    (35) expr -> . exprOR
    (23) declaration -> . TYPE ID SEMICOLON
    (24) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (25) declaration -> . TYPE multi_declaration stop
    (31) function -> . TYPE ID L_PAREN R_PAREN function_2
    (47) exprOR -> . exprOR OR exprAND
    (48) exprOR -> . exprAND
    (49) exprAND -> . exprAND AND exprBITOR
    (50) exprAND -> . exprBITOR
    (51) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (52) exprBITOR -> . exprBITXOR
    (53) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (54) exprBITXOR -> . exprBITAND
    (55) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (56) exprBITAND -> . exprEQ
    (57) exprEQ -> . exprEQ EQ exprRELOP
    (58) exprEQ -> . exprEQ NE exprRELOP
    (59) exprEQ -> . exprRELOP
    (60) exprRELOP -> . exprRELOP relop exprSHIFT
    (61) exprRELOP -> . exprSHIFT
    (66) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (67) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (68) exprSHIFT -> . exprOP
    (69) exprOP -> . exprOP PLUS term
    (70) exprOP -> . exprOP MINUS term
    (71) exprOP -> . term
    (72) term -> . term MULTIPLY factor
    (73) term -> . term DIVIDE factor
    (74) term -> . term MOD factor
    (75) term -> . factor
    (76) factor -> . NOT factor
    (77) factor -> . PLUS factor
    (78) factor -> . MINUS factor
    (79) factor -> . PLUS_PLUS factor
    (80) factor -> . MINUS_MINUS factor
    (81) factor -> . brace
    (82) brace -> . L_PAREN expr R_PAREN
    (83) brace -> . brace PLUS_PLUS
    (84) brace -> . brace MINUS_MINUS
    (85) brace -> . INT_NUM
    (86) brace -> . FLOAT_NUM
    (87) brace -> . ID

    IF              shift and go to state 6
    WHILE           shift and go to state 7
    FOR             shift and go to state 8
    SEMICOLON       shift and go to state 12
    L_FLOWBRACE     shift and go to state 15
    TYPE            shift and go to state 17
    NOT             shift and go to state 32
    PLUS            shift and go to state 28
    MINUS           shift and go to state 30
    PLUS_PLUS       shift and go to state 33
    MINUS_MINUS     shift and go to state 34
    L_PAREN         shift and go to state 19
    INT_NUM         shift and go to state 36
    FLOAT_NUM       shift and go to state 37
    ID              shift and go to state 18

    open                           shift and go to state 93
    closed                         shift and go to state 94
    simple                         shift and go to state 9
    block                          shift and go to state 10
    expr                           shift and go to state 11
    declaration                    shift and go to state 13
    function                       shift and go to state 14
    exprOR                         shift and go to state 16
    exprAND                        shift and go to state 20
    exprBITOR                      shift and go to state 21
    exprBITXOR                     shift and go to state 22
    exprBITAND                     shift and go to state 23
    exprEQ                         shift and go to state 24
    exprRELOP                      shift and go to state 25
    exprSHIFT                      shift and go to state 26
    exprOP                         shift and go to state 27
    term                           shift and go to state 29
    factor                         shift and go to state 31
    brace                          shift and go to state 35

state 42

    (9) open -> FOR for_condition . open
    (14) closed -> FOR for_condition . closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) open -> . FOR for_condition open
    (10) closed -> . simple
    (11) closed -> . block
    (12) closed -> . IF condition closed ELSE closed
    (13) closed -> . WHILE condition closed
    (14) closed -> . FOR for_condition closed
    (27) simple -> . expr SEMICOLON
    (28) simple -> . declaration
    (29) simple -> . SEMICOLON
    (30) simple -> . function
    (26) block -> . L_FLOWBRACE multiple_statements R_FLOWBRACE
    (34) expr -> . expr assignment exprOR
    (35) expr -> . exprOR
    (23) declaration -> . TYPE ID SEMICOLON
    (24) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (25) declaration -> . TYPE multi_declaration stop
    (31) function -> . TYPE ID L_PAREN R_PAREN function_2
    (47) exprOR -> . exprOR OR exprAND
    (48) exprOR -> . exprAND
    (49) exprAND -> . exprAND AND exprBITOR
    (50) exprAND -> . exprBITOR
    (51) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (52) exprBITOR -> . exprBITXOR
    (53) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (54) exprBITXOR -> . exprBITAND
    (55) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (56) exprBITAND -> . exprEQ
    (57) exprEQ -> . exprEQ EQ exprRELOP
    (58) exprEQ -> . exprEQ NE exprRELOP
    (59) exprEQ -> . exprRELOP
    (60) exprRELOP -> . exprRELOP relop exprSHIFT
    (61) exprRELOP -> . exprSHIFT
    (66) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (67) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (68) exprSHIFT -> . exprOP
    (69) exprOP -> . exprOP PLUS term
    (70) exprOP -> . exprOP MINUS term
    (71) exprOP -> . term
    (72) term -> . term MULTIPLY factor
    (73) term -> . term DIVIDE factor
    (74) term -> . term MOD factor
    (75) term -> . factor
    (76) factor -> . NOT factor
    (77) factor -> . PLUS factor
    (78) factor -> . MINUS factor
    (79) factor -> . PLUS_PLUS factor
    (80) factor -> . MINUS_MINUS factor
    (81) factor -> . brace
    (82) brace -> . L_PAREN expr R_PAREN
    (83) brace -> . brace PLUS_PLUS
    (84) brace -> . brace MINUS_MINUS
    (85) brace -> . INT_NUM
    (86) brace -> . FLOAT_NUM
    (87) brace -> . ID

    IF              shift and go to state 6
    WHILE           shift and go to state 7
    FOR             shift and go to state 8
    SEMICOLON       shift and go to state 12
    L_FLOWBRACE     shift and go to state 15
    TYPE            shift and go to state 17
    NOT             shift and go to state 32
    PLUS            shift and go to state 28
    MINUS           shift and go to state 30
    PLUS_PLUS       shift and go to state 33
    MINUS_MINUS     shift and go to state 34
    L_PAREN         shift and go to state 19
    INT_NUM         shift and go to state 36
    FLOAT_NUM       shift and go to state 37
    ID              shift and go to state 18

    open                           shift and go to state 95
    closed                         shift and go to state 96
    simple                         shift and go to state 9
    block                          shift and go to state 10
    expr                           shift and go to state 11
    declaration                    shift and go to state 13
    function                       shift and go to state 14
    exprOR                         shift and go to state 16
    exprAND                        shift and go to state 20
    exprBITOR                      shift and go to state 21
    exprBITXOR                     shift and go to state 22
    exprBITAND                     shift and go to state 23
    exprEQ                         shift and go to state 24
    exprRELOP                      shift and go to state 25
    exprSHIFT                      shift and go to state 26
    exprOP                         shift and go to state 27
    term                           shift and go to state 29
    factor                         shift and go to state 31
    brace                          shift and go to state 35

state 43

    (16) for_condition -> L_PAREN . declaration expr SEMICOLON expr R_PAREN
    (23) declaration -> . TYPE ID SEMICOLON
    (24) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (25) declaration -> . TYPE multi_declaration stop

    TYPE            shift and go to state 98

    declaration                    shift and go to state 97

state 44

    (27) simple -> expr SEMICOLON .

    IF              reduce using rule 27 (simple -> expr SEMICOLON .)
    WHILE           reduce using rule 27 (simple -> expr SEMICOLON .)
    FOR             reduce using rule 27 (simple -> expr SEMICOLON .)
    SEMICOLON       reduce using rule 27 (simple -> expr SEMICOLON .)
    L_FLOWBRACE     reduce using rule 27 (simple -> expr SEMICOLON .)
    TYPE            reduce using rule 27 (simple -> expr SEMICOLON .)
    NOT             reduce using rule 27 (simple -> expr SEMICOLON .)
    PLUS            reduce using rule 27 (simple -> expr SEMICOLON .)
    MINUS           reduce using rule 27 (simple -> expr SEMICOLON .)
    PLUS_PLUS       reduce using rule 27 (simple -> expr SEMICOLON .)
    MINUS_MINUS     reduce using rule 27 (simple -> expr SEMICOLON .)
    L_PAREN         reduce using rule 27 (simple -> expr SEMICOLON .)
    INT_NUM         reduce using rule 27 (simple -> expr SEMICOLON .)
    FLOAT_NUM       reduce using rule 27 (simple -> expr SEMICOLON .)
    ID              reduce using rule 27 (simple -> expr SEMICOLON .)
    $end            reduce using rule 27 (simple -> expr SEMICOLON .)
    R_FLOWBRACE     reduce using rule 27 (simple -> expr SEMICOLON .)
    ELSE            reduce using rule 27 (simple -> expr SEMICOLON .)


state 45

    (34) expr -> expr assignment . exprOR
    (47) exprOR -> . exprOR OR exprAND
    (48) exprOR -> . exprAND
    (49) exprAND -> . exprAND AND exprBITOR
    (50) exprAND -> . exprBITOR
    (51) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (52) exprBITOR -> . exprBITXOR
    (53) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (54) exprBITXOR -> . exprBITAND
    (55) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (56) exprBITAND -> . exprEQ
    (57) exprEQ -> . exprEQ EQ exprRELOP
    (58) exprEQ -> . exprEQ NE exprRELOP
    (59) exprEQ -> . exprRELOP
    (60) exprRELOP -> . exprRELOP relop exprSHIFT
    (61) exprRELOP -> . exprSHIFT
    (66) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (67) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (68) exprSHIFT -> . exprOP
    (69) exprOP -> . exprOP PLUS term
    (70) exprOP -> . exprOP MINUS term
    (71) exprOP -> . term
    (72) term -> . term MULTIPLY factor
    (73) term -> . term DIVIDE factor
    (74) term -> . term MOD factor
    (75) term -> . factor
    (76) factor -> . NOT factor
    (77) factor -> . PLUS factor
    (78) factor -> . MINUS factor
    (79) factor -> . PLUS_PLUS factor
    (80) factor -> . MINUS_MINUS factor
    (81) factor -> . brace
    (82) brace -> . L_PAREN expr R_PAREN
    (83) brace -> . brace PLUS_PLUS
    (84) brace -> . brace MINUS_MINUS
    (85) brace -> . INT_NUM
    (86) brace -> . FLOAT_NUM
    (87) brace -> . ID

    NOT             shift and go to state 32
    PLUS            shift and go to state 28
    MINUS           shift and go to state 30
    PLUS_PLUS       shift and go to state 33
    MINUS_MINUS     shift and go to state 34
    L_PAREN         shift and go to state 19
    INT_NUM         shift and go to state 36
    FLOAT_NUM       shift and go to state 37
    ID              shift and go to state 18

    exprOR                         shift and go to state 99
    exprAND                        shift and go to state 20
    exprBITOR                      shift and go to state 21
    exprBITXOR                     shift and go to state 22
    exprBITAND                     shift and go to state 23
    exprEQ                         shift and go to state 24
    exprRELOP                      shift and go to state 25
    exprSHIFT                      shift and go to state 26
    exprOP                         shift and go to state 27
    term                           shift and go to state 29
    factor                         shift and go to state 31
    brace                          shift and go to state 35

state 46

    (36) assignment -> ASSIGN .

    NOT             reduce using rule 36 (assignment -> ASSIGN .)
    PLUS            reduce using rule 36 (assignment -> ASSIGN .)
    MINUS           reduce using rule 36 (assignment -> ASSIGN .)
    PLUS_PLUS       reduce using rule 36 (assignment -> ASSIGN .)
    MINUS_MINUS     reduce using rule 36 (assignment -> ASSIGN .)
    L_PAREN         reduce using rule 36 (assignment -> ASSIGN .)
    INT_NUM         reduce using rule 36 (assignment -> ASSIGN .)
    FLOAT_NUM       reduce using rule 36 (assignment -> ASSIGN .)
    ID              reduce using rule 36 (assignment -> ASSIGN .)


state 47

    (37) assignment -> PLUS_ASSIGN .

    NOT             reduce using rule 37 (assignment -> PLUS_ASSIGN .)
    PLUS            reduce using rule 37 (assignment -> PLUS_ASSIGN .)
    MINUS           reduce using rule 37 (assignment -> PLUS_ASSIGN .)
    PLUS_PLUS       reduce using rule 37 (assignment -> PLUS_ASSIGN .)
    MINUS_MINUS     reduce using rule 37 (assignment -> PLUS_ASSIGN .)
    L_PAREN         reduce using rule 37 (assignment -> PLUS_ASSIGN .)
    INT_NUM         reduce using rule 37 (assignment -> PLUS_ASSIGN .)
    FLOAT_NUM       reduce using rule 37 (assignment -> PLUS_ASSIGN .)
    ID              reduce using rule 37 (assignment -> PLUS_ASSIGN .)


state 48

    (38) assignment -> MINUS_ASSIGN .

    NOT             reduce using rule 38 (assignment -> MINUS_ASSIGN .)
    PLUS            reduce using rule 38 (assignment -> MINUS_ASSIGN .)
    MINUS           reduce using rule 38 (assignment -> MINUS_ASSIGN .)
    PLUS_PLUS       reduce using rule 38 (assignment -> MINUS_ASSIGN .)
    MINUS_MINUS     reduce using rule 38 (assignment -> MINUS_ASSIGN .)
    L_PAREN         reduce using rule 38 (assignment -> MINUS_ASSIGN .)
    INT_NUM         reduce using rule 38 (assignment -> MINUS_ASSIGN .)
    FLOAT_NUM       reduce using rule 38 (assignment -> MINUS_ASSIGN .)
    ID              reduce using rule 38 (assignment -> MINUS_ASSIGN .)


state 49

    (39) assignment -> MUL_ASSIGN .

    NOT             reduce using rule 39 (assignment -> MUL_ASSIGN .)
    PLUS            reduce using rule 39 (assignment -> MUL_ASSIGN .)
    MINUS           reduce using rule 39 (assignment -> MUL_ASSIGN .)
    PLUS_PLUS       reduce using rule 39 (assignment -> MUL_ASSIGN .)
    MINUS_MINUS     reduce using rule 39 (assignment -> MUL_ASSIGN .)
    L_PAREN         reduce using rule 39 (assignment -> MUL_ASSIGN .)
    INT_NUM         reduce using rule 39 (assignment -> MUL_ASSIGN .)
    FLOAT_NUM       reduce using rule 39 (assignment -> MUL_ASSIGN .)
    ID              reduce using rule 39 (assignment -> MUL_ASSIGN .)


state 50

    (40) assignment -> DIV_ASSIGN .

    NOT             reduce using rule 40 (assignment -> DIV_ASSIGN .)
    PLUS            reduce using rule 40 (assignment -> DIV_ASSIGN .)
    MINUS           reduce using rule 40 (assignment -> DIV_ASSIGN .)
    PLUS_PLUS       reduce using rule 40 (assignment -> DIV_ASSIGN .)
    MINUS_MINUS     reduce using rule 40 (assignment -> DIV_ASSIGN .)
    L_PAREN         reduce using rule 40 (assignment -> DIV_ASSIGN .)
    INT_NUM         reduce using rule 40 (assignment -> DIV_ASSIGN .)
    FLOAT_NUM       reduce using rule 40 (assignment -> DIV_ASSIGN .)
    ID              reduce using rule 40 (assignment -> DIV_ASSIGN .)


state 51

    (41) assignment -> AND_ASSIGN .

    NOT             reduce using rule 41 (assignment -> AND_ASSIGN .)
    PLUS            reduce using rule 41 (assignment -> AND_ASSIGN .)
    MINUS           reduce using rule 41 (assignment -> AND_ASSIGN .)
    PLUS_PLUS       reduce using rule 41 (assignment -> AND_ASSIGN .)
    MINUS_MINUS     reduce using rule 41 (assignment -> AND_ASSIGN .)
    L_PAREN         reduce using rule 41 (assignment -> AND_ASSIGN .)
    INT_NUM         reduce using rule 41 (assignment -> AND_ASSIGN .)
    FLOAT_NUM       reduce using rule 41 (assignment -> AND_ASSIGN .)
    ID              reduce using rule 41 (assignment -> AND_ASSIGN .)


state 52

    (42) assignment -> OR_ASSIGN .

    NOT             reduce using rule 42 (assignment -> OR_ASSIGN .)
    PLUS            reduce using rule 42 (assignment -> OR_ASSIGN .)
    MINUS           reduce using rule 42 (assignment -> OR_ASSIGN .)
    PLUS_PLUS       reduce using rule 42 (assignment -> OR_ASSIGN .)
    MINUS_MINUS     reduce using rule 42 (assignment -> OR_ASSIGN .)
    L_PAREN         reduce using rule 42 (assignment -> OR_ASSIGN .)
    INT_NUM         reduce using rule 42 (assignment -> OR_ASSIGN .)
    FLOAT_NUM       reduce using rule 42 (assignment -> OR_ASSIGN .)
    ID              reduce using rule 42 (assignment -> OR_ASSIGN .)


state 53

    (43) assignment -> XOR_ASSIGN .

    NOT             reduce using rule 43 (assignment -> XOR_ASSIGN .)
    PLUS            reduce using rule 43 (assignment -> XOR_ASSIGN .)
    MINUS           reduce using rule 43 (assignment -> XOR_ASSIGN .)
    PLUS_PLUS       reduce using rule 43 (assignment -> XOR_ASSIGN .)
    MINUS_MINUS     reduce using rule 43 (assignment -> XOR_ASSIGN .)
    L_PAREN         reduce using rule 43 (assignment -> XOR_ASSIGN .)
    INT_NUM         reduce using rule 43 (assignment -> XOR_ASSIGN .)
    FLOAT_NUM       reduce using rule 43 (assignment -> XOR_ASSIGN .)
    ID              reduce using rule 43 (assignment -> XOR_ASSIGN .)


state 54

    (44) assignment -> MOD_ASSIGN .

    NOT             reduce using rule 44 (assignment -> MOD_ASSIGN .)
    PLUS            reduce using rule 44 (assignment -> MOD_ASSIGN .)
    MINUS           reduce using rule 44 (assignment -> MOD_ASSIGN .)
    PLUS_PLUS       reduce using rule 44 (assignment -> MOD_ASSIGN .)
    MINUS_MINUS     reduce using rule 44 (assignment -> MOD_ASSIGN .)
    L_PAREN         reduce using rule 44 (assignment -> MOD_ASSIGN .)
    INT_NUM         reduce using rule 44 (assignment -> MOD_ASSIGN .)
    FLOAT_NUM       reduce using rule 44 (assignment -> MOD_ASSIGN .)
    ID              reduce using rule 44 (assignment -> MOD_ASSIGN .)


state 55

    (45) assignment -> L_SHIFT_ASSIGN .

    NOT             reduce using rule 45 (assignment -> L_SHIFT_ASSIGN .)
    PLUS            reduce using rule 45 (assignment -> L_SHIFT_ASSIGN .)
    MINUS           reduce using rule 45 (assignment -> L_SHIFT_ASSIGN .)
    PLUS_PLUS       reduce using rule 45 (assignment -> L_SHIFT_ASSIGN .)
    MINUS_MINUS     reduce using rule 45 (assignment -> L_SHIFT_ASSIGN .)
    L_PAREN         reduce using rule 45 (assignment -> L_SHIFT_ASSIGN .)
    INT_NUM         reduce using rule 45 (assignment -> L_SHIFT_ASSIGN .)
    FLOAT_NUM       reduce using rule 45 (assignment -> L_SHIFT_ASSIGN .)
    ID              reduce using rule 45 (assignment -> L_SHIFT_ASSIGN .)


state 56

    (46) assignment -> R_SHIFT_ASSIGN .

    NOT             reduce using rule 46 (assignment -> R_SHIFT_ASSIGN .)
    PLUS            reduce using rule 46 (assignment -> R_SHIFT_ASSIGN .)
    MINUS           reduce using rule 46 (assignment -> R_SHIFT_ASSIGN .)
    PLUS_PLUS       reduce using rule 46 (assignment -> R_SHIFT_ASSIGN .)
    MINUS_MINUS     reduce using rule 46 (assignment -> R_SHIFT_ASSIGN .)
    L_PAREN         reduce using rule 46 (assignment -> R_SHIFT_ASSIGN .)
    INT_NUM         reduce using rule 46 (assignment -> R_SHIFT_ASSIGN .)
    FLOAT_NUM       reduce using rule 46 (assignment -> R_SHIFT_ASSIGN .)
    ID              reduce using rule 46 (assignment -> R_SHIFT_ASSIGN .)


state 57

    (26) block -> L_FLOWBRACE multiple_statements . R_FLOWBRACE
    (2) multiple_statements -> multiple_statements . statement
    (4) statement -> . open
    (5) statement -> . closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) open -> . FOR for_condition open
    (10) closed -> . simple
    (11) closed -> . block
    (12) closed -> . IF condition closed ELSE closed
    (13) closed -> . WHILE condition closed
    (14) closed -> . FOR for_condition closed
    (27) simple -> . expr SEMICOLON
    (28) simple -> . declaration
    (29) simple -> . SEMICOLON
    (30) simple -> . function
    (26) block -> . L_FLOWBRACE multiple_statements R_FLOWBRACE
    (34) expr -> . expr assignment exprOR
    (35) expr -> . exprOR
    (23) declaration -> . TYPE ID SEMICOLON
    (24) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (25) declaration -> . TYPE multi_declaration stop
    (31) function -> . TYPE ID L_PAREN R_PAREN function_2
    (47) exprOR -> . exprOR OR exprAND
    (48) exprOR -> . exprAND
    (49) exprAND -> . exprAND AND exprBITOR
    (50) exprAND -> . exprBITOR
    (51) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (52) exprBITOR -> . exprBITXOR
    (53) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (54) exprBITXOR -> . exprBITAND
    (55) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (56) exprBITAND -> . exprEQ
    (57) exprEQ -> . exprEQ EQ exprRELOP
    (58) exprEQ -> . exprEQ NE exprRELOP
    (59) exprEQ -> . exprRELOP
    (60) exprRELOP -> . exprRELOP relop exprSHIFT
    (61) exprRELOP -> . exprSHIFT
    (66) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (67) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (68) exprSHIFT -> . exprOP
    (69) exprOP -> . exprOP PLUS term
    (70) exprOP -> . exprOP MINUS term
    (71) exprOP -> . term
    (72) term -> . term MULTIPLY factor
    (73) term -> . term DIVIDE factor
    (74) term -> . term MOD factor
    (75) term -> . factor
    (76) factor -> . NOT factor
    (77) factor -> . PLUS factor
    (78) factor -> . MINUS factor
    (79) factor -> . PLUS_PLUS factor
    (80) factor -> . MINUS_MINUS factor
    (81) factor -> . brace
    (82) brace -> . L_PAREN expr R_PAREN
    (83) brace -> . brace PLUS_PLUS
    (84) brace -> . brace MINUS_MINUS
    (85) brace -> . INT_NUM
    (86) brace -> . FLOAT_NUM
    (87) brace -> . ID

    R_FLOWBRACE     shift and go to state 100
    IF              shift and go to state 6
    WHILE           shift and go to state 7
    FOR             shift and go to state 8
    SEMICOLON       shift and go to state 12
    L_FLOWBRACE     shift and go to state 15
    TYPE            shift and go to state 17
    NOT             shift and go to state 32
    PLUS            shift and go to state 28
    MINUS           shift and go to state 30
    PLUS_PLUS       shift and go to state 33
    MINUS_MINUS     shift and go to state 34
    L_PAREN         shift and go to state 19
    INT_NUM         shift and go to state 36
    FLOAT_NUM       shift and go to state 37
    ID              shift and go to state 18

    statement                      shift and go to state 38
    open                           shift and go to state 4
    closed                         shift and go to state 5
    simple                         shift and go to state 9
    block                          shift and go to state 10
    expr                           shift and go to state 11
    declaration                    shift and go to state 13
    function                       shift and go to state 14
    exprOR                         shift and go to state 16
    exprAND                        shift and go to state 20
    exprBITOR                      shift and go to state 21
    exprBITXOR                     shift and go to state 22
    exprBITAND                     shift and go to state 23
    exprEQ                         shift and go to state 24
    exprRELOP                      shift and go to state 25
    exprSHIFT                      shift and go to state 26
    exprOP                         shift and go to state 27
    term                           shift and go to state 29
    factor                         shift and go to state 31
    brace                          shift and go to state 35

state 58

    (47) exprOR -> exprOR OR . exprAND
    (49) exprAND -> . exprAND AND exprBITOR
    (50) exprAND -> . exprBITOR
    (51) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (52) exprBITOR -> . exprBITXOR
    (53) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (54) exprBITXOR -> . exprBITAND
    (55) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (56) exprBITAND -> . exprEQ
    (57) exprEQ -> . exprEQ EQ exprRELOP
    (58) exprEQ -> . exprEQ NE exprRELOP
    (59) exprEQ -> . exprRELOP
    (60) exprRELOP -> . exprRELOP relop exprSHIFT
    (61) exprRELOP -> . exprSHIFT
    (66) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (67) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (68) exprSHIFT -> . exprOP
    (69) exprOP -> . exprOP PLUS term
    (70) exprOP -> . exprOP MINUS term
    (71) exprOP -> . term
    (72) term -> . term MULTIPLY factor
    (73) term -> . term DIVIDE factor
    (74) term -> . term MOD factor
    (75) term -> . factor
    (76) factor -> . NOT factor
    (77) factor -> . PLUS factor
    (78) factor -> . MINUS factor
    (79) factor -> . PLUS_PLUS factor
    (80) factor -> . MINUS_MINUS factor
    (81) factor -> . brace
    (82) brace -> . L_PAREN expr R_PAREN
    (83) brace -> . brace PLUS_PLUS
    (84) brace -> . brace MINUS_MINUS
    (85) brace -> . INT_NUM
    (86) brace -> . FLOAT_NUM
    (87) brace -> . ID

    NOT             shift and go to state 32
    PLUS            shift and go to state 28
    MINUS           shift and go to state 30
    PLUS_PLUS       shift and go to state 33
    MINUS_MINUS     shift and go to state 34
    L_PAREN         shift and go to state 19
    INT_NUM         shift and go to state 36
    FLOAT_NUM       shift and go to state 37
    ID              shift and go to state 18

    exprAND                        shift and go to state 101
    exprBITOR                      shift and go to state 21
    exprBITXOR                     shift and go to state 22
    exprBITAND                     shift and go to state 23
    exprEQ                         shift and go to state 24
    exprRELOP                      shift and go to state 25
    exprSHIFT                      shift and go to state 26
    exprOP                         shift and go to state 27
    term                           shift and go to state 29
    factor                         shift and go to state 31
    brace                          shift and go to state 35

state 59

    (23) declaration -> TYPE ID . SEMICOLON
    (24) declaration -> TYPE ID . ASSIGN expr SEMICOLON
    (31) function -> TYPE ID . L_PAREN R_PAREN function_2
    (19) multi_declaration -> ID . COMMA
    (20) multi_declaration -> ID . ASSIGN expr COMMA

    SEMICOLON       shift and go to state 102
    ASSIGN          shift and go to state 103
    L_PAREN         shift and go to state 104
    COMMA           shift and go to state 105


state 60

    (25) declaration -> TYPE multi_declaration . stop
    (17) multi_declaration -> multi_declaration . ID COMMA
    (18) multi_declaration -> multi_declaration . ID ASSIGN expr COMMA
    (21) stop -> . ID SEMICOLON
    (22) stop -> . ID ASSIGN expr SEMICOLON

    ID              shift and go to state 107

    stop                           shift and go to state 106

state 61

    (82) brace -> L_PAREN expr . R_PAREN
    (34) expr -> expr . assignment exprOR
    (36) assignment -> . ASSIGN
    (37) assignment -> . PLUS_ASSIGN
    (38) assignment -> . MINUS_ASSIGN
    (39) assignment -> . MUL_ASSIGN
    (40) assignment -> . DIV_ASSIGN
    (41) assignment -> . AND_ASSIGN
    (42) assignment -> . OR_ASSIGN
    (43) assignment -> . XOR_ASSIGN
    (44) assignment -> . MOD_ASSIGN
    (45) assignment -> . L_SHIFT_ASSIGN
    (46) assignment -> . R_SHIFT_ASSIGN

    R_PAREN         shift and go to state 108
    ASSIGN          shift and go to state 46
    PLUS_ASSIGN     shift and go to state 47
    MINUS_ASSIGN    shift and go to state 48
    MUL_ASSIGN      shift and go to state 49
    DIV_ASSIGN      shift and go to state 50
    AND_ASSIGN      shift and go to state 51
    OR_ASSIGN       shift and go to state 52
    XOR_ASSIGN      shift and go to state 53
    MOD_ASSIGN      shift and go to state 54
    L_SHIFT_ASSIGN  shift and go to state 55
    R_SHIFT_ASSIGN  shift and go to state 56

    assignment                     shift and go to state 45

state 62

    (49) exprAND -> exprAND AND . exprBITOR
    (51) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (52) exprBITOR -> . exprBITXOR
    (53) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (54) exprBITXOR -> . exprBITAND
    (55) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (56) exprBITAND -> . exprEQ
    (57) exprEQ -> . exprEQ EQ exprRELOP
    (58) exprEQ -> . exprEQ NE exprRELOP
    (59) exprEQ -> . exprRELOP
    (60) exprRELOP -> . exprRELOP relop exprSHIFT
    (61) exprRELOP -> . exprSHIFT
    (66) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (67) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (68) exprSHIFT -> . exprOP
    (69) exprOP -> . exprOP PLUS term
    (70) exprOP -> . exprOP MINUS term
    (71) exprOP -> . term
    (72) term -> . term MULTIPLY factor
    (73) term -> . term DIVIDE factor
    (74) term -> . term MOD factor
    (75) term -> . factor
    (76) factor -> . NOT factor
    (77) factor -> . PLUS factor
    (78) factor -> . MINUS factor
    (79) factor -> . PLUS_PLUS factor
    (80) factor -> . MINUS_MINUS factor
    (81) factor -> . brace
    (82) brace -> . L_PAREN expr R_PAREN
    (83) brace -> . brace PLUS_PLUS
    (84) brace -> . brace MINUS_MINUS
    (85) brace -> . INT_NUM
    (86) brace -> . FLOAT_NUM
    (87) brace -> . ID

    NOT             shift and go to state 32
    PLUS            shift and go to state 28
    MINUS           shift and go to state 30
    PLUS_PLUS       shift and go to state 33
    MINUS_MINUS     shift and go to state 34
    L_PAREN         shift and go to state 19
    INT_NUM         shift and go to state 36
    FLOAT_NUM       shift and go to state 37
    ID              shift and go to state 18

    exprBITOR                      shift and go to state 109
    exprBITXOR                     shift and go to state 22
    exprBITAND                     shift and go to state 23
    exprEQ                         shift and go to state 24
    exprRELOP                      shift and go to state 25
    exprSHIFT                      shift and go to state 26
    exprOP                         shift and go to state 27
    term                           shift and go to state 29
    factor                         shift and go to state 31
    brace                          shift and go to state 35

state 63

    (51) exprBITOR -> exprBITOR BIT_OR . exprBITXOR
    (53) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (54) exprBITXOR -> . exprBITAND
    (55) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (56) exprBITAND -> . exprEQ
    (57) exprEQ -> . exprEQ EQ exprRELOP
    (58) exprEQ -> . exprEQ NE exprRELOP
    (59) exprEQ -> . exprRELOP
    (60) exprRELOP -> . exprRELOP relop exprSHIFT
    (61) exprRELOP -> . exprSHIFT
    (66) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (67) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (68) exprSHIFT -> . exprOP
    (69) exprOP -> . exprOP PLUS term
    (70) exprOP -> . exprOP MINUS term
    (71) exprOP -> . term
    (72) term -> . term MULTIPLY factor
    (73) term -> . term DIVIDE factor
    (74) term -> . term MOD factor
    (75) term -> . factor
    (76) factor -> . NOT factor
    (77) factor -> . PLUS factor
    (78) factor -> . MINUS factor
    (79) factor -> . PLUS_PLUS factor
    (80) factor -> . MINUS_MINUS factor
    (81) factor -> . brace
    (82) brace -> . L_PAREN expr R_PAREN
    (83) brace -> . brace PLUS_PLUS
    (84) brace -> . brace MINUS_MINUS
    (85) brace -> . INT_NUM
    (86) brace -> . FLOAT_NUM
    (87) brace -> . ID

    NOT             shift and go to state 32
    PLUS            shift and go to state 28
    MINUS           shift and go to state 30
    PLUS_PLUS       shift and go to state 33
    MINUS_MINUS     shift and go to state 34
    L_PAREN         shift and go to state 19
    INT_NUM         shift and go to state 36
    FLOAT_NUM       shift and go to state 37
    ID              shift and go to state 18

    exprBITXOR                     shift and go to state 110
    exprBITAND                     shift and go to state 23
    exprEQ                         shift and go to state 24
    exprRELOP                      shift and go to state 25
    exprSHIFT                      shift and go to state 26
    exprOP                         shift and go to state 27
    term                           shift and go to state 29
    factor                         shift and go to state 31
    brace                          shift and go to state 35

state 64

    (53) exprBITXOR -> exprBITXOR BIT_XOR . exprBITAND
    (55) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (56) exprBITAND -> . exprEQ
    (57) exprEQ -> . exprEQ EQ exprRELOP
    (58) exprEQ -> . exprEQ NE exprRELOP
    (59) exprEQ -> . exprRELOP
    (60) exprRELOP -> . exprRELOP relop exprSHIFT
    (61) exprRELOP -> . exprSHIFT
    (66) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (67) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (68) exprSHIFT -> . exprOP
    (69) exprOP -> . exprOP PLUS term
    (70) exprOP -> . exprOP MINUS term
    (71) exprOP -> . term
    (72) term -> . term MULTIPLY factor
    (73) term -> . term DIVIDE factor
    (74) term -> . term MOD factor
    (75) term -> . factor
    (76) factor -> . NOT factor
    (77) factor -> . PLUS factor
    (78) factor -> . MINUS factor
    (79) factor -> . PLUS_PLUS factor
    (80) factor -> . MINUS_MINUS factor
    (81) factor -> . brace
    (82) brace -> . L_PAREN expr R_PAREN
    (83) brace -> . brace PLUS_PLUS
    (84) brace -> . brace MINUS_MINUS
    (85) brace -> . INT_NUM
    (86) brace -> . FLOAT_NUM
    (87) brace -> . ID

    NOT             shift and go to state 32
    PLUS            shift and go to state 28
    MINUS           shift and go to state 30
    PLUS_PLUS       shift and go to state 33
    MINUS_MINUS     shift and go to state 34
    L_PAREN         shift and go to state 19
    INT_NUM         shift and go to state 36
    FLOAT_NUM       shift and go to state 37
    ID              shift and go to state 18

    exprBITAND                     shift and go to state 111
    exprEQ                         shift and go to state 24
    exprRELOP                      shift and go to state 25
    exprSHIFT                      shift and go to state 26
    exprOP                         shift and go to state 27
    term                           shift and go to state 29
    factor                         shift and go to state 31
    brace                          shift and go to state 35

state 65

    (55) exprBITAND -> exprBITAND BIT_AND . exprEQ
    (57) exprEQ -> . exprEQ EQ exprRELOP
    (58) exprEQ -> . exprEQ NE exprRELOP
    (59) exprEQ -> . exprRELOP
    (60) exprRELOP -> . exprRELOP relop exprSHIFT
    (61) exprRELOP -> . exprSHIFT
    (66) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (67) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (68) exprSHIFT -> . exprOP
    (69) exprOP -> . exprOP PLUS term
    (70) exprOP -> . exprOP MINUS term
    (71) exprOP -> . term
    (72) term -> . term MULTIPLY factor
    (73) term -> . term DIVIDE factor
    (74) term -> . term MOD factor
    (75) term -> . factor
    (76) factor -> . NOT factor
    (77) factor -> . PLUS factor
    (78) factor -> . MINUS factor
    (79) factor -> . PLUS_PLUS factor
    (80) factor -> . MINUS_MINUS factor
    (81) factor -> . brace
    (82) brace -> . L_PAREN expr R_PAREN
    (83) brace -> . brace PLUS_PLUS
    (84) brace -> . brace MINUS_MINUS
    (85) brace -> . INT_NUM
    (86) brace -> . FLOAT_NUM
    (87) brace -> . ID

    NOT             shift and go to state 32
    PLUS            shift and go to state 28
    MINUS           shift and go to state 30
    PLUS_PLUS       shift and go to state 33
    MINUS_MINUS     shift and go to state 34
    L_PAREN         shift and go to state 19
    INT_NUM         shift and go to state 36
    FLOAT_NUM       shift and go to state 37
    ID              shift and go to state 18

    exprEQ                         shift and go to state 112
    exprRELOP                      shift and go to state 25
    exprSHIFT                      shift and go to state 26
    exprOP                         shift and go to state 27
    term                           shift and go to state 29
    factor                         shift and go to state 31
    brace                          shift and go to state 35

state 66

    (57) exprEQ -> exprEQ EQ . exprRELOP
    (60) exprRELOP -> . exprRELOP relop exprSHIFT
    (61) exprRELOP -> . exprSHIFT
    (66) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (67) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (68) exprSHIFT -> . exprOP
    (69) exprOP -> . exprOP PLUS term
    (70) exprOP -> . exprOP MINUS term
    (71) exprOP -> . term
    (72) term -> . term MULTIPLY factor
    (73) term -> . term DIVIDE factor
    (74) term -> . term MOD factor
    (75) term -> . factor
    (76) factor -> . NOT factor
    (77) factor -> . PLUS factor
    (78) factor -> . MINUS factor
    (79) factor -> . PLUS_PLUS factor
    (80) factor -> . MINUS_MINUS factor
    (81) factor -> . brace
    (82) brace -> . L_PAREN expr R_PAREN
    (83) brace -> . brace PLUS_PLUS
    (84) brace -> . brace MINUS_MINUS
    (85) brace -> . INT_NUM
    (86) brace -> . FLOAT_NUM
    (87) brace -> . ID

    NOT             shift and go to state 32
    PLUS            shift and go to state 28
    MINUS           shift and go to state 30
    PLUS_PLUS       shift and go to state 33
    MINUS_MINUS     shift and go to state 34
    L_PAREN         shift and go to state 19
    INT_NUM         shift and go to state 36
    FLOAT_NUM       shift and go to state 37
    ID              shift and go to state 18

    exprRELOP                      shift and go to state 113
    exprSHIFT                      shift and go to state 26
    exprOP                         shift and go to state 27
    term                           shift and go to state 29
    factor                         shift and go to state 31
    brace                          shift and go to state 35

state 67

    (58) exprEQ -> exprEQ NE . exprRELOP
    (60) exprRELOP -> . exprRELOP relop exprSHIFT
    (61) exprRELOP -> . exprSHIFT
    (66) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (67) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (68) exprSHIFT -> . exprOP
    (69) exprOP -> . exprOP PLUS term
    (70) exprOP -> . exprOP MINUS term
    (71) exprOP -> . term
    (72) term -> . term MULTIPLY factor
    (73) term -> . term DIVIDE factor
    (74) term -> . term MOD factor
    (75) term -> . factor
    (76) factor -> . NOT factor
    (77) factor -> . PLUS factor
    (78) factor -> . MINUS factor
    (79) factor -> . PLUS_PLUS factor
    (80) factor -> . MINUS_MINUS factor
    (81) factor -> . brace
    (82) brace -> . L_PAREN expr R_PAREN
    (83) brace -> . brace PLUS_PLUS
    (84) brace -> . brace MINUS_MINUS
    (85) brace -> . INT_NUM
    (86) brace -> . FLOAT_NUM
    (87) brace -> . ID

    NOT             shift and go to state 32
    PLUS            shift and go to state 28
    MINUS           shift and go to state 30
    PLUS_PLUS       shift and go to state 33
    MINUS_MINUS     shift and go to state 34
    L_PAREN         shift and go to state 19
    INT_NUM         shift and go to state 36
    FLOAT_NUM       shift and go to state 37
    ID              shift and go to state 18

    exprRELOP                      shift and go to state 114
    exprSHIFT                      shift and go to state 26
    exprOP                         shift and go to state 27
    term                           shift and go to state 29
    factor                         shift and go to state 31
    brace                          shift and go to state 35

state 68

    (60) exprRELOP -> exprRELOP relop . exprSHIFT
    (66) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (67) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (68) exprSHIFT -> . exprOP
    (69) exprOP -> . exprOP PLUS term
    (70) exprOP -> . exprOP MINUS term
    (71) exprOP -> . term
    (72) term -> . term MULTIPLY factor
    (73) term -> . term DIVIDE factor
    (74) term -> . term MOD factor
    (75) term -> . factor
    (76) factor -> . NOT factor
    (77) factor -> . PLUS factor
    (78) factor -> . MINUS factor
    (79) factor -> . PLUS_PLUS factor
    (80) factor -> . MINUS_MINUS factor
    (81) factor -> . brace
    (82) brace -> . L_PAREN expr R_PAREN
    (83) brace -> . brace PLUS_PLUS
    (84) brace -> . brace MINUS_MINUS
    (85) brace -> . INT_NUM
    (86) brace -> . FLOAT_NUM
    (87) brace -> . ID

    NOT             shift and go to state 32
    PLUS            shift and go to state 28
    MINUS           shift and go to state 30
    PLUS_PLUS       shift and go to state 33
    MINUS_MINUS     shift and go to state 34
    L_PAREN         shift and go to state 19
    INT_NUM         shift and go to state 36
    FLOAT_NUM       shift and go to state 37
    ID              shift and go to state 18

    exprSHIFT                      shift and go to state 115
    exprOP                         shift and go to state 27
    term                           shift and go to state 29
    factor                         shift and go to state 31
    brace                          shift and go to state 35

state 69

    (62) relop -> LE .

    NOT             reduce using rule 62 (relop -> LE .)
    PLUS            reduce using rule 62 (relop -> LE .)
    MINUS           reduce using rule 62 (relop -> LE .)
    PLUS_PLUS       reduce using rule 62 (relop -> LE .)
    MINUS_MINUS     reduce using rule 62 (relop -> LE .)
    L_PAREN         reduce using rule 62 (relop -> LE .)
    INT_NUM         reduce using rule 62 (relop -> LE .)
    FLOAT_NUM       reduce using rule 62 (relop -> LE .)
    ID              reduce using rule 62 (relop -> LE .)


state 70

    (63) relop -> LT .

    NOT             reduce using rule 63 (relop -> LT .)
    PLUS            reduce using rule 63 (relop -> LT .)
    MINUS           reduce using rule 63 (relop -> LT .)
    PLUS_PLUS       reduce using rule 63 (relop -> LT .)
    MINUS_MINUS     reduce using rule 63 (relop -> LT .)
    L_PAREN         reduce using rule 63 (relop -> LT .)
    INT_NUM         reduce using rule 63 (relop -> LT .)
    FLOAT_NUM       reduce using rule 63 (relop -> LT .)
    ID              reduce using rule 63 (relop -> LT .)


state 71

    (64) relop -> GE .

    NOT             reduce using rule 64 (relop -> GE .)
    PLUS            reduce using rule 64 (relop -> GE .)
    MINUS           reduce using rule 64 (relop -> GE .)
    PLUS_PLUS       reduce using rule 64 (relop -> GE .)
    MINUS_MINUS     reduce using rule 64 (relop -> GE .)
    L_PAREN         reduce using rule 64 (relop -> GE .)
    INT_NUM         reduce using rule 64 (relop -> GE .)
    FLOAT_NUM       reduce using rule 64 (relop -> GE .)
    ID              reduce using rule 64 (relop -> GE .)


state 72

    (65) relop -> GT .

    NOT             reduce using rule 65 (relop -> GT .)
    PLUS            reduce using rule 65 (relop -> GT .)
    MINUS           reduce using rule 65 (relop -> GT .)
    PLUS_PLUS       reduce using rule 65 (relop -> GT .)
    MINUS_MINUS     reduce using rule 65 (relop -> GT .)
    L_PAREN         reduce using rule 65 (relop -> GT .)
    INT_NUM         reduce using rule 65 (relop -> GT .)
    FLOAT_NUM       reduce using rule 65 (relop -> GT .)
    ID              reduce using rule 65 (relop -> GT .)


state 73

    (66) exprSHIFT -> exprSHIFT L_SHIFT . exprOP
    (69) exprOP -> . exprOP PLUS term
    (70) exprOP -> . exprOP MINUS term
    (71) exprOP -> . term
    (72) term -> . term MULTIPLY factor
    (73) term -> . term DIVIDE factor
    (74) term -> . term MOD factor
    (75) term -> . factor
    (76) factor -> . NOT factor
    (77) factor -> . PLUS factor
    (78) factor -> . MINUS factor
    (79) factor -> . PLUS_PLUS factor
    (80) factor -> . MINUS_MINUS factor
    (81) factor -> . brace
    (82) brace -> . L_PAREN expr R_PAREN
    (83) brace -> . brace PLUS_PLUS
    (84) brace -> . brace MINUS_MINUS
    (85) brace -> . INT_NUM
    (86) brace -> . FLOAT_NUM
    (87) brace -> . ID

    NOT             shift and go to state 32
    PLUS            shift and go to state 28
    MINUS           shift and go to state 30
    PLUS_PLUS       shift and go to state 33
    MINUS_MINUS     shift and go to state 34
    L_PAREN         shift and go to state 19
    INT_NUM         shift and go to state 36
    FLOAT_NUM       shift and go to state 37
    ID              shift and go to state 18

    exprOP                         shift and go to state 116
    term                           shift and go to state 29
    factor                         shift and go to state 31
    brace                          shift and go to state 35

state 74

    (67) exprSHIFT -> exprSHIFT R_SHIFT . exprOP
    (69) exprOP -> . exprOP PLUS term
    (70) exprOP -> . exprOP MINUS term
    (71) exprOP -> . term
    (72) term -> . term MULTIPLY factor
    (73) term -> . term DIVIDE factor
    (74) term -> . term MOD factor
    (75) term -> . factor
    (76) factor -> . NOT factor
    (77) factor -> . PLUS factor
    (78) factor -> . MINUS factor
    (79) factor -> . PLUS_PLUS factor
    (80) factor -> . MINUS_MINUS factor
    (81) factor -> . brace
    (82) brace -> . L_PAREN expr R_PAREN
    (83) brace -> . brace PLUS_PLUS
    (84) brace -> . brace MINUS_MINUS
    (85) brace -> . INT_NUM
    (86) brace -> . FLOAT_NUM
    (87) brace -> . ID

    NOT             shift and go to state 32
    PLUS            shift and go to state 28
    MINUS           shift and go to state 30
    PLUS_PLUS       shift and go to state 33
    MINUS_MINUS     shift and go to state 34
    L_PAREN         shift and go to state 19
    INT_NUM         shift and go to state 36
    FLOAT_NUM       shift and go to state 37
    ID              shift and go to state 18

    exprOP                         shift and go to state 117
    term                           shift and go to state 29
    factor                         shift and go to state 31
    brace                          shift and go to state 35

state 75

    (69) exprOP -> exprOP PLUS . term
    (72) term -> . term MULTIPLY factor
    (73) term -> . term DIVIDE factor
    (74) term -> . term MOD factor
    (75) term -> . factor
    (76) factor -> . NOT factor
    (77) factor -> . PLUS factor
    (78) factor -> . MINUS factor
    (79) factor -> . PLUS_PLUS factor
    (80) factor -> . MINUS_MINUS factor
    (81) factor -> . brace
    (82) brace -> . L_PAREN expr R_PAREN
    (83) brace -> . brace PLUS_PLUS
    (84) brace -> . brace MINUS_MINUS
    (85) brace -> . INT_NUM
    (86) brace -> . FLOAT_NUM
    (87) brace -> . ID

    NOT             shift and go to state 32
    PLUS            shift and go to state 28
    MINUS           shift and go to state 30
    PLUS_PLUS       shift and go to state 33
    MINUS_MINUS     shift and go to state 34
    L_PAREN         shift and go to state 19
    INT_NUM         shift and go to state 36
    FLOAT_NUM       shift and go to state 37
    ID              shift and go to state 18

    term                           shift and go to state 118
    factor                         shift and go to state 31
    brace                          shift and go to state 35

state 76

    (70) exprOP -> exprOP MINUS . term
    (72) term -> . term MULTIPLY factor
    (73) term -> . term DIVIDE factor
    (74) term -> . term MOD factor
    (75) term -> . factor
    (76) factor -> . NOT factor
    (77) factor -> . PLUS factor
    (78) factor -> . MINUS factor
    (79) factor -> . PLUS_PLUS factor
    (80) factor -> . MINUS_MINUS factor
    (81) factor -> . brace
    (82) brace -> . L_PAREN expr R_PAREN
    (83) brace -> . brace PLUS_PLUS
    (84) brace -> . brace MINUS_MINUS
    (85) brace -> . INT_NUM
    (86) brace -> . FLOAT_NUM
    (87) brace -> . ID

    NOT             shift and go to state 32
    PLUS            shift and go to state 28
    MINUS           shift and go to state 30
    PLUS_PLUS       shift and go to state 33
    MINUS_MINUS     shift and go to state 34
    L_PAREN         shift and go to state 19
    INT_NUM         shift and go to state 36
    FLOAT_NUM       shift and go to state 37
    ID              shift and go to state 18

    term                           shift and go to state 119
    factor                         shift and go to state 31
    brace                          shift and go to state 35

state 77

    (77) factor -> PLUS factor .

    MULTIPLY        reduce using rule 77 (factor -> PLUS factor .)
    DIVIDE          reduce using rule 77 (factor -> PLUS factor .)
    MOD             reduce using rule 77 (factor -> PLUS factor .)
    PLUS            reduce using rule 77 (factor -> PLUS factor .)
    MINUS           reduce using rule 77 (factor -> PLUS factor .)
    L_SHIFT         reduce using rule 77 (factor -> PLUS factor .)
    R_SHIFT         reduce using rule 77 (factor -> PLUS factor .)
    LE              reduce using rule 77 (factor -> PLUS factor .)
    LT              reduce using rule 77 (factor -> PLUS factor .)
    GE              reduce using rule 77 (factor -> PLUS factor .)
    GT              reduce using rule 77 (factor -> PLUS factor .)
    EQ              reduce using rule 77 (factor -> PLUS factor .)
    NE              reduce using rule 77 (factor -> PLUS factor .)
    BIT_AND         reduce using rule 77 (factor -> PLUS factor .)
    BIT_XOR         reduce using rule 77 (factor -> PLUS factor .)
    BIT_OR          reduce using rule 77 (factor -> PLUS factor .)
    AND             reduce using rule 77 (factor -> PLUS factor .)
    OR              reduce using rule 77 (factor -> PLUS factor .)
    SEMICOLON       reduce using rule 77 (factor -> PLUS factor .)
    ASSIGN          reduce using rule 77 (factor -> PLUS factor .)
    PLUS_ASSIGN     reduce using rule 77 (factor -> PLUS factor .)
    MINUS_ASSIGN    reduce using rule 77 (factor -> PLUS factor .)
    MUL_ASSIGN      reduce using rule 77 (factor -> PLUS factor .)
    DIV_ASSIGN      reduce using rule 77 (factor -> PLUS factor .)
    AND_ASSIGN      reduce using rule 77 (factor -> PLUS factor .)
    OR_ASSIGN       reduce using rule 77 (factor -> PLUS factor .)
    XOR_ASSIGN      reduce using rule 77 (factor -> PLUS factor .)
    MOD_ASSIGN      reduce using rule 77 (factor -> PLUS factor .)
    L_SHIFT_ASSIGN  reduce using rule 77 (factor -> PLUS factor .)
    R_SHIFT_ASSIGN  reduce using rule 77 (factor -> PLUS factor .)
    R_PAREN         reduce using rule 77 (factor -> PLUS factor .)
    COMMA           reduce using rule 77 (factor -> PLUS factor .)


state 78

    (72) term -> term MULTIPLY . factor
    (76) factor -> . NOT factor
    (77) factor -> . PLUS factor
    (78) factor -> . MINUS factor
    (79) factor -> . PLUS_PLUS factor
    (80) factor -> . MINUS_MINUS factor
    (81) factor -> . brace
    (82) brace -> . L_PAREN expr R_PAREN
    (83) brace -> . brace PLUS_PLUS
    (84) brace -> . brace MINUS_MINUS
    (85) brace -> . INT_NUM
    (86) brace -> . FLOAT_NUM
    (87) brace -> . ID

    NOT             shift and go to state 32
    PLUS            shift and go to state 28
    MINUS           shift and go to state 30
    PLUS_PLUS       shift and go to state 33
    MINUS_MINUS     shift and go to state 34
    L_PAREN         shift and go to state 19
    INT_NUM         shift and go to state 36
    FLOAT_NUM       shift and go to state 37
    ID              shift and go to state 18

    factor                         shift and go to state 120
    brace                          shift and go to state 35

state 79

    (73) term -> term DIVIDE . factor
    (76) factor -> . NOT factor
    (77) factor -> . PLUS factor
    (78) factor -> . MINUS factor
    (79) factor -> . PLUS_PLUS factor
    (80) factor -> . MINUS_MINUS factor
    (81) factor -> . brace
    (82) brace -> . L_PAREN expr R_PAREN
    (83) brace -> . brace PLUS_PLUS
    (84) brace -> . brace MINUS_MINUS
    (85) brace -> . INT_NUM
    (86) brace -> . FLOAT_NUM
    (87) brace -> . ID

    NOT             shift and go to state 32
    PLUS            shift and go to state 28
    MINUS           shift and go to state 30
    PLUS_PLUS       shift and go to state 33
    MINUS_MINUS     shift and go to state 34
    L_PAREN         shift and go to state 19
    INT_NUM         shift and go to state 36
    FLOAT_NUM       shift and go to state 37
    ID              shift and go to state 18

    factor                         shift and go to state 121
    brace                          shift and go to state 35

state 80

    (74) term -> term MOD . factor
    (76) factor -> . NOT factor
    (77) factor -> . PLUS factor
    (78) factor -> . MINUS factor
    (79) factor -> . PLUS_PLUS factor
    (80) factor -> . MINUS_MINUS factor
    (81) factor -> . brace
    (82) brace -> . L_PAREN expr R_PAREN
    (83) brace -> . brace PLUS_PLUS
    (84) brace -> . brace MINUS_MINUS
    (85) brace -> . INT_NUM
    (86) brace -> . FLOAT_NUM
    (87) brace -> . ID

    NOT             shift and go to state 32
    PLUS            shift and go to state 28
    MINUS           shift and go to state 30
    PLUS_PLUS       shift and go to state 33
    MINUS_MINUS     shift and go to state 34
    L_PAREN         shift and go to state 19
    INT_NUM         shift and go to state 36
    FLOAT_NUM       shift and go to state 37
    ID              shift and go to state 18

    factor                         shift and go to state 122
    brace                          shift and go to state 35

state 81

    (78) factor -> MINUS factor .

    MULTIPLY        reduce using rule 78 (factor -> MINUS factor .)
    DIVIDE          reduce using rule 78 (factor -> MINUS factor .)
    MOD             reduce using rule 78 (factor -> MINUS factor .)
    PLUS            reduce using rule 78 (factor -> MINUS factor .)
    MINUS           reduce using rule 78 (factor -> MINUS factor .)
    L_SHIFT         reduce using rule 78 (factor -> MINUS factor .)
    R_SHIFT         reduce using rule 78 (factor -> MINUS factor .)
    LE              reduce using rule 78 (factor -> MINUS factor .)
    LT              reduce using rule 78 (factor -> MINUS factor .)
    GE              reduce using rule 78 (factor -> MINUS factor .)
    GT              reduce using rule 78 (factor -> MINUS factor .)
    EQ              reduce using rule 78 (factor -> MINUS factor .)
    NE              reduce using rule 78 (factor -> MINUS factor .)
    BIT_AND         reduce using rule 78 (factor -> MINUS factor .)
    BIT_XOR         reduce using rule 78 (factor -> MINUS factor .)
    BIT_OR          reduce using rule 78 (factor -> MINUS factor .)
    AND             reduce using rule 78 (factor -> MINUS factor .)
    OR              reduce using rule 78 (factor -> MINUS factor .)
    SEMICOLON       reduce using rule 78 (factor -> MINUS factor .)
    ASSIGN          reduce using rule 78 (factor -> MINUS factor .)
    PLUS_ASSIGN     reduce using rule 78 (factor -> MINUS factor .)
    MINUS_ASSIGN    reduce using rule 78 (factor -> MINUS factor .)
    MUL_ASSIGN      reduce using rule 78 (factor -> MINUS factor .)
    DIV_ASSIGN      reduce using rule 78 (factor -> MINUS factor .)
    AND_ASSIGN      reduce using rule 78 (factor -> MINUS factor .)
    OR_ASSIGN       reduce using rule 78 (factor -> MINUS factor .)
    XOR_ASSIGN      reduce using rule 78 (factor -> MINUS factor .)
    MOD_ASSIGN      reduce using rule 78 (factor -> MINUS factor .)
    L_SHIFT_ASSIGN  reduce using rule 78 (factor -> MINUS factor .)
    R_SHIFT_ASSIGN  reduce using rule 78 (factor -> MINUS factor .)
    R_PAREN         reduce using rule 78 (factor -> MINUS factor .)
    COMMA           reduce using rule 78 (factor -> MINUS factor .)


state 82

    (76) factor -> NOT factor .

    MULTIPLY        reduce using rule 76 (factor -> NOT factor .)
    DIVIDE          reduce using rule 76 (factor -> NOT factor .)
    MOD             reduce using rule 76 (factor -> NOT factor .)
    PLUS            reduce using rule 76 (factor -> NOT factor .)
    MINUS           reduce using rule 76 (factor -> NOT factor .)
    L_SHIFT         reduce using rule 76 (factor -> NOT factor .)
    R_SHIFT         reduce using rule 76 (factor -> NOT factor .)
    LE              reduce using rule 76 (factor -> NOT factor .)
    LT              reduce using rule 76 (factor -> NOT factor .)
    GE              reduce using rule 76 (factor -> NOT factor .)
    GT              reduce using rule 76 (factor -> NOT factor .)
    EQ              reduce using rule 76 (factor -> NOT factor .)
    NE              reduce using rule 76 (factor -> NOT factor .)
    BIT_AND         reduce using rule 76 (factor -> NOT factor .)
    BIT_XOR         reduce using rule 76 (factor -> NOT factor .)
    BIT_OR          reduce using rule 76 (factor -> NOT factor .)
    AND             reduce using rule 76 (factor -> NOT factor .)
    OR              reduce using rule 76 (factor -> NOT factor .)
    SEMICOLON       reduce using rule 76 (factor -> NOT factor .)
    ASSIGN          reduce using rule 76 (factor -> NOT factor .)
    PLUS_ASSIGN     reduce using rule 76 (factor -> NOT factor .)
    MINUS_ASSIGN    reduce using rule 76 (factor -> NOT factor .)
    MUL_ASSIGN      reduce using rule 76 (factor -> NOT factor .)
    DIV_ASSIGN      reduce using rule 76 (factor -> NOT factor .)
    AND_ASSIGN      reduce using rule 76 (factor -> NOT factor .)
    OR_ASSIGN       reduce using rule 76 (factor -> NOT factor .)
    XOR_ASSIGN      reduce using rule 76 (factor -> NOT factor .)
    MOD_ASSIGN      reduce using rule 76 (factor -> NOT factor .)
    L_SHIFT_ASSIGN  reduce using rule 76 (factor -> NOT factor .)
    R_SHIFT_ASSIGN  reduce using rule 76 (factor -> NOT factor .)
    R_PAREN         reduce using rule 76 (factor -> NOT factor .)
    COMMA           reduce using rule 76 (factor -> NOT factor .)


state 83

    (79) factor -> PLUS_PLUS factor .

    MULTIPLY        reduce using rule 79 (factor -> PLUS_PLUS factor .)
    DIVIDE          reduce using rule 79 (factor -> PLUS_PLUS factor .)
    MOD             reduce using rule 79 (factor -> PLUS_PLUS factor .)
    PLUS            reduce using rule 79 (factor -> PLUS_PLUS factor .)
    MINUS           reduce using rule 79 (factor -> PLUS_PLUS factor .)
    L_SHIFT         reduce using rule 79 (factor -> PLUS_PLUS factor .)
    R_SHIFT         reduce using rule 79 (factor -> PLUS_PLUS factor .)
    LE              reduce using rule 79 (factor -> PLUS_PLUS factor .)
    LT              reduce using rule 79 (factor -> PLUS_PLUS factor .)
    GE              reduce using rule 79 (factor -> PLUS_PLUS factor .)
    GT              reduce using rule 79 (factor -> PLUS_PLUS factor .)
    EQ              reduce using rule 79 (factor -> PLUS_PLUS factor .)
    NE              reduce using rule 79 (factor -> PLUS_PLUS factor .)
    BIT_AND         reduce using rule 79 (factor -> PLUS_PLUS factor .)
    BIT_XOR         reduce using rule 79 (factor -> PLUS_PLUS factor .)
    BIT_OR          reduce using rule 79 (factor -> PLUS_PLUS factor .)
    AND             reduce using rule 79 (factor -> PLUS_PLUS factor .)
    OR              reduce using rule 79 (factor -> PLUS_PLUS factor .)
    SEMICOLON       reduce using rule 79 (factor -> PLUS_PLUS factor .)
    ASSIGN          reduce using rule 79 (factor -> PLUS_PLUS factor .)
    PLUS_ASSIGN     reduce using rule 79 (factor -> PLUS_PLUS factor .)
    MINUS_ASSIGN    reduce using rule 79 (factor -> PLUS_PLUS factor .)
    MUL_ASSIGN      reduce using rule 79 (factor -> PLUS_PLUS factor .)
    DIV_ASSIGN      reduce using rule 79 (factor -> PLUS_PLUS factor .)
    AND_ASSIGN      reduce using rule 79 (factor -> PLUS_PLUS factor .)
    OR_ASSIGN       reduce using rule 79 (factor -> PLUS_PLUS factor .)
    XOR_ASSIGN      reduce using rule 79 (factor -> PLUS_PLUS factor .)
    MOD_ASSIGN      reduce using rule 79 (factor -> PLUS_PLUS factor .)
    L_SHIFT_ASSIGN  reduce using rule 79 (factor -> PLUS_PLUS factor .)
    R_SHIFT_ASSIGN  reduce using rule 79 (factor -> PLUS_PLUS factor .)
    R_PAREN         reduce using rule 79 (factor -> PLUS_PLUS factor .)
    COMMA           reduce using rule 79 (factor -> PLUS_PLUS factor .)


state 84

    (80) factor -> MINUS_MINUS factor .

    MULTIPLY        reduce using rule 80 (factor -> MINUS_MINUS factor .)
    DIVIDE          reduce using rule 80 (factor -> MINUS_MINUS factor .)
    MOD             reduce using rule 80 (factor -> MINUS_MINUS factor .)
    PLUS            reduce using rule 80 (factor -> MINUS_MINUS factor .)
    MINUS           reduce using rule 80 (factor -> MINUS_MINUS factor .)
    L_SHIFT         reduce using rule 80 (factor -> MINUS_MINUS factor .)
    R_SHIFT         reduce using rule 80 (factor -> MINUS_MINUS factor .)
    LE              reduce using rule 80 (factor -> MINUS_MINUS factor .)
    LT              reduce using rule 80 (factor -> MINUS_MINUS factor .)
    GE              reduce using rule 80 (factor -> MINUS_MINUS factor .)
    GT              reduce using rule 80 (factor -> MINUS_MINUS factor .)
    EQ              reduce using rule 80 (factor -> MINUS_MINUS factor .)
    NE              reduce using rule 80 (factor -> MINUS_MINUS factor .)
    BIT_AND         reduce using rule 80 (factor -> MINUS_MINUS factor .)
    BIT_XOR         reduce using rule 80 (factor -> MINUS_MINUS factor .)
    BIT_OR          reduce using rule 80 (factor -> MINUS_MINUS factor .)
    AND             reduce using rule 80 (factor -> MINUS_MINUS factor .)
    OR              reduce using rule 80 (factor -> MINUS_MINUS factor .)
    SEMICOLON       reduce using rule 80 (factor -> MINUS_MINUS factor .)
    ASSIGN          reduce using rule 80 (factor -> MINUS_MINUS factor .)
    PLUS_ASSIGN     reduce using rule 80 (factor -> MINUS_MINUS factor .)
    MINUS_ASSIGN    reduce using rule 80 (factor -> MINUS_MINUS factor .)
    MUL_ASSIGN      reduce using rule 80 (factor -> MINUS_MINUS factor .)
    DIV_ASSIGN      reduce using rule 80 (factor -> MINUS_MINUS factor .)
    AND_ASSIGN      reduce using rule 80 (factor -> MINUS_MINUS factor .)
    OR_ASSIGN       reduce using rule 80 (factor -> MINUS_MINUS factor .)
    XOR_ASSIGN      reduce using rule 80 (factor -> MINUS_MINUS factor .)
    MOD_ASSIGN      reduce using rule 80 (factor -> MINUS_MINUS factor .)
    L_SHIFT_ASSIGN  reduce using rule 80 (factor -> MINUS_MINUS factor .)
    R_SHIFT_ASSIGN  reduce using rule 80 (factor -> MINUS_MINUS factor .)
    R_PAREN         reduce using rule 80 (factor -> MINUS_MINUS factor .)
    COMMA           reduce using rule 80 (factor -> MINUS_MINUS factor .)


state 85

    (83) brace -> brace PLUS_PLUS .

    PLUS_PLUS       reduce using rule 83 (brace -> brace PLUS_PLUS .)
    MINUS_MINUS     reduce using rule 83 (brace -> brace PLUS_PLUS .)
    MULTIPLY        reduce using rule 83 (brace -> brace PLUS_PLUS .)
    DIVIDE          reduce using rule 83 (brace -> brace PLUS_PLUS .)
    MOD             reduce using rule 83 (brace -> brace PLUS_PLUS .)
    PLUS            reduce using rule 83 (brace -> brace PLUS_PLUS .)
    MINUS           reduce using rule 83 (brace -> brace PLUS_PLUS .)
    L_SHIFT         reduce using rule 83 (brace -> brace PLUS_PLUS .)
    R_SHIFT         reduce using rule 83 (brace -> brace PLUS_PLUS .)
    LE              reduce using rule 83 (brace -> brace PLUS_PLUS .)
    LT              reduce using rule 83 (brace -> brace PLUS_PLUS .)
    GE              reduce using rule 83 (brace -> brace PLUS_PLUS .)
    GT              reduce using rule 83 (brace -> brace PLUS_PLUS .)
    EQ              reduce using rule 83 (brace -> brace PLUS_PLUS .)
    NE              reduce using rule 83 (brace -> brace PLUS_PLUS .)
    BIT_AND         reduce using rule 83 (brace -> brace PLUS_PLUS .)
    BIT_XOR         reduce using rule 83 (brace -> brace PLUS_PLUS .)
    BIT_OR          reduce using rule 83 (brace -> brace PLUS_PLUS .)
    AND             reduce using rule 83 (brace -> brace PLUS_PLUS .)
    OR              reduce using rule 83 (brace -> brace PLUS_PLUS .)
    SEMICOLON       reduce using rule 83 (brace -> brace PLUS_PLUS .)
    ASSIGN          reduce using rule 83 (brace -> brace PLUS_PLUS .)
    PLUS_ASSIGN     reduce using rule 83 (brace -> brace PLUS_PLUS .)
    MINUS_ASSIGN    reduce using rule 83 (brace -> brace PLUS_PLUS .)
    MUL_ASSIGN      reduce using rule 83 (brace -> brace PLUS_PLUS .)
    DIV_ASSIGN      reduce using rule 83 (brace -> brace PLUS_PLUS .)
    AND_ASSIGN      reduce using rule 83 (brace -> brace PLUS_PLUS .)
    OR_ASSIGN       reduce using rule 83 (brace -> brace PLUS_PLUS .)
    XOR_ASSIGN      reduce using rule 83 (brace -> brace PLUS_PLUS .)
    MOD_ASSIGN      reduce using rule 83 (brace -> brace PLUS_PLUS .)
    L_SHIFT_ASSIGN  reduce using rule 83 (brace -> brace PLUS_PLUS .)
    R_SHIFT_ASSIGN  reduce using rule 83 (brace -> brace PLUS_PLUS .)
    R_PAREN         reduce using rule 83 (brace -> brace PLUS_PLUS .)
    COMMA           reduce using rule 83 (brace -> brace PLUS_PLUS .)


state 86

    (84) brace -> brace MINUS_MINUS .

    PLUS_PLUS       reduce using rule 84 (brace -> brace MINUS_MINUS .)
    MINUS_MINUS     reduce using rule 84 (brace -> brace MINUS_MINUS .)
    MULTIPLY        reduce using rule 84 (brace -> brace MINUS_MINUS .)
    DIVIDE          reduce using rule 84 (brace -> brace MINUS_MINUS .)
    MOD             reduce using rule 84 (brace -> brace MINUS_MINUS .)
    PLUS            reduce using rule 84 (brace -> brace MINUS_MINUS .)
    MINUS           reduce using rule 84 (brace -> brace MINUS_MINUS .)
    L_SHIFT         reduce using rule 84 (brace -> brace MINUS_MINUS .)
    R_SHIFT         reduce using rule 84 (brace -> brace MINUS_MINUS .)
    LE              reduce using rule 84 (brace -> brace MINUS_MINUS .)
    LT              reduce using rule 84 (brace -> brace MINUS_MINUS .)
    GE              reduce using rule 84 (brace -> brace MINUS_MINUS .)
    GT              reduce using rule 84 (brace -> brace MINUS_MINUS .)
    EQ              reduce using rule 84 (brace -> brace MINUS_MINUS .)
    NE              reduce using rule 84 (brace -> brace MINUS_MINUS .)
    BIT_AND         reduce using rule 84 (brace -> brace MINUS_MINUS .)
    BIT_XOR         reduce using rule 84 (brace -> brace MINUS_MINUS .)
    BIT_OR          reduce using rule 84 (brace -> brace MINUS_MINUS .)
    AND             reduce using rule 84 (brace -> brace MINUS_MINUS .)
    OR              reduce using rule 84 (brace -> brace MINUS_MINUS .)
    SEMICOLON       reduce using rule 84 (brace -> brace MINUS_MINUS .)
    ASSIGN          reduce using rule 84 (brace -> brace MINUS_MINUS .)
    PLUS_ASSIGN     reduce using rule 84 (brace -> brace MINUS_MINUS .)
    MINUS_ASSIGN    reduce using rule 84 (brace -> brace MINUS_MINUS .)
    MUL_ASSIGN      reduce using rule 84 (brace -> brace MINUS_MINUS .)
    DIV_ASSIGN      reduce using rule 84 (brace -> brace MINUS_MINUS .)
    AND_ASSIGN      reduce using rule 84 (brace -> brace MINUS_MINUS .)
    OR_ASSIGN       reduce using rule 84 (brace -> brace MINUS_MINUS .)
    XOR_ASSIGN      reduce using rule 84 (brace -> brace MINUS_MINUS .)
    MOD_ASSIGN      reduce using rule 84 (brace -> brace MINUS_MINUS .)
    L_SHIFT_ASSIGN  reduce using rule 84 (brace -> brace MINUS_MINUS .)
    R_SHIFT_ASSIGN  reduce using rule 84 (brace -> brace MINUS_MINUS .)
    R_PAREN         reduce using rule 84 (brace -> brace MINUS_MINUS .)
    COMMA           reduce using rule 84 (brace -> brace MINUS_MINUS .)


state 87

    (12) closed -> IF . condition closed ELSE closed
    (6) open -> IF . condition statement
    (7) open -> IF . condition closed ELSE open
    (15) condition -> . L_PAREN expr R_PAREN

    L_PAREN         shift and go to state 40

    condition                      shift and go to state 123

state 88

    (6) open -> IF condition statement .

    IF              reduce using rule 6 (open -> IF condition statement .)
    WHILE           reduce using rule 6 (open -> IF condition statement .)
    FOR             reduce using rule 6 (open -> IF condition statement .)
    SEMICOLON       reduce using rule 6 (open -> IF condition statement .)
    L_FLOWBRACE     reduce using rule 6 (open -> IF condition statement .)
    TYPE            reduce using rule 6 (open -> IF condition statement .)
    NOT             reduce using rule 6 (open -> IF condition statement .)
    PLUS            reduce using rule 6 (open -> IF condition statement .)
    MINUS           reduce using rule 6 (open -> IF condition statement .)
    PLUS_PLUS       reduce using rule 6 (open -> IF condition statement .)
    MINUS_MINUS     reduce using rule 6 (open -> IF condition statement .)
    L_PAREN         reduce using rule 6 (open -> IF condition statement .)
    INT_NUM         reduce using rule 6 (open -> IF condition statement .)
    FLOAT_NUM       reduce using rule 6 (open -> IF condition statement .)
    ID              reduce using rule 6 (open -> IF condition statement .)
    $end            reduce using rule 6 (open -> IF condition statement .)
    R_FLOWBRACE     reduce using rule 6 (open -> IF condition statement .)


state 89

    (7) open -> IF condition closed . ELSE open
    (12) closed -> IF condition closed . ELSE closed
    (5) statement -> closed .

    ELSE            shift and go to state 124
    IF              reduce using rule 5 (statement -> closed .)
    WHILE           reduce using rule 5 (statement -> closed .)
    FOR             reduce using rule 5 (statement -> closed .)
    SEMICOLON       reduce using rule 5 (statement -> closed .)
    L_FLOWBRACE     reduce using rule 5 (statement -> closed .)
    TYPE            reduce using rule 5 (statement -> closed .)
    NOT             reduce using rule 5 (statement -> closed .)
    PLUS            reduce using rule 5 (statement -> closed .)
    MINUS           reduce using rule 5 (statement -> closed .)
    PLUS_PLUS       reduce using rule 5 (statement -> closed .)
    MINUS_MINUS     reduce using rule 5 (statement -> closed .)
    L_PAREN         reduce using rule 5 (statement -> closed .)
    INT_NUM         reduce using rule 5 (statement -> closed .)
    FLOAT_NUM       reduce using rule 5 (statement -> closed .)
    ID              reduce using rule 5 (statement -> closed .)
    $end            reduce using rule 5 (statement -> closed .)
    R_FLOWBRACE     reduce using rule 5 (statement -> closed .)


state 90

    (13) closed -> WHILE . condition closed
    (8) open -> WHILE . condition open
    (15) condition -> . L_PAREN expr R_PAREN

    L_PAREN         shift and go to state 40

    condition                      shift and go to state 125

state 91

    (14) closed -> FOR . for_condition closed
    (9) open -> FOR . for_condition open
    (16) for_condition -> . L_PAREN declaration expr SEMICOLON expr R_PAREN

    L_PAREN         shift and go to state 43

    for_condition                  shift and go to state 126

state 92

    (15) condition -> L_PAREN expr . R_PAREN
    (34) expr -> expr . assignment exprOR
    (36) assignment -> . ASSIGN
    (37) assignment -> . PLUS_ASSIGN
    (38) assignment -> . MINUS_ASSIGN
    (39) assignment -> . MUL_ASSIGN
    (40) assignment -> . DIV_ASSIGN
    (41) assignment -> . AND_ASSIGN
    (42) assignment -> . OR_ASSIGN
    (43) assignment -> . XOR_ASSIGN
    (44) assignment -> . MOD_ASSIGN
    (45) assignment -> . L_SHIFT_ASSIGN
    (46) assignment -> . R_SHIFT_ASSIGN

    R_PAREN         shift and go to state 127
    ASSIGN          shift and go to state 46
    PLUS_ASSIGN     shift and go to state 47
    MINUS_ASSIGN    shift and go to state 48
    MUL_ASSIGN      shift and go to state 49
    DIV_ASSIGN      shift and go to state 50
    AND_ASSIGN      shift and go to state 51
    OR_ASSIGN       shift and go to state 52
    XOR_ASSIGN      shift and go to state 53
    MOD_ASSIGN      shift and go to state 54
    L_SHIFT_ASSIGN  shift and go to state 55
    R_SHIFT_ASSIGN  shift and go to state 56

    assignment                     shift and go to state 45

state 93

    (8) open -> WHILE condition open .

    IF              reduce using rule 8 (open -> WHILE condition open .)
    WHILE           reduce using rule 8 (open -> WHILE condition open .)
    FOR             reduce using rule 8 (open -> WHILE condition open .)
    SEMICOLON       reduce using rule 8 (open -> WHILE condition open .)
    L_FLOWBRACE     reduce using rule 8 (open -> WHILE condition open .)
    TYPE            reduce using rule 8 (open -> WHILE condition open .)
    NOT             reduce using rule 8 (open -> WHILE condition open .)
    PLUS            reduce using rule 8 (open -> WHILE condition open .)
    MINUS           reduce using rule 8 (open -> WHILE condition open .)
    PLUS_PLUS       reduce using rule 8 (open -> WHILE condition open .)
    MINUS_MINUS     reduce using rule 8 (open -> WHILE condition open .)
    L_PAREN         reduce using rule 8 (open -> WHILE condition open .)
    INT_NUM         reduce using rule 8 (open -> WHILE condition open .)
    FLOAT_NUM       reduce using rule 8 (open -> WHILE condition open .)
    ID              reduce using rule 8 (open -> WHILE condition open .)
    $end            reduce using rule 8 (open -> WHILE condition open .)
    R_FLOWBRACE     reduce using rule 8 (open -> WHILE condition open .)


state 94

    (13) closed -> WHILE condition closed .

    IF              reduce using rule 13 (closed -> WHILE condition closed .)
    WHILE           reduce using rule 13 (closed -> WHILE condition closed .)
    FOR             reduce using rule 13 (closed -> WHILE condition closed .)
    SEMICOLON       reduce using rule 13 (closed -> WHILE condition closed .)
    L_FLOWBRACE     reduce using rule 13 (closed -> WHILE condition closed .)
    TYPE            reduce using rule 13 (closed -> WHILE condition closed .)
    NOT             reduce using rule 13 (closed -> WHILE condition closed .)
    PLUS            reduce using rule 13 (closed -> WHILE condition closed .)
    MINUS           reduce using rule 13 (closed -> WHILE condition closed .)
    PLUS_PLUS       reduce using rule 13 (closed -> WHILE condition closed .)
    MINUS_MINUS     reduce using rule 13 (closed -> WHILE condition closed .)
    L_PAREN         reduce using rule 13 (closed -> WHILE condition closed .)
    INT_NUM         reduce using rule 13 (closed -> WHILE condition closed .)
    FLOAT_NUM       reduce using rule 13 (closed -> WHILE condition closed .)
    ID              reduce using rule 13 (closed -> WHILE condition closed .)
    $end            reduce using rule 13 (closed -> WHILE condition closed .)
    R_FLOWBRACE     reduce using rule 13 (closed -> WHILE condition closed .)
    ELSE            reduce using rule 13 (closed -> WHILE condition closed .)


state 95

    (9) open -> FOR for_condition open .

    IF              reduce using rule 9 (open -> FOR for_condition open .)
    WHILE           reduce using rule 9 (open -> FOR for_condition open .)
    FOR             reduce using rule 9 (open -> FOR for_condition open .)
    SEMICOLON       reduce using rule 9 (open -> FOR for_condition open .)
    L_FLOWBRACE     reduce using rule 9 (open -> FOR for_condition open .)
    TYPE            reduce using rule 9 (open -> FOR for_condition open .)
    NOT             reduce using rule 9 (open -> FOR for_condition open .)
    PLUS            reduce using rule 9 (open -> FOR for_condition open .)
    MINUS           reduce using rule 9 (open -> FOR for_condition open .)
    PLUS_PLUS       reduce using rule 9 (open -> FOR for_condition open .)
    MINUS_MINUS     reduce using rule 9 (open -> FOR for_condition open .)
    L_PAREN         reduce using rule 9 (open -> FOR for_condition open .)
    INT_NUM         reduce using rule 9 (open -> FOR for_condition open .)
    FLOAT_NUM       reduce using rule 9 (open -> FOR for_condition open .)
    ID              reduce using rule 9 (open -> FOR for_condition open .)
    $end            reduce using rule 9 (open -> FOR for_condition open .)
    R_FLOWBRACE     reduce using rule 9 (open -> FOR for_condition open .)


state 96

    (14) closed -> FOR for_condition closed .

    IF              reduce using rule 14 (closed -> FOR for_condition closed .)
    WHILE           reduce using rule 14 (closed -> FOR for_condition closed .)
    FOR             reduce using rule 14 (closed -> FOR for_condition closed .)
    SEMICOLON       reduce using rule 14 (closed -> FOR for_condition closed .)
    L_FLOWBRACE     reduce using rule 14 (closed -> FOR for_condition closed .)
    TYPE            reduce using rule 14 (closed -> FOR for_condition closed .)
    NOT             reduce using rule 14 (closed -> FOR for_condition closed .)
    PLUS            reduce using rule 14 (closed -> FOR for_condition closed .)
    MINUS           reduce using rule 14 (closed -> FOR for_condition closed .)
    PLUS_PLUS       reduce using rule 14 (closed -> FOR for_condition closed .)
    MINUS_MINUS     reduce using rule 14 (closed -> FOR for_condition closed .)
    L_PAREN         reduce using rule 14 (closed -> FOR for_condition closed .)
    INT_NUM         reduce using rule 14 (closed -> FOR for_condition closed .)
    FLOAT_NUM       reduce using rule 14 (closed -> FOR for_condition closed .)
    ID              reduce using rule 14 (closed -> FOR for_condition closed .)
    $end            reduce using rule 14 (closed -> FOR for_condition closed .)
    R_FLOWBRACE     reduce using rule 14 (closed -> FOR for_condition closed .)
    ELSE            reduce using rule 14 (closed -> FOR for_condition closed .)


state 97

    (16) for_condition -> L_PAREN declaration . expr SEMICOLON expr R_PAREN
    (34) expr -> . expr assignment exprOR
    (35) expr -> . exprOR
    (47) exprOR -> . exprOR OR exprAND
    (48) exprOR -> . exprAND
    (49) exprAND -> . exprAND AND exprBITOR
    (50) exprAND -> . exprBITOR
    (51) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (52) exprBITOR -> . exprBITXOR
    (53) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (54) exprBITXOR -> . exprBITAND
    (55) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (56) exprBITAND -> . exprEQ
    (57) exprEQ -> . exprEQ EQ exprRELOP
    (58) exprEQ -> . exprEQ NE exprRELOP
    (59) exprEQ -> . exprRELOP
    (60) exprRELOP -> . exprRELOP relop exprSHIFT
    (61) exprRELOP -> . exprSHIFT
    (66) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (67) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (68) exprSHIFT -> . exprOP
    (69) exprOP -> . exprOP PLUS term
    (70) exprOP -> . exprOP MINUS term
    (71) exprOP -> . term
    (72) term -> . term MULTIPLY factor
    (73) term -> . term DIVIDE factor
    (74) term -> . term MOD factor
    (75) term -> . factor
    (76) factor -> . NOT factor
    (77) factor -> . PLUS factor
    (78) factor -> . MINUS factor
    (79) factor -> . PLUS_PLUS factor
    (80) factor -> . MINUS_MINUS factor
    (81) factor -> . brace
    (82) brace -> . L_PAREN expr R_PAREN
    (83) brace -> . brace PLUS_PLUS
    (84) brace -> . brace MINUS_MINUS
    (85) brace -> . INT_NUM
    (86) brace -> . FLOAT_NUM
    (87) brace -> . ID

    NOT             shift and go to state 32
    PLUS            shift and go to state 28
    MINUS           shift and go to state 30
    PLUS_PLUS       shift and go to state 33
    MINUS_MINUS     shift and go to state 34
    L_PAREN         shift and go to state 19
    INT_NUM         shift and go to state 36
    FLOAT_NUM       shift and go to state 37
    ID              shift and go to state 18

    expr                           shift and go to state 128
    exprOR                         shift and go to state 16
    exprAND                        shift and go to state 20
    exprBITOR                      shift and go to state 21
    exprBITXOR                     shift and go to state 22
    exprBITAND                     shift and go to state 23
    exprEQ                         shift and go to state 24
    exprRELOP                      shift and go to state 25
    exprSHIFT                      shift and go to state 26
    exprOP                         shift and go to state 27
    term                           shift and go to state 29
    factor                         shift and go to state 31
    brace                          shift and go to state 35

state 98

    (23) declaration -> TYPE . ID SEMICOLON
    (24) declaration -> TYPE . ID ASSIGN expr SEMICOLON
    (25) declaration -> TYPE . multi_declaration stop
    (17) multi_declaration -> . multi_declaration ID COMMA
    (18) multi_declaration -> . multi_declaration ID ASSIGN expr COMMA
    (19) multi_declaration -> . ID COMMA
    (20) multi_declaration -> . ID ASSIGN expr COMMA

    ID              shift and go to state 129

    multi_declaration              shift and go to state 60

state 99

    (34) expr -> expr assignment exprOR .
    (47) exprOR -> exprOR . OR exprAND

    SEMICOLON       reduce using rule 34 (expr -> expr assignment exprOR .)
    ASSIGN          reduce using rule 34 (expr -> expr assignment exprOR .)
    PLUS_ASSIGN     reduce using rule 34 (expr -> expr assignment exprOR .)
    MINUS_ASSIGN    reduce using rule 34 (expr -> expr assignment exprOR .)
    MUL_ASSIGN      reduce using rule 34 (expr -> expr assignment exprOR .)
    DIV_ASSIGN      reduce using rule 34 (expr -> expr assignment exprOR .)
    AND_ASSIGN      reduce using rule 34 (expr -> expr assignment exprOR .)
    OR_ASSIGN       reduce using rule 34 (expr -> expr assignment exprOR .)
    XOR_ASSIGN      reduce using rule 34 (expr -> expr assignment exprOR .)
    MOD_ASSIGN      reduce using rule 34 (expr -> expr assignment exprOR .)
    L_SHIFT_ASSIGN  reduce using rule 34 (expr -> expr assignment exprOR .)
    R_SHIFT_ASSIGN  reduce using rule 34 (expr -> expr assignment exprOR .)
    R_PAREN         reduce using rule 34 (expr -> expr assignment exprOR .)
    COMMA           reduce using rule 34 (expr -> expr assignment exprOR .)
    OR              shift and go to state 58


state 100

    (26) block -> L_FLOWBRACE multiple_statements R_FLOWBRACE .

    IF              reduce using rule 26 (block -> L_FLOWBRACE multiple_statements R_FLOWBRACE .)
    WHILE           reduce using rule 26 (block -> L_FLOWBRACE multiple_statements R_FLOWBRACE .)
    FOR             reduce using rule 26 (block -> L_FLOWBRACE multiple_statements R_FLOWBRACE .)
    SEMICOLON       reduce using rule 26 (block -> L_FLOWBRACE multiple_statements R_FLOWBRACE .)
    L_FLOWBRACE     reduce using rule 26 (block -> L_FLOWBRACE multiple_statements R_FLOWBRACE .)
    TYPE            reduce using rule 26 (block -> L_FLOWBRACE multiple_statements R_FLOWBRACE .)
    NOT             reduce using rule 26 (block -> L_FLOWBRACE multiple_statements R_FLOWBRACE .)
    PLUS            reduce using rule 26 (block -> L_FLOWBRACE multiple_statements R_FLOWBRACE .)
    MINUS           reduce using rule 26 (block -> L_FLOWBRACE multiple_statements R_FLOWBRACE .)
    PLUS_PLUS       reduce using rule 26 (block -> L_FLOWBRACE multiple_statements R_FLOWBRACE .)
    MINUS_MINUS     reduce using rule 26 (block -> L_FLOWBRACE multiple_statements R_FLOWBRACE .)
    L_PAREN         reduce using rule 26 (block -> L_FLOWBRACE multiple_statements R_FLOWBRACE .)
    INT_NUM         reduce using rule 26 (block -> L_FLOWBRACE multiple_statements R_FLOWBRACE .)
    FLOAT_NUM       reduce using rule 26 (block -> L_FLOWBRACE multiple_statements R_FLOWBRACE .)
    ID              reduce using rule 26 (block -> L_FLOWBRACE multiple_statements R_FLOWBRACE .)
    $end            reduce using rule 26 (block -> L_FLOWBRACE multiple_statements R_FLOWBRACE .)
    R_FLOWBRACE     reduce using rule 26 (block -> L_FLOWBRACE multiple_statements R_FLOWBRACE .)
    ELSE            reduce using rule 26 (block -> L_FLOWBRACE multiple_statements R_FLOWBRACE .)


state 101

    (47) exprOR -> exprOR OR exprAND .
    (49) exprAND -> exprAND . AND exprBITOR

    OR              reduce using rule 47 (exprOR -> exprOR OR exprAND .)
    SEMICOLON       reduce using rule 47 (exprOR -> exprOR OR exprAND .)
    ASSIGN          reduce using rule 47 (exprOR -> exprOR OR exprAND .)
    PLUS_ASSIGN     reduce using rule 47 (exprOR -> exprOR OR exprAND .)
    MINUS_ASSIGN    reduce using rule 47 (exprOR -> exprOR OR exprAND .)
    MUL_ASSIGN      reduce using rule 47 (exprOR -> exprOR OR exprAND .)
    DIV_ASSIGN      reduce using rule 47 (exprOR -> exprOR OR exprAND .)
    AND_ASSIGN      reduce using rule 47 (exprOR -> exprOR OR exprAND .)
    OR_ASSIGN       reduce using rule 47 (exprOR -> exprOR OR exprAND .)
    XOR_ASSIGN      reduce using rule 47 (exprOR -> exprOR OR exprAND .)
    MOD_ASSIGN      reduce using rule 47 (exprOR -> exprOR OR exprAND .)
    L_SHIFT_ASSIGN  reduce using rule 47 (exprOR -> exprOR OR exprAND .)
    R_SHIFT_ASSIGN  reduce using rule 47 (exprOR -> exprOR OR exprAND .)
    R_PAREN         reduce using rule 47 (exprOR -> exprOR OR exprAND .)
    COMMA           reduce using rule 47 (exprOR -> exprOR OR exprAND .)
    AND             shift and go to state 62


state 102

    (23) declaration -> TYPE ID SEMICOLON .

    IF              reduce using rule 23 (declaration -> TYPE ID SEMICOLON .)
    WHILE           reduce using rule 23 (declaration -> TYPE ID SEMICOLON .)
    FOR             reduce using rule 23 (declaration -> TYPE ID SEMICOLON .)
    SEMICOLON       reduce using rule 23 (declaration -> TYPE ID SEMICOLON .)
    L_FLOWBRACE     reduce using rule 23 (declaration -> TYPE ID SEMICOLON .)
    TYPE            reduce using rule 23 (declaration -> TYPE ID SEMICOLON .)
    NOT             reduce using rule 23 (declaration -> TYPE ID SEMICOLON .)
    PLUS            reduce using rule 23 (declaration -> TYPE ID SEMICOLON .)
    MINUS           reduce using rule 23 (declaration -> TYPE ID SEMICOLON .)
    PLUS_PLUS       reduce using rule 23 (declaration -> TYPE ID SEMICOLON .)
    MINUS_MINUS     reduce using rule 23 (declaration -> TYPE ID SEMICOLON .)
    L_PAREN         reduce using rule 23 (declaration -> TYPE ID SEMICOLON .)
    INT_NUM         reduce using rule 23 (declaration -> TYPE ID SEMICOLON .)
    FLOAT_NUM       reduce using rule 23 (declaration -> TYPE ID SEMICOLON .)
    ID              reduce using rule 23 (declaration -> TYPE ID SEMICOLON .)
    $end            reduce using rule 23 (declaration -> TYPE ID SEMICOLON .)
    R_FLOWBRACE     reduce using rule 23 (declaration -> TYPE ID SEMICOLON .)
    ELSE            reduce using rule 23 (declaration -> TYPE ID SEMICOLON .)


state 103

    (24) declaration -> TYPE ID ASSIGN . expr SEMICOLON
    (20) multi_declaration -> ID ASSIGN . expr COMMA
    (34) expr -> . expr assignment exprOR
    (35) expr -> . exprOR
    (47) exprOR -> . exprOR OR exprAND
    (48) exprOR -> . exprAND
    (49) exprAND -> . exprAND AND exprBITOR
    (50) exprAND -> . exprBITOR
    (51) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (52) exprBITOR -> . exprBITXOR
    (53) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (54) exprBITXOR -> . exprBITAND
    (55) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (56) exprBITAND -> . exprEQ
    (57) exprEQ -> . exprEQ EQ exprRELOP
    (58) exprEQ -> . exprEQ NE exprRELOP
    (59) exprEQ -> . exprRELOP
    (60) exprRELOP -> . exprRELOP relop exprSHIFT
    (61) exprRELOP -> . exprSHIFT
    (66) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (67) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (68) exprSHIFT -> . exprOP
    (69) exprOP -> . exprOP PLUS term
    (70) exprOP -> . exprOP MINUS term
    (71) exprOP -> . term
    (72) term -> . term MULTIPLY factor
    (73) term -> . term DIVIDE factor
    (74) term -> . term MOD factor
    (75) term -> . factor
    (76) factor -> . NOT factor
    (77) factor -> . PLUS factor
    (78) factor -> . MINUS factor
    (79) factor -> . PLUS_PLUS factor
    (80) factor -> . MINUS_MINUS factor
    (81) factor -> . brace
    (82) brace -> . L_PAREN expr R_PAREN
    (83) brace -> . brace PLUS_PLUS
    (84) brace -> . brace MINUS_MINUS
    (85) brace -> . INT_NUM
    (86) brace -> . FLOAT_NUM
    (87) brace -> . ID

    NOT             shift and go to state 32
    PLUS            shift and go to state 28
    MINUS           shift and go to state 30
    PLUS_PLUS       shift and go to state 33
    MINUS_MINUS     shift and go to state 34
    L_PAREN         shift and go to state 19
    INT_NUM         shift and go to state 36
    FLOAT_NUM       shift and go to state 37
    ID              shift and go to state 18

    expr                           shift and go to state 130
    exprOR                         shift and go to state 16
    exprAND                        shift and go to state 20
    exprBITOR                      shift and go to state 21
    exprBITXOR                     shift and go to state 22
    exprBITAND                     shift and go to state 23
    exprEQ                         shift and go to state 24
    exprRELOP                      shift and go to state 25
    exprSHIFT                      shift and go to state 26
    exprOP                         shift and go to state 27
    term                           shift and go to state 29
    factor                         shift and go to state 31
    brace                          shift and go to state 35

state 104

    (31) function -> TYPE ID L_PAREN . R_PAREN function_2

    R_PAREN         shift and go to state 131


state 105

    (19) multi_declaration -> ID COMMA .

    ID              reduce using rule 19 (multi_declaration -> ID COMMA .)


state 106

    (25) declaration -> TYPE multi_declaration stop .

    IF              reduce using rule 25 (declaration -> TYPE multi_declaration stop .)
    WHILE           reduce using rule 25 (declaration -> TYPE multi_declaration stop .)
    FOR             reduce using rule 25 (declaration -> TYPE multi_declaration stop .)
    SEMICOLON       reduce using rule 25 (declaration -> TYPE multi_declaration stop .)
    L_FLOWBRACE     reduce using rule 25 (declaration -> TYPE multi_declaration stop .)
    TYPE            reduce using rule 25 (declaration -> TYPE multi_declaration stop .)
    NOT             reduce using rule 25 (declaration -> TYPE multi_declaration stop .)
    PLUS            reduce using rule 25 (declaration -> TYPE multi_declaration stop .)
    MINUS           reduce using rule 25 (declaration -> TYPE multi_declaration stop .)
    PLUS_PLUS       reduce using rule 25 (declaration -> TYPE multi_declaration stop .)
    MINUS_MINUS     reduce using rule 25 (declaration -> TYPE multi_declaration stop .)
    L_PAREN         reduce using rule 25 (declaration -> TYPE multi_declaration stop .)
    INT_NUM         reduce using rule 25 (declaration -> TYPE multi_declaration stop .)
    FLOAT_NUM       reduce using rule 25 (declaration -> TYPE multi_declaration stop .)
    ID              reduce using rule 25 (declaration -> TYPE multi_declaration stop .)
    $end            reduce using rule 25 (declaration -> TYPE multi_declaration stop .)
    R_FLOWBRACE     reduce using rule 25 (declaration -> TYPE multi_declaration stop .)
    ELSE            reduce using rule 25 (declaration -> TYPE multi_declaration stop .)


state 107

    (17) multi_declaration -> multi_declaration ID . COMMA
    (18) multi_declaration -> multi_declaration ID . ASSIGN expr COMMA
    (21) stop -> ID . SEMICOLON
    (22) stop -> ID . ASSIGN expr SEMICOLON

    COMMA           shift and go to state 132
    ASSIGN          shift and go to state 133
    SEMICOLON       shift and go to state 134


state 108

    (82) brace -> L_PAREN expr R_PAREN .

    PLUS_PLUS       reduce using rule 82 (brace -> L_PAREN expr R_PAREN .)
    MINUS_MINUS     reduce using rule 82 (brace -> L_PAREN expr R_PAREN .)
    MULTIPLY        reduce using rule 82 (brace -> L_PAREN expr R_PAREN .)
    DIVIDE          reduce using rule 82 (brace -> L_PAREN expr R_PAREN .)
    MOD             reduce using rule 82 (brace -> L_PAREN expr R_PAREN .)
    PLUS            reduce using rule 82 (brace -> L_PAREN expr R_PAREN .)
    MINUS           reduce using rule 82 (brace -> L_PAREN expr R_PAREN .)
    L_SHIFT         reduce using rule 82 (brace -> L_PAREN expr R_PAREN .)
    R_SHIFT         reduce using rule 82 (brace -> L_PAREN expr R_PAREN .)
    LE              reduce using rule 82 (brace -> L_PAREN expr R_PAREN .)
    LT              reduce using rule 82 (brace -> L_PAREN expr R_PAREN .)
    GE              reduce using rule 82 (brace -> L_PAREN expr R_PAREN .)
    GT              reduce using rule 82 (brace -> L_PAREN expr R_PAREN .)
    EQ              reduce using rule 82 (brace -> L_PAREN expr R_PAREN .)
    NE              reduce using rule 82 (brace -> L_PAREN expr R_PAREN .)
    BIT_AND         reduce using rule 82 (brace -> L_PAREN expr R_PAREN .)
    BIT_XOR         reduce using rule 82 (brace -> L_PAREN expr R_PAREN .)
    BIT_OR          reduce using rule 82 (brace -> L_PAREN expr R_PAREN .)
    AND             reduce using rule 82 (brace -> L_PAREN expr R_PAREN .)
    OR              reduce using rule 82 (brace -> L_PAREN expr R_PAREN .)
    SEMICOLON       reduce using rule 82 (brace -> L_PAREN expr R_PAREN .)
    ASSIGN          reduce using rule 82 (brace -> L_PAREN expr R_PAREN .)
    PLUS_ASSIGN     reduce using rule 82 (brace -> L_PAREN expr R_PAREN .)
    MINUS_ASSIGN    reduce using rule 82 (brace -> L_PAREN expr R_PAREN .)
    MUL_ASSIGN      reduce using rule 82 (brace -> L_PAREN expr R_PAREN .)
    DIV_ASSIGN      reduce using rule 82 (brace -> L_PAREN expr R_PAREN .)
    AND_ASSIGN      reduce using rule 82 (brace -> L_PAREN expr R_PAREN .)
    OR_ASSIGN       reduce using rule 82 (brace -> L_PAREN expr R_PAREN .)
    XOR_ASSIGN      reduce using rule 82 (brace -> L_PAREN expr R_PAREN .)
    MOD_ASSIGN      reduce using rule 82 (brace -> L_PAREN expr R_PAREN .)
    L_SHIFT_ASSIGN  reduce using rule 82 (brace -> L_PAREN expr R_PAREN .)
    R_SHIFT_ASSIGN  reduce using rule 82 (brace -> L_PAREN expr R_PAREN .)
    R_PAREN         reduce using rule 82 (brace -> L_PAREN expr R_PAREN .)
    COMMA           reduce using rule 82 (brace -> L_PAREN expr R_PAREN .)


state 109

    (49) exprAND -> exprAND AND exprBITOR .
    (51) exprBITOR -> exprBITOR . BIT_OR exprBITXOR

    AND             reduce using rule 49 (exprAND -> exprAND AND exprBITOR .)
    OR              reduce using rule 49 (exprAND -> exprAND AND exprBITOR .)
    SEMICOLON       reduce using rule 49 (exprAND -> exprAND AND exprBITOR .)
    ASSIGN          reduce using rule 49 (exprAND -> exprAND AND exprBITOR .)
    PLUS_ASSIGN     reduce using rule 49 (exprAND -> exprAND AND exprBITOR .)
    MINUS_ASSIGN    reduce using rule 49 (exprAND -> exprAND AND exprBITOR .)
    MUL_ASSIGN      reduce using rule 49 (exprAND -> exprAND AND exprBITOR .)
    DIV_ASSIGN      reduce using rule 49 (exprAND -> exprAND AND exprBITOR .)
    AND_ASSIGN      reduce using rule 49 (exprAND -> exprAND AND exprBITOR .)
    OR_ASSIGN       reduce using rule 49 (exprAND -> exprAND AND exprBITOR .)
    XOR_ASSIGN      reduce using rule 49 (exprAND -> exprAND AND exprBITOR .)
    MOD_ASSIGN      reduce using rule 49 (exprAND -> exprAND AND exprBITOR .)
    L_SHIFT_ASSIGN  reduce using rule 49 (exprAND -> exprAND AND exprBITOR .)
    R_SHIFT_ASSIGN  reduce using rule 49 (exprAND -> exprAND AND exprBITOR .)
    R_PAREN         reduce using rule 49 (exprAND -> exprAND AND exprBITOR .)
    COMMA           reduce using rule 49 (exprAND -> exprAND AND exprBITOR .)
    BIT_OR          shift and go to state 63


state 110

    (51) exprBITOR -> exprBITOR BIT_OR exprBITXOR .
    (53) exprBITXOR -> exprBITXOR . BIT_XOR exprBITAND

    BIT_OR          reduce using rule 51 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    AND             reduce using rule 51 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    OR              reduce using rule 51 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    SEMICOLON       reduce using rule 51 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    ASSIGN          reduce using rule 51 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    PLUS_ASSIGN     reduce using rule 51 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    MINUS_ASSIGN    reduce using rule 51 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    MUL_ASSIGN      reduce using rule 51 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    DIV_ASSIGN      reduce using rule 51 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    AND_ASSIGN      reduce using rule 51 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    OR_ASSIGN       reduce using rule 51 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    XOR_ASSIGN      reduce using rule 51 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    MOD_ASSIGN      reduce using rule 51 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    L_SHIFT_ASSIGN  reduce using rule 51 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    R_SHIFT_ASSIGN  reduce using rule 51 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    R_PAREN         reduce using rule 51 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    COMMA           reduce using rule 51 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    BIT_XOR         shift and go to state 64


state 111

    (53) exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .
    (55) exprBITAND -> exprBITAND . BIT_AND exprEQ

    BIT_XOR         reduce using rule 53 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    BIT_OR          reduce using rule 53 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    AND             reduce using rule 53 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    OR              reduce using rule 53 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    SEMICOLON       reduce using rule 53 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    ASSIGN          reduce using rule 53 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    PLUS_ASSIGN     reduce using rule 53 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    MINUS_ASSIGN    reduce using rule 53 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    MUL_ASSIGN      reduce using rule 53 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    DIV_ASSIGN      reduce using rule 53 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    AND_ASSIGN      reduce using rule 53 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    OR_ASSIGN       reduce using rule 53 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    XOR_ASSIGN      reduce using rule 53 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    MOD_ASSIGN      reduce using rule 53 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    L_SHIFT_ASSIGN  reduce using rule 53 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    R_SHIFT_ASSIGN  reduce using rule 53 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    R_PAREN         reduce using rule 53 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    COMMA           reduce using rule 53 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    BIT_AND         shift and go to state 65


state 112

    (55) exprBITAND -> exprBITAND BIT_AND exprEQ .
    (57) exprEQ -> exprEQ . EQ exprRELOP
    (58) exprEQ -> exprEQ . NE exprRELOP

    BIT_AND         reduce using rule 55 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    BIT_XOR         reduce using rule 55 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    BIT_OR          reduce using rule 55 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    AND             reduce using rule 55 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    OR              reduce using rule 55 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    SEMICOLON       reduce using rule 55 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    ASSIGN          reduce using rule 55 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    PLUS_ASSIGN     reduce using rule 55 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    MINUS_ASSIGN    reduce using rule 55 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    MUL_ASSIGN      reduce using rule 55 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    DIV_ASSIGN      reduce using rule 55 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    AND_ASSIGN      reduce using rule 55 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    OR_ASSIGN       reduce using rule 55 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    XOR_ASSIGN      reduce using rule 55 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    MOD_ASSIGN      reduce using rule 55 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    L_SHIFT_ASSIGN  reduce using rule 55 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    R_SHIFT_ASSIGN  reduce using rule 55 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    R_PAREN         reduce using rule 55 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    COMMA           reduce using rule 55 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    EQ              shift and go to state 66
    NE              shift and go to state 67


state 113

    (57) exprEQ -> exprEQ EQ exprRELOP .
    (60) exprRELOP -> exprRELOP . relop exprSHIFT
    (62) relop -> . LE
    (63) relop -> . LT
    (64) relop -> . GE
    (65) relop -> . GT

    EQ              reduce using rule 57 (exprEQ -> exprEQ EQ exprRELOP .)
    NE              reduce using rule 57 (exprEQ -> exprEQ EQ exprRELOP .)
    BIT_AND         reduce using rule 57 (exprEQ -> exprEQ EQ exprRELOP .)
    BIT_XOR         reduce using rule 57 (exprEQ -> exprEQ EQ exprRELOP .)
    BIT_OR          reduce using rule 57 (exprEQ -> exprEQ EQ exprRELOP .)
    AND             reduce using rule 57 (exprEQ -> exprEQ EQ exprRELOP .)
    OR              reduce using rule 57 (exprEQ -> exprEQ EQ exprRELOP .)
    SEMICOLON       reduce using rule 57 (exprEQ -> exprEQ EQ exprRELOP .)
    ASSIGN          reduce using rule 57 (exprEQ -> exprEQ EQ exprRELOP .)
    PLUS_ASSIGN     reduce using rule 57 (exprEQ -> exprEQ EQ exprRELOP .)
    MINUS_ASSIGN    reduce using rule 57 (exprEQ -> exprEQ EQ exprRELOP .)
    MUL_ASSIGN      reduce using rule 57 (exprEQ -> exprEQ EQ exprRELOP .)
    DIV_ASSIGN      reduce using rule 57 (exprEQ -> exprEQ EQ exprRELOP .)
    AND_ASSIGN      reduce using rule 57 (exprEQ -> exprEQ EQ exprRELOP .)
    OR_ASSIGN       reduce using rule 57 (exprEQ -> exprEQ EQ exprRELOP .)
    XOR_ASSIGN      reduce using rule 57 (exprEQ -> exprEQ EQ exprRELOP .)
    MOD_ASSIGN      reduce using rule 57 (exprEQ -> exprEQ EQ exprRELOP .)
    L_SHIFT_ASSIGN  reduce using rule 57 (exprEQ -> exprEQ EQ exprRELOP .)
    R_SHIFT_ASSIGN  reduce using rule 57 (exprEQ -> exprEQ EQ exprRELOP .)
    R_PAREN         reduce using rule 57 (exprEQ -> exprEQ EQ exprRELOP .)
    COMMA           reduce using rule 57 (exprEQ -> exprEQ EQ exprRELOP .)
    LE              shift and go to state 69
    LT              shift and go to state 70
    GE              shift and go to state 71
    GT              shift and go to state 72

    relop                          shift and go to state 68

state 114

    (58) exprEQ -> exprEQ NE exprRELOP .
    (60) exprRELOP -> exprRELOP . relop exprSHIFT
    (62) relop -> . LE
    (63) relop -> . LT
    (64) relop -> . GE
    (65) relop -> . GT

    EQ              reduce using rule 58 (exprEQ -> exprEQ NE exprRELOP .)
    NE              reduce using rule 58 (exprEQ -> exprEQ NE exprRELOP .)
    BIT_AND         reduce using rule 58 (exprEQ -> exprEQ NE exprRELOP .)
    BIT_XOR         reduce using rule 58 (exprEQ -> exprEQ NE exprRELOP .)
    BIT_OR          reduce using rule 58 (exprEQ -> exprEQ NE exprRELOP .)
    AND             reduce using rule 58 (exprEQ -> exprEQ NE exprRELOP .)
    OR              reduce using rule 58 (exprEQ -> exprEQ NE exprRELOP .)
    SEMICOLON       reduce using rule 58 (exprEQ -> exprEQ NE exprRELOP .)
    ASSIGN          reduce using rule 58 (exprEQ -> exprEQ NE exprRELOP .)
    PLUS_ASSIGN     reduce using rule 58 (exprEQ -> exprEQ NE exprRELOP .)
    MINUS_ASSIGN    reduce using rule 58 (exprEQ -> exprEQ NE exprRELOP .)
    MUL_ASSIGN      reduce using rule 58 (exprEQ -> exprEQ NE exprRELOP .)
    DIV_ASSIGN      reduce using rule 58 (exprEQ -> exprEQ NE exprRELOP .)
    AND_ASSIGN      reduce using rule 58 (exprEQ -> exprEQ NE exprRELOP .)
    OR_ASSIGN       reduce using rule 58 (exprEQ -> exprEQ NE exprRELOP .)
    XOR_ASSIGN      reduce using rule 58 (exprEQ -> exprEQ NE exprRELOP .)
    MOD_ASSIGN      reduce using rule 58 (exprEQ -> exprEQ NE exprRELOP .)
    L_SHIFT_ASSIGN  reduce using rule 58 (exprEQ -> exprEQ NE exprRELOP .)
    R_SHIFT_ASSIGN  reduce using rule 58 (exprEQ -> exprEQ NE exprRELOP .)
    R_PAREN         reduce using rule 58 (exprEQ -> exprEQ NE exprRELOP .)
    COMMA           reduce using rule 58 (exprEQ -> exprEQ NE exprRELOP .)
    LE              shift and go to state 69
    LT              shift and go to state 70
    GE              shift and go to state 71
    GT              shift and go to state 72

    relop                          shift and go to state 68

state 115

    (60) exprRELOP -> exprRELOP relop exprSHIFT .
    (66) exprSHIFT -> exprSHIFT . L_SHIFT exprOP
    (67) exprSHIFT -> exprSHIFT . R_SHIFT exprOP

    LE              reduce using rule 60 (exprRELOP -> exprRELOP relop exprSHIFT .)
    LT              reduce using rule 60 (exprRELOP -> exprRELOP relop exprSHIFT .)
    GE              reduce using rule 60 (exprRELOP -> exprRELOP relop exprSHIFT .)
    GT              reduce using rule 60 (exprRELOP -> exprRELOP relop exprSHIFT .)
    EQ              reduce using rule 60 (exprRELOP -> exprRELOP relop exprSHIFT .)
    NE              reduce using rule 60 (exprRELOP -> exprRELOP relop exprSHIFT .)
    BIT_AND         reduce using rule 60 (exprRELOP -> exprRELOP relop exprSHIFT .)
    BIT_XOR         reduce using rule 60 (exprRELOP -> exprRELOP relop exprSHIFT .)
    BIT_OR          reduce using rule 60 (exprRELOP -> exprRELOP relop exprSHIFT .)
    AND             reduce using rule 60 (exprRELOP -> exprRELOP relop exprSHIFT .)
    OR              reduce using rule 60 (exprRELOP -> exprRELOP relop exprSHIFT .)
    SEMICOLON       reduce using rule 60 (exprRELOP -> exprRELOP relop exprSHIFT .)
    ASSIGN          reduce using rule 60 (exprRELOP -> exprRELOP relop exprSHIFT .)
    PLUS_ASSIGN     reduce using rule 60 (exprRELOP -> exprRELOP relop exprSHIFT .)
    MINUS_ASSIGN    reduce using rule 60 (exprRELOP -> exprRELOP relop exprSHIFT .)
    MUL_ASSIGN      reduce using rule 60 (exprRELOP -> exprRELOP relop exprSHIFT .)
    DIV_ASSIGN      reduce using rule 60 (exprRELOP -> exprRELOP relop exprSHIFT .)
    AND_ASSIGN      reduce using rule 60 (exprRELOP -> exprRELOP relop exprSHIFT .)
    OR_ASSIGN       reduce using rule 60 (exprRELOP -> exprRELOP relop exprSHIFT .)
    XOR_ASSIGN      reduce using rule 60 (exprRELOP -> exprRELOP relop exprSHIFT .)
    MOD_ASSIGN      reduce using rule 60 (exprRELOP -> exprRELOP relop exprSHIFT .)
    L_SHIFT_ASSIGN  reduce using rule 60 (exprRELOP -> exprRELOP relop exprSHIFT .)
    R_SHIFT_ASSIGN  reduce using rule 60 (exprRELOP -> exprRELOP relop exprSHIFT .)
    R_PAREN         reduce using rule 60 (exprRELOP -> exprRELOP relop exprSHIFT .)
    COMMA           reduce using rule 60 (exprRELOP -> exprRELOP relop exprSHIFT .)
    L_SHIFT         shift and go to state 73
    R_SHIFT         shift and go to state 74


state 116

    (66) exprSHIFT -> exprSHIFT L_SHIFT exprOP .
    (69) exprOP -> exprOP . PLUS term
    (70) exprOP -> exprOP . MINUS term

    L_SHIFT         reduce using rule 66 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    R_SHIFT         reduce using rule 66 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    LE              reduce using rule 66 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    LT              reduce using rule 66 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    GE              reduce using rule 66 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    GT              reduce using rule 66 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    EQ              reduce using rule 66 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    NE              reduce using rule 66 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    BIT_AND         reduce using rule 66 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    BIT_XOR         reduce using rule 66 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    BIT_OR          reduce using rule 66 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    AND             reduce using rule 66 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    OR              reduce using rule 66 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    SEMICOLON       reduce using rule 66 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    ASSIGN          reduce using rule 66 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    PLUS_ASSIGN     reduce using rule 66 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    MINUS_ASSIGN    reduce using rule 66 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    MUL_ASSIGN      reduce using rule 66 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    DIV_ASSIGN      reduce using rule 66 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    AND_ASSIGN      reduce using rule 66 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    OR_ASSIGN       reduce using rule 66 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    XOR_ASSIGN      reduce using rule 66 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    MOD_ASSIGN      reduce using rule 66 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    L_SHIFT_ASSIGN  reduce using rule 66 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    R_SHIFT_ASSIGN  reduce using rule 66 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    R_PAREN         reduce using rule 66 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    COMMA           reduce using rule 66 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    PLUS            shift and go to state 75
    MINUS           shift and go to state 76


state 117

    (67) exprSHIFT -> exprSHIFT R_SHIFT exprOP .
    (69) exprOP -> exprOP . PLUS term
    (70) exprOP -> exprOP . MINUS term

    L_SHIFT         reduce using rule 67 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    R_SHIFT         reduce using rule 67 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    LE              reduce using rule 67 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    LT              reduce using rule 67 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    GE              reduce using rule 67 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    GT              reduce using rule 67 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    EQ              reduce using rule 67 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    NE              reduce using rule 67 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    BIT_AND         reduce using rule 67 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    BIT_XOR         reduce using rule 67 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    BIT_OR          reduce using rule 67 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    AND             reduce using rule 67 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    OR              reduce using rule 67 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    SEMICOLON       reduce using rule 67 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    ASSIGN          reduce using rule 67 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    PLUS_ASSIGN     reduce using rule 67 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    MINUS_ASSIGN    reduce using rule 67 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    MUL_ASSIGN      reduce using rule 67 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    DIV_ASSIGN      reduce using rule 67 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    AND_ASSIGN      reduce using rule 67 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    OR_ASSIGN       reduce using rule 67 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    XOR_ASSIGN      reduce using rule 67 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    MOD_ASSIGN      reduce using rule 67 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    L_SHIFT_ASSIGN  reduce using rule 67 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    R_SHIFT_ASSIGN  reduce using rule 67 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    R_PAREN         reduce using rule 67 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    COMMA           reduce using rule 67 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    PLUS            shift and go to state 75
    MINUS           shift and go to state 76


state 118

    (69) exprOP -> exprOP PLUS term .
    (72) term -> term . MULTIPLY factor
    (73) term -> term . DIVIDE factor
    (74) term -> term . MOD factor

    PLUS            reduce using rule 69 (exprOP -> exprOP PLUS term .)
    MINUS           reduce using rule 69 (exprOP -> exprOP PLUS term .)
    L_SHIFT         reduce using rule 69 (exprOP -> exprOP PLUS term .)
    R_SHIFT         reduce using rule 69 (exprOP -> exprOP PLUS term .)
    LE              reduce using rule 69 (exprOP -> exprOP PLUS term .)
    LT              reduce using rule 69 (exprOP -> exprOP PLUS term .)
    GE              reduce using rule 69 (exprOP -> exprOP PLUS term .)
    GT              reduce using rule 69 (exprOP -> exprOP PLUS term .)
    EQ              reduce using rule 69 (exprOP -> exprOP PLUS term .)
    NE              reduce using rule 69 (exprOP -> exprOP PLUS term .)
    BIT_AND         reduce using rule 69 (exprOP -> exprOP PLUS term .)
    BIT_XOR         reduce using rule 69 (exprOP -> exprOP PLUS term .)
    BIT_OR          reduce using rule 69 (exprOP -> exprOP PLUS term .)
    AND             reduce using rule 69 (exprOP -> exprOP PLUS term .)
    OR              reduce using rule 69 (exprOP -> exprOP PLUS term .)
    SEMICOLON       reduce using rule 69 (exprOP -> exprOP PLUS term .)
    ASSIGN          reduce using rule 69 (exprOP -> exprOP PLUS term .)
    PLUS_ASSIGN     reduce using rule 69 (exprOP -> exprOP PLUS term .)
    MINUS_ASSIGN    reduce using rule 69 (exprOP -> exprOP PLUS term .)
    MUL_ASSIGN      reduce using rule 69 (exprOP -> exprOP PLUS term .)
    DIV_ASSIGN      reduce using rule 69 (exprOP -> exprOP PLUS term .)
    AND_ASSIGN      reduce using rule 69 (exprOP -> exprOP PLUS term .)
    OR_ASSIGN       reduce using rule 69 (exprOP -> exprOP PLUS term .)
    XOR_ASSIGN      reduce using rule 69 (exprOP -> exprOP PLUS term .)
    MOD_ASSIGN      reduce using rule 69 (exprOP -> exprOP PLUS term .)
    L_SHIFT_ASSIGN  reduce using rule 69 (exprOP -> exprOP PLUS term .)
    R_SHIFT_ASSIGN  reduce using rule 69 (exprOP -> exprOP PLUS term .)
    R_PAREN         reduce using rule 69 (exprOP -> exprOP PLUS term .)
    COMMA           reduce using rule 69 (exprOP -> exprOP PLUS term .)
    MULTIPLY        shift and go to state 78
    DIVIDE          shift and go to state 79
    MOD             shift and go to state 80


state 119

    (70) exprOP -> exprOP MINUS term .
    (72) term -> term . MULTIPLY factor
    (73) term -> term . DIVIDE factor
    (74) term -> term . MOD factor

    PLUS            reduce using rule 70 (exprOP -> exprOP MINUS term .)
    MINUS           reduce using rule 70 (exprOP -> exprOP MINUS term .)
    L_SHIFT         reduce using rule 70 (exprOP -> exprOP MINUS term .)
    R_SHIFT         reduce using rule 70 (exprOP -> exprOP MINUS term .)
    LE              reduce using rule 70 (exprOP -> exprOP MINUS term .)
    LT              reduce using rule 70 (exprOP -> exprOP MINUS term .)
    GE              reduce using rule 70 (exprOP -> exprOP MINUS term .)
    GT              reduce using rule 70 (exprOP -> exprOP MINUS term .)
    EQ              reduce using rule 70 (exprOP -> exprOP MINUS term .)
    NE              reduce using rule 70 (exprOP -> exprOP MINUS term .)
    BIT_AND         reduce using rule 70 (exprOP -> exprOP MINUS term .)
    BIT_XOR         reduce using rule 70 (exprOP -> exprOP MINUS term .)
    BIT_OR          reduce using rule 70 (exprOP -> exprOP MINUS term .)
    AND             reduce using rule 70 (exprOP -> exprOP MINUS term .)
    OR              reduce using rule 70 (exprOP -> exprOP MINUS term .)
    SEMICOLON       reduce using rule 70 (exprOP -> exprOP MINUS term .)
    ASSIGN          reduce using rule 70 (exprOP -> exprOP MINUS term .)
    PLUS_ASSIGN     reduce using rule 70 (exprOP -> exprOP MINUS term .)
    MINUS_ASSIGN    reduce using rule 70 (exprOP -> exprOP MINUS term .)
    MUL_ASSIGN      reduce using rule 70 (exprOP -> exprOP MINUS term .)
    DIV_ASSIGN      reduce using rule 70 (exprOP -> exprOP MINUS term .)
    AND_ASSIGN      reduce using rule 70 (exprOP -> exprOP MINUS term .)
    OR_ASSIGN       reduce using rule 70 (exprOP -> exprOP MINUS term .)
    XOR_ASSIGN      reduce using rule 70 (exprOP -> exprOP MINUS term .)
    MOD_ASSIGN      reduce using rule 70 (exprOP -> exprOP MINUS term .)
    L_SHIFT_ASSIGN  reduce using rule 70 (exprOP -> exprOP MINUS term .)
    R_SHIFT_ASSIGN  reduce using rule 70 (exprOP -> exprOP MINUS term .)
    R_PAREN         reduce using rule 70 (exprOP -> exprOP MINUS term .)
    COMMA           reduce using rule 70 (exprOP -> exprOP MINUS term .)
    MULTIPLY        shift and go to state 78
    DIVIDE          shift and go to state 79
    MOD             shift and go to state 80


state 120

    (72) term -> term MULTIPLY factor .

    MULTIPLY        reduce using rule 72 (term -> term MULTIPLY factor .)
    DIVIDE          reduce using rule 72 (term -> term MULTIPLY factor .)
    MOD             reduce using rule 72 (term -> term MULTIPLY factor .)
    PLUS            reduce using rule 72 (term -> term MULTIPLY factor .)
    MINUS           reduce using rule 72 (term -> term MULTIPLY factor .)
    L_SHIFT         reduce using rule 72 (term -> term MULTIPLY factor .)
    R_SHIFT         reduce using rule 72 (term -> term MULTIPLY factor .)
    LE              reduce using rule 72 (term -> term MULTIPLY factor .)
    LT              reduce using rule 72 (term -> term MULTIPLY factor .)
    GE              reduce using rule 72 (term -> term MULTIPLY factor .)
    GT              reduce using rule 72 (term -> term MULTIPLY factor .)
    EQ              reduce using rule 72 (term -> term MULTIPLY factor .)
    NE              reduce using rule 72 (term -> term MULTIPLY factor .)
    BIT_AND         reduce using rule 72 (term -> term MULTIPLY factor .)
    BIT_XOR         reduce using rule 72 (term -> term MULTIPLY factor .)
    BIT_OR          reduce using rule 72 (term -> term MULTIPLY factor .)
    AND             reduce using rule 72 (term -> term MULTIPLY factor .)
    OR              reduce using rule 72 (term -> term MULTIPLY factor .)
    SEMICOLON       reduce using rule 72 (term -> term MULTIPLY factor .)
    ASSIGN          reduce using rule 72 (term -> term MULTIPLY factor .)
    PLUS_ASSIGN     reduce using rule 72 (term -> term MULTIPLY factor .)
    MINUS_ASSIGN    reduce using rule 72 (term -> term MULTIPLY factor .)
    MUL_ASSIGN      reduce using rule 72 (term -> term MULTIPLY factor .)
    DIV_ASSIGN      reduce using rule 72 (term -> term MULTIPLY factor .)
    AND_ASSIGN      reduce using rule 72 (term -> term MULTIPLY factor .)
    OR_ASSIGN       reduce using rule 72 (term -> term MULTIPLY factor .)
    XOR_ASSIGN      reduce using rule 72 (term -> term MULTIPLY factor .)
    MOD_ASSIGN      reduce using rule 72 (term -> term MULTIPLY factor .)
    L_SHIFT_ASSIGN  reduce using rule 72 (term -> term MULTIPLY factor .)
    R_SHIFT_ASSIGN  reduce using rule 72 (term -> term MULTIPLY factor .)
    R_PAREN         reduce using rule 72 (term -> term MULTIPLY factor .)
    COMMA           reduce using rule 72 (term -> term MULTIPLY factor .)


state 121

    (73) term -> term DIVIDE factor .

    MULTIPLY        reduce using rule 73 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 73 (term -> term DIVIDE factor .)
    MOD             reduce using rule 73 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 73 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 73 (term -> term DIVIDE factor .)
    L_SHIFT         reduce using rule 73 (term -> term DIVIDE factor .)
    R_SHIFT         reduce using rule 73 (term -> term DIVIDE factor .)
    LE              reduce using rule 73 (term -> term DIVIDE factor .)
    LT              reduce using rule 73 (term -> term DIVIDE factor .)
    GE              reduce using rule 73 (term -> term DIVIDE factor .)
    GT              reduce using rule 73 (term -> term DIVIDE factor .)
    EQ              reduce using rule 73 (term -> term DIVIDE factor .)
    NE              reduce using rule 73 (term -> term DIVIDE factor .)
    BIT_AND         reduce using rule 73 (term -> term DIVIDE factor .)
    BIT_XOR         reduce using rule 73 (term -> term DIVIDE factor .)
    BIT_OR          reduce using rule 73 (term -> term DIVIDE factor .)
    AND             reduce using rule 73 (term -> term DIVIDE factor .)
    OR              reduce using rule 73 (term -> term DIVIDE factor .)
    SEMICOLON       reduce using rule 73 (term -> term DIVIDE factor .)
    ASSIGN          reduce using rule 73 (term -> term DIVIDE factor .)
    PLUS_ASSIGN     reduce using rule 73 (term -> term DIVIDE factor .)
    MINUS_ASSIGN    reduce using rule 73 (term -> term DIVIDE factor .)
    MUL_ASSIGN      reduce using rule 73 (term -> term DIVIDE factor .)
    DIV_ASSIGN      reduce using rule 73 (term -> term DIVIDE factor .)
    AND_ASSIGN      reduce using rule 73 (term -> term DIVIDE factor .)
    OR_ASSIGN       reduce using rule 73 (term -> term DIVIDE factor .)
    XOR_ASSIGN      reduce using rule 73 (term -> term DIVIDE factor .)
    MOD_ASSIGN      reduce using rule 73 (term -> term DIVIDE factor .)
    L_SHIFT_ASSIGN  reduce using rule 73 (term -> term DIVIDE factor .)
    R_SHIFT_ASSIGN  reduce using rule 73 (term -> term DIVIDE factor .)
    R_PAREN         reduce using rule 73 (term -> term DIVIDE factor .)
    COMMA           reduce using rule 73 (term -> term DIVIDE factor .)


state 122

    (74) term -> term MOD factor .

    MULTIPLY        reduce using rule 74 (term -> term MOD factor .)
    DIVIDE          reduce using rule 74 (term -> term MOD factor .)
    MOD             reduce using rule 74 (term -> term MOD factor .)
    PLUS            reduce using rule 74 (term -> term MOD factor .)
    MINUS           reduce using rule 74 (term -> term MOD factor .)
    L_SHIFT         reduce using rule 74 (term -> term MOD factor .)
    R_SHIFT         reduce using rule 74 (term -> term MOD factor .)
    LE              reduce using rule 74 (term -> term MOD factor .)
    LT              reduce using rule 74 (term -> term MOD factor .)
    GE              reduce using rule 74 (term -> term MOD factor .)
    GT              reduce using rule 74 (term -> term MOD factor .)
    EQ              reduce using rule 74 (term -> term MOD factor .)
    NE              reduce using rule 74 (term -> term MOD factor .)
    BIT_AND         reduce using rule 74 (term -> term MOD factor .)
    BIT_XOR         reduce using rule 74 (term -> term MOD factor .)
    BIT_OR          reduce using rule 74 (term -> term MOD factor .)
    AND             reduce using rule 74 (term -> term MOD factor .)
    OR              reduce using rule 74 (term -> term MOD factor .)
    SEMICOLON       reduce using rule 74 (term -> term MOD factor .)
    ASSIGN          reduce using rule 74 (term -> term MOD factor .)
    PLUS_ASSIGN     reduce using rule 74 (term -> term MOD factor .)
    MINUS_ASSIGN    reduce using rule 74 (term -> term MOD factor .)
    MUL_ASSIGN      reduce using rule 74 (term -> term MOD factor .)
    DIV_ASSIGN      reduce using rule 74 (term -> term MOD factor .)
    AND_ASSIGN      reduce using rule 74 (term -> term MOD factor .)
    OR_ASSIGN       reduce using rule 74 (term -> term MOD factor .)
    XOR_ASSIGN      reduce using rule 74 (term -> term MOD factor .)
    MOD_ASSIGN      reduce using rule 74 (term -> term MOD factor .)
    L_SHIFT_ASSIGN  reduce using rule 74 (term -> term MOD factor .)
    R_SHIFT_ASSIGN  reduce using rule 74 (term -> term MOD factor .)
    R_PAREN         reduce using rule 74 (term -> term MOD factor .)
    COMMA           reduce using rule 74 (term -> term MOD factor .)


state 123

    (12) closed -> IF condition . closed ELSE closed
    (6) open -> IF condition . statement
    (7) open -> IF condition . closed ELSE open
    (10) closed -> . simple
    (11) closed -> . block
    (12) closed -> . IF condition closed ELSE closed
    (13) closed -> . WHILE condition closed
    (14) closed -> . FOR for_condition closed
    (4) statement -> . open
    (5) statement -> . closed
    (27) simple -> . expr SEMICOLON
    (28) simple -> . declaration
    (29) simple -> . SEMICOLON
    (30) simple -> . function
    (26) block -> . L_FLOWBRACE multiple_statements R_FLOWBRACE
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) open -> . FOR for_condition open
    (34) expr -> . expr assignment exprOR
    (35) expr -> . exprOR
    (23) declaration -> . TYPE ID SEMICOLON
    (24) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (25) declaration -> . TYPE multi_declaration stop
    (31) function -> . TYPE ID L_PAREN R_PAREN function_2
    (47) exprOR -> . exprOR OR exprAND
    (48) exprOR -> . exprAND
    (49) exprAND -> . exprAND AND exprBITOR
    (50) exprAND -> . exprBITOR
    (51) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (52) exprBITOR -> . exprBITXOR
    (53) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (54) exprBITXOR -> . exprBITAND
    (55) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (56) exprBITAND -> . exprEQ
    (57) exprEQ -> . exprEQ EQ exprRELOP
    (58) exprEQ -> . exprEQ NE exprRELOP
    (59) exprEQ -> . exprRELOP
    (60) exprRELOP -> . exprRELOP relop exprSHIFT
    (61) exprRELOP -> . exprSHIFT
    (66) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (67) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (68) exprSHIFT -> . exprOP
    (69) exprOP -> . exprOP PLUS term
    (70) exprOP -> . exprOP MINUS term
    (71) exprOP -> . term
    (72) term -> . term MULTIPLY factor
    (73) term -> . term DIVIDE factor
    (74) term -> . term MOD factor
    (75) term -> . factor
    (76) factor -> . NOT factor
    (77) factor -> . PLUS factor
    (78) factor -> . MINUS factor
    (79) factor -> . PLUS_PLUS factor
    (80) factor -> . MINUS_MINUS factor
    (81) factor -> . brace
    (82) brace -> . L_PAREN expr R_PAREN
    (83) brace -> . brace PLUS_PLUS
    (84) brace -> . brace MINUS_MINUS
    (85) brace -> . INT_NUM
    (86) brace -> . FLOAT_NUM
    (87) brace -> . ID

    IF              shift and go to state 87
    WHILE           shift and go to state 90
    FOR             shift and go to state 91
    SEMICOLON       shift and go to state 12
    L_FLOWBRACE     shift and go to state 15
    TYPE            shift and go to state 17
    NOT             shift and go to state 32
    PLUS            shift and go to state 28
    MINUS           shift and go to state 30
    PLUS_PLUS       shift and go to state 33
    MINUS_MINUS     shift and go to state 34
    L_PAREN         shift and go to state 19
    INT_NUM         shift and go to state 36
    FLOAT_NUM       shift and go to state 37
    ID              shift and go to state 18

    closed                         shift and go to state 135
    statement                      shift and go to state 88
    open                           shift and go to state 4
    simple                         shift and go to state 9
    block                          shift and go to state 10
    expr                           shift and go to state 11
    declaration                    shift and go to state 13
    function                       shift and go to state 14
    exprOR                         shift and go to state 16
    exprAND                        shift and go to state 20
    exprBITOR                      shift and go to state 21
    exprBITXOR                     shift and go to state 22
    exprBITAND                     shift and go to state 23
    exprEQ                         shift and go to state 24
    exprRELOP                      shift and go to state 25
    exprSHIFT                      shift and go to state 26
    exprOP                         shift and go to state 27
    term                           shift and go to state 29
    factor                         shift and go to state 31
    brace                          shift and go to state 35

state 124

    (7) open -> IF condition closed ELSE . open
    (12) closed -> IF condition closed ELSE . closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) open -> . FOR for_condition open
    (10) closed -> . simple
    (11) closed -> . block
    (12) closed -> . IF condition closed ELSE closed
    (13) closed -> . WHILE condition closed
    (14) closed -> . FOR for_condition closed
    (27) simple -> . expr SEMICOLON
    (28) simple -> . declaration
    (29) simple -> . SEMICOLON
    (30) simple -> . function
    (26) block -> . L_FLOWBRACE multiple_statements R_FLOWBRACE
    (34) expr -> . expr assignment exprOR
    (35) expr -> . exprOR
    (23) declaration -> . TYPE ID SEMICOLON
    (24) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (25) declaration -> . TYPE multi_declaration stop
    (31) function -> . TYPE ID L_PAREN R_PAREN function_2
    (47) exprOR -> . exprOR OR exprAND
    (48) exprOR -> . exprAND
    (49) exprAND -> . exprAND AND exprBITOR
    (50) exprAND -> . exprBITOR
    (51) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (52) exprBITOR -> . exprBITXOR
    (53) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (54) exprBITXOR -> . exprBITAND
    (55) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (56) exprBITAND -> . exprEQ
    (57) exprEQ -> . exprEQ EQ exprRELOP
    (58) exprEQ -> . exprEQ NE exprRELOP
    (59) exprEQ -> . exprRELOP
    (60) exprRELOP -> . exprRELOP relop exprSHIFT
    (61) exprRELOP -> . exprSHIFT
    (66) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (67) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (68) exprSHIFT -> . exprOP
    (69) exprOP -> . exprOP PLUS term
    (70) exprOP -> . exprOP MINUS term
    (71) exprOP -> . term
    (72) term -> . term MULTIPLY factor
    (73) term -> . term DIVIDE factor
    (74) term -> . term MOD factor
    (75) term -> . factor
    (76) factor -> . NOT factor
    (77) factor -> . PLUS factor
    (78) factor -> . MINUS factor
    (79) factor -> . PLUS_PLUS factor
    (80) factor -> . MINUS_MINUS factor
    (81) factor -> . brace
    (82) brace -> . L_PAREN expr R_PAREN
    (83) brace -> . brace PLUS_PLUS
    (84) brace -> . brace MINUS_MINUS
    (85) brace -> . INT_NUM
    (86) brace -> . FLOAT_NUM
    (87) brace -> . ID

    IF              shift and go to state 6
    WHILE           shift and go to state 7
    FOR             shift and go to state 8
    SEMICOLON       shift and go to state 12
    L_FLOWBRACE     shift and go to state 15
    TYPE            shift and go to state 17
    NOT             shift and go to state 32
    PLUS            shift and go to state 28
    MINUS           shift and go to state 30
    PLUS_PLUS       shift and go to state 33
    MINUS_MINUS     shift and go to state 34
    L_PAREN         shift and go to state 19
    INT_NUM         shift and go to state 36
    FLOAT_NUM       shift and go to state 37
    ID              shift and go to state 18

    closed                         shift and go to state 136
    open                           shift and go to state 137
    simple                         shift and go to state 9
    block                          shift and go to state 10
    expr                           shift and go to state 11
    declaration                    shift and go to state 13
    function                       shift and go to state 14
    exprOR                         shift and go to state 16
    exprAND                        shift and go to state 20
    exprBITOR                      shift and go to state 21
    exprBITXOR                     shift and go to state 22
    exprBITAND                     shift and go to state 23
    exprEQ                         shift and go to state 24
    exprRELOP                      shift and go to state 25
    exprSHIFT                      shift and go to state 26
    exprOP                         shift and go to state 27
    term                           shift and go to state 29
    factor                         shift and go to state 31
    brace                          shift and go to state 35

state 125

    (13) closed -> WHILE condition . closed
    (8) open -> WHILE condition . open
    (10) closed -> . simple
    (11) closed -> . block
    (12) closed -> . IF condition closed ELSE closed
    (13) closed -> . WHILE condition closed
    (14) closed -> . FOR for_condition closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) open -> . FOR for_condition open
    (27) simple -> . expr SEMICOLON
    (28) simple -> . declaration
    (29) simple -> . SEMICOLON
    (30) simple -> . function
    (26) block -> . L_FLOWBRACE multiple_statements R_FLOWBRACE
    (34) expr -> . expr assignment exprOR
    (35) expr -> . exprOR
    (23) declaration -> . TYPE ID SEMICOLON
    (24) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (25) declaration -> . TYPE multi_declaration stop
    (31) function -> . TYPE ID L_PAREN R_PAREN function_2
    (47) exprOR -> . exprOR OR exprAND
    (48) exprOR -> . exprAND
    (49) exprAND -> . exprAND AND exprBITOR
    (50) exprAND -> . exprBITOR
    (51) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (52) exprBITOR -> . exprBITXOR
    (53) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (54) exprBITXOR -> . exprBITAND
    (55) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (56) exprBITAND -> . exprEQ
    (57) exprEQ -> . exprEQ EQ exprRELOP
    (58) exprEQ -> . exprEQ NE exprRELOP
    (59) exprEQ -> . exprRELOP
    (60) exprRELOP -> . exprRELOP relop exprSHIFT
    (61) exprRELOP -> . exprSHIFT
    (66) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (67) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (68) exprSHIFT -> . exprOP
    (69) exprOP -> . exprOP PLUS term
    (70) exprOP -> . exprOP MINUS term
    (71) exprOP -> . term
    (72) term -> . term MULTIPLY factor
    (73) term -> . term DIVIDE factor
    (74) term -> . term MOD factor
    (75) term -> . factor
    (76) factor -> . NOT factor
    (77) factor -> . PLUS factor
    (78) factor -> . MINUS factor
    (79) factor -> . PLUS_PLUS factor
    (80) factor -> . MINUS_MINUS factor
    (81) factor -> . brace
    (82) brace -> . L_PAREN expr R_PAREN
    (83) brace -> . brace PLUS_PLUS
    (84) brace -> . brace MINUS_MINUS
    (85) brace -> . INT_NUM
    (86) brace -> . FLOAT_NUM
    (87) brace -> . ID

    IF              shift and go to state 87
    WHILE           shift and go to state 90
    FOR             shift and go to state 91
    SEMICOLON       shift and go to state 12
    L_FLOWBRACE     shift and go to state 15
    TYPE            shift and go to state 17
    NOT             shift and go to state 32
    PLUS            shift and go to state 28
    MINUS           shift and go to state 30
    PLUS_PLUS       shift and go to state 33
    MINUS_MINUS     shift and go to state 34
    L_PAREN         shift and go to state 19
    INT_NUM         shift and go to state 36
    FLOAT_NUM       shift and go to state 37
    ID              shift and go to state 18

    closed                         shift and go to state 94
    open                           shift and go to state 93
    simple                         shift and go to state 9
    block                          shift and go to state 10
    expr                           shift and go to state 11
    declaration                    shift and go to state 13
    function                       shift and go to state 14
    exprOR                         shift and go to state 16
    exprAND                        shift and go to state 20
    exprBITOR                      shift and go to state 21
    exprBITXOR                     shift and go to state 22
    exprBITAND                     shift and go to state 23
    exprEQ                         shift and go to state 24
    exprRELOP                      shift and go to state 25
    exprSHIFT                      shift and go to state 26
    exprOP                         shift and go to state 27
    term                           shift and go to state 29
    factor                         shift and go to state 31
    brace                          shift and go to state 35

state 126

    (14) closed -> FOR for_condition . closed
    (9) open -> FOR for_condition . open
    (10) closed -> . simple
    (11) closed -> . block
    (12) closed -> . IF condition closed ELSE closed
    (13) closed -> . WHILE condition closed
    (14) closed -> . FOR for_condition closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) open -> . FOR for_condition open
    (27) simple -> . expr SEMICOLON
    (28) simple -> . declaration
    (29) simple -> . SEMICOLON
    (30) simple -> . function
    (26) block -> . L_FLOWBRACE multiple_statements R_FLOWBRACE
    (34) expr -> . expr assignment exprOR
    (35) expr -> . exprOR
    (23) declaration -> . TYPE ID SEMICOLON
    (24) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (25) declaration -> . TYPE multi_declaration stop
    (31) function -> . TYPE ID L_PAREN R_PAREN function_2
    (47) exprOR -> . exprOR OR exprAND
    (48) exprOR -> . exprAND
    (49) exprAND -> . exprAND AND exprBITOR
    (50) exprAND -> . exprBITOR
    (51) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (52) exprBITOR -> . exprBITXOR
    (53) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (54) exprBITXOR -> . exprBITAND
    (55) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (56) exprBITAND -> . exprEQ
    (57) exprEQ -> . exprEQ EQ exprRELOP
    (58) exprEQ -> . exprEQ NE exprRELOP
    (59) exprEQ -> . exprRELOP
    (60) exprRELOP -> . exprRELOP relop exprSHIFT
    (61) exprRELOP -> . exprSHIFT
    (66) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (67) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (68) exprSHIFT -> . exprOP
    (69) exprOP -> . exprOP PLUS term
    (70) exprOP -> . exprOP MINUS term
    (71) exprOP -> . term
    (72) term -> . term MULTIPLY factor
    (73) term -> . term DIVIDE factor
    (74) term -> . term MOD factor
    (75) term -> . factor
    (76) factor -> . NOT factor
    (77) factor -> . PLUS factor
    (78) factor -> . MINUS factor
    (79) factor -> . PLUS_PLUS factor
    (80) factor -> . MINUS_MINUS factor
    (81) factor -> . brace
    (82) brace -> . L_PAREN expr R_PAREN
    (83) brace -> . brace PLUS_PLUS
    (84) brace -> . brace MINUS_MINUS
    (85) brace -> . INT_NUM
    (86) brace -> . FLOAT_NUM
    (87) brace -> . ID

    IF              shift and go to state 87
    WHILE           shift and go to state 90
    FOR             shift and go to state 91
    SEMICOLON       shift and go to state 12
    L_FLOWBRACE     shift and go to state 15
    TYPE            shift and go to state 17
    NOT             shift and go to state 32
    PLUS            shift and go to state 28
    MINUS           shift and go to state 30
    PLUS_PLUS       shift and go to state 33
    MINUS_MINUS     shift and go to state 34
    L_PAREN         shift and go to state 19
    INT_NUM         shift and go to state 36
    FLOAT_NUM       shift and go to state 37
    ID              shift and go to state 18

    closed                         shift and go to state 96
    open                           shift and go to state 95
    simple                         shift and go to state 9
    block                          shift and go to state 10
    expr                           shift and go to state 11
    declaration                    shift and go to state 13
    function                       shift and go to state 14
    exprOR                         shift and go to state 16
    exprAND                        shift and go to state 20
    exprBITOR                      shift and go to state 21
    exprBITXOR                     shift and go to state 22
    exprBITAND                     shift and go to state 23
    exprEQ                         shift and go to state 24
    exprRELOP                      shift and go to state 25
    exprSHIFT                      shift and go to state 26
    exprOP                         shift and go to state 27
    term                           shift and go to state 29
    factor                         shift and go to state 31
    brace                          shift and go to state 35

state 127

    (15) condition -> L_PAREN expr R_PAREN .

    IF              reduce using rule 15 (condition -> L_PAREN expr R_PAREN .)
    WHILE           reduce using rule 15 (condition -> L_PAREN expr R_PAREN .)
    FOR             reduce using rule 15 (condition -> L_PAREN expr R_PAREN .)
    SEMICOLON       reduce using rule 15 (condition -> L_PAREN expr R_PAREN .)
    L_FLOWBRACE     reduce using rule 15 (condition -> L_PAREN expr R_PAREN .)
    TYPE            reduce using rule 15 (condition -> L_PAREN expr R_PAREN .)
    NOT             reduce using rule 15 (condition -> L_PAREN expr R_PAREN .)
    PLUS            reduce using rule 15 (condition -> L_PAREN expr R_PAREN .)
    MINUS           reduce using rule 15 (condition -> L_PAREN expr R_PAREN .)
    PLUS_PLUS       reduce using rule 15 (condition -> L_PAREN expr R_PAREN .)
    MINUS_MINUS     reduce using rule 15 (condition -> L_PAREN expr R_PAREN .)
    L_PAREN         reduce using rule 15 (condition -> L_PAREN expr R_PAREN .)
    INT_NUM         reduce using rule 15 (condition -> L_PAREN expr R_PAREN .)
    FLOAT_NUM       reduce using rule 15 (condition -> L_PAREN expr R_PAREN .)
    ID              reduce using rule 15 (condition -> L_PAREN expr R_PAREN .)


state 128

    (16) for_condition -> L_PAREN declaration expr . SEMICOLON expr R_PAREN
    (34) expr -> expr . assignment exprOR
    (36) assignment -> . ASSIGN
    (37) assignment -> . PLUS_ASSIGN
    (38) assignment -> . MINUS_ASSIGN
    (39) assignment -> . MUL_ASSIGN
    (40) assignment -> . DIV_ASSIGN
    (41) assignment -> . AND_ASSIGN
    (42) assignment -> . OR_ASSIGN
    (43) assignment -> . XOR_ASSIGN
    (44) assignment -> . MOD_ASSIGN
    (45) assignment -> . L_SHIFT_ASSIGN
    (46) assignment -> . R_SHIFT_ASSIGN

    SEMICOLON       shift and go to state 138
    ASSIGN          shift and go to state 46
    PLUS_ASSIGN     shift and go to state 47
    MINUS_ASSIGN    shift and go to state 48
    MUL_ASSIGN      shift and go to state 49
    DIV_ASSIGN      shift and go to state 50
    AND_ASSIGN      shift and go to state 51
    OR_ASSIGN       shift and go to state 52
    XOR_ASSIGN      shift and go to state 53
    MOD_ASSIGN      shift and go to state 54
    L_SHIFT_ASSIGN  shift and go to state 55
    R_SHIFT_ASSIGN  shift and go to state 56

    assignment                     shift and go to state 45

state 129

    (23) declaration -> TYPE ID . SEMICOLON
    (24) declaration -> TYPE ID . ASSIGN expr SEMICOLON
    (19) multi_declaration -> ID . COMMA
    (20) multi_declaration -> ID . ASSIGN expr COMMA

    SEMICOLON       shift and go to state 102
    ASSIGN          shift and go to state 103
    COMMA           shift and go to state 105


state 130

    (24) declaration -> TYPE ID ASSIGN expr . SEMICOLON
    (20) multi_declaration -> ID ASSIGN expr . COMMA
    (34) expr -> expr . assignment exprOR
    (36) assignment -> . ASSIGN
    (37) assignment -> . PLUS_ASSIGN
    (38) assignment -> . MINUS_ASSIGN
    (39) assignment -> . MUL_ASSIGN
    (40) assignment -> . DIV_ASSIGN
    (41) assignment -> . AND_ASSIGN
    (42) assignment -> . OR_ASSIGN
    (43) assignment -> . XOR_ASSIGN
    (44) assignment -> . MOD_ASSIGN
    (45) assignment -> . L_SHIFT_ASSIGN
    (46) assignment -> . R_SHIFT_ASSIGN

    SEMICOLON       shift and go to state 139
    COMMA           shift and go to state 140
    ASSIGN          shift and go to state 46
    PLUS_ASSIGN     shift and go to state 47
    MINUS_ASSIGN    shift and go to state 48
    MUL_ASSIGN      shift and go to state 49
    DIV_ASSIGN      shift and go to state 50
    AND_ASSIGN      shift and go to state 51
    OR_ASSIGN       shift and go to state 52
    XOR_ASSIGN      shift and go to state 53
    MOD_ASSIGN      shift and go to state 54
    L_SHIFT_ASSIGN  shift and go to state 55
    R_SHIFT_ASSIGN  shift and go to state 56

    assignment                     shift and go to state 45

state 131

    (31) function -> TYPE ID L_PAREN R_PAREN . function_2
    (32) function_2 -> . SEMICOLON
    (33) function_2 -> . block
    (26) block -> . L_FLOWBRACE multiple_statements R_FLOWBRACE

    SEMICOLON       shift and go to state 142
    L_FLOWBRACE     shift and go to state 15

    function_2                     shift and go to state 141
    block                          shift and go to state 143

state 132

    (17) multi_declaration -> multi_declaration ID COMMA .

    ID              reduce using rule 17 (multi_declaration -> multi_declaration ID COMMA .)


state 133

    (18) multi_declaration -> multi_declaration ID ASSIGN . expr COMMA
    (22) stop -> ID ASSIGN . expr SEMICOLON
    (34) expr -> . expr assignment exprOR
    (35) expr -> . exprOR
    (47) exprOR -> . exprOR OR exprAND
    (48) exprOR -> . exprAND
    (49) exprAND -> . exprAND AND exprBITOR
    (50) exprAND -> . exprBITOR
    (51) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (52) exprBITOR -> . exprBITXOR
    (53) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (54) exprBITXOR -> . exprBITAND
    (55) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (56) exprBITAND -> . exprEQ
    (57) exprEQ -> . exprEQ EQ exprRELOP
    (58) exprEQ -> . exprEQ NE exprRELOP
    (59) exprEQ -> . exprRELOP
    (60) exprRELOP -> . exprRELOP relop exprSHIFT
    (61) exprRELOP -> . exprSHIFT
    (66) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (67) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (68) exprSHIFT -> . exprOP
    (69) exprOP -> . exprOP PLUS term
    (70) exprOP -> . exprOP MINUS term
    (71) exprOP -> . term
    (72) term -> . term MULTIPLY factor
    (73) term -> . term DIVIDE factor
    (74) term -> . term MOD factor
    (75) term -> . factor
    (76) factor -> . NOT factor
    (77) factor -> . PLUS factor
    (78) factor -> . MINUS factor
    (79) factor -> . PLUS_PLUS factor
    (80) factor -> . MINUS_MINUS factor
    (81) factor -> . brace
    (82) brace -> . L_PAREN expr R_PAREN
    (83) brace -> . brace PLUS_PLUS
    (84) brace -> . brace MINUS_MINUS
    (85) brace -> . INT_NUM
    (86) brace -> . FLOAT_NUM
    (87) brace -> . ID

    NOT             shift and go to state 32
    PLUS            shift and go to state 28
    MINUS           shift and go to state 30
    PLUS_PLUS       shift and go to state 33
    MINUS_MINUS     shift and go to state 34
    L_PAREN         shift and go to state 19
    INT_NUM         shift and go to state 36
    FLOAT_NUM       shift and go to state 37
    ID              shift and go to state 18

    expr                           shift and go to state 144
    exprOR                         shift and go to state 16
    exprAND                        shift and go to state 20
    exprBITOR                      shift and go to state 21
    exprBITXOR                     shift and go to state 22
    exprBITAND                     shift and go to state 23
    exprEQ                         shift and go to state 24
    exprRELOP                      shift and go to state 25
    exprSHIFT                      shift and go to state 26
    exprOP                         shift and go to state 27
    term                           shift and go to state 29
    factor                         shift and go to state 31
    brace                          shift and go to state 35

state 134

    (21) stop -> ID SEMICOLON .

    IF              reduce using rule 21 (stop -> ID SEMICOLON .)
    WHILE           reduce using rule 21 (stop -> ID SEMICOLON .)
    FOR             reduce using rule 21 (stop -> ID SEMICOLON .)
    SEMICOLON       reduce using rule 21 (stop -> ID SEMICOLON .)
    L_FLOWBRACE     reduce using rule 21 (stop -> ID SEMICOLON .)
    TYPE            reduce using rule 21 (stop -> ID SEMICOLON .)
    NOT             reduce using rule 21 (stop -> ID SEMICOLON .)
    PLUS            reduce using rule 21 (stop -> ID SEMICOLON .)
    MINUS           reduce using rule 21 (stop -> ID SEMICOLON .)
    PLUS_PLUS       reduce using rule 21 (stop -> ID SEMICOLON .)
    MINUS_MINUS     reduce using rule 21 (stop -> ID SEMICOLON .)
    L_PAREN         reduce using rule 21 (stop -> ID SEMICOLON .)
    INT_NUM         reduce using rule 21 (stop -> ID SEMICOLON .)
    FLOAT_NUM       reduce using rule 21 (stop -> ID SEMICOLON .)
    ID              reduce using rule 21 (stop -> ID SEMICOLON .)
    $end            reduce using rule 21 (stop -> ID SEMICOLON .)
    R_FLOWBRACE     reduce using rule 21 (stop -> ID SEMICOLON .)
    ELSE            reduce using rule 21 (stop -> ID SEMICOLON .)


state 135

    (12) closed -> IF condition closed . ELSE closed
    (7) open -> IF condition closed . ELSE open
    (5) statement -> closed .

    ELSE            shift and go to state 145
    IF              reduce using rule 5 (statement -> closed .)
    WHILE           reduce using rule 5 (statement -> closed .)
    FOR             reduce using rule 5 (statement -> closed .)
    SEMICOLON       reduce using rule 5 (statement -> closed .)
    L_FLOWBRACE     reduce using rule 5 (statement -> closed .)
    TYPE            reduce using rule 5 (statement -> closed .)
    NOT             reduce using rule 5 (statement -> closed .)
    PLUS            reduce using rule 5 (statement -> closed .)
    MINUS           reduce using rule 5 (statement -> closed .)
    PLUS_PLUS       reduce using rule 5 (statement -> closed .)
    MINUS_MINUS     reduce using rule 5 (statement -> closed .)
    L_PAREN         reduce using rule 5 (statement -> closed .)
    INT_NUM         reduce using rule 5 (statement -> closed .)
    FLOAT_NUM       reduce using rule 5 (statement -> closed .)
    ID              reduce using rule 5 (statement -> closed .)
    $end            reduce using rule 5 (statement -> closed .)
    R_FLOWBRACE     reduce using rule 5 (statement -> closed .)


state 136

    (12) closed -> IF condition closed ELSE closed .

    IF              reduce using rule 12 (closed -> IF condition closed ELSE closed .)
    WHILE           reduce using rule 12 (closed -> IF condition closed ELSE closed .)
    FOR             reduce using rule 12 (closed -> IF condition closed ELSE closed .)
    SEMICOLON       reduce using rule 12 (closed -> IF condition closed ELSE closed .)
    L_FLOWBRACE     reduce using rule 12 (closed -> IF condition closed ELSE closed .)
    TYPE            reduce using rule 12 (closed -> IF condition closed ELSE closed .)
    NOT             reduce using rule 12 (closed -> IF condition closed ELSE closed .)
    PLUS            reduce using rule 12 (closed -> IF condition closed ELSE closed .)
    MINUS           reduce using rule 12 (closed -> IF condition closed ELSE closed .)
    PLUS_PLUS       reduce using rule 12 (closed -> IF condition closed ELSE closed .)
    MINUS_MINUS     reduce using rule 12 (closed -> IF condition closed ELSE closed .)
    L_PAREN         reduce using rule 12 (closed -> IF condition closed ELSE closed .)
    INT_NUM         reduce using rule 12 (closed -> IF condition closed ELSE closed .)
    FLOAT_NUM       reduce using rule 12 (closed -> IF condition closed ELSE closed .)
    ID              reduce using rule 12 (closed -> IF condition closed ELSE closed .)
    $end            reduce using rule 12 (closed -> IF condition closed ELSE closed .)
    R_FLOWBRACE     reduce using rule 12 (closed -> IF condition closed ELSE closed .)
    ELSE            reduce using rule 12 (closed -> IF condition closed ELSE closed .)


state 137

    (7) open -> IF condition closed ELSE open .

    IF              reduce using rule 7 (open -> IF condition closed ELSE open .)
    WHILE           reduce using rule 7 (open -> IF condition closed ELSE open .)
    FOR             reduce using rule 7 (open -> IF condition closed ELSE open .)
    SEMICOLON       reduce using rule 7 (open -> IF condition closed ELSE open .)
    L_FLOWBRACE     reduce using rule 7 (open -> IF condition closed ELSE open .)
    TYPE            reduce using rule 7 (open -> IF condition closed ELSE open .)
    NOT             reduce using rule 7 (open -> IF condition closed ELSE open .)
    PLUS            reduce using rule 7 (open -> IF condition closed ELSE open .)
    MINUS           reduce using rule 7 (open -> IF condition closed ELSE open .)
    PLUS_PLUS       reduce using rule 7 (open -> IF condition closed ELSE open .)
    MINUS_MINUS     reduce using rule 7 (open -> IF condition closed ELSE open .)
    L_PAREN         reduce using rule 7 (open -> IF condition closed ELSE open .)
    INT_NUM         reduce using rule 7 (open -> IF condition closed ELSE open .)
    FLOAT_NUM       reduce using rule 7 (open -> IF condition closed ELSE open .)
    ID              reduce using rule 7 (open -> IF condition closed ELSE open .)
    $end            reduce using rule 7 (open -> IF condition closed ELSE open .)
    R_FLOWBRACE     reduce using rule 7 (open -> IF condition closed ELSE open .)


state 138

    (16) for_condition -> L_PAREN declaration expr SEMICOLON . expr R_PAREN
    (34) expr -> . expr assignment exprOR
    (35) expr -> . exprOR
    (47) exprOR -> . exprOR OR exprAND
    (48) exprOR -> . exprAND
    (49) exprAND -> . exprAND AND exprBITOR
    (50) exprAND -> . exprBITOR
    (51) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (52) exprBITOR -> . exprBITXOR
    (53) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (54) exprBITXOR -> . exprBITAND
    (55) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (56) exprBITAND -> . exprEQ
    (57) exprEQ -> . exprEQ EQ exprRELOP
    (58) exprEQ -> . exprEQ NE exprRELOP
    (59) exprEQ -> . exprRELOP
    (60) exprRELOP -> . exprRELOP relop exprSHIFT
    (61) exprRELOP -> . exprSHIFT
    (66) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (67) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (68) exprSHIFT -> . exprOP
    (69) exprOP -> . exprOP PLUS term
    (70) exprOP -> . exprOP MINUS term
    (71) exprOP -> . term
    (72) term -> . term MULTIPLY factor
    (73) term -> . term DIVIDE factor
    (74) term -> . term MOD factor
    (75) term -> . factor
    (76) factor -> . NOT factor
    (77) factor -> . PLUS factor
    (78) factor -> . MINUS factor
    (79) factor -> . PLUS_PLUS factor
    (80) factor -> . MINUS_MINUS factor
    (81) factor -> . brace
    (82) brace -> . L_PAREN expr R_PAREN
    (83) brace -> . brace PLUS_PLUS
    (84) brace -> . brace MINUS_MINUS
    (85) brace -> . INT_NUM
    (86) brace -> . FLOAT_NUM
    (87) brace -> . ID

    NOT             shift and go to state 32
    PLUS            shift and go to state 28
    MINUS           shift and go to state 30
    PLUS_PLUS       shift and go to state 33
    MINUS_MINUS     shift and go to state 34
    L_PAREN         shift and go to state 19
    INT_NUM         shift and go to state 36
    FLOAT_NUM       shift and go to state 37
    ID              shift and go to state 18

    expr                           shift and go to state 146
    exprOR                         shift and go to state 16
    exprAND                        shift and go to state 20
    exprBITOR                      shift and go to state 21
    exprBITXOR                     shift and go to state 22
    exprBITAND                     shift and go to state 23
    exprEQ                         shift and go to state 24
    exprRELOP                      shift and go to state 25
    exprSHIFT                      shift and go to state 26
    exprOP                         shift and go to state 27
    term                           shift and go to state 29
    factor                         shift and go to state 31
    brace                          shift and go to state 35

state 139

    (24) declaration -> TYPE ID ASSIGN expr SEMICOLON .

    IF              reduce using rule 24 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    WHILE           reduce using rule 24 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    FOR             reduce using rule 24 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    SEMICOLON       reduce using rule 24 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    L_FLOWBRACE     reduce using rule 24 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    TYPE            reduce using rule 24 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    NOT             reduce using rule 24 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    PLUS            reduce using rule 24 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    MINUS           reduce using rule 24 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    PLUS_PLUS       reduce using rule 24 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    MINUS_MINUS     reduce using rule 24 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    L_PAREN         reduce using rule 24 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    INT_NUM         reduce using rule 24 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    FLOAT_NUM       reduce using rule 24 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    ID              reduce using rule 24 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    $end            reduce using rule 24 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    R_FLOWBRACE     reduce using rule 24 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    ELSE            reduce using rule 24 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)


state 140

    (20) multi_declaration -> ID ASSIGN expr COMMA .

    ID              reduce using rule 20 (multi_declaration -> ID ASSIGN expr COMMA .)


state 141

    (31) function -> TYPE ID L_PAREN R_PAREN function_2 .

    IF              reduce using rule 31 (function -> TYPE ID L_PAREN R_PAREN function_2 .)
    WHILE           reduce using rule 31 (function -> TYPE ID L_PAREN R_PAREN function_2 .)
    FOR             reduce using rule 31 (function -> TYPE ID L_PAREN R_PAREN function_2 .)
    SEMICOLON       reduce using rule 31 (function -> TYPE ID L_PAREN R_PAREN function_2 .)
    L_FLOWBRACE     reduce using rule 31 (function -> TYPE ID L_PAREN R_PAREN function_2 .)
    TYPE            reduce using rule 31 (function -> TYPE ID L_PAREN R_PAREN function_2 .)
    NOT             reduce using rule 31 (function -> TYPE ID L_PAREN R_PAREN function_2 .)
    PLUS            reduce using rule 31 (function -> TYPE ID L_PAREN R_PAREN function_2 .)
    MINUS           reduce using rule 31 (function -> TYPE ID L_PAREN R_PAREN function_2 .)
    PLUS_PLUS       reduce using rule 31 (function -> TYPE ID L_PAREN R_PAREN function_2 .)
    MINUS_MINUS     reduce using rule 31 (function -> TYPE ID L_PAREN R_PAREN function_2 .)
    L_PAREN         reduce using rule 31 (function -> TYPE ID L_PAREN R_PAREN function_2 .)
    INT_NUM         reduce using rule 31 (function -> TYPE ID L_PAREN R_PAREN function_2 .)
    FLOAT_NUM       reduce using rule 31 (function -> TYPE ID L_PAREN R_PAREN function_2 .)
    ID              reduce using rule 31 (function -> TYPE ID L_PAREN R_PAREN function_2 .)
    $end            reduce using rule 31 (function -> TYPE ID L_PAREN R_PAREN function_2 .)
    R_FLOWBRACE     reduce using rule 31 (function -> TYPE ID L_PAREN R_PAREN function_2 .)
    ELSE            reduce using rule 31 (function -> TYPE ID L_PAREN R_PAREN function_2 .)


state 142

    (32) function_2 -> SEMICOLON .

    IF              reduce using rule 32 (function_2 -> SEMICOLON .)
    WHILE           reduce using rule 32 (function_2 -> SEMICOLON .)
    FOR             reduce using rule 32 (function_2 -> SEMICOLON .)
    SEMICOLON       reduce using rule 32 (function_2 -> SEMICOLON .)
    L_FLOWBRACE     reduce using rule 32 (function_2 -> SEMICOLON .)
    TYPE            reduce using rule 32 (function_2 -> SEMICOLON .)
    NOT             reduce using rule 32 (function_2 -> SEMICOLON .)
    PLUS            reduce using rule 32 (function_2 -> SEMICOLON .)
    MINUS           reduce using rule 32 (function_2 -> SEMICOLON .)
    PLUS_PLUS       reduce using rule 32 (function_2 -> SEMICOLON .)
    MINUS_MINUS     reduce using rule 32 (function_2 -> SEMICOLON .)
    L_PAREN         reduce using rule 32 (function_2 -> SEMICOLON .)
    INT_NUM         reduce using rule 32 (function_2 -> SEMICOLON .)
    FLOAT_NUM       reduce using rule 32 (function_2 -> SEMICOLON .)
    ID              reduce using rule 32 (function_2 -> SEMICOLON .)
    $end            reduce using rule 32 (function_2 -> SEMICOLON .)
    R_FLOWBRACE     reduce using rule 32 (function_2 -> SEMICOLON .)
    ELSE            reduce using rule 32 (function_2 -> SEMICOLON .)


state 143

    (33) function_2 -> block .

    IF              reduce using rule 33 (function_2 -> block .)
    WHILE           reduce using rule 33 (function_2 -> block .)
    FOR             reduce using rule 33 (function_2 -> block .)
    SEMICOLON       reduce using rule 33 (function_2 -> block .)
    L_FLOWBRACE     reduce using rule 33 (function_2 -> block .)
    TYPE            reduce using rule 33 (function_2 -> block .)
    NOT             reduce using rule 33 (function_2 -> block .)
    PLUS            reduce using rule 33 (function_2 -> block .)
    MINUS           reduce using rule 33 (function_2 -> block .)
    PLUS_PLUS       reduce using rule 33 (function_2 -> block .)
    MINUS_MINUS     reduce using rule 33 (function_2 -> block .)
    L_PAREN         reduce using rule 33 (function_2 -> block .)
    INT_NUM         reduce using rule 33 (function_2 -> block .)
    FLOAT_NUM       reduce using rule 33 (function_2 -> block .)
    ID              reduce using rule 33 (function_2 -> block .)
    $end            reduce using rule 33 (function_2 -> block .)
    R_FLOWBRACE     reduce using rule 33 (function_2 -> block .)
    ELSE            reduce using rule 33 (function_2 -> block .)


state 144

    (18) multi_declaration -> multi_declaration ID ASSIGN expr . COMMA
    (22) stop -> ID ASSIGN expr . SEMICOLON
    (34) expr -> expr . assignment exprOR
    (36) assignment -> . ASSIGN
    (37) assignment -> . PLUS_ASSIGN
    (38) assignment -> . MINUS_ASSIGN
    (39) assignment -> . MUL_ASSIGN
    (40) assignment -> . DIV_ASSIGN
    (41) assignment -> . AND_ASSIGN
    (42) assignment -> . OR_ASSIGN
    (43) assignment -> . XOR_ASSIGN
    (44) assignment -> . MOD_ASSIGN
    (45) assignment -> . L_SHIFT_ASSIGN
    (46) assignment -> . R_SHIFT_ASSIGN

    COMMA           shift and go to state 147
    SEMICOLON       shift and go to state 148
    ASSIGN          shift and go to state 46
    PLUS_ASSIGN     shift and go to state 47
    MINUS_ASSIGN    shift and go to state 48
    MUL_ASSIGN      shift and go to state 49
    DIV_ASSIGN      shift and go to state 50
    AND_ASSIGN      shift and go to state 51
    OR_ASSIGN       shift and go to state 52
    XOR_ASSIGN      shift and go to state 53
    MOD_ASSIGN      shift and go to state 54
    L_SHIFT_ASSIGN  shift and go to state 55
    R_SHIFT_ASSIGN  shift and go to state 56

    assignment                     shift and go to state 45

state 145

    (12) closed -> IF condition closed ELSE . closed
    (7) open -> IF condition closed ELSE . open
    (10) closed -> . simple
    (11) closed -> . block
    (12) closed -> . IF condition closed ELSE closed
    (13) closed -> . WHILE condition closed
    (14) closed -> . FOR for_condition closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) open -> . FOR for_condition open
    (27) simple -> . expr SEMICOLON
    (28) simple -> . declaration
    (29) simple -> . SEMICOLON
    (30) simple -> . function
    (26) block -> . L_FLOWBRACE multiple_statements R_FLOWBRACE
    (34) expr -> . expr assignment exprOR
    (35) expr -> . exprOR
    (23) declaration -> . TYPE ID SEMICOLON
    (24) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (25) declaration -> . TYPE multi_declaration stop
    (31) function -> . TYPE ID L_PAREN R_PAREN function_2
    (47) exprOR -> . exprOR OR exprAND
    (48) exprOR -> . exprAND
    (49) exprAND -> . exprAND AND exprBITOR
    (50) exprAND -> . exprBITOR
    (51) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (52) exprBITOR -> . exprBITXOR
    (53) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (54) exprBITXOR -> . exprBITAND
    (55) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (56) exprBITAND -> . exprEQ
    (57) exprEQ -> . exprEQ EQ exprRELOP
    (58) exprEQ -> . exprEQ NE exprRELOP
    (59) exprEQ -> . exprRELOP
    (60) exprRELOP -> . exprRELOP relop exprSHIFT
    (61) exprRELOP -> . exprSHIFT
    (66) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (67) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (68) exprSHIFT -> . exprOP
    (69) exprOP -> . exprOP PLUS term
    (70) exprOP -> . exprOP MINUS term
    (71) exprOP -> . term
    (72) term -> . term MULTIPLY factor
    (73) term -> . term DIVIDE factor
    (74) term -> . term MOD factor
    (75) term -> . factor
    (76) factor -> . NOT factor
    (77) factor -> . PLUS factor
    (78) factor -> . MINUS factor
    (79) factor -> . PLUS_PLUS factor
    (80) factor -> . MINUS_MINUS factor
    (81) factor -> . brace
    (82) brace -> . L_PAREN expr R_PAREN
    (83) brace -> . brace PLUS_PLUS
    (84) brace -> . brace MINUS_MINUS
    (85) brace -> . INT_NUM
    (86) brace -> . FLOAT_NUM
    (87) brace -> . ID

    IF              shift and go to state 87
    WHILE           shift and go to state 90
    FOR             shift and go to state 91
    SEMICOLON       shift and go to state 12
    L_FLOWBRACE     shift and go to state 15
    TYPE            shift and go to state 17
    NOT             shift and go to state 32
    PLUS            shift and go to state 28
    MINUS           shift and go to state 30
    PLUS_PLUS       shift and go to state 33
    MINUS_MINUS     shift and go to state 34
    L_PAREN         shift and go to state 19
    INT_NUM         shift and go to state 36
    FLOAT_NUM       shift and go to state 37
    ID              shift and go to state 18

    closed                         shift and go to state 136
    open                           shift and go to state 137
    simple                         shift and go to state 9
    block                          shift and go to state 10
    expr                           shift and go to state 11
    declaration                    shift and go to state 13
    function                       shift and go to state 14
    exprOR                         shift and go to state 16
    exprAND                        shift and go to state 20
    exprBITOR                      shift and go to state 21
    exprBITXOR                     shift and go to state 22
    exprBITAND                     shift and go to state 23
    exprEQ                         shift and go to state 24
    exprRELOP                      shift and go to state 25
    exprSHIFT                      shift and go to state 26
    exprOP                         shift and go to state 27
    term                           shift and go to state 29
    factor                         shift and go to state 31
    brace                          shift and go to state 35

state 146

    (16) for_condition -> L_PAREN declaration expr SEMICOLON expr . R_PAREN
    (34) expr -> expr . assignment exprOR
    (36) assignment -> . ASSIGN
    (37) assignment -> . PLUS_ASSIGN
    (38) assignment -> . MINUS_ASSIGN
    (39) assignment -> . MUL_ASSIGN
    (40) assignment -> . DIV_ASSIGN
    (41) assignment -> . AND_ASSIGN
    (42) assignment -> . OR_ASSIGN
    (43) assignment -> . XOR_ASSIGN
    (44) assignment -> . MOD_ASSIGN
    (45) assignment -> . L_SHIFT_ASSIGN
    (46) assignment -> . R_SHIFT_ASSIGN

    R_PAREN         shift and go to state 149
    ASSIGN          shift and go to state 46
    PLUS_ASSIGN     shift and go to state 47
    MINUS_ASSIGN    shift and go to state 48
    MUL_ASSIGN      shift and go to state 49
    DIV_ASSIGN      shift and go to state 50
    AND_ASSIGN      shift and go to state 51
    OR_ASSIGN       shift and go to state 52
    XOR_ASSIGN      shift and go to state 53
    MOD_ASSIGN      shift and go to state 54
    L_SHIFT_ASSIGN  shift and go to state 55
    R_SHIFT_ASSIGN  shift and go to state 56

    assignment                     shift and go to state 45

state 147

    (18) multi_declaration -> multi_declaration ID ASSIGN expr COMMA .

    ID              reduce using rule 18 (multi_declaration -> multi_declaration ID ASSIGN expr COMMA .)


state 148

    (22) stop -> ID ASSIGN expr SEMICOLON .

    IF              reduce using rule 22 (stop -> ID ASSIGN expr SEMICOLON .)
    WHILE           reduce using rule 22 (stop -> ID ASSIGN expr SEMICOLON .)
    FOR             reduce using rule 22 (stop -> ID ASSIGN expr SEMICOLON .)
    SEMICOLON       reduce using rule 22 (stop -> ID ASSIGN expr SEMICOLON .)
    L_FLOWBRACE     reduce using rule 22 (stop -> ID ASSIGN expr SEMICOLON .)
    TYPE            reduce using rule 22 (stop -> ID ASSIGN expr SEMICOLON .)
    NOT             reduce using rule 22 (stop -> ID ASSIGN expr SEMICOLON .)
    PLUS            reduce using rule 22 (stop -> ID ASSIGN expr SEMICOLON .)
    MINUS           reduce using rule 22 (stop -> ID ASSIGN expr SEMICOLON .)
    PLUS_PLUS       reduce using rule 22 (stop -> ID ASSIGN expr SEMICOLON .)
    MINUS_MINUS     reduce using rule 22 (stop -> ID ASSIGN expr SEMICOLON .)
    L_PAREN         reduce using rule 22 (stop -> ID ASSIGN expr SEMICOLON .)
    INT_NUM         reduce using rule 22 (stop -> ID ASSIGN expr SEMICOLON .)
    FLOAT_NUM       reduce using rule 22 (stop -> ID ASSIGN expr SEMICOLON .)
    ID              reduce using rule 22 (stop -> ID ASSIGN expr SEMICOLON .)
    $end            reduce using rule 22 (stop -> ID ASSIGN expr SEMICOLON .)
    R_FLOWBRACE     reduce using rule 22 (stop -> ID ASSIGN expr SEMICOLON .)
    ELSE            reduce using rule 22 (stop -> ID ASSIGN expr SEMICOLON .)


state 149

    (16) for_condition -> L_PAREN declaration expr SEMICOLON expr R_PAREN .

    IF              reduce using rule 16 (for_condition -> L_PAREN declaration expr SEMICOLON expr R_PAREN .)
    WHILE           reduce using rule 16 (for_condition -> L_PAREN declaration expr SEMICOLON expr R_PAREN .)
    FOR             reduce using rule 16 (for_condition -> L_PAREN declaration expr SEMICOLON expr R_PAREN .)
    SEMICOLON       reduce using rule 16 (for_condition -> L_PAREN declaration expr SEMICOLON expr R_PAREN .)
    L_FLOWBRACE     reduce using rule 16 (for_condition -> L_PAREN declaration expr SEMICOLON expr R_PAREN .)
    TYPE            reduce using rule 16 (for_condition -> L_PAREN declaration expr SEMICOLON expr R_PAREN .)
    NOT             reduce using rule 16 (for_condition -> L_PAREN declaration expr SEMICOLON expr R_PAREN .)
    PLUS            reduce using rule 16 (for_condition -> L_PAREN declaration expr SEMICOLON expr R_PAREN .)
    MINUS           reduce using rule 16 (for_condition -> L_PAREN declaration expr SEMICOLON expr R_PAREN .)
    PLUS_PLUS       reduce using rule 16 (for_condition -> L_PAREN declaration expr SEMICOLON expr R_PAREN .)
    MINUS_MINUS     reduce using rule 16 (for_condition -> L_PAREN declaration expr SEMICOLON expr R_PAREN .)
    L_PAREN         reduce using rule 16 (for_condition -> L_PAREN declaration expr SEMICOLON expr R_PAREN .)
    INT_NUM         reduce using rule 16 (for_condition -> L_PAREN declaration expr SEMICOLON expr R_PAREN .)
    FLOAT_NUM       reduce using rule 16 (for_condition -> L_PAREN declaration expr SEMICOLON expr R_PAREN .)
    ID              reduce using rule 16 (for_condition -> L_PAREN declaration expr SEMICOLON expr R_PAREN .)

