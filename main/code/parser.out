Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> start
Rule 1     start -> multiple_statements
Rule 2     multiple_statements -> multiple_statements statement
Rule 3     multiple_statements -> statement
Rule 4     statement -> open
Rule 5     statement -> closed
Rule 6     open -> IF condition statement
Rule 7     open -> IF condition closed ELSE open
Rule 8     open -> WHILE condition open
Rule 9     open -> FOR for_condition open
Rule 10    closed -> simple
Rule 11    closed -> block
Rule 12    closed -> IF condition closed ELSE closed
Rule 13    closed -> WHILE condition closed
Rule 14    closed -> FOR for_condition closed
Rule 15    condition -> L_PAREN expr R_PAREN
Rule 16    for_condition -> L_PAREN declaration expr SEMICOLON expr R_PAREN
Rule 17    for_condition -> L_PAREN expr SEMICOLON expr SEMICOLON expr R_PAREN
Rule 18    multi_declaration -> multi_declaration ID COMMA
Rule 19    multi_declaration -> multi_declaration ID ASSIGN expr COMMA
Rule 20    multi_declaration -> ID COMMA
Rule 21    multi_declaration -> ID ASSIGN expr COMMA
Rule 22    stop -> ID SEMICOLON
Rule 23    stop -> ID ASSIGN expr SEMICOLON
Rule 24    declaration -> TYPE ID SEMICOLON
Rule 25    declaration -> TYPE ID ASSIGN expr SEMICOLON
Rule 26    declaration -> TYPE ID ASSIGN function_call
Rule 27    declaration -> TYPE multi_declaration stop
Rule 28    block -> L_FLOWBRACE multiple_statements R_FLOWBRACE
Rule 29    simple -> expr SEMICOLON
Rule 30    simple -> declaration
Rule 31    simple -> SEMICOLON
Rule 32    simple -> function
Rule 33    simple -> function_call
Rule 34    simple -> RETURN ID SEMICOLON
Rule 35    simple -> RETURN INT_NUM SEMICOLON
Rule 36    empty -> <empty>
Rule 37    function_call -> ID L_PAREN call_params R_PAREN SEMICOLON
Rule 38    call_params -> empty
Rule 39    call_params -> yes_call_params end_call_params
Rule 40    call_params -> end_call_params
Rule 41    yes_call_params -> yes_call_params INT_NUM COMMA
Rule 42    yes_call_params -> yes_call_params ID COMMA
Rule 43    yes_call_params -> INT_NUM COMMA
Rule 44    yes_call_params -> ID COMMA
Rule 45    end_call_params -> INT_NUM
Rule 46    end_call_params -> ID
Rule 47    yes_dec_params -> yes_dec_params TYPE ID COMMA
Rule 48    yes_dec_params -> TYPE ID COMMA
Rule 49    end_dec_params -> TYPE ID
Rule 50    dec_params -> empty
Rule 51    dec_params -> yes_dec_params end_dec_params
Rule 52    dec_params -> end_dec_params
Rule 53    function -> TYPE ID L_PAREN dec_params R_PAREN function_2
Rule 54    function_2 -> SEMICOLON
Rule 55    function_2 -> block
Rule 56    expr -> expr assignment exprOR
Rule 57    expr -> expr assignment ID L_PAREN call_params R_PAREN
Rule 58    expr -> exprOR
Rule 59    assignment -> ASSIGN
Rule 60    assignment -> PLUS_ASSIGN
Rule 61    assignment -> MINUS_ASSIGN
Rule 62    assignment -> MUL_ASSIGN
Rule 63    assignment -> DIV_ASSIGN
Rule 64    assignment -> AND_ASSIGN
Rule 65    assignment -> OR_ASSIGN
Rule 66    assignment -> XOR_ASSIGN
Rule 67    assignment -> MOD_ASSIGN
Rule 68    assignment -> L_SHIFT_ASSIGN
Rule 69    assignment -> R_SHIFT_ASSIGN
Rule 70    exprOR -> exprOR OR exprAND
Rule 71    exprOR -> exprAND
Rule 72    exprAND -> exprAND AND exprBITOR
Rule 73    exprAND -> exprBITOR
Rule 74    exprBITOR -> exprBITOR BIT_OR exprBITXOR
Rule 75    exprBITOR -> exprBITXOR
Rule 76    exprBITXOR -> exprBITXOR BIT_XOR exprBITAND
Rule 77    exprBITXOR -> exprBITAND
Rule 78    exprBITAND -> exprBITAND BIT_AND exprEQ
Rule 79    exprBITAND -> exprEQ
Rule 80    exprEQ -> exprEQ EQ exprRELOP
Rule 81    exprEQ -> exprEQ NE exprRELOP
Rule 82    exprEQ -> exprRELOP
Rule 83    exprRELOP -> exprRELOP relop exprSHIFT
Rule 84    exprRELOP -> exprSHIFT
Rule 85    relop -> LE
Rule 86    relop -> LT
Rule 87    relop -> GE
Rule 88    relop -> GT
Rule 89    exprSHIFT -> exprSHIFT L_SHIFT exprOP
Rule 90    exprSHIFT -> exprSHIFT R_SHIFT exprOP
Rule 91    exprSHIFT -> exprOP
Rule 92    exprOP -> exprOP PLUS term
Rule 93    exprOP -> exprOP MINUS term
Rule 94    exprOP -> term
Rule 95    term -> term MULTIPLY factor
Rule 96    term -> term DIVIDE factor
Rule 97    term -> term MOD factor
Rule 98    term -> factor
Rule 99    factor -> NOT factor
Rule 100   factor -> PLUS factor
Rule 101   factor -> MINUS factor
Rule 102   factor -> PLUS_PLUS factor
Rule 103   factor -> MINUS_MINUS factor
Rule 104   factor -> brace
Rule 105   brace -> L_PAREN expr R_PAREN
Rule 106   brace -> brace PLUS_PLUS
Rule 107   brace -> brace MINUS_MINUS
Rule 108   brace -> INT_NUM
Rule 109   brace -> FLOAT_NUM
Rule 110   brace -> ID

Terminals, with rules where they appear

AND                  : 72
AND_ASSIGN           : 64
ASSIGN               : 19 21 23 25 26 59
BIT_AND              : 78
BIT_OR               : 74
BIT_XOR              : 76
COMMA                : 18 19 20 21 41 42 43 44 47 48
DIVIDE               : 96
DIV_ASSIGN           : 63
ELSE                 : 7 12
EQ                   : 80
FLOAT_NUM            : 109
FOR                  : 9 14
GE                   : 87
GT                   : 88
ID                   : 18 19 20 21 22 23 24 25 26 34 37 42 44 46 47 48 49 53 57 110
IF                   : 6 7 12
INT_NUM              : 35 41 43 45 108
LE                   : 85
LT                   : 86
L_FLOWBRACE          : 28
L_PAREN              : 15 16 17 37 53 57 105
L_SHIFT              : 89
L_SHIFT_ASSIGN       : 68
MINUS                : 93 101
MINUS_ASSIGN         : 61
MINUS_MINUS          : 103 107
MOD                  : 97
MOD_ASSIGN           : 67
MULTIPLY             : 95
MUL_ASSIGN           : 62
NE                   : 81
NOT                  : 99
OR                   : 70
OR_ASSIGN            : 65
PLUS                 : 92 100
PLUS_ASSIGN          : 60
PLUS_PLUS            : 102 106
RETURN               : 34 35
R_FLOWBRACE          : 28
R_PAREN              : 15 16 17 37 53 57 105
R_SHIFT              : 90
R_SHIFT_ASSIGN       : 69
SEMICOLON            : 16 17 17 22 23 24 25 29 31 34 35 37 54
TYPE                 : 24 25 26 27 47 48 49 53
WHILE                : 8 13
XOR_ASSIGN           : 66
error                : 

Nonterminals, with rules where they appear

assignment           : 56 57
block                : 11 55
brace                : 104 106 107
call_params          : 37 57
closed               : 5 7 12 12 13 14
condition            : 6 7 8 12 13
dec_params           : 53
declaration          : 16 30
empty                : 38 50
end_call_params      : 39 40
end_dec_params       : 51 52
expr                 : 15 16 16 17 17 17 19 21 23 25 29 56 57 105
exprAND              : 70 71 72
exprBITAND           : 76 77 78
exprBITOR            : 72 73 74
exprBITXOR           : 74 75 76
exprEQ               : 78 79 80 81
exprOP               : 89 90 91 92 93
exprOR               : 56 58 70
exprRELOP            : 80 81 82 83
exprSHIFT            : 83 84 89 90
factor               : 95 96 97 98 99 100 101 102 103
for_condition        : 9 14
function             : 32
function_2           : 53
function_call        : 26 33
multi_declaration    : 18 19 27
multiple_statements  : 1 2 28
open                 : 4 7 8 9
relop                : 83
simple               : 10
start                : 0
statement            : 2 3 6
stop                 : 27
term                 : 92 93 94 95 96 97
yes_call_params      : 39 41 42
yes_dec_params       : 47 51

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . multiple_statements
    (2) multiple_statements -> . multiple_statements statement
    (3) multiple_statements -> . statement
    (4) statement -> . open
    (5) statement -> . closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) open -> . FOR for_condition open
    (10) closed -> . simple
    (11) closed -> . block
    (12) closed -> . IF condition closed ELSE closed
    (13) closed -> . WHILE condition closed
    (14) closed -> . FOR for_condition closed
    (29) simple -> . expr SEMICOLON
    (30) simple -> . declaration
    (31) simple -> . SEMICOLON
    (32) simple -> . function
    (33) simple -> . function_call
    (34) simple -> . RETURN ID SEMICOLON
    (35) simple -> . RETURN INT_NUM SEMICOLON
    (28) block -> . L_FLOWBRACE multiple_statements R_FLOWBRACE
    (56) expr -> . expr assignment exprOR
    (57) expr -> . expr assignment ID L_PAREN call_params R_PAREN
    (58) expr -> . exprOR
    (24) declaration -> . TYPE ID SEMICOLON
    (25) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (26) declaration -> . TYPE ID ASSIGN function_call
    (27) declaration -> . TYPE multi_declaration stop
    (53) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (37) function_call -> . ID L_PAREN call_params R_PAREN SEMICOLON
    (70) exprOR -> . exprOR OR exprAND
    (71) exprOR -> . exprAND
    (72) exprAND -> . exprAND AND exprBITOR
    (73) exprAND -> . exprBITOR
    (74) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (75) exprBITOR -> . exprBITXOR
    (76) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (77) exprBITXOR -> . exprBITAND
    (78) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (79) exprBITAND -> . exprEQ
    (80) exprEQ -> . exprEQ EQ exprRELOP
    (81) exprEQ -> . exprEQ NE exprRELOP
    (82) exprEQ -> . exprRELOP
    (83) exprRELOP -> . exprRELOP relop exprSHIFT
    (84) exprRELOP -> . exprSHIFT
    (89) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (90) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (91) exprSHIFT -> . exprOP
    (92) exprOP -> . exprOP PLUS term
    (93) exprOP -> . exprOP MINUS term
    (94) exprOP -> . term
    (95) term -> . term MULTIPLY factor
    (96) term -> . term DIVIDE factor
    (97) term -> . term MOD factor
    (98) term -> . factor
    (99) factor -> . NOT factor
    (100) factor -> . PLUS factor
    (101) factor -> . MINUS factor
    (102) factor -> . PLUS_PLUS factor
    (103) factor -> . MINUS_MINUS factor
    (104) factor -> . brace
    (105) brace -> . L_PAREN expr R_PAREN
    (106) brace -> . brace PLUS_PLUS
    (107) brace -> . brace MINUS_MINUS
    (108) brace -> . INT_NUM
    (109) brace -> . FLOAT_NUM
    (110) brace -> . ID

    IF              shift and go to state 6
    WHILE           shift and go to state 7
    FOR             shift and go to state 8
    SEMICOLON       shift and go to state 12
    RETURN          shift and go to state 16
    L_FLOWBRACE     shift and go to state 19
    TYPE            shift and go to state 22
    ID              shift and go to state 17
    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    INT_NUM         shift and go to state 18
    FLOAT_NUM       shift and go to state 39

    start                          shift and go to state 1
    multiple_statements            shift and go to state 2
    statement                      shift and go to state 3
    open                           shift and go to state 4
    closed                         shift and go to state 5
    simple                         shift and go to state 9
    block                          shift and go to state 10
    expr                           shift and go to state 11
    declaration                    shift and go to state 13
    function                       shift and go to state 14
    function_call                  shift and go to state 15
    exprOR                         shift and go to state 20
    exprAND                        shift and go to state 23
    exprBITOR                      shift and go to state 24
    exprBITXOR                     shift and go to state 25
    exprBITAND                     shift and go to state 26
    exprEQ                         shift and go to state 27
    exprRELOP                      shift and go to state 28
    exprSHIFT                      shift and go to state 29
    exprOP                         shift and go to state 30
    term                           shift and go to state 32
    factor                         shift and go to state 34
    brace                          shift and go to state 38

state 1

    (0) S' -> start .



state 2

    (1) start -> multiple_statements .
    (2) multiple_statements -> multiple_statements . statement
    (4) statement -> . open
    (5) statement -> . closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) open -> . FOR for_condition open
    (10) closed -> . simple
    (11) closed -> . block
    (12) closed -> . IF condition closed ELSE closed
    (13) closed -> . WHILE condition closed
    (14) closed -> . FOR for_condition closed
    (29) simple -> . expr SEMICOLON
    (30) simple -> . declaration
    (31) simple -> . SEMICOLON
    (32) simple -> . function
    (33) simple -> . function_call
    (34) simple -> . RETURN ID SEMICOLON
    (35) simple -> . RETURN INT_NUM SEMICOLON
    (28) block -> . L_FLOWBRACE multiple_statements R_FLOWBRACE
    (56) expr -> . expr assignment exprOR
    (57) expr -> . expr assignment ID L_PAREN call_params R_PAREN
    (58) expr -> . exprOR
    (24) declaration -> . TYPE ID SEMICOLON
    (25) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (26) declaration -> . TYPE ID ASSIGN function_call
    (27) declaration -> . TYPE multi_declaration stop
    (53) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (37) function_call -> . ID L_PAREN call_params R_PAREN SEMICOLON
    (70) exprOR -> . exprOR OR exprAND
    (71) exprOR -> . exprAND
    (72) exprAND -> . exprAND AND exprBITOR
    (73) exprAND -> . exprBITOR
    (74) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (75) exprBITOR -> . exprBITXOR
    (76) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (77) exprBITXOR -> . exprBITAND
    (78) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (79) exprBITAND -> . exprEQ
    (80) exprEQ -> . exprEQ EQ exprRELOP
    (81) exprEQ -> . exprEQ NE exprRELOP
    (82) exprEQ -> . exprRELOP
    (83) exprRELOP -> . exprRELOP relop exprSHIFT
    (84) exprRELOP -> . exprSHIFT
    (89) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (90) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (91) exprSHIFT -> . exprOP
    (92) exprOP -> . exprOP PLUS term
    (93) exprOP -> . exprOP MINUS term
    (94) exprOP -> . term
    (95) term -> . term MULTIPLY factor
    (96) term -> . term DIVIDE factor
    (97) term -> . term MOD factor
    (98) term -> . factor
    (99) factor -> . NOT factor
    (100) factor -> . PLUS factor
    (101) factor -> . MINUS factor
    (102) factor -> . PLUS_PLUS factor
    (103) factor -> . MINUS_MINUS factor
    (104) factor -> . brace
    (105) brace -> . L_PAREN expr R_PAREN
    (106) brace -> . brace PLUS_PLUS
    (107) brace -> . brace MINUS_MINUS
    (108) brace -> . INT_NUM
    (109) brace -> . FLOAT_NUM
    (110) brace -> . ID

    $end            reduce using rule 1 (start -> multiple_statements .)
    IF              shift and go to state 6
    WHILE           shift and go to state 7
    FOR             shift and go to state 8
    SEMICOLON       shift and go to state 12
    RETURN          shift and go to state 16
    L_FLOWBRACE     shift and go to state 19
    TYPE            shift and go to state 22
    ID              shift and go to state 17
    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    INT_NUM         shift and go to state 18
    FLOAT_NUM       shift and go to state 39

    statement                      shift and go to state 40
    open                           shift and go to state 4
    closed                         shift and go to state 5
    simple                         shift and go to state 9
    block                          shift and go to state 10
    expr                           shift and go to state 11
    declaration                    shift and go to state 13
    function                       shift and go to state 14
    function_call                  shift and go to state 15
    exprOR                         shift and go to state 20
    exprAND                        shift and go to state 23
    exprBITOR                      shift and go to state 24
    exprBITXOR                     shift and go to state 25
    exprBITAND                     shift and go to state 26
    exprEQ                         shift and go to state 27
    exprRELOP                      shift and go to state 28
    exprSHIFT                      shift and go to state 29
    exprOP                         shift and go to state 30
    term                           shift and go to state 32
    factor                         shift and go to state 34
    brace                          shift and go to state 38

state 3

    (3) multiple_statements -> statement .

    IF              reduce using rule 3 (multiple_statements -> statement .)
    WHILE           reduce using rule 3 (multiple_statements -> statement .)
    FOR             reduce using rule 3 (multiple_statements -> statement .)
    SEMICOLON       reduce using rule 3 (multiple_statements -> statement .)
    RETURN          reduce using rule 3 (multiple_statements -> statement .)
    L_FLOWBRACE     reduce using rule 3 (multiple_statements -> statement .)
    TYPE            reduce using rule 3 (multiple_statements -> statement .)
    ID              reduce using rule 3 (multiple_statements -> statement .)
    NOT             reduce using rule 3 (multiple_statements -> statement .)
    PLUS            reduce using rule 3 (multiple_statements -> statement .)
    MINUS           reduce using rule 3 (multiple_statements -> statement .)
    PLUS_PLUS       reduce using rule 3 (multiple_statements -> statement .)
    MINUS_MINUS     reduce using rule 3 (multiple_statements -> statement .)
    L_PAREN         reduce using rule 3 (multiple_statements -> statement .)
    INT_NUM         reduce using rule 3 (multiple_statements -> statement .)
    FLOAT_NUM       reduce using rule 3 (multiple_statements -> statement .)
    $end            reduce using rule 3 (multiple_statements -> statement .)
    R_FLOWBRACE     reduce using rule 3 (multiple_statements -> statement .)


state 4

    (4) statement -> open .

    IF              reduce using rule 4 (statement -> open .)
    WHILE           reduce using rule 4 (statement -> open .)
    FOR             reduce using rule 4 (statement -> open .)
    SEMICOLON       reduce using rule 4 (statement -> open .)
    RETURN          reduce using rule 4 (statement -> open .)
    L_FLOWBRACE     reduce using rule 4 (statement -> open .)
    TYPE            reduce using rule 4 (statement -> open .)
    ID              reduce using rule 4 (statement -> open .)
    NOT             reduce using rule 4 (statement -> open .)
    PLUS            reduce using rule 4 (statement -> open .)
    MINUS           reduce using rule 4 (statement -> open .)
    PLUS_PLUS       reduce using rule 4 (statement -> open .)
    MINUS_MINUS     reduce using rule 4 (statement -> open .)
    L_PAREN         reduce using rule 4 (statement -> open .)
    INT_NUM         reduce using rule 4 (statement -> open .)
    FLOAT_NUM       reduce using rule 4 (statement -> open .)
    $end            reduce using rule 4 (statement -> open .)
    R_FLOWBRACE     reduce using rule 4 (statement -> open .)


state 5

    (5) statement -> closed .

    IF              reduce using rule 5 (statement -> closed .)
    WHILE           reduce using rule 5 (statement -> closed .)
    FOR             reduce using rule 5 (statement -> closed .)
    SEMICOLON       reduce using rule 5 (statement -> closed .)
    RETURN          reduce using rule 5 (statement -> closed .)
    L_FLOWBRACE     reduce using rule 5 (statement -> closed .)
    TYPE            reduce using rule 5 (statement -> closed .)
    ID              reduce using rule 5 (statement -> closed .)
    NOT             reduce using rule 5 (statement -> closed .)
    PLUS            reduce using rule 5 (statement -> closed .)
    MINUS           reduce using rule 5 (statement -> closed .)
    PLUS_PLUS       reduce using rule 5 (statement -> closed .)
    MINUS_MINUS     reduce using rule 5 (statement -> closed .)
    L_PAREN         reduce using rule 5 (statement -> closed .)
    INT_NUM         reduce using rule 5 (statement -> closed .)
    FLOAT_NUM       reduce using rule 5 (statement -> closed .)
    $end            reduce using rule 5 (statement -> closed .)
    R_FLOWBRACE     reduce using rule 5 (statement -> closed .)


state 6

    (6) open -> IF . condition statement
    (7) open -> IF . condition closed ELSE open
    (12) closed -> IF . condition closed ELSE closed
    (15) condition -> . L_PAREN expr R_PAREN

    L_PAREN         shift and go to state 42

    condition                      shift and go to state 41

state 7

    (8) open -> WHILE . condition open
    (13) closed -> WHILE . condition closed
    (15) condition -> . L_PAREN expr R_PAREN

    L_PAREN         shift and go to state 42

    condition                      shift and go to state 43

state 8

    (9) open -> FOR . for_condition open
    (14) closed -> FOR . for_condition closed
    (16) for_condition -> . L_PAREN declaration expr SEMICOLON expr R_PAREN
    (17) for_condition -> . L_PAREN expr SEMICOLON expr SEMICOLON expr R_PAREN

    L_PAREN         shift and go to state 45

    for_condition                  shift and go to state 44

state 9

    (10) closed -> simple .

    IF              reduce using rule 10 (closed -> simple .)
    WHILE           reduce using rule 10 (closed -> simple .)
    FOR             reduce using rule 10 (closed -> simple .)
    SEMICOLON       reduce using rule 10 (closed -> simple .)
    RETURN          reduce using rule 10 (closed -> simple .)
    L_FLOWBRACE     reduce using rule 10 (closed -> simple .)
    TYPE            reduce using rule 10 (closed -> simple .)
    ID              reduce using rule 10 (closed -> simple .)
    NOT             reduce using rule 10 (closed -> simple .)
    PLUS            reduce using rule 10 (closed -> simple .)
    MINUS           reduce using rule 10 (closed -> simple .)
    PLUS_PLUS       reduce using rule 10 (closed -> simple .)
    MINUS_MINUS     reduce using rule 10 (closed -> simple .)
    L_PAREN         reduce using rule 10 (closed -> simple .)
    INT_NUM         reduce using rule 10 (closed -> simple .)
    FLOAT_NUM       reduce using rule 10 (closed -> simple .)
    $end            reduce using rule 10 (closed -> simple .)
    R_FLOWBRACE     reduce using rule 10 (closed -> simple .)
    ELSE            reduce using rule 10 (closed -> simple .)


state 10

    (11) closed -> block .

    IF              reduce using rule 11 (closed -> block .)
    WHILE           reduce using rule 11 (closed -> block .)
    FOR             reduce using rule 11 (closed -> block .)
    SEMICOLON       reduce using rule 11 (closed -> block .)
    RETURN          reduce using rule 11 (closed -> block .)
    L_FLOWBRACE     reduce using rule 11 (closed -> block .)
    TYPE            reduce using rule 11 (closed -> block .)
    ID              reduce using rule 11 (closed -> block .)
    NOT             reduce using rule 11 (closed -> block .)
    PLUS            reduce using rule 11 (closed -> block .)
    MINUS           reduce using rule 11 (closed -> block .)
    PLUS_PLUS       reduce using rule 11 (closed -> block .)
    MINUS_MINUS     reduce using rule 11 (closed -> block .)
    L_PAREN         reduce using rule 11 (closed -> block .)
    INT_NUM         reduce using rule 11 (closed -> block .)
    FLOAT_NUM       reduce using rule 11 (closed -> block .)
    $end            reduce using rule 11 (closed -> block .)
    R_FLOWBRACE     reduce using rule 11 (closed -> block .)
    ELSE            reduce using rule 11 (closed -> block .)


state 11

    (29) simple -> expr . SEMICOLON
    (56) expr -> expr . assignment exprOR
    (57) expr -> expr . assignment ID L_PAREN call_params R_PAREN
    (59) assignment -> . ASSIGN
    (60) assignment -> . PLUS_ASSIGN
    (61) assignment -> . MINUS_ASSIGN
    (62) assignment -> . MUL_ASSIGN
    (63) assignment -> . DIV_ASSIGN
    (64) assignment -> . AND_ASSIGN
    (65) assignment -> . OR_ASSIGN
    (66) assignment -> . XOR_ASSIGN
    (67) assignment -> . MOD_ASSIGN
    (68) assignment -> . L_SHIFT_ASSIGN
    (69) assignment -> . R_SHIFT_ASSIGN

    SEMICOLON       shift and go to state 46
    ASSIGN          shift and go to state 48
    PLUS_ASSIGN     shift and go to state 49
    MINUS_ASSIGN    shift and go to state 50
    MUL_ASSIGN      shift and go to state 51
    DIV_ASSIGN      shift and go to state 52
    AND_ASSIGN      shift and go to state 53
    OR_ASSIGN       shift and go to state 54
    XOR_ASSIGN      shift and go to state 55
    MOD_ASSIGN      shift and go to state 56
    L_SHIFT_ASSIGN  shift and go to state 57
    R_SHIFT_ASSIGN  shift and go to state 58

    assignment                     shift and go to state 47

state 12

    (31) simple -> SEMICOLON .

    IF              reduce using rule 31 (simple -> SEMICOLON .)
    WHILE           reduce using rule 31 (simple -> SEMICOLON .)
    FOR             reduce using rule 31 (simple -> SEMICOLON .)
    SEMICOLON       reduce using rule 31 (simple -> SEMICOLON .)
    RETURN          reduce using rule 31 (simple -> SEMICOLON .)
    L_FLOWBRACE     reduce using rule 31 (simple -> SEMICOLON .)
    TYPE            reduce using rule 31 (simple -> SEMICOLON .)
    ID              reduce using rule 31 (simple -> SEMICOLON .)
    NOT             reduce using rule 31 (simple -> SEMICOLON .)
    PLUS            reduce using rule 31 (simple -> SEMICOLON .)
    MINUS           reduce using rule 31 (simple -> SEMICOLON .)
    PLUS_PLUS       reduce using rule 31 (simple -> SEMICOLON .)
    MINUS_MINUS     reduce using rule 31 (simple -> SEMICOLON .)
    L_PAREN         reduce using rule 31 (simple -> SEMICOLON .)
    INT_NUM         reduce using rule 31 (simple -> SEMICOLON .)
    FLOAT_NUM       reduce using rule 31 (simple -> SEMICOLON .)
    $end            reduce using rule 31 (simple -> SEMICOLON .)
    R_FLOWBRACE     reduce using rule 31 (simple -> SEMICOLON .)
    ELSE            reduce using rule 31 (simple -> SEMICOLON .)


state 13

    (30) simple -> declaration .

    IF              reduce using rule 30 (simple -> declaration .)
    WHILE           reduce using rule 30 (simple -> declaration .)
    FOR             reduce using rule 30 (simple -> declaration .)
    SEMICOLON       reduce using rule 30 (simple -> declaration .)
    RETURN          reduce using rule 30 (simple -> declaration .)
    L_FLOWBRACE     reduce using rule 30 (simple -> declaration .)
    TYPE            reduce using rule 30 (simple -> declaration .)
    ID              reduce using rule 30 (simple -> declaration .)
    NOT             reduce using rule 30 (simple -> declaration .)
    PLUS            reduce using rule 30 (simple -> declaration .)
    MINUS           reduce using rule 30 (simple -> declaration .)
    PLUS_PLUS       reduce using rule 30 (simple -> declaration .)
    MINUS_MINUS     reduce using rule 30 (simple -> declaration .)
    L_PAREN         reduce using rule 30 (simple -> declaration .)
    INT_NUM         reduce using rule 30 (simple -> declaration .)
    FLOAT_NUM       reduce using rule 30 (simple -> declaration .)
    $end            reduce using rule 30 (simple -> declaration .)
    R_FLOWBRACE     reduce using rule 30 (simple -> declaration .)
    ELSE            reduce using rule 30 (simple -> declaration .)


state 14

    (32) simple -> function .

    IF              reduce using rule 32 (simple -> function .)
    WHILE           reduce using rule 32 (simple -> function .)
    FOR             reduce using rule 32 (simple -> function .)
    SEMICOLON       reduce using rule 32 (simple -> function .)
    RETURN          reduce using rule 32 (simple -> function .)
    L_FLOWBRACE     reduce using rule 32 (simple -> function .)
    TYPE            reduce using rule 32 (simple -> function .)
    ID              reduce using rule 32 (simple -> function .)
    NOT             reduce using rule 32 (simple -> function .)
    PLUS            reduce using rule 32 (simple -> function .)
    MINUS           reduce using rule 32 (simple -> function .)
    PLUS_PLUS       reduce using rule 32 (simple -> function .)
    MINUS_MINUS     reduce using rule 32 (simple -> function .)
    L_PAREN         reduce using rule 32 (simple -> function .)
    INT_NUM         reduce using rule 32 (simple -> function .)
    FLOAT_NUM       reduce using rule 32 (simple -> function .)
    $end            reduce using rule 32 (simple -> function .)
    R_FLOWBRACE     reduce using rule 32 (simple -> function .)
    ELSE            reduce using rule 32 (simple -> function .)


state 15

    (33) simple -> function_call .

    IF              reduce using rule 33 (simple -> function_call .)
    WHILE           reduce using rule 33 (simple -> function_call .)
    FOR             reduce using rule 33 (simple -> function_call .)
    SEMICOLON       reduce using rule 33 (simple -> function_call .)
    RETURN          reduce using rule 33 (simple -> function_call .)
    L_FLOWBRACE     reduce using rule 33 (simple -> function_call .)
    TYPE            reduce using rule 33 (simple -> function_call .)
    ID              reduce using rule 33 (simple -> function_call .)
    NOT             reduce using rule 33 (simple -> function_call .)
    PLUS            reduce using rule 33 (simple -> function_call .)
    MINUS           reduce using rule 33 (simple -> function_call .)
    PLUS_PLUS       reduce using rule 33 (simple -> function_call .)
    MINUS_MINUS     reduce using rule 33 (simple -> function_call .)
    L_PAREN         reduce using rule 33 (simple -> function_call .)
    INT_NUM         reduce using rule 33 (simple -> function_call .)
    FLOAT_NUM       reduce using rule 33 (simple -> function_call .)
    $end            reduce using rule 33 (simple -> function_call .)
    R_FLOWBRACE     reduce using rule 33 (simple -> function_call .)
    ELSE            reduce using rule 33 (simple -> function_call .)


state 16

    (34) simple -> RETURN . ID SEMICOLON
    (35) simple -> RETURN . INT_NUM SEMICOLON

    ID              shift and go to state 59
    INT_NUM         shift and go to state 60


state 17

    (37) function_call -> ID . L_PAREN call_params R_PAREN SEMICOLON
    (110) brace -> ID .

    L_PAREN         shift and go to state 61
    PLUS_PLUS       reduce using rule 110 (brace -> ID .)
    MINUS_MINUS     reduce using rule 110 (brace -> ID .)
    MULTIPLY        reduce using rule 110 (brace -> ID .)
    DIVIDE          reduce using rule 110 (brace -> ID .)
    MOD             reduce using rule 110 (brace -> ID .)
    PLUS            reduce using rule 110 (brace -> ID .)
    MINUS           reduce using rule 110 (brace -> ID .)
    L_SHIFT         reduce using rule 110 (brace -> ID .)
    R_SHIFT         reduce using rule 110 (brace -> ID .)
    LE              reduce using rule 110 (brace -> ID .)
    LT              reduce using rule 110 (brace -> ID .)
    GE              reduce using rule 110 (brace -> ID .)
    GT              reduce using rule 110 (brace -> ID .)
    EQ              reduce using rule 110 (brace -> ID .)
    NE              reduce using rule 110 (brace -> ID .)
    BIT_AND         reduce using rule 110 (brace -> ID .)
    BIT_XOR         reduce using rule 110 (brace -> ID .)
    BIT_OR          reduce using rule 110 (brace -> ID .)
    AND             reduce using rule 110 (brace -> ID .)
    OR              reduce using rule 110 (brace -> ID .)
    SEMICOLON       reduce using rule 110 (brace -> ID .)
    ASSIGN          reduce using rule 110 (brace -> ID .)
    PLUS_ASSIGN     reduce using rule 110 (brace -> ID .)
    MINUS_ASSIGN    reduce using rule 110 (brace -> ID .)
    MUL_ASSIGN      reduce using rule 110 (brace -> ID .)
    DIV_ASSIGN      reduce using rule 110 (brace -> ID .)
    AND_ASSIGN      reduce using rule 110 (brace -> ID .)
    OR_ASSIGN       reduce using rule 110 (brace -> ID .)
    XOR_ASSIGN      reduce using rule 110 (brace -> ID .)
    MOD_ASSIGN      reduce using rule 110 (brace -> ID .)
    L_SHIFT_ASSIGN  reduce using rule 110 (brace -> ID .)
    R_SHIFT_ASSIGN  reduce using rule 110 (brace -> ID .)
    COMMA           reduce using rule 110 (brace -> ID .)


state 18

    (108) brace -> INT_NUM .

    PLUS_PLUS       reduce using rule 108 (brace -> INT_NUM .)
    MINUS_MINUS     reduce using rule 108 (brace -> INT_NUM .)
    MULTIPLY        reduce using rule 108 (brace -> INT_NUM .)
    DIVIDE          reduce using rule 108 (brace -> INT_NUM .)
    MOD             reduce using rule 108 (brace -> INT_NUM .)
    PLUS            reduce using rule 108 (brace -> INT_NUM .)
    MINUS           reduce using rule 108 (brace -> INT_NUM .)
    L_SHIFT         reduce using rule 108 (brace -> INT_NUM .)
    R_SHIFT         reduce using rule 108 (brace -> INT_NUM .)
    LE              reduce using rule 108 (brace -> INT_NUM .)
    LT              reduce using rule 108 (brace -> INT_NUM .)
    GE              reduce using rule 108 (brace -> INT_NUM .)
    GT              reduce using rule 108 (brace -> INT_NUM .)
    EQ              reduce using rule 108 (brace -> INT_NUM .)
    NE              reduce using rule 108 (brace -> INT_NUM .)
    BIT_AND         reduce using rule 108 (brace -> INT_NUM .)
    BIT_XOR         reduce using rule 108 (brace -> INT_NUM .)
    BIT_OR          reduce using rule 108 (brace -> INT_NUM .)
    AND             reduce using rule 108 (brace -> INT_NUM .)
    OR              reduce using rule 108 (brace -> INT_NUM .)
    SEMICOLON       reduce using rule 108 (brace -> INT_NUM .)
    ASSIGN          reduce using rule 108 (brace -> INT_NUM .)
    PLUS_ASSIGN     reduce using rule 108 (brace -> INT_NUM .)
    MINUS_ASSIGN    reduce using rule 108 (brace -> INT_NUM .)
    MUL_ASSIGN      reduce using rule 108 (brace -> INT_NUM .)
    DIV_ASSIGN      reduce using rule 108 (brace -> INT_NUM .)
    AND_ASSIGN      reduce using rule 108 (brace -> INT_NUM .)
    OR_ASSIGN       reduce using rule 108 (brace -> INT_NUM .)
    XOR_ASSIGN      reduce using rule 108 (brace -> INT_NUM .)
    MOD_ASSIGN      reduce using rule 108 (brace -> INT_NUM .)
    L_SHIFT_ASSIGN  reduce using rule 108 (brace -> INT_NUM .)
    R_SHIFT_ASSIGN  reduce using rule 108 (brace -> INT_NUM .)
    R_PAREN         reduce using rule 108 (brace -> INT_NUM .)
    COMMA           reduce using rule 108 (brace -> INT_NUM .)


state 19

    (28) block -> L_FLOWBRACE . multiple_statements R_FLOWBRACE
    (2) multiple_statements -> . multiple_statements statement
    (3) multiple_statements -> . statement
    (4) statement -> . open
    (5) statement -> . closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) open -> . FOR for_condition open
    (10) closed -> . simple
    (11) closed -> . block
    (12) closed -> . IF condition closed ELSE closed
    (13) closed -> . WHILE condition closed
    (14) closed -> . FOR for_condition closed
    (29) simple -> . expr SEMICOLON
    (30) simple -> . declaration
    (31) simple -> . SEMICOLON
    (32) simple -> . function
    (33) simple -> . function_call
    (34) simple -> . RETURN ID SEMICOLON
    (35) simple -> . RETURN INT_NUM SEMICOLON
    (28) block -> . L_FLOWBRACE multiple_statements R_FLOWBRACE
    (56) expr -> . expr assignment exprOR
    (57) expr -> . expr assignment ID L_PAREN call_params R_PAREN
    (58) expr -> . exprOR
    (24) declaration -> . TYPE ID SEMICOLON
    (25) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (26) declaration -> . TYPE ID ASSIGN function_call
    (27) declaration -> . TYPE multi_declaration stop
    (53) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (37) function_call -> . ID L_PAREN call_params R_PAREN SEMICOLON
    (70) exprOR -> . exprOR OR exprAND
    (71) exprOR -> . exprAND
    (72) exprAND -> . exprAND AND exprBITOR
    (73) exprAND -> . exprBITOR
    (74) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (75) exprBITOR -> . exprBITXOR
    (76) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (77) exprBITXOR -> . exprBITAND
    (78) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (79) exprBITAND -> . exprEQ
    (80) exprEQ -> . exprEQ EQ exprRELOP
    (81) exprEQ -> . exprEQ NE exprRELOP
    (82) exprEQ -> . exprRELOP
    (83) exprRELOP -> . exprRELOP relop exprSHIFT
    (84) exprRELOP -> . exprSHIFT
    (89) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (90) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (91) exprSHIFT -> . exprOP
    (92) exprOP -> . exprOP PLUS term
    (93) exprOP -> . exprOP MINUS term
    (94) exprOP -> . term
    (95) term -> . term MULTIPLY factor
    (96) term -> . term DIVIDE factor
    (97) term -> . term MOD factor
    (98) term -> . factor
    (99) factor -> . NOT factor
    (100) factor -> . PLUS factor
    (101) factor -> . MINUS factor
    (102) factor -> . PLUS_PLUS factor
    (103) factor -> . MINUS_MINUS factor
    (104) factor -> . brace
    (105) brace -> . L_PAREN expr R_PAREN
    (106) brace -> . brace PLUS_PLUS
    (107) brace -> . brace MINUS_MINUS
    (108) brace -> . INT_NUM
    (109) brace -> . FLOAT_NUM
    (110) brace -> . ID

    IF              shift and go to state 6
    WHILE           shift and go to state 7
    FOR             shift and go to state 8
    SEMICOLON       shift and go to state 12
    RETURN          shift and go to state 16
    L_FLOWBRACE     shift and go to state 19
    TYPE            shift and go to state 22
    ID              shift and go to state 17
    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    INT_NUM         shift and go to state 18
    FLOAT_NUM       shift and go to state 39

    multiple_statements            shift and go to state 62
    statement                      shift and go to state 3
    open                           shift and go to state 4
    closed                         shift and go to state 5
    simple                         shift and go to state 9
    block                          shift and go to state 10
    expr                           shift and go to state 11
    declaration                    shift and go to state 13
    function                       shift and go to state 14
    function_call                  shift and go to state 15
    exprOR                         shift and go to state 20
    exprAND                        shift and go to state 23
    exprBITOR                      shift and go to state 24
    exprBITXOR                     shift and go to state 25
    exprBITAND                     shift and go to state 26
    exprEQ                         shift and go to state 27
    exprRELOP                      shift and go to state 28
    exprSHIFT                      shift and go to state 29
    exprOP                         shift and go to state 30
    term                           shift and go to state 32
    factor                         shift and go to state 34
    brace                          shift and go to state 38

state 20

    (58) expr -> exprOR .
    (70) exprOR -> exprOR . OR exprAND

    SEMICOLON       reduce using rule 58 (expr -> exprOR .)
    ASSIGN          reduce using rule 58 (expr -> exprOR .)
    PLUS_ASSIGN     reduce using rule 58 (expr -> exprOR .)
    MINUS_ASSIGN    reduce using rule 58 (expr -> exprOR .)
    MUL_ASSIGN      reduce using rule 58 (expr -> exprOR .)
    DIV_ASSIGN      reduce using rule 58 (expr -> exprOR .)
    AND_ASSIGN      reduce using rule 58 (expr -> exprOR .)
    OR_ASSIGN       reduce using rule 58 (expr -> exprOR .)
    XOR_ASSIGN      reduce using rule 58 (expr -> exprOR .)
    MOD_ASSIGN      reduce using rule 58 (expr -> exprOR .)
    L_SHIFT_ASSIGN  reduce using rule 58 (expr -> exprOR .)
    R_SHIFT_ASSIGN  reduce using rule 58 (expr -> exprOR .)
    R_PAREN         reduce using rule 58 (expr -> exprOR .)
    COMMA           reduce using rule 58 (expr -> exprOR .)
    OR              shift and go to state 63


state 21

    (105) brace -> L_PAREN . expr R_PAREN
    (56) expr -> . expr assignment exprOR
    (57) expr -> . expr assignment ID L_PAREN call_params R_PAREN
    (58) expr -> . exprOR
    (70) exprOR -> . exprOR OR exprAND
    (71) exprOR -> . exprAND
    (72) exprAND -> . exprAND AND exprBITOR
    (73) exprAND -> . exprBITOR
    (74) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (75) exprBITOR -> . exprBITXOR
    (76) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (77) exprBITXOR -> . exprBITAND
    (78) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (79) exprBITAND -> . exprEQ
    (80) exprEQ -> . exprEQ EQ exprRELOP
    (81) exprEQ -> . exprEQ NE exprRELOP
    (82) exprEQ -> . exprRELOP
    (83) exprRELOP -> . exprRELOP relop exprSHIFT
    (84) exprRELOP -> . exprSHIFT
    (89) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (90) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (91) exprSHIFT -> . exprOP
    (92) exprOP -> . exprOP PLUS term
    (93) exprOP -> . exprOP MINUS term
    (94) exprOP -> . term
    (95) term -> . term MULTIPLY factor
    (96) term -> . term DIVIDE factor
    (97) term -> . term MOD factor
    (98) term -> . factor
    (99) factor -> . NOT factor
    (100) factor -> . PLUS factor
    (101) factor -> . MINUS factor
    (102) factor -> . PLUS_PLUS factor
    (103) factor -> . MINUS_MINUS factor
    (104) factor -> . brace
    (105) brace -> . L_PAREN expr R_PAREN
    (106) brace -> . brace PLUS_PLUS
    (107) brace -> . brace MINUS_MINUS
    (108) brace -> . INT_NUM
    (109) brace -> . FLOAT_NUM
    (110) brace -> . ID

    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    INT_NUM         shift and go to state 18
    FLOAT_NUM       shift and go to state 39
    ID              shift and go to state 65

    expr                           shift and go to state 64
    exprOR                         shift and go to state 20
    exprAND                        shift and go to state 23
    exprBITOR                      shift and go to state 24
    exprBITXOR                     shift and go to state 25
    exprBITAND                     shift and go to state 26
    exprEQ                         shift and go to state 27
    exprRELOP                      shift and go to state 28
    exprSHIFT                      shift and go to state 29
    exprOP                         shift and go to state 30
    term                           shift and go to state 32
    factor                         shift and go to state 34
    brace                          shift and go to state 38

state 22

    (24) declaration -> TYPE . ID SEMICOLON
    (25) declaration -> TYPE . ID ASSIGN expr SEMICOLON
    (26) declaration -> TYPE . ID ASSIGN function_call
    (27) declaration -> TYPE . multi_declaration stop
    (53) function -> TYPE . ID L_PAREN dec_params R_PAREN function_2
    (18) multi_declaration -> . multi_declaration ID COMMA
    (19) multi_declaration -> . multi_declaration ID ASSIGN expr COMMA
    (20) multi_declaration -> . ID COMMA
    (21) multi_declaration -> . ID ASSIGN expr COMMA

    ID              shift and go to state 66

    multi_declaration              shift and go to state 67

state 23

    (71) exprOR -> exprAND .
    (72) exprAND -> exprAND . AND exprBITOR

    OR              reduce using rule 71 (exprOR -> exprAND .)
    SEMICOLON       reduce using rule 71 (exprOR -> exprAND .)
    ASSIGN          reduce using rule 71 (exprOR -> exprAND .)
    PLUS_ASSIGN     reduce using rule 71 (exprOR -> exprAND .)
    MINUS_ASSIGN    reduce using rule 71 (exprOR -> exprAND .)
    MUL_ASSIGN      reduce using rule 71 (exprOR -> exprAND .)
    DIV_ASSIGN      reduce using rule 71 (exprOR -> exprAND .)
    AND_ASSIGN      reduce using rule 71 (exprOR -> exprAND .)
    OR_ASSIGN       reduce using rule 71 (exprOR -> exprAND .)
    XOR_ASSIGN      reduce using rule 71 (exprOR -> exprAND .)
    MOD_ASSIGN      reduce using rule 71 (exprOR -> exprAND .)
    L_SHIFT_ASSIGN  reduce using rule 71 (exprOR -> exprAND .)
    R_SHIFT_ASSIGN  reduce using rule 71 (exprOR -> exprAND .)
    R_PAREN         reduce using rule 71 (exprOR -> exprAND .)
    COMMA           reduce using rule 71 (exprOR -> exprAND .)
    AND             shift and go to state 68


state 24

    (73) exprAND -> exprBITOR .
    (74) exprBITOR -> exprBITOR . BIT_OR exprBITXOR

    AND             reduce using rule 73 (exprAND -> exprBITOR .)
    OR              reduce using rule 73 (exprAND -> exprBITOR .)
    SEMICOLON       reduce using rule 73 (exprAND -> exprBITOR .)
    ASSIGN          reduce using rule 73 (exprAND -> exprBITOR .)
    PLUS_ASSIGN     reduce using rule 73 (exprAND -> exprBITOR .)
    MINUS_ASSIGN    reduce using rule 73 (exprAND -> exprBITOR .)
    MUL_ASSIGN      reduce using rule 73 (exprAND -> exprBITOR .)
    DIV_ASSIGN      reduce using rule 73 (exprAND -> exprBITOR .)
    AND_ASSIGN      reduce using rule 73 (exprAND -> exprBITOR .)
    OR_ASSIGN       reduce using rule 73 (exprAND -> exprBITOR .)
    XOR_ASSIGN      reduce using rule 73 (exprAND -> exprBITOR .)
    MOD_ASSIGN      reduce using rule 73 (exprAND -> exprBITOR .)
    L_SHIFT_ASSIGN  reduce using rule 73 (exprAND -> exprBITOR .)
    R_SHIFT_ASSIGN  reduce using rule 73 (exprAND -> exprBITOR .)
    R_PAREN         reduce using rule 73 (exprAND -> exprBITOR .)
    COMMA           reduce using rule 73 (exprAND -> exprBITOR .)
    BIT_OR          shift and go to state 69


state 25

    (75) exprBITOR -> exprBITXOR .
    (76) exprBITXOR -> exprBITXOR . BIT_XOR exprBITAND

    BIT_OR          reduce using rule 75 (exprBITOR -> exprBITXOR .)
    AND             reduce using rule 75 (exprBITOR -> exprBITXOR .)
    OR              reduce using rule 75 (exprBITOR -> exprBITXOR .)
    SEMICOLON       reduce using rule 75 (exprBITOR -> exprBITXOR .)
    ASSIGN          reduce using rule 75 (exprBITOR -> exprBITXOR .)
    PLUS_ASSIGN     reduce using rule 75 (exprBITOR -> exprBITXOR .)
    MINUS_ASSIGN    reduce using rule 75 (exprBITOR -> exprBITXOR .)
    MUL_ASSIGN      reduce using rule 75 (exprBITOR -> exprBITXOR .)
    DIV_ASSIGN      reduce using rule 75 (exprBITOR -> exprBITXOR .)
    AND_ASSIGN      reduce using rule 75 (exprBITOR -> exprBITXOR .)
    OR_ASSIGN       reduce using rule 75 (exprBITOR -> exprBITXOR .)
    XOR_ASSIGN      reduce using rule 75 (exprBITOR -> exprBITXOR .)
    MOD_ASSIGN      reduce using rule 75 (exprBITOR -> exprBITXOR .)
    L_SHIFT_ASSIGN  reduce using rule 75 (exprBITOR -> exprBITXOR .)
    R_SHIFT_ASSIGN  reduce using rule 75 (exprBITOR -> exprBITXOR .)
    R_PAREN         reduce using rule 75 (exprBITOR -> exprBITXOR .)
    COMMA           reduce using rule 75 (exprBITOR -> exprBITXOR .)
    BIT_XOR         shift and go to state 70


state 26

    (77) exprBITXOR -> exprBITAND .
    (78) exprBITAND -> exprBITAND . BIT_AND exprEQ

    BIT_XOR         reduce using rule 77 (exprBITXOR -> exprBITAND .)
    BIT_OR          reduce using rule 77 (exprBITXOR -> exprBITAND .)
    AND             reduce using rule 77 (exprBITXOR -> exprBITAND .)
    OR              reduce using rule 77 (exprBITXOR -> exprBITAND .)
    SEMICOLON       reduce using rule 77 (exprBITXOR -> exprBITAND .)
    ASSIGN          reduce using rule 77 (exprBITXOR -> exprBITAND .)
    PLUS_ASSIGN     reduce using rule 77 (exprBITXOR -> exprBITAND .)
    MINUS_ASSIGN    reduce using rule 77 (exprBITXOR -> exprBITAND .)
    MUL_ASSIGN      reduce using rule 77 (exprBITXOR -> exprBITAND .)
    DIV_ASSIGN      reduce using rule 77 (exprBITXOR -> exprBITAND .)
    AND_ASSIGN      reduce using rule 77 (exprBITXOR -> exprBITAND .)
    OR_ASSIGN       reduce using rule 77 (exprBITXOR -> exprBITAND .)
    XOR_ASSIGN      reduce using rule 77 (exprBITXOR -> exprBITAND .)
    MOD_ASSIGN      reduce using rule 77 (exprBITXOR -> exprBITAND .)
    L_SHIFT_ASSIGN  reduce using rule 77 (exprBITXOR -> exprBITAND .)
    R_SHIFT_ASSIGN  reduce using rule 77 (exprBITXOR -> exprBITAND .)
    R_PAREN         reduce using rule 77 (exprBITXOR -> exprBITAND .)
    COMMA           reduce using rule 77 (exprBITXOR -> exprBITAND .)
    BIT_AND         shift and go to state 71


state 27

    (79) exprBITAND -> exprEQ .
    (80) exprEQ -> exprEQ . EQ exprRELOP
    (81) exprEQ -> exprEQ . NE exprRELOP

    BIT_AND         reduce using rule 79 (exprBITAND -> exprEQ .)
    BIT_XOR         reduce using rule 79 (exprBITAND -> exprEQ .)
    BIT_OR          reduce using rule 79 (exprBITAND -> exprEQ .)
    AND             reduce using rule 79 (exprBITAND -> exprEQ .)
    OR              reduce using rule 79 (exprBITAND -> exprEQ .)
    SEMICOLON       reduce using rule 79 (exprBITAND -> exprEQ .)
    ASSIGN          reduce using rule 79 (exprBITAND -> exprEQ .)
    PLUS_ASSIGN     reduce using rule 79 (exprBITAND -> exprEQ .)
    MINUS_ASSIGN    reduce using rule 79 (exprBITAND -> exprEQ .)
    MUL_ASSIGN      reduce using rule 79 (exprBITAND -> exprEQ .)
    DIV_ASSIGN      reduce using rule 79 (exprBITAND -> exprEQ .)
    AND_ASSIGN      reduce using rule 79 (exprBITAND -> exprEQ .)
    OR_ASSIGN       reduce using rule 79 (exprBITAND -> exprEQ .)
    XOR_ASSIGN      reduce using rule 79 (exprBITAND -> exprEQ .)
    MOD_ASSIGN      reduce using rule 79 (exprBITAND -> exprEQ .)
    L_SHIFT_ASSIGN  reduce using rule 79 (exprBITAND -> exprEQ .)
    R_SHIFT_ASSIGN  reduce using rule 79 (exprBITAND -> exprEQ .)
    R_PAREN         reduce using rule 79 (exprBITAND -> exprEQ .)
    COMMA           reduce using rule 79 (exprBITAND -> exprEQ .)
    EQ              shift and go to state 72
    NE              shift and go to state 73


state 28

    (82) exprEQ -> exprRELOP .
    (83) exprRELOP -> exprRELOP . relop exprSHIFT
    (85) relop -> . LE
    (86) relop -> . LT
    (87) relop -> . GE
    (88) relop -> . GT

    EQ              reduce using rule 82 (exprEQ -> exprRELOP .)
    NE              reduce using rule 82 (exprEQ -> exprRELOP .)
    BIT_AND         reduce using rule 82 (exprEQ -> exprRELOP .)
    BIT_XOR         reduce using rule 82 (exprEQ -> exprRELOP .)
    BIT_OR          reduce using rule 82 (exprEQ -> exprRELOP .)
    AND             reduce using rule 82 (exprEQ -> exprRELOP .)
    OR              reduce using rule 82 (exprEQ -> exprRELOP .)
    SEMICOLON       reduce using rule 82 (exprEQ -> exprRELOP .)
    ASSIGN          reduce using rule 82 (exprEQ -> exprRELOP .)
    PLUS_ASSIGN     reduce using rule 82 (exprEQ -> exprRELOP .)
    MINUS_ASSIGN    reduce using rule 82 (exprEQ -> exprRELOP .)
    MUL_ASSIGN      reduce using rule 82 (exprEQ -> exprRELOP .)
    DIV_ASSIGN      reduce using rule 82 (exprEQ -> exprRELOP .)
    AND_ASSIGN      reduce using rule 82 (exprEQ -> exprRELOP .)
    OR_ASSIGN       reduce using rule 82 (exprEQ -> exprRELOP .)
    XOR_ASSIGN      reduce using rule 82 (exprEQ -> exprRELOP .)
    MOD_ASSIGN      reduce using rule 82 (exprEQ -> exprRELOP .)
    L_SHIFT_ASSIGN  reduce using rule 82 (exprEQ -> exprRELOP .)
    R_SHIFT_ASSIGN  reduce using rule 82 (exprEQ -> exprRELOP .)
    R_PAREN         reduce using rule 82 (exprEQ -> exprRELOP .)
    COMMA           reduce using rule 82 (exprEQ -> exprRELOP .)
    LE              shift and go to state 75
    LT              shift and go to state 76
    GE              shift and go to state 77
    GT              shift and go to state 78

    relop                          shift and go to state 74

state 29

    (84) exprRELOP -> exprSHIFT .
    (89) exprSHIFT -> exprSHIFT . L_SHIFT exprOP
    (90) exprSHIFT -> exprSHIFT . R_SHIFT exprOP

    LE              reduce using rule 84 (exprRELOP -> exprSHIFT .)
    LT              reduce using rule 84 (exprRELOP -> exprSHIFT .)
    GE              reduce using rule 84 (exprRELOP -> exprSHIFT .)
    GT              reduce using rule 84 (exprRELOP -> exprSHIFT .)
    EQ              reduce using rule 84 (exprRELOP -> exprSHIFT .)
    NE              reduce using rule 84 (exprRELOP -> exprSHIFT .)
    BIT_AND         reduce using rule 84 (exprRELOP -> exprSHIFT .)
    BIT_XOR         reduce using rule 84 (exprRELOP -> exprSHIFT .)
    BIT_OR          reduce using rule 84 (exprRELOP -> exprSHIFT .)
    AND             reduce using rule 84 (exprRELOP -> exprSHIFT .)
    OR              reduce using rule 84 (exprRELOP -> exprSHIFT .)
    SEMICOLON       reduce using rule 84 (exprRELOP -> exprSHIFT .)
    ASSIGN          reduce using rule 84 (exprRELOP -> exprSHIFT .)
    PLUS_ASSIGN     reduce using rule 84 (exprRELOP -> exprSHIFT .)
    MINUS_ASSIGN    reduce using rule 84 (exprRELOP -> exprSHIFT .)
    MUL_ASSIGN      reduce using rule 84 (exprRELOP -> exprSHIFT .)
    DIV_ASSIGN      reduce using rule 84 (exprRELOP -> exprSHIFT .)
    AND_ASSIGN      reduce using rule 84 (exprRELOP -> exprSHIFT .)
    OR_ASSIGN       reduce using rule 84 (exprRELOP -> exprSHIFT .)
    XOR_ASSIGN      reduce using rule 84 (exprRELOP -> exprSHIFT .)
    MOD_ASSIGN      reduce using rule 84 (exprRELOP -> exprSHIFT .)
    L_SHIFT_ASSIGN  reduce using rule 84 (exprRELOP -> exprSHIFT .)
    R_SHIFT_ASSIGN  reduce using rule 84 (exprRELOP -> exprSHIFT .)
    R_PAREN         reduce using rule 84 (exprRELOP -> exprSHIFT .)
    COMMA           reduce using rule 84 (exprRELOP -> exprSHIFT .)
    L_SHIFT         shift and go to state 79
    R_SHIFT         shift and go to state 80


state 30

    (91) exprSHIFT -> exprOP .
    (92) exprOP -> exprOP . PLUS term
    (93) exprOP -> exprOP . MINUS term

    L_SHIFT         reduce using rule 91 (exprSHIFT -> exprOP .)
    R_SHIFT         reduce using rule 91 (exprSHIFT -> exprOP .)
    LE              reduce using rule 91 (exprSHIFT -> exprOP .)
    LT              reduce using rule 91 (exprSHIFT -> exprOP .)
    GE              reduce using rule 91 (exprSHIFT -> exprOP .)
    GT              reduce using rule 91 (exprSHIFT -> exprOP .)
    EQ              reduce using rule 91 (exprSHIFT -> exprOP .)
    NE              reduce using rule 91 (exprSHIFT -> exprOP .)
    BIT_AND         reduce using rule 91 (exprSHIFT -> exprOP .)
    BIT_XOR         reduce using rule 91 (exprSHIFT -> exprOP .)
    BIT_OR          reduce using rule 91 (exprSHIFT -> exprOP .)
    AND             reduce using rule 91 (exprSHIFT -> exprOP .)
    OR              reduce using rule 91 (exprSHIFT -> exprOP .)
    SEMICOLON       reduce using rule 91 (exprSHIFT -> exprOP .)
    ASSIGN          reduce using rule 91 (exprSHIFT -> exprOP .)
    PLUS_ASSIGN     reduce using rule 91 (exprSHIFT -> exprOP .)
    MINUS_ASSIGN    reduce using rule 91 (exprSHIFT -> exprOP .)
    MUL_ASSIGN      reduce using rule 91 (exprSHIFT -> exprOP .)
    DIV_ASSIGN      reduce using rule 91 (exprSHIFT -> exprOP .)
    AND_ASSIGN      reduce using rule 91 (exprSHIFT -> exprOP .)
    OR_ASSIGN       reduce using rule 91 (exprSHIFT -> exprOP .)
    XOR_ASSIGN      reduce using rule 91 (exprSHIFT -> exprOP .)
    MOD_ASSIGN      reduce using rule 91 (exprSHIFT -> exprOP .)
    L_SHIFT_ASSIGN  reduce using rule 91 (exprSHIFT -> exprOP .)
    R_SHIFT_ASSIGN  reduce using rule 91 (exprSHIFT -> exprOP .)
    R_PAREN         reduce using rule 91 (exprSHIFT -> exprOP .)
    COMMA           reduce using rule 91 (exprSHIFT -> exprOP .)
    PLUS            shift and go to state 81
    MINUS           shift and go to state 82


state 31

    (100) factor -> PLUS . factor
    (99) factor -> . NOT factor
    (100) factor -> . PLUS factor
    (101) factor -> . MINUS factor
    (102) factor -> . PLUS_PLUS factor
    (103) factor -> . MINUS_MINUS factor
    (104) factor -> . brace
    (105) brace -> . L_PAREN expr R_PAREN
    (106) brace -> . brace PLUS_PLUS
    (107) brace -> . brace MINUS_MINUS
    (108) brace -> . INT_NUM
    (109) brace -> . FLOAT_NUM
    (110) brace -> . ID

    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    INT_NUM         shift and go to state 18
    FLOAT_NUM       shift and go to state 39
    ID              shift and go to state 65

    factor                         shift and go to state 83
    brace                          shift and go to state 38

state 32

    (94) exprOP -> term .
    (95) term -> term . MULTIPLY factor
    (96) term -> term . DIVIDE factor
    (97) term -> term . MOD factor

    PLUS            reduce using rule 94 (exprOP -> term .)
    MINUS           reduce using rule 94 (exprOP -> term .)
    L_SHIFT         reduce using rule 94 (exprOP -> term .)
    R_SHIFT         reduce using rule 94 (exprOP -> term .)
    LE              reduce using rule 94 (exprOP -> term .)
    LT              reduce using rule 94 (exprOP -> term .)
    GE              reduce using rule 94 (exprOP -> term .)
    GT              reduce using rule 94 (exprOP -> term .)
    EQ              reduce using rule 94 (exprOP -> term .)
    NE              reduce using rule 94 (exprOP -> term .)
    BIT_AND         reduce using rule 94 (exprOP -> term .)
    BIT_XOR         reduce using rule 94 (exprOP -> term .)
    BIT_OR          reduce using rule 94 (exprOP -> term .)
    AND             reduce using rule 94 (exprOP -> term .)
    OR              reduce using rule 94 (exprOP -> term .)
    SEMICOLON       reduce using rule 94 (exprOP -> term .)
    ASSIGN          reduce using rule 94 (exprOP -> term .)
    PLUS_ASSIGN     reduce using rule 94 (exprOP -> term .)
    MINUS_ASSIGN    reduce using rule 94 (exprOP -> term .)
    MUL_ASSIGN      reduce using rule 94 (exprOP -> term .)
    DIV_ASSIGN      reduce using rule 94 (exprOP -> term .)
    AND_ASSIGN      reduce using rule 94 (exprOP -> term .)
    OR_ASSIGN       reduce using rule 94 (exprOP -> term .)
    XOR_ASSIGN      reduce using rule 94 (exprOP -> term .)
    MOD_ASSIGN      reduce using rule 94 (exprOP -> term .)
    L_SHIFT_ASSIGN  reduce using rule 94 (exprOP -> term .)
    R_SHIFT_ASSIGN  reduce using rule 94 (exprOP -> term .)
    R_PAREN         reduce using rule 94 (exprOP -> term .)
    COMMA           reduce using rule 94 (exprOP -> term .)
    MULTIPLY        shift and go to state 84
    DIVIDE          shift and go to state 85
    MOD             shift and go to state 86


state 33

    (101) factor -> MINUS . factor
    (99) factor -> . NOT factor
    (100) factor -> . PLUS factor
    (101) factor -> . MINUS factor
    (102) factor -> . PLUS_PLUS factor
    (103) factor -> . MINUS_MINUS factor
    (104) factor -> . brace
    (105) brace -> . L_PAREN expr R_PAREN
    (106) brace -> . brace PLUS_PLUS
    (107) brace -> . brace MINUS_MINUS
    (108) brace -> . INT_NUM
    (109) brace -> . FLOAT_NUM
    (110) brace -> . ID

    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    INT_NUM         shift and go to state 18
    FLOAT_NUM       shift and go to state 39
    ID              shift and go to state 65

    factor                         shift and go to state 87
    brace                          shift and go to state 38

state 34

    (98) term -> factor .

    MULTIPLY        reduce using rule 98 (term -> factor .)
    DIVIDE          reduce using rule 98 (term -> factor .)
    MOD             reduce using rule 98 (term -> factor .)
    PLUS            reduce using rule 98 (term -> factor .)
    MINUS           reduce using rule 98 (term -> factor .)
    L_SHIFT         reduce using rule 98 (term -> factor .)
    R_SHIFT         reduce using rule 98 (term -> factor .)
    LE              reduce using rule 98 (term -> factor .)
    LT              reduce using rule 98 (term -> factor .)
    GE              reduce using rule 98 (term -> factor .)
    GT              reduce using rule 98 (term -> factor .)
    EQ              reduce using rule 98 (term -> factor .)
    NE              reduce using rule 98 (term -> factor .)
    BIT_AND         reduce using rule 98 (term -> factor .)
    BIT_XOR         reduce using rule 98 (term -> factor .)
    BIT_OR          reduce using rule 98 (term -> factor .)
    AND             reduce using rule 98 (term -> factor .)
    OR              reduce using rule 98 (term -> factor .)
    SEMICOLON       reduce using rule 98 (term -> factor .)
    ASSIGN          reduce using rule 98 (term -> factor .)
    PLUS_ASSIGN     reduce using rule 98 (term -> factor .)
    MINUS_ASSIGN    reduce using rule 98 (term -> factor .)
    MUL_ASSIGN      reduce using rule 98 (term -> factor .)
    DIV_ASSIGN      reduce using rule 98 (term -> factor .)
    AND_ASSIGN      reduce using rule 98 (term -> factor .)
    OR_ASSIGN       reduce using rule 98 (term -> factor .)
    XOR_ASSIGN      reduce using rule 98 (term -> factor .)
    MOD_ASSIGN      reduce using rule 98 (term -> factor .)
    L_SHIFT_ASSIGN  reduce using rule 98 (term -> factor .)
    R_SHIFT_ASSIGN  reduce using rule 98 (term -> factor .)
    R_PAREN         reduce using rule 98 (term -> factor .)
    COMMA           reduce using rule 98 (term -> factor .)


state 35

    (99) factor -> NOT . factor
    (99) factor -> . NOT factor
    (100) factor -> . PLUS factor
    (101) factor -> . MINUS factor
    (102) factor -> . PLUS_PLUS factor
    (103) factor -> . MINUS_MINUS factor
    (104) factor -> . brace
    (105) brace -> . L_PAREN expr R_PAREN
    (106) brace -> . brace PLUS_PLUS
    (107) brace -> . brace MINUS_MINUS
    (108) brace -> . INT_NUM
    (109) brace -> . FLOAT_NUM
    (110) brace -> . ID

    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    INT_NUM         shift and go to state 18
    FLOAT_NUM       shift and go to state 39
    ID              shift and go to state 65

    factor                         shift and go to state 88
    brace                          shift and go to state 38

state 36

    (102) factor -> PLUS_PLUS . factor
    (99) factor -> . NOT factor
    (100) factor -> . PLUS factor
    (101) factor -> . MINUS factor
    (102) factor -> . PLUS_PLUS factor
    (103) factor -> . MINUS_MINUS factor
    (104) factor -> . brace
    (105) brace -> . L_PAREN expr R_PAREN
    (106) brace -> . brace PLUS_PLUS
    (107) brace -> . brace MINUS_MINUS
    (108) brace -> . INT_NUM
    (109) brace -> . FLOAT_NUM
    (110) brace -> . ID

    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    INT_NUM         shift and go to state 18
    FLOAT_NUM       shift and go to state 39
    ID              shift and go to state 65

    factor                         shift and go to state 89
    brace                          shift and go to state 38

state 37

    (103) factor -> MINUS_MINUS . factor
    (99) factor -> . NOT factor
    (100) factor -> . PLUS factor
    (101) factor -> . MINUS factor
    (102) factor -> . PLUS_PLUS factor
    (103) factor -> . MINUS_MINUS factor
    (104) factor -> . brace
    (105) brace -> . L_PAREN expr R_PAREN
    (106) brace -> . brace PLUS_PLUS
    (107) brace -> . brace MINUS_MINUS
    (108) brace -> . INT_NUM
    (109) brace -> . FLOAT_NUM
    (110) brace -> . ID

    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    INT_NUM         shift and go to state 18
    FLOAT_NUM       shift and go to state 39
    ID              shift and go to state 65

    factor                         shift and go to state 90
    brace                          shift and go to state 38

state 38

    (104) factor -> brace .
    (106) brace -> brace . PLUS_PLUS
    (107) brace -> brace . MINUS_MINUS

    MULTIPLY        reduce using rule 104 (factor -> brace .)
    DIVIDE          reduce using rule 104 (factor -> brace .)
    MOD             reduce using rule 104 (factor -> brace .)
    PLUS            reduce using rule 104 (factor -> brace .)
    MINUS           reduce using rule 104 (factor -> brace .)
    L_SHIFT         reduce using rule 104 (factor -> brace .)
    R_SHIFT         reduce using rule 104 (factor -> brace .)
    LE              reduce using rule 104 (factor -> brace .)
    LT              reduce using rule 104 (factor -> brace .)
    GE              reduce using rule 104 (factor -> brace .)
    GT              reduce using rule 104 (factor -> brace .)
    EQ              reduce using rule 104 (factor -> brace .)
    NE              reduce using rule 104 (factor -> brace .)
    BIT_AND         reduce using rule 104 (factor -> brace .)
    BIT_XOR         reduce using rule 104 (factor -> brace .)
    BIT_OR          reduce using rule 104 (factor -> brace .)
    AND             reduce using rule 104 (factor -> brace .)
    OR              reduce using rule 104 (factor -> brace .)
    SEMICOLON       reduce using rule 104 (factor -> brace .)
    ASSIGN          reduce using rule 104 (factor -> brace .)
    PLUS_ASSIGN     reduce using rule 104 (factor -> brace .)
    MINUS_ASSIGN    reduce using rule 104 (factor -> brace .)
    MUL_ASSIGN      reduce using rule 104 (factor -> brace .)
    DIV_ASSIGN      reduce using rule 104 (factor -> brace .)
    AND_ASSIGN      reduce using rule 104 (factor -> brace .)
    OR_ASSIGN       reduce using rule 104 (factor -> brace .)
    XOR_ASSIGN      reduce using rule 104 (factor -> brace .)
    MOD_ASSIGN      reduce using rule 104 (factor -> brace .)
    L_SHIFT_ASSIGN  reduce using rule 104 (factor -> brace .)
    R_SHIFT_ASSIGN  reduce using rule 104 (factor -> brace .)
    R_PAREN         reduce using rule 104 (factor -> brace .)
    COMMA           reduce using rule 104 (factor -> brace .)
    PLUS_PLUS       shift and go to state 91
    MINUS_MINUS     shift and go to state 92


state 39

    (109) brace -> FLOAT_NUM .

    PLUS_PLUS       reduce using rule 109 (brace -> FLOAT_NUM .)
    MINUS_MINUS     reduce using rule 109 (brace -> FLOAT_NUM .)
    MULTIPLY        reduce using rule 109 (brace -> FLOAT_NUM .)
    DIVIDE          reduce using rule 109 (brace -> FLOAT_NUM .)
    MOD             reduce using rule 109 (brace -> FLOAT_NUM .)
    PLUS            reduce using rule 109 (brace -> FLOAT_NUM .)
    MINUS           reduce using rule 109 (brace -> FLOAT_NUM .)
    L_SHIFT         reduce using rule 109 (brace -> FLOAT_NUM .)
    R_SHIFT         reduce using rule 109 (brace -> FLOAT_NUM .)
    LE              reduce using rule 109 (brace -> FLOAT_NUM .)
    LT              reduce using rule 109 (brace -> FLOAT_NUM .)
    GE              reduce using rule 109 (brace -> FLOAT_NUM .)
    GT              reduce using rule 109 (brace -> FLOAT_NUM .)
    EQ              reduce using rule 109 (brace -> FLOAT_NUM .)
    NE              reduce using rule 109 (brace -> FLOAT_NUM .)
    BIT_AND         reduce using rule 109 (brace -> FLOAT_NUM .)
    BIT_XOR         reduce using rule 109 (brace -> FLOAT_NUM .)
    BIT_OR          reduce using rule 109 (brace -> FLOAT_NUM .)
    AND             reduce using rule 109 (brace -> FLOAT_NUM .)
    OR              reduce using rule 109 (brace -> FLOAT_NUM .)
    SEMICOLON       reduce using rule 109 (brace -> FLOAT_NUM .)
    ASSIGN          reduce using rule 109 (brace -> FLOAT_NUM .)
    PLUS_ASSIGN     reduce using rule 109 (brace -> FLOAT_NUM .)
    MINUS_ASSIGN    reduce using rule 109 (brace -> FLOAT_NUM .)
    MUL_ASSIGN      reduce using rule 109 (brace -> FLOAT_NUM .)
    DIV_ASSIGN      reduce using rule 109 (brace -> FLOAT_NUM .)
    AND_ASSIGN      reduce using rule 109 (brace -> FLOAT_NUM .)
    OR_ASSIGN       reduce using rule 109 (brace -> FLOAT_NUM .)
    XOR_ASSIGN      reduce using rule 109 (brace -> FLOAT_NUM .)
    MOD_ASSIGN      reduce using rule 109 (brace -> FLOAT_NUM .)
    L_SHIFT_ASSIGN  reduce using rule 109 (brace -> FLOAT_NUM .)
    R_SHIFT_ASSIGN  reduce using rule 109 (brace -> FLOAT_NUM .)
    R_PAREN         reduce using rule 109 (brace -> FLOAT_NUM .)
    COMMA           reduce using rule 109 (brace -> FLOAT_NUM .)


state 40

    (2) multiple_statements -> multiple_statements statement .

    IF              reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    WHILE           reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    FOR             reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    SEMICOLON       reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    RETURN          reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    L_FLOWBRACE     reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    TYPE            reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    ID              reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    NOT             reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    PLUS            reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    MINUS           reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    PLUS_PLUS       reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    MINUS_MINUS     reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    L_PAREN         reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    INT_NUM         reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    FLOAT_NUM       reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    $end            reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    R_FLOWBRACE     reduce using rule 2 (multiple_statements -> multiple_statements statement .)


state 41

    (6) open -> IF condition . statement
    (7) open -> IF condition . closed ELSE open
    (12) closed -> IF condition . closed ELSE closed
    (4) statement -> . open
    (5) statement -> . closed
    (10) closed -> . simple
    (11) closed -> . block
    (12) closed -> . IF condition closed ELSE closed
    (13) closed -> . WHILE condition closed
    (14) closed -> . FOR for_condition closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) open -> . FOR for_condition open
    (29) simple -> . expr SEMICOLON
    (30) simple -> . declaration
    (31) simple -> . SEMICOLON
    (32) simple -> . function
    (33) simple -> . function_call
    (34) simple -> . RETURN ID SEMICOLON
    (35) simple -> . RETURN INT_NUM SEMICOLON
    (28) block -> . L_FLOWBRACE multiple_statements R_FLOWBRACE
    (56) expr -> . expr assignment exprOR
    (57) expr -> . expr assignment ID L_PAREN call_params R_PAREN
    (58) expr -> . exprOR
    (24) declaration -> . TYPE ID SEMICOLON
    (25) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (26) declaration -> . TYPE ID ASSIGN function_call
    (27) declaration -> . TYPE multi_declaration stop
    (53) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (37) function_call -> . ID L_PAREN call_params R_PAREN SEMICOLON
    (70) exprOR -> . exprOR OR exprAND
    (71) exprOR -> . exprAND
    (72) exprAND -> . exprAND AND exprBITOR
    (73) exprAND -> . exprBITOR
    (74) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (75) exprBITOR -> . exprBITXOR
    (76) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (77) exprBITXOR -> . exprBITAND
    (78) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (79) exprBITAND -> . exprEQ
    (80) exprEQ -> . exprEQ EQ exprRELOP
    (81) exprEQ -> . exprEQ NE exprRELOP
    (82) exprEQ -> . exprRELOP
    (83) exprRELOP -> . exprRELOP relop exprSHIFT
    (84) exprRELOP -> . exprSHIFT
    (89) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (90) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (91) exprSHIFT -> . exprOP
    (92) exprOP -> . exprOP PLUS term
    (93) exprOP -> . exprOP MINUS term
    (94) exprOP -> . term
    (95) term -> . term MULTIPLY factor
    (96) term -> . term DIVIDE factor
    (97) term -> . term MOD factor
    (98) term -> . factor
    (99) factor -> . NOT factor
    (100) factor -> . PLUS factor
    (101) factor -> . MINUS factor
    (102) factor -> . PLUS_PLUS factor
    (103) factor -> . MINUS_MINUS factor
    (104) factor -> . brace
    (105) brace -> . L_PAREN expr R_PAREN
    (106) brace -> . brace PLUS_PLUS
    (107) brace -> . brace MINUS_MINUS
    (108) brace -> . INT_NUM
    (109) brace -> . FLOAT_NUM
    (110) brace -> . ID

    IF              shift and go to state 93
    WHILE           shift and go to state 96
    FOR             shift and go to state 97
    SEMICOLON       shift and go to state 12
    RETURN          shift and go to state 16
    L_FLOWBRACE     shift and go to state 19
    TYPE            shift and go to state 22
    ID              shift and go to state 17
    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    INT_NUM         shift and go to state 18
    FLOAT_NUM       shift and go to state 39

    statement                      shift and go to state 94
    closed                         shift and go to state 95
    open                           shift and go to state 4
    simple                         shift and go to state 9
    block                          shift and go to state 10
    expr                           shift and go to state 11
    declaration                    shift and go to state 13
    function                       shift and go to state 14
    function_call                  shift and go to state 15
    exprOR                         shift and go to state 20
    exprAND                        shift and go to state 23
    exprBITOR                      shift and go to state 24
    exprBITXOR                     shift and go to state 25
    exprBITAND                     shift and go to state 26
    exprEQ                         shift and go to state 27
    exprRELOP                      shift and go to state 28
    exprSHIFT                      shift and go to state 29
    exprOP                         shift and go to state 30
    term                           shift and go to state 32
    factor                         shift and go to state 34
    brace                          shift and go to state 38

state 42

    (15) condition -> L_PAREN . expr R_PAREN
    (56) expr -> . expr assignment exprOR
    (57) expr -> . expr assignment ID L_PAREN call_params R_PAREN
    (58) expr -> . exprOR
    (70) exprOR -> . exprOR OR exprAND
    (71) exprOR -> . exprAND
    (72) exprAND -> . exprAND AND exprBITOR
    (73) exprAND -> . exprBITOR
    (74) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (75) exprBITOR -> . exprBITXOR
    (76) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (77) exprBITXOR -> . exprBITAND
    (78) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (79) exprBITAND -> . exprEQ
    (80) exprEQ -> . exprEQ EQ exprRELOP
    (81) exprEQ -> . exprEQ NE exprRELOP
    (82) exprEQ -> . exprRELOP
    (83) exprRELOP -> . exprRELOP relop exprSHIFT
    (84) exprRELOP -> . exprSHIFT
    (89) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (90) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (91) exprSHIFT -> . exprOP
    (92) exprOP -> . exprOP PLUS term
    (93) exprOP -> . exprOP MINUS term
    (94) exprOP -> . term
    (95) term -> . term MULTIPLY factor
    (96) term -> . term DIVIDE factor
    (97) term -> . term MOD factor
    (98) term -> . factor
    (99) factor -> . NOT factor
    (100) factor -> . PLUS factor
    (101) factor -> . MINUS factor
    (102) factor -> . PLUS_PLUS factor
    (103) factor -> . MINUS_MINUS factor
    (104) factor -> . brace
    (105) brace -> . L_PAREN expr R_PAREN
    (106) brace -> . brace PLUS_PLUS
    (107) brace -> . brace MINUS_MINUS
    (108) brace -> . INT_NUM
    (109) brace -> . FLOAT_NUM
    (110) brace -> . ID

    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    INT_NUM         shift and go to state 18
    FLOAT_NUM       shift and go to state 39
    ID              shift and go to state 65

    expr                           shift and go to state 98
    exprOR                         shift and go to state 20
    exprAND                        shift and go to state 23
    exprBITOR                      shift and go to state 24
    exprBITXOR                     shift and go to state 25
    exprBITAND                     shift and go to state 26
    exprEQ                         shift and go to state 27
    exprRELOP                      shift and go to state 28
    exprSHIFT                      shift and go to state 29
    exprOP                         shift and go to state 30
    term                           shift and go to state 32
    factor                         shift and go to state 34
    brace                          shift and go to state 38

state 43

    (8) open -> WHILE condition . open
    (13) closed -> WHILE condition . closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) open -> . FOR for_condition open
    (10) closed -> . simple
    (11) closed -> . block
    (12) closed -> . IF condition closed ELSE closed
    (13) closed -> . WHILE condition closed
    (14) closed -> . FOR for_condition closed
    (29) simple -> . expr SEMICOLON
    (30) simple -> . declaration
    (31) simple -> . SEMICOLON
    (32) simple -> . function
    (33) simple -> . function_call
    (34) simple -> . RETURN ID SEMICOLON
    (35) simple -> . RETURN INT_NUM SEMICOLON
    (28) block -> . L_FLOWBRACE multiple_statements R_FLOWBRACE
    (56) expr -> . expr assignment exprOR
    (57) expr -> . expr assignment ID L_PAREN call_params R_PAREN
    (58) expr -> . exprOR
    (24) declaration -> . TYPE ID SEMICOLON
    (25) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (26) declaration -> . TYPE ID ASSIGN function_call
    (27) declaration -> . TYPE multi_declaration stop
    (53) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (37) function_call -> . ID L_PAREN call_params R_PAREN SEMICOLON
    (70) exprOR -> . exprOR OR exprAND
    (71) exprOR -> . exprAND
    (72) exprAND -> . exprAND AND exprBITOR
    (73) exprAND -> . exprBITOR
    (74) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (75) exprBITOR -> . exprBITXOR
    (76) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (77) exprBITXOR -> . exprBITAND
    (78) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (79) exprBITAND -> . exprEQ
    (80) exprEQ -> . exprEQ EQ exprRELOP
    (81) exprEQ -> . exprEQ NE exprRELOP
    (82) exprEQ -> . exprRELOP
    (83) exprRELOP -> . exprRELOP relop exprSHIFT
    (84) exprRELOP -> . exprSHIFT
    (89) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (90) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (91) exprSHIFT -> . exprOP
    (92) exprOP -> . exprOP PLUS term
    (93) exprOP -> . exprOP MINUS term
    (94) exprOP -> . term
    (95) term -> . term MULTIPLY factor
    (96) term -> . term DIVIDE factor
    (97) term -> . term MOD factor
    (98) term -> . factor
    (99) factor -> . NOT factor
    (100) factor -> . PLUS factor
    (101) factor -> . MINUS factor
    (102) factor -> . PLUS_PLUS factor
    (103) factor -> . MINUS_MINUS factor
    (104) factor -> . brace
    (105) brace -> . L_PAREN expr R_PAREN
    (106) brace -> . brace PLUS_PLUS
    (107) brace -> . brace MINUS_MINUS
    (108) brace -> . INT_NUM
    (109) brace -> . FLOAT_NUM
    (110) brace -> . ID

    IF              shift and go to state 6
    WHILE           shift and go to state 7
    FOR             shift and go to state 8
    SEMICOLON       shift and go to state 12
    RETURN          shift and go to state 16
    L_FLOWBRACE     shift and go to state 19
    TYPE            shift and go to state 22
    ID              shift and go to state 17
    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    INT_NUM         shift and go to state 18
    FLOAT_NUM       shift and go to state 39

    open                           shift and go to state 99
    closed                         shift and go to state 100
    simple                         shift and go to state 9
    block                          shift and go to state 10
    expr                           shift and go to state 11
    declaration                    shift and go to state 13
    function                       shift and go to state 14
    function_call                  shift and go to state 15
    exprOR                         shift and go to state 20
    exprAND                        shift and go to state 23
    exprBITOR                      shift and go to state 24
    exprBITXOR                     shift and go to state 25
    exprBITAND                     shift and go to state 26
    exprEQ                         shift and go to state 27
    exprRELOP                      shift and go to state 28
    exprSHIFT                      shift and go to state 29
    exprOP                         shift and go to state 30
    term                           shift and go to state 32
    factor                         shift and go to state 34
    brace                          shift and go to state 38

state 44

    (9) open -> FOR for_condition . open
    (14) closed -> FOR for_condition . closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) open -> . FOR for_condition open
    (10) closed -> . simple
    (11) closed -> . block
    (12) closed -> . IF condition closed ELSE closed
    (13) closed -> . WHILE condition closed
    (14) closed -> . FOR for_condition closed
    (29) simple -> . expr SEMICOLON
    (30) simple -> . declaration
    (31) simple -> . SEMICOLON
    (32) simple -> . function
    (33) simple -> . function_call
    (34) simple -> . RETURN ID SEMICOLON
    (35) simple -> . RETURN INT_NUM SEMICOLON
    (28) block -> . L_FLOWBRACE multiple_statements R_FLOWBRACE
    (56) expr -> . expr assignment exprOR
    (57) expr -> . expr assignment ID L_PAREN call_params R_PAREN
    (58) expr -> . exprOR
    (24) declaration -> . TYPE ID SEMICOLON
    (25) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (26) declaration -> . TYPE ID ASSIGN function_call
    (27) declaration -> . TYPE multi_declaration stop
    (53) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (37) function_call -> . ID L_PAREN call_params R_PAREN SEMICOLON
    (70) exprOR -> . exprOR OR exprAND
    (71) exprOR -> . exprAND
    (72) exprAND -> . exprAND AND exprBITOR
    (73) exprAND -> . exprBITOR
    (74) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (75) exprBITOR -> . exprBITXOR
    (76) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (77) exprBITXOR -> . exprBITAND
    (78) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (79) exprBITAND -> . exprEQ
    (80) exprEQ -> . exprEQ EQ exprRELOP
    (81) exprEQ -> . exprEQ NE exprRELOP
    (82) exprEQ -> . exprRELOP
    (83) exprRELOP -> . exprRELOP relop exprSHIFT
    (84) exprRELOP -> . exprSHIFT
    (89) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (90) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (91) exprSHIFT -> . exprOP
    (92) exprOP -> . exprOP PLUS term
    (93) exprOP -> . exprOP MINUS term
    (94) exprOP -> . term
    (95) term -> . term MULTIPLY factor
    (96) term -> . term DIVIDE factor
    (97) term -> . term MOD factor
    (98) term -> . factor
    (99) factor -> . NOT factor
    (100) factor -> . PLUS factor
    (101) factor -> . MINUS factor
    (102) factor -> . PLUS_PLUS factor
    (103) factor -> . MINUS_MINUS factor
    (104) factor -> . brace
    (105) brace -> . L_PAREN expr R_PAREN
    (106) brace -> . brace PLUS_PLUS
    (107) brace -> . brace MINUS_MINUS
    (108) brace -> . INT_NUM
    (109) brace -> . FLOAT_NUM
    (110) brace -> . ID

    IF              shift and go to state 6
    WHILE           shift and go to state 7
    FOR             shift and go to state 8
    SEMICOLON       shift and go to state 12
    RETURN          shift and go to state 16
    L_FLOWBRACE     shift and go to state 19
    TYPE            shift and go to state 22
    ID              shift and go to state 17
    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    INT_NUM         shift and go to state 18
    FLOAT_NUM       shift and go to state 39

    open                           shift and go to state 101
    closed                         shift and go to state 102
    simple                         shift and go to state 9
    block                          shift and go to state 10
    expr                           shift and go to state 11
    declaration                    shift and go to state 13
    function                       shift and go to state 14
    function_call                  shift and go to state 15
    exprOR                         shift and go to state 20
    exprAND                        shift and go to state 23
    exprBITOR                      shift and go to state 24
    exprBITXOR                     shift and go to state 25
    exprBITAND                     shift and go to state 26
    exprEQ                         shift and go to state 27
    exprRELOP                      shift and go to state 28
    exprSHIFT                      shift and go to state 29
    exprOP                         shift and go to state 30
    term                           shift and go to state 32
    factor                         shift and go to state 34
    brace                          shift and go to state 38

state 45

    (16) for_condition -> L_PAREN . declaration expr SEMICOLON expr R_PAREN
    (17) for_condition -> L_PAREN . expr SEMICOLON expr SEMICOLON expr R_PAREN
    (24) declaration -> . TYPE ID SEMICOLON
    (25) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (26) declaration -> . TYPE ID ASSIGN function_call
    (27) declaration -> . TYPE multi_declaration stop
    (56) expr -> . expr assignment exprOR
    (57) expr -> . expr assignment ID L_PAREN call_params R_PAREN
    (58) expr -> . exprOR
    (70) exprOR -> . exprOR OR exprAND
    (71) exprOR -> . exprAND
    (72) exprAND -> . exprAND AND exprBITOR
    (73) exprAND -> . exprBITOR
    (74) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (75) exprBITOR -> . exprBITXOR
    (76) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (77) exprBITXOR -> . exprBITAND
    (78) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (79) exprBITAND -> . exprEQ
    (80) exprEQ -> . exprEQ EQ exprRELOP
    (81) exprEQ -> . exprEQ NE exprRELOP
    (82) exprEQ -> . exprRELOP
    (83) exprRELOP -> . exprRELOP relop exprSHIFT
    (84) exprRELOP -> . exprSHIFT
    (89) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (90) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (91) exprSHIFT -> . exprOP
    (92) exprOP -> . exprOP PLUS term
    (93) exprOP -> . exprOP MINUS term
    (94) exprOP -> . term
    (95) term -> . term MULTIPLY factor
    (96) term -> . term DIVIDE factor
    (97) term -> . term MOD factor
    (98) term -> . factor
    (99) factor -> . NOT factor
    (100) factor -> . PLUS factor
    (101) factor -> . MINUS factor
    (102) factor -> . PLUS_PLUS factor
    (103) factor -> . MINUS_MINUS factor
    (104) factor -> . brace
    (105) brace -> . L_PAREN expr R_PAREN
    (106) brace -> . brace PLUS_PLUS
    (107) brace -> . brace MINUS_MINUS
    (108) brace -> . INT_NUM
    (109) brace -> . FLOAT_NUM
    (110) brace -> . ID

    TYPE            shift and go to state 105
    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    INT_NUM         shift and go to state 18
    FLOAT_NUM       shift and go to state 39
    ID              shift and go to state 65

    declaration                    shift and go to state 103
    expr                           shift and go to state 104
    exprOR                         shift and go to state 20
    exprAND                        shift and go to state 23
    exprBITOR                      shift and go to state 24
    exprBITXOR                     shift and go to state 25
    exprBITAND                     shift and go to state 26
    exprEQ                         shift and go to state 27
    exprRELOP                      shift and go to state 28
    exprSHIFT                      shift and go to state 29
    exprOP                         shift and go to state 30
    term                           shift and go to state 32
    factor                         shift and go to state 34
    brace                          shift and go to state 38

state 46

    (29) simple -> expr SEMICOLON .

    IF              reduce using rule 29 (simple -> expr SEMICOLON .)
    WHILE           reduce using rule 29 (simple -> expr SEMICOLON .)
    FOR             reduce using rule 29 (simple -> expr SEMICOLON .)
    SEMICOLON       reduce using rule 29 (simple -> expr SEMICOLON .)
    RETURN          reduce using rule 29 (simple -> expr SEMICOLON .)
    L_FLOWBRACE     reduce using rule 29 (simple -> expr SEMICOLON .)
    TYPE            reduce using rule 29 (simple -> expr SEMICOLON .)
    ID              reduce using rule 29 (simple -> expr SEMICOLON .)
    NOT             reduce using rule 29 (simple -> expr SEMICOLON .)
    PLUS            reduce using rule 29 (simple -> expr SEMICOLON .)
    MINUS           reduce using rule 29 (simple -> expr SEMICOLON .)
    PLUS_PLUS       reduce using rule 29 (simple -> expr SEMICOLON .)
    MINUS_MINUS     reduce using rule 29 (simple -> expr SEMICOLON .)
    L_PAREN         reduce using rule 29 (simple -> expr SEMICOLON .)
    INT_NUM         reduce using rule 29 (simple -> expr SEMICOLON .)
    FLOAT_NUM       reduce using rule 29 (simple -> expr SEMICOLON .)
    $end            reduce using rule 29 (simple -> expr SEMICOLON .)
    R_FLOWBRACE     reduce using rule 29 (simple -> expr SEMICOLON .)
    ELSE            reduce using rule 29 (simple -> expr SEMICOLON .)


state 47

    (56) expr -> expr assignment . exprOR
    (57) expr -> expr assignment . ID L_PAREN call_params R_PAREN
    (70) exprOR -> . exprOR OR exprAND
    (71) exprOR -> . exprAND
    (72) exprAND -> . exprAND AND exprBITOR
    (73) exprAND -> . exprBITOR
    (74) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (75) exprBITOR -> . exprBITXOR
    (76) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (77) exprBITXOR -> . exprBITAND
    (78) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (79) exprBITAND -> . exprEQ
    (80) exprEQ -> . exprEQ EQ exprRELOP
    (81) exprEQ -> . exprEQ NE exprRELOP
    (82) exprEQ -> . exprRELOP
    (83) exprRELOP -> . exprRELOP relop exprSHIFT
    (84) exprRELOP -> . exprSHIFT
    (89) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (90) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (91) exprSHIFT -> . exprOP
    (92) exprOP -> . exprOP PLUS term
    (93) exprOP -> . exprOP MINUS term
    (94) exprOP -> . term
    (95) term -> . term MULTIPLY factor
    (96) term -> . term DIVIDE factor
    (97) term -> . term MOD factor
    (98) term -> . factor
    (99) factor -> . NOT factor
    (100) factor -> . PLUS factor
    (101) factor -> . MINUS factor
    (102) factor -> . PLUS_PLUS factor
    (103) factor -> . MINUS_MINUS factor
    (104) factor -> . brace
    (105) brace -> . L_PAREN expr R_PAREN
    (106) brace -> . brace PLUS_PLUS
    (107) brace -> . brace MINUS_MINUS
    (108) brace -> . INT_NUM
    (109) brace -> . FLOAT_NUM
    (110) brace -> . ID

    ID              shift and go to state 107
    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    INT_NUM         shift and go to state 18
    FLOAT_NUM       shift and go to state 39

    exprOR                         shift and go to state 106
    exprAND                        shift and go to state 23
    exprBITOR                      shift and go to state 24
    exprBITXOR                     shift and go to state 25
    exprBITAND                     shift and go to state 26
    exprEQ                         shift and go to state 27
    exprRELOP                      shift and go to state 28
    exprSHIFT                      shift and go to state 29
    exprOP                         shift and go to state 30
    term                           shift and go to state 32
    factor                         shift and go to state 34
    brace                          shift and go to state 38

state 48

    (59) assignment -> ASSIGN .

    ID              reduce using rule 59 (assignment -> ASSIGN .)
    NOT             reduce using rule 59 (assignment -> ASSIGN .)
    PLUS            reduce using rule 59 (assignment -> ASSIGN .)
    MINUS           reduce using rule 59 (assignment -> ASSIGN .)
    PLUS_PLUS       reduce using rule 59 (assignment -> ASSIGN .)
    MINUS_MINUS     reduce using rule 59 (assignment -> ASSIGN .)
    L_PAREN         reduce using rule 59 (assignment -> ASSIGN .)
    INT_NUM         reduce using rule 59 (assignment -> ASSIGN .)
    FLOAT_NUM       reduce using rule 59 (assignment -> ASSIGN .)


state 49

    (60) assignment -> PLUS_ASSIGN .

    ID              reduce using rule 60 (assignment -> PLUS_ASSIGN .)
    NOT             reduce using rule 60 (assignment -> PLUS_ASSIGN .)
    PLUS            reduce using rule 60 (assignment -> PLUS_ASSIGN .)
    MINUS           reduce using rule 60 (assignment -> PLUS_ASSIGN .)
    PLUS_PLUS       reduce using rule 60 (assignment -> PLUS_ASSIGN .)
    MINUS_MINUS     reduce using rule 60 (assignment -> PLUS_ASSIGN .)
    L_PAREN         reduce using rule 60 (assignment -> PLUS_ASSIGN .)
    INT_NUM         reduce using rule 60 (assignment -> PLUS_ASSIGN .)
    FLOAT_NUM       reduce using rule 60 (assignment -> PLUS_ASSIGN .)


state 50

    (61) assignment -> MINUS_ASSIGN .

    ID              reduce using rule 61 (assignment -> MINUS_ASSIGN .)
    NOT             reduce using rule 61 (assignment -> MINUS_ASSIGN .)
    PLUS            reduce using rule 61 (assignment -> MINUS_ASSIGN .)
    MINUS           reduce using rule 61 (assignment -> MINUS_ASSIGN .)
    PLUS_PLUS       reduce using rule 61 (assignment -> MINUS_ASSIGN .)
    MINUS_MINUS     reduce using rule 61 (assignment -> MINUS_ASSIGN .)
    L_PAREN         reduce using rule 61 (assignment -> MINUS_ASSIGN .)
    INT_NUM         reduce using rule 61 (assignment -> MINUS_ASSIGN .)
    FLOAT_NUM       reduce using rule 61 (assignment -> MINUS_ASSIGN .)


state 51

    (62) assignment -> MUL_ASSIGN .

    ID              reduce using rule 62 (assignment -> MUL_ASSIGN .)
    NOT             reduce using rule 62 (assignment -> MUL_ASSIGN .)
    PLUS            reduce using rule 62 (assignment -> MUL_ASSIGN .)
    MINUS           reduce using rule 62 (assignment -> MUL_ASSIGN .)
    PLUS_PLUS       reduce using rule 62 (assignment -> MUL_ASSIGN .)
    MINUS_MINUS     reduce using rule 62 (assignment -> MUL_ASSIGN .)
    L_PAREN         reduce using rule 62 (assignment -> MUL_ASSIGN .)
    INT_NUM         reduce using rule 62 (assignment -> MUL_ASSIGN .)
    FLOAT_NUM       reduce using rule 62 (assignment -> MUL_ASSIGN .)


state 52

    (63) assignment -> DIV_ASSIGN .

    ID              reduce using rule 63 (assignment -> DIV_ASSIGN .)
    NOT             reduce using rule 63 (assignment -> DIV_ASSIGN .)
    PLUS            reduce using rule 63 (assignment -> DIV_ASSIGN .)
    MINUS           reduce using rule 63 (assignment -> DIV_ASSIGN .)
    PLUS_PLUS       reduce using rule 63 (assignment -> DIV_ASSIGN .)
    MINUS_MINUS     reduce using rule 63 (assignment -> DIV_ASSIGN .)
    L_PAREN         reduce using rule 63 (assignment -> DIV_ASSIGN .)
    INT_NUM         reduce using rule 63 (assignment -> DIV_ASSIGN .)
    FLOAT_NUM       reduce using rule 63 (assignment -> DIV_ASSIGN .)


state 53

    (64) assignment -> AND_ASSIGN .

    ID              reduce using rule 64 (assignment -> AND_ASSIGN .)
    NOT             reduce using rule 64 (assignment -> AND_ASSIGN .)
    PLUS            reduce using rule 64 (assignment -> AND_ASSIGN .)
    MINUS           reduce using rule 64 (assignment -> AND_ASSIGN .)
    PLUS_PLUS       reduce using rule 64 (assignment -> AND_ASSIGN .)
    MINUS_MINUS     reduce using rule 64 (assignment -> AND_ASSIGN .)
    L_PAREN         reduce using rule 64 (assignment -> AND_ASSIGN .)
    INT_NUM         reduce using rule 64 (assignment -> AND_ASSIGN .)
    FLOAT_NUM       reduce using rule 64 (assignment -> AND_ASSIGN .)


state 54

    (65) assignment -> OR_ASSIGN .

    ID              reduce using rule 65 (assignment -> OR_ASSIGN .)
    NOT             reduce using rule 65 (assignment -> OR_ASSIGN .)
    PLUS            reduce using rule 65 (assignment -> OR_ASSIGN .)
    MINUS           reduce using rule 65 (assignment -> OR_ASSIGN .)
    PLUS_PLUS       reduce using rule 65 (assignment -> OR_ASSIGN .)
    MINUS_MINUS     reduce using rule 65 (assignment -> OR_ASSIGN .)
    L_PAREN         reduce using rule 65 (assignment -> OR_ASSIGN .)
    INT_NUM         reduce using rule 65 (assignment -> OR_ASSIGN .)
    FLOAT_NUM       reduce using rule 65 (assignment -> OR_ASSIGN .)


state 55

    (66) assignment -> XOR_ASSIGN .

    ID              reduce using rule 66 (assignment -> XOR_ASSIGN .)
    NOT             reduce using rule 66 (assignment -> XOR_ASSIGN .)
    PLUS            reduce using rule 66 (assignment -> XOR_ASSIGN .)
    MINUS           reduce using rule 66 (assignment -> XOR_ASSIGN .)
    PLUS_PLUS       reduce using rule 66 (assignment -> XOR_ASSIGN .)
    MINUS_MINUS     reduce using rule 66 (assignment -> XOR_ASSIGN .)
    L_PAREN         reduce using rule 66 (assignment -> XOR_ASSIGN .)
    INT_NUM         reduce using rule 66 (assignment -> XOR_ASSIGN .)
    FLOAT_NUM       reduce using rule 66 (assignment -> XOR_ASSIGN .)


state 56

    (67) assignment -> MOD_ASSIGN .

    ID              reduce using rule 67 (assignment -> MOD_ASSIGN .)
    NOT             reduce using rule 67 (assignment -> MOD_ASSIGN .)
    PLUS            reduce using rule 67 (assignment -> MOD_ASSIGN .)
    MINUS           reduce using rule 67 (assignment -> MOD_ASSIGN .)
    PLUS_PLUS       reduce using rule 67 (assignment -> MOD_ASSIGN .)
    MINUS_MINUS     reduce using rule 67 (assignment -> MOD_ASSIGN .)
    L_PAREN         reduce using rule 67 (assignment -> MOD_ASSIGN .)
    INT_NUM         reduce using rule 67 (assignment -> MOD_ASSIGN .)
    FLOAT_NUM       reduce using rule 67 (assignment -> MOD_ASSIGN .)


state 57

    (68) assignment -> L_SHIFT_ASSIGN .

    ID              reduce using rule 68 (assignment -> L_SHIFT_ASSIGN .)
    NOT             reduce using rule 68 (assignment -> L_SHIFT_ASSIGN .)
    PLUS            reduce using rule 68 (assignment -> L_SHIFT_ASSIGN .)
    MINUS           reduce using rule 68 (assignment -> L_SHIFT_ASSIGN .)
    PLUS_PLUS       reduce using rule 68 (assignment -> L_SHIFT_ASSIGN .)
    MINUS_MINUS     reduce using rule 68 (assignment -> L_SHIFT_ASSIGN .)
    L_PAREN         reduce using rule 68 (assignment -> L_SHIFT_ASSIGN .)
    INT_NUM         reduce using rule 68 (assignment -> L_SHIFT_ASSIGN .)
    FLOAT_NUM       reduce using rule 68 (assignment -> L_SHIFT_ASSIGN .)


state 58

    (69) assignment -> R_SHIFT_ASSIGN .

    ID              reduce using rule 69 (assignment -> R_SHIFT_ASSIGN .)
    NOT             reduce using rule 69 (assignment -> R_SHIFT_ASSIGN .)
    PLUS            reduce using rule 69 (assignment -> R_SHIFT_ASSIGN .)
    MINUS           reduce using rule 69 (assignment -> R_SHIFT_ASSIGN .)
    PLUS_PLUS       reduce using rule 69 (assignment -> R_SHIFT_ASSIGN .)
    MINUS_MINUS     reduce using rule 69 (assignment -> R_SHIFT_ASSIGN .)
    L_PAREN         reduce using rule 69 (assignment -> R_SHIFT_ASSIGN .)
    INT_NUM         reduce using rule 69 (assignment -> R_SHIFT_ASSIGN .)
    FLOAT_NUM       reduce using rule 69 (assignment -> R_SHIFT_ASSIGN .)


state 59

    (34) simple -> RETURN ID . SEMICOLON

    SEMICOLON       shift and go to state 108


state 60

    (35) simple -> RETURN INT_NUM . SEMICOLON

    SEMICOLON       shift and go to state 109


state 61

    (37) function_call -> ID L_PAREN . call_params R_PAREN SEMICOLON
    (38) call_params -> . empty
    (39) call_params -> . yes_call_params end_call_params
    (40) call_params -> . end_call_params
    (36) empty -> .
    (41) yes_call_params -> . yes_call_params INT_NUM COMMA
    (42) yes_call_params -> . yes_call_params ID COMMA
    (43) yes_call_params -> . INT_NUM COMMA
    (44) yes_call_params -> . ID COMMA
    (45) end_call_params -> . INT_NUM
    (46) end_call_params -> . ID

    R_PAREN         reduce using rule 36 (empty -> .)
    INT_NUM         shift and go to state 115
    ID              shift and go to state 110

    call_params                    shift and go to state 111
    empty                          shift and go to state 112
    yes_call_params                shift and go to state 113
    end_call_params                shift and go to state 114

state 62

    (28) block -> L_FLOWBRACE multiple_statements . R_FLOWBRACE
    (2) multiple_statements -> multiple_statements . statement
    (4) statement -> . open
    (5) statement -> . closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) open -> . FOR for_condition open
    (10) closed -> . simple
    (11) closed -> . block
    (12) closed -> . IF condition closed ELSE closed
    (13) closed -> . WHILE condition closed
    (14) closed -> . FOR for_condition closed
    (29) simple -> . expr SEMICOLON
    (30) simple -> . declaration
    (31) simple -> . SEMICOLON
    (32) simple -> . function
    (33) simple -> . function_call
    (34) simple -> . RETURN ID SEMICOLON
    (35) simple -> . RETURN INT_NUM SEMICOLON
    (28) block -> . L_FLOWBRACE multiple_statements R_FLOWBRACE
    (56) expr -> . expr assignment exprOR
    (57) expr -> . expr assignment ID L_PAREN call_params R_PAREN
    (58) expr -> . exprOR
    (24) declaration -> . TYPE ID SEMICOLON
    (25) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (26) declaration -> . TYPE ID ASSIGN function_call
    (27) declaration -> . TYPE multi_declaration stop
    (53) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (37) function_call -> . ID L_PAREN call_params R_PAREN SEMICOLON
    (70) exprOR -> . exprOR OR exprAND
    (71) exprOR -> . exprAND
    (72) exprAND -> . exprAND AND exprBITOR
    (73) exprAND -> . exprBITOR
    (74) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (75) exprBITOR -> . exprBITXOR
    (76) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (77) exprBITXOR -> . exprBITAND
    (78) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (79) exprBITAND -> . exprEQ
    (80) exprEQ -> . exprEQ EQ exprRELOP
    (81) exprEQ -> . exprEQ NE exprRELOP
    (82) exprEQ -> . exprRELOP
    (83) exprRELOP -> . exprRELOP relop exprSHIFT
    (84) exprRELOP -> . exprSHIFT
    (89) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (90) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (91) exprSHIFT -> . exprOP
    (92) exprOP -> . exprOP PLUS term
    (93) exprOP -> . exprOP MINUS term
    (94) exprOP -> . term
    (95) term -> . term MULTIPLY factor
    (96) term -> . term DIVIDE factor
    (97) term -> . term MOD factor
    (98) term -> . factor
    (99) factor -> . NOT factor
    (100) factor -> . PLUS factor
    (101) factor -> . MINUS factor
    (102) factor -> . PLUS_PLUS factor
    (103) factor -> . MINUS_MINUS factor
    (104) factor -> . brace
    (105) brace -> . L_PAREN expr R_PAREN
    (106) brace -> . brace PLUS_PLUS
    (107) brace -> . brace MINUS_MINUS
    (108) brace -> . INT_NUM
    (109) brace -> . FLOAT_NUM
    (110) brace -> . ID

    R_FLOWBRACE     shift and go to state 116
    IF              shift and go to state 6
    WHILE           shift and go to state 7
    FOR             shift and go to state 8
    SEMICOLON       shift and go to state 12
    RETURN          shift and go to state 16
    L_FLOWBRACE     shift and go to state 19
    TYPE            shift and go to state 22
    ID              shift and go to state 17
    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    INT_NUM         shift and go to state 18
    FLOAT_NUM       shift and go to state 39

    statement                      shift and go to state 40
    open                           shift and go to state 4
    closed                         shift and go to state 5
    simple                         shift and go to state 9
    block                          shift and go to state 10
    expr                           shift and go to state 11
    declaration                    shift and go to state 13
    function                       shift and go to state 14
    function_call                  shift and go to state 15
    exprOR                         shift and go to state 20
    exprAND                        shift and go to state 23
    exprBITOR                      shift and go to state 24
    exprBITXOR                     shift and go to state 25
    exprBITAND                     shift and go to state 26
    exprEQ                         shift and go to state 27
    exprRELOP                      shift and go to state 28
    exprSHIFT                      shift and go to state 29
    exprOP                         shift and go to state 30
    term                           shift and go to state 32
    factor                         shift and go to state 34
    brace                          shift and go to state 38

state 63

    (70) exprOR -> exprOR OR . exprAND
    (72) exprAND -> . exprAND AND exprBITOR
    (73) exprAND -> . exprBITOR
    (74) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (75) exprBITOR -> . exprBITXOR
    (76) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (77) exprBITXOR -> . exprBITAND
    (78) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (79) exprBITAND -> . exprEQ
    (80) exprEQ -> . exprEQ EQ exprRELOP
    (81) exprEQ -> . exprEQ NE exprRELOP
    (82) exprEQ -> . exprRELOP
    (83) exprRELOP -> . exprRELOP relop exprSHIFT
    (84) exprRELOP -> . exprSHIFT
    (89) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (90) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (91) exprSHIFT -> . exprOP
    (92) exprOP -> . exprOP PLUS term
    (93) exprOP -> . exprOP MINUS term
    (94) exprOP -> . term
    (95) term -> . term MULTIPLY factor
    (96) term -> . term DIVIDE factor
    (97) term -> . term MOD factor
    (98) term -> . factor
    (99) factor -> . NOT factor
    (100) factor -> . PLUS factor
    (101) factor -> . MINUS factor
    (102) factor -> . PLUS_PLUS factor
    (103) factor -> . MINUS_MINUS factor
    (104) factor -> . brace
    (105) brace -> . L_PAREN expr R_PAREN
    (106) brace -> . brace PLUS_PLUS
    (107) brace -> . brace MINUS_MINUS
    (108) brace -> . INT_NUM
    (109) brace -> . FLOAT_NUM
    (110) brace -> . ID

    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    INT_NUM         shift and go to state 18
    FLOAT_NUM       shift and go to state 39
    ID              shift and go to state 65

    exprAND                        shift and go to state 117
    exprBITOR                      shift and go to state 24
    exprBITXOR                     shift and go to state 25
    exprBITAND                     shift and go to state 26
    exprEQ                         shift and go to state 27
    exprRELOP                      shift and go to state 28
    exprSHIFT                      shift and go to state 29
    exprOP                         shift and go to state 30
    term                           shift and go to state 32
    factor                         shift and go to state 34
    brace                          shift and go to state 38

state 64

    (105) brace -> L_PAREN expr . R_PAREN
    (56) expr -> expr . assignment exprOR
    (57) expr -> expr . assignment ID L_PAREN call_params R_PAREN
    (59) assignment -> . ASSIGN
    (60) assignment -> . PLUS_ASSIGN
    (61) assignment -> . MINUS_ASSIGN
    (62) assignment -> . MUL_ASSIGN
    (63) assignment -> . DIV_ASSIGN
    (64) assignment -> . AND_ASSIGN
    (65) assignment -> . OR_ASSIGN
    (66) assignment -> . XOR_ASSIGN
    (67) assignment -> . MOD_ASSIGN
    (68) assignment -> . L_SHIFT_ASSIGN
    (69) assignment -> . R_SHIFT_ASSIGN

    R_PAREN         shift and go to state 118
    ASSIGN          shift and go to state 48
    PLUS_ASSIGN     shift and go to state 49
    MINUS_ASSIGN    shift and go to state 50
    MUL_ASSIGN      shift and go to state 51
    DIV_ASSIGN      shift and go to state 52
    AND_ASSIGN      shift and go to state 53
    OR_ASSIGN       shift and go to state 54
    XOR_ASSIGN      shift and go to state 55
    MOD_ASSIGN      shift and go to state 56
    L_SHIFT_ASSIGN  shift and go to state 57
    R_SHIFT_ASSIGN  shift and go to state 58

    assignment                     shift and go to state 47

state 65

    (110) brace -> ID .

    PLUS_PLUS       reduce using rule 110 (brace -> ID .)
    MINUS_MINUS     reduce using rule 110 (brace -> ID .)
    MULTIPLY        reduce using rule 110 (brace -> ID .)
    DIVIDE          reduce using rule 110 (brace -> ID .)
    MOD             reduce using rule 110 (brace -> ID .)
    PLUS            reduce using rule 110 (brace -> ID .)
    MINUS           reduce using rule 110 (brace -> ID .)
    L_SHIFT         reduce using rule 110 (brace -> ID .)
    R_SHIFT         reduce using rule 110 (brace -> ID .)
    LE              reduce using rule 110 (brace -> ID .)
    LT              reduce using rule 110 (brace -> ID .)
    GE              reduce using rule 110 (brace -> ID .)
    GT              reduce using rule 110 (brace -> ID .)
    EQ              reduce using rule 110 (brace -> ID .)
    NE              reduce using rule 110 (brace -> ID .)
    BIT_AND         reduce using rule 110 (brace -> ID .)
    BIT_XOR         reduce using rule 110 (brace -> ID .)
    BIT_OR          reduce using rule 110 (brace -> ID .)
    AND             reduce using rule 110 (brace -> ID .)
    OR              reduce using rule 110 (brace -> ID .)
    R_PAREN         reduce using rule 110 (brace -> ID .)
    ASSIGN          reduce using rule 110 (brace -> ID .)
    PLUS_ASSIGN     reduce using rule 110 (brace -> ID .)
    MINUS_ASSIGN    reduce using rule 110 (brace -> ID .)
    MUL_ASSIGN      reduce using rule 110 (brace -> ID .)
    DIV_ASSIGN      reduce using rule 110 (brace -> ID .)
    AND_ASSIGN      reduce using rule 110 (brace -> ID .)
    OR_ASSIGN       reduce using rule 110 (brace -> ID .)
    XOR_ASSIGN      reduce using rule 110 (brace -> ID .)
    MOD_ASSIGN      reduce using rule 110 (brace -> ID .)
    L_SHIFT_ASSIGN  reduce using rule 110 (brace -> ID .)
    R_SHIFT_ASSIGN  reduce using rule 110 (brace -> ID .)
    SEMICOLON       reduce using rule 110 (brace -> ID .)
    COMMA           reduce using rule 110 (brace -> ID .)


state 66

    (24) declaration -> TYPE ID . SEMICOLON
    (25) declaration -> TYPE ID . ASSIGN expr SEMICOLON
    (26) declaration -> TYPE ID . ASSIGN function_call
    (53) function -> TYPE ID . L_PAREN dec_params R_PAREN function_2
    (20) multi_declaration -> ID . COMMA
    (21) multi_declaration -> ID . ASSIGN expr COMMA

    SEMICOLON       shift and go to state 119
    ASSIGN          shift and go to state 120
    L_PAREN         shift and go to state 121
    COMMA           shift and go to state 122


state 67

    (27) declaration -> TYPE multi_declaration . stop
    (18) multi_declaration -> multi_declaration . ID COMMA
    (19) multi_declaration -> multi_declaration . ID ASSIGN expr COMMA
    (22) stop -> . ID SEMICOLON
    (23) stop -> . ID ASSIGN expr SEMICOLON

    ID              shift and go to state 124

    stop                           shift and go to state 123

state 68

    (72) exprAND -> exprAND AND . exprBITOR
    (74) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (75) exprBITOR -> . exprBITXOR
    (76) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (77) exprBITXOR -> . exprBITAND
    (78) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (79) exprBITAND -> . exprEQ
    (80) exprEQ -> . exprEQ EQ exprRELOP
    (81) exprEQ -> . exprEQ NE exprRELOP
    (82) exprEQ -> . exprRELOP
    (83) exprRELOP -> . exprRELOP relop exprSHIFT
    (84) exprRELOP -> . exprSHIFT
    (89) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (90) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (91) exprSHIFT -> . exprOP
    (92) exprOP -> . exprOP PLUS term
    (93) exprOP -> . exprOP MINUS term
    (94) exprOP -> . term
    (95) term -> . term MULTIPLY factor
    (96) term -> . term DIVIDE factor
    (97) term -> . term MOD factor
    (98) term -> . factor
    (99) factor -> . NOT factor
    (100) factor -> . PLUS factor
    (101) factor -> . MINUS factor
    (102) factor -> . PLUS_PLUS factor
    (103) factor -> . MINUS_MINUS factor
    (104) factor -> . brace
    (105) brace -> . L_PAREN expr R_PAREN
    (106) brace -> . brace PLUS_PLUS
    (107) brace -> . brace MINUS_MINUS
    (108) brace -> . INT_NUM
    (109) brace -> . FLOAT_NUM
    (110) brace -> . ID

    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    INT_NUM         shift and go to state 18
    FLOAT_NUM       shift and go to state 39
    ID              shift and go to state 65

    exprBITOR                      shift and go to state 125
    exprBITXOR                     shift and go to state 25
    exprBITAND                     shift and go to state 26
    exprEQ                         shift and go to state 27
    exprRELOP                      shift and go to state 28
    exprSHIFT                      shift and go to state 29
    exprOP                         shift and go to state 30
    term                           shift and go to state 32
    factor                         shift and go to state 34
    brace                          shift and go to state 38

state 69

    (74) exprBITOR -> exprBITOR BIT_OR . exprBITXOR
    (76) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (77) exprBITXOR -> . exprBITAND
    (78) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (79) exprBITAND -> . exprEQ
    (80) exprEQ -> . exprEQ EQ exprRELOP
    (81) exprEQ -> . exprEQ NE exprRELOP
    (82) exprEQ -> . exprRELOP
    (83) exprRELOP -> . exprRELOP relop exprSHIFT
    (84) exprRELOP -> . exprSHIFT
    (89) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (90) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (91) exprSHIFT -> . exprOP
    (92) exprOP -> . exprOP PLUS term
    (93) exprOP -> . exprOP MINUS term
    (94) exprOP -> . term
    (95) term -> . term MULTIPLY factor
    (96) term -> . term DIVIDE factor
    (97) term -> . term MOD factor
    (98) term -> . factor
    (99) factor -> . NOT factor
    (100) factor -> . PLUS factor
    (101) factor -> . MINUS factor
    (102) factor -> . PLUS_PLUS factor
    (103) factor -> . MINUS_MINUS factor
    (104) factor -> . brace
    (105) brace -> . L_PAREN expr R_PAREN
    (106) brace -> . brace PLUS_PLUS
    (107) brace -> . brace MINUS_MINUS
    (108) brace -> . INT_NUM
    (109) brace -> . FLOAT_NUM
    (110) brace -> . ID

    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    INT_NUM         shift and go to state 18
    FLOAT_NUM       shift and go to state 39
    ID              shift and go to state 65

    exprBITXOR                     shift and go to state 126
    exprBITAND                     shift and go to state 26
    exprEQ                         shift and go to state 27
    exprRELOP                      shift and go to state 28
    exprSHIFT                      shift and go to state 29
    exprOP                         shift and go to state 30
    term                           shift and go to state 32
    factor                         shift and go to state 34
    brace                          shift and go to state 38

state 70

    (76) exprBITXOR -> exprBITXOR BIT_XOR . exprBITAND
    (78) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (79) exprBITAND -> . exprEQ
    (80) exprEQ -> . exprEQ EQ exprRELOP
    (81) exprEQ -> . exprEQ NE exprRELOP
    (82) exprEQ -> . exprRELOP
    (83) exprRELOP -> . exprRELOP relop exprSHIFT
    (84) exprRELOP -> . exprSHIFT
    (89) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (90) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (91) exprSHIFT -> . exprOP
    (92) exprOP -> . exprOP PLUS term
    (93) exprOP -> . exprOP MINUS term
    (94) exprOP -> . term
    (95) term -> . term MULTIPLY factor
    (96) term -> . term DIVIDE factor
    (97) term -> . term MOD factor
    (98) term -> . factor
    (99) factor -> . NOT factor
    (100) factor -> . PLUS factor
    (101) factor -> . MINUS factor
    (102) factor -> . PLUS_PLUS factor
    (103) factor -> . MINUS_MINUS factor
    (104) factor -> . brace
    (105) brace -> . L_PAREN expr R_PAREN
    (106) brace -> . brace PLUS_PLUS
    (107) brace -> . brace MINUS_MINUS
    (108) brace -> . INT_NUM
    (109) brace -> . FLOAT_NUM
    (110) brace -> . ID

    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    INT_NUM         shift and go to state 18
    FLOAT_NUM       shift and go to state 39
    ID              shift and go to state 65

    exprBITAND                     shift and go to state 127
    exprEQ                         shift and go to state 27
    exprRELOP                      shift and go to state 28
    exprSHIFT                      shift and go to state 29
    exprOP                         shift and go to state 30
    term                           shift and go to state 32
    factor                         shift and go to state 34
    brace                          shift and go to state 38

state 71

    (78) exprBITAND -> exprBITAND BIT_AND . exprEQ
    (80) exprEQ -> . exprEQ EQ exprRELOP
    (81) exprEQ -> . exprEQ NE exprRELOP
    (82) exprEQ -> . exprRELOP
    (83) exprRELOP -> . exprRELOP relop exprSHIFT
    (84) exprRELOP -> . exprSHIFT
    (89) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (90) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (91) exprSHIFT -> . exprOP
    (92) exprOP -> . exprOP PLUS term
    (93) exprOP -> . exprOP MINUS term
    (94) exprOP -> . term
    (95) term -> . term MULTIPLY factor
    (96) term -> . term DIVIDE factor
    (97) term -> . term MOD factor
    (98) term -> . factor
    (99) factor -> . NOT factor
    (100) factor -> . PLUS factor
    (101) factor -> . MINUS factor
    (102) factor -> . PLUS_PLUS factor
    (103) factor -> . MINUS_MINUS factor
    (104) factor -> . brace
    (105) brace -> . L_PAREN expr R_PAREN
    (106) brace -> . brace PLUS_PLUS
    (107) brace -> . brace MINUS_MINUS
    (108) brace -> . INT_NUM
    (109) brace -> . FLOAT_NUM
    (110) brace -> . ID

    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    INT_NUM         shift and go to state 18
    FLOAT_NUM       shift and go to state 39
    ID              shift and go to state 65

    exprEQ                         shift and go to state 128
    exprRELOP                      shift and go to state 28
    exprSHIFT                      shift and go to state 29
    exprOP                         shift and go to state 30
    term                           shift and go to state 32
    factor                         shift and go to state 34
    brace                          shift and go to state 38

state 72

    (80) exprEQ -> exprEQ EQ . exprRELOP
    (83) exprRELOP -> . exprRELOP relop exprSHIFT
    (84) exprRELOP -> . exprSHIFT
    (89) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (90) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (91) exprSHIFT -> . exprOP
    (92) exprOP -> . exprOP PLUS term
    (93) exprOP -> . exprOP MINUS term
    (94) exprOP -> . term
    (95) term -> . term MULTIPLY factor
    (96) term -> . term DIVIDE factor
    (97) term -> . term MOD factor
    (98) term -> . factor
    (99) factor -> . NOT factor
    (100) factor -> . PLUS factor
    (101) factor -> . MINUS factor
    (102) factor -> . PLUS_PLUS factor
    (103) factor -> . MINUS_MINUS factor
    (104) factor -> . brace
    (105) brace -> . L_PAREN expr R_PAREN
    (106) brace -> . brace PLUS_PLUS
    (107) brace -> . brace MINUS_MINUS
    (108) brace -> . INT_NUM
    (109) brace -> . FLOAT_NUM
    (110) brace -> . ID

    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    INT_NUM         shift and go to state 18
    FLOAT_NUM       shift and go to state 39
    ID              shift and go to state 65

    exprRELOP                      shift and go to state 129
    exprSHIFT                      shift and go to state 29
    exprOP                         shift and go to state 30
    term                           shift and go to state 32
    factor                         shift and go to state 34
    brace                          shift and go to state 38

state 73

    (81) exprEQ -> exprEQ NE . exprRELOP
    (83) exprRELOP -> . exprRELOP relop exprSHIFT
    (84) exprRELOP -> . exprSHIFT
    (89) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (90) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (91) exprSHIFT -> . exprOP
    (92) exprOP -> . exprOP PLUS term
    (93) exprOP -> . exprOP MINUS term
    (94) exprOP -> . term
    (95) term -> . term MULTIPLY factor
    (96) term -> . term DIVIDE factor
    (97) term -> . term MOD factor
    (98) term -> . factor
    (99) factor -> . NOT factor
    (100) factor -> . PLUS factor
    (101) factor -> . MINUS factor
    (102) factor -> . PLUS_PLUS factor
    (103) factor -> . MINUS_MINUS factor
    (104) factor -> . brace
    (105) brace -> . L_PAREN expr R_PAREN
    (106) brace -> . brace PLUS_PLUS
    (107) brace -> . brace MINUS_MINUS
    (108) brace -> . INT_NUM
    (109) brace -> . FLOAT_NUM
    (110) brace -> . ID

    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    INT_NUM         shift and go to state 18
    FLOAT_NUM       shift and go to state 39
    ID              shift and go to state 65

    exprRELOP                      shift and go to state 130
    exprSHIFT                      shift and go to state 29
    exprOP                         shift and go to state 30
    term                           shift and go to state 32
    factor                         shift and go to state 34
    brace                          shift and go to state 38

state 74

    (83) exprRELOP -> exprRELOP relop . exprSHIFT
    (89) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (90) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (91) exprSHIFT -> . exprOP
    (92) exprOP -> . exprOP PLUS term
    (93) exprOP -> . exprOP MINUS term
    (94) exprOP -> . term
    (95) term -> . term MULTIPLY factor
    (96) term -> . term DIVIDE factor
    (97) term -> . term MOD factor
    (98) term -> . factor
    (99) factor -> . NOT factor
    (100) factor -> . PLUS factor
    (101) factor -> . MINUS factor
    (102) factor -> . PLUS_PLUS factor
    (103) factor -> . MINUS_MINUS factor
    (104) factor -> . brace
    (105) brace -> . L_PAREN expr R_PAREN
    (106) brace -> . brace PLUS_PLUS
    (107) brace -> . brace MINUS_MINUS
    (108) brace -> . INT_NUM
    (109) brace -> . FLOAT_NUM
    (110) brace -> . ID

    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    INT_NUM         shift and go to state 18
    FLOAT_NUM       shift and go to state 39
    ID              shift and go to state 65

    exprSHIFT                      shift and go to state 131
    exprOP                         shift and go to state 30
    term                           shift and go to state 32
    factor                         shift and go to state 34
    brace                          shift and go to state 38

state 75

    (85) relop -> LE .

    NOT             reduce using rule 85 (relop -> LE .)
    PLUS            reduce using rule 85 (relop -> LE .)
    MINUS           reduce using rule 85 (relop -> LE .)
    PLUS_PLUS       reduce using rule 85 (relop -> LE .)
    MINUS_MINUS     reduce using rule 85 (relop -> LE .)
    L_PAREN         reduce using rule 85 (relop -> LE .)
    INT_NUM         reduce using rule 85 (relop -> LE .)
    FLOAT_NUM       reduce using rule 85 (relop -> LE .)
    ID              reduce using rule 85 (relop -> LE .)


state 76

    (86) relop -> LT .

    NOT             reduce using rule 86 (relop -> LT .)
    PLUS            reduce using rule 86 (relop -> LT .)
    MINUS           reduce using rule 86 (relop -> LT .)
    PLUS_PLUS       reduce using rule 86 (relop -> LT .)
    MINUS_MINUS     reduce using rule 86 (relop -> LT .)
    L_PAREN         reduce using rule 86 (relop -> LT .)
    INT_NUM         reduce using rule 86 (relop -> LT .)
    FLOAT_NUM       reduce using rule 86 (relop -> LT .)
    ID              reduce using rule 86 (relop -> LT .)


state 77

    (87) relop -> GE .

    NOT             reduce using rule 87 (relop -> GE .)
    PLUS            reduce using rule 87 (relop -> GE .)
    MINUS           reduce using rule 87 (relop -> GE .)
    PLUS_PLUS       reduce using rule 87 (relop -> GE .)
    MINUS_MINUS     reduce using rule 87 (relop -> GE .)
    L_PAREN         reduce using rule 87 (relop -> GE .)
    INT_NUM         reduce using rule 87 (relop -> GE .)
    FLOAT_NUM       reduce using rule 87 (relop -> GE .)
    ID              reduce using rule 87 (relop -> GE .)


state 78

    (88) relop -> GT .

    NOT             reduce using rule 88 (relop -> GT .)
    PLUS            reduce using rule 88 (relop -> GT .)
    MINUS           reduce using rule 88 (relop -> GT .)
    PLUS_PLUS       reduce using rule 88 (relop -> GT .)
    MINUS_MINUS     reduce using rule 88 (relop -> GT .)
    L_PAREN         reduce using rule 88 (relop -> GT .)
    INT_NUM         reduce using rule 88 (relop -> GT .)
    FLOAT_NUM       reduce using rule 88 (relop -> GT .)
    ID              reduce using rule 88 (relop -> GT .)


state 79

    (89) exprSHIFT -> exprSHIFT L_SHIFT . exprOP
    (92) exprOP -> . exprOP PLUS term
    (93) exprOP -> . exprOP MINUS term
    (94) exprOP -> . term
    (95) term -> . term MULTIPLY factor
    (96) term -> . term DIVIDE factor
    (97) term -> . term MOD factor
    (98) term -> . factor
    (99) factor -> . NOT factor
    (100) factor -> . PLUS factor
    (101) factor -> . MINUS factor
    (102) factor -> . PLUS_PLUS factor
    (103) factor -> . MINUS_MINUS factor
    (104) factor -> . brace
    (105) brace -> . L_PAREN expr R_PAREN
    (106) brace -> . brace PLUS_PLUS
    (107) brace -> . brace MINUS_MINUS
    (108) brace -> . INT_NUM
    (109) brace -> . FLOAT_NUM
    (110) brace -> . ID

    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    INT_NUM         shift and go to state 18
    FLOAT_NUM       shift and go to state 39
    ID              shift and go to state 65

    exprOP                         shift and go to state 132
    term                           shift and go to state 32
    factor                         shift and go to state 34
    brace                          shift and go to state 38

state 80

    (90) exprSHIFT -> exprSHIFT R_SHIFT . exprOP
    (92) exprOP -> . exprOP PLUS term
    (93) exprOP -> . exprOP MINUS term
    (94) exprOP -> . term
    (95) term -> . term MULTIPLY factor
    (96) term -> . term DIVIDE factor
    (97) term -> . term MOD factor
    (98) term -> . factor
    (99) factor -> . NOT factor
    (100) factor -> . PLUS factor
    (101) factor -> . MINUS factor
    (102) factor -> . PLUS_PLUS factor
    (103) factor -> . MINUS_MINUS factor
    (104) factor -> . brace
    (105) brace -> . L_PAREN expr R_PAREN
    (106) brace -> . brace PLUS_PLUS
    (107) brace -> . brace MINUS_MINUS
    (108) brace -> . INT_NUM
    (109) brace -> . FLOAT_NUM
    (110) brace -> . ID

    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    INT_NUM         shift and go to state 18
    FLOAT_NUM       shift and go to state 39
    ID              shift and go to state 65

    exprOP                         shift and go to state 133
    term                           shift and go to state 32
    factor                         shift and go to state 34
    brace                          shift and go to state 38

state 81

    (92) exprOP -> exprOP PLUS . term
    (95) term -> . term MULTIPLY factor
    (96) term -> . term DIVIDE factor
    (97) term -> . term MOD factor
    (98) term -> . factor
    (99) factor -> . NOT factor
    (100) factor -> . PLUS factor
    (101) factor -> . MINUS factor
    (102) factor -> . PLUS_PLUS factor
    (103) factor -> . MINUS_MINUS factor
    (104) factor -> . brace
    (105) brace -> . L_PAREN expr R_PAREN
    (106) brace -> . brace PLUS_PLUS
    (107) brace -> . brace MINUS_MINUS
    (108) brace -> . INT_NUM
    (109) brace -> . FLOAT_NUM
    (110) brace -> . ID

    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    INT_NUM         shift and go to state 18
    FLOAT_NUM       shift and go to state 39
    ID              shift and go to state 65

    term                           shift and go to state 134
    factor                         shift and go to state 34
    brace                          shift and go to state 38

state 82

    (93) exprOP -> exprOP MINUS . term
    (95) term -> . term MULTIPLY factor
    (96) term -> . term DIVIDE factor
    (97) term -> . term MOD factor
    (98) term -> . factor
    (99) factor -> . NOT factor
    (100) factor -> . PLUS factor
    (101) factor -> . MINUS factor
    (102) factor -> . PLUS_PLUS factor
    (103) factor -> . MINUS_MINUS factor
    (104) factor -> . brace
    (105) brace -> . L_PAREN expr R_PAREN
    (106) brace -> . brace PLUS_PLUS
    (107) brace -> . brace MINUS_MINUS
    (108) brace -> . INT_NUM
    (109) brace -> . FLOAT_NUM
    (110) brace -> . ID

    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    INT_NUM         shift and go to state 18
    FLOAT_NUM       shift and go to state 39
    ID              shift and go to state 65

    term                           shift and go to state 135
    factor                         shift and go to state 34
    brace                          shift and go to state 38

state 83

    (100) factor -> PLUS factor .

    MULTIPLY        reduce using rule 100 (factor -> PLUS factor .)
    DIVIDE          reduce using rule 100 (factor -> PLUS factor .)
    MOD             reduce using rule 100 (factor -> PLUS factor .)
    PLUS            reduce using rule 100 (factor -> PLUS factor .)
    MINUS           reduce using rule 100 (factor -> PLUS factor .)
    L_SHIFT         reduce using rule 100 (factor -> PLUS factor .)
    R_SHIFT         reduce using rule 100 (factor -> PLUS factor .)
    LE              reduce using rule 100 (factor -> PLUS factor .)
    LT              reduce using rule 100 (factor -> PLUS factor .)
    GE              reduce using rule 100 (factor -> PLUS factor .)
    GT              reduce using rule 100 (factor -> PLUS factor .)
    EQ              reduce using rule 100 (factor -> PLUS factor .)
    NE              reduce using rule 100 (factor -> PLUS factor .)
    BIT_AND         reduce using rule 100 (factor -> PLUS factor .)
    BIT_XOR         reduce using rule 100 (factor -> PLUS factor .)
    BIT_OR          reduce using rule 100 (factor -> PLUS factor .)
    AND             reduce using rule 100 (factor -> PLUS factor .)
    OR              reduce using rule 100 (factor -> PLUS factor .)
    SEMICOLON       reduce using rule 100 (factor -> PLUS factor .)
    ASSIGN          reduce using rule 100 (factor -> PLUS factor .)
    PLUS_ASSIGN     reduce using rule 100 (factor -> PLUS factor .)
    MINUS_ASSIGN    reduce using rule 100 (factor -> PLUS factor .)
    MUL_ASSIGN      reduce using rule 100 (factor -> PLUS factor .)
    DIV_ASSIGN      reduce using rule 100 (factor -> PLUS factor .)
    AND_ASSIGN      reduce using rule 100 (factor -> PLUS factor .)
    OR_ASSIGN       reduce using rule 100 (factor -> PLUS factor .)
    XOR_ASSIGN      reduce using rule 100 (factor -> PLUS factor .)
    MOD_ASSIGN      reduce using rule 100 (factor -> PLUS factor .)
    L_SHIFT_ASSIGN  reduce using rule 100 (factor -> PLUS factor .)
    R_SHIFT_ASSIGN  reduce using rule 100 (factor -> PLUS factor .)
    R_PAREN         reduce using rule 100 (factor -> PLUS factor .)
    COMMA           reduce using rule 100 (factor -> PLUS factor .)


state 84

    (95) term -> term MULTIPLY . factor
    (99) factor -> . NOT factor
    (100) factor -> . PLUS factor
    (101) factor -> . MINUS factor
    (102) factor -> . PLUS_PLUS factor
    (103) factor -> . MINUS_MINUS factor
    (104) factor -> . brace
    (105) brace -> . L_PAREN expr R_PAREN
    (106) brace -> . brace PLUS_PLUS
    (107) brace -> . brace MINUS_MINUS
    (108) brace -> . INT_NUM
    (109) brace -> . FLOAT_NUM
    (110) brace -> . ID

    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    INT_NUM         shift and go to state 18
    FLOAT_NUM       shift and go to state 39
    ID              shift and go to state 65

    factor                         shift and go to state 136
    brace                          shift and go to state 38

state 85

    (96) term -> term DIVIDE . factor
    (99) factor -> . NOT factor
    (100) factor -> . PLUS factor
    (101) factor -> . MINUS factor
    (102) factor -> . PLUS_PLUS factor
    (103) factor -> . MINUS_MINUS factor
    (104) factor -> . brace
    (105) brace -> . L_PAREN expr R_PAREN
    (106) brace -> . brace PLUS_PLUS
    (107) brace -> . brace MINUS_MINUS
    (108) brace -> . INT_NUM
    (109) brace -> . FLOAT_NUM
    (110) brace -> . ID

    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    INT_NUM         shift and go to state 18
    FLOAT_NUM       shift and go to state 39
    ID              shift and go to state 65

    factor                         shift and go to state 137
    brace                          shift and go to state 38

state 86

    (97) term -> term MOD . factor
    (99) factor -> . NOT factor
    (100) factor -> . PLUS factor
    (101) factor -> . MINUS factor
    (102) factor -> . PLUS_PLUS factor
    (103) factor -> . MINUS_MINUS factor
    (104) factor -> . brace
    (105) brace -> . L_PAREN expr R_PAREN
    (106) brace -> . brace PLUS_PLUS
    (107) brace -> . brace MINUS_MINUS
    (108) brace -> . INT_NUM
    (109) brace -> . FLOAT_NUM
    (110) brace -> . ID

    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    INT_NUM         shift and go to state 18
    FLOAT_NUM       shift and go to state 39
    ID              shift and go to state 65

    factor                         shift and go to state 138
    brace                          shift and go to state 38

state 87

    (101) factor -> MINUS factor .

    MULTIPLY        reduce using rule 101 (factor -> MINUS factor .)
    DIVIDE          reduce using rule 101 (factor -> MINUS factor .)
    MOD             reduce using rule 101 (factor -> MINUS factor .)
    PLUS            reduce using rule 101 (factor -> MINUS factor .)
    MINUS           reduce using rule 101 (factor -> MINUS factor .)
    L_SHIFT         reduce using rule 101 (factor -> MINUS factor .)
    R_SHIFT         reduce using rule 101 (factor -> MINUS factor .)
    LE              reduce using rule 101 (factor -> MINUS factor .)
    LT              reduce using rule 101 (factor -> MINUS factor .)
    GE              reduce using rule 101 (factor -> MINUS factor .)
    GT              reduce using rule 101 (factor -> MINUS factor .)
    EQ              reduce using rule 101 (factor -> MINUS factor .)
    NE              reduce using rule 101 (factor -> MINUS factor .)
    BIT_AND         reduce using rule 101 (factor -> MINUS factor .)
    BIT_XOR         reduce using rule 101 (factor -> MINUS factor .)
    BIT_OR          reduce using rule 101 (factor -> MINUS factor .)
    AND             reduce using rule 101 (factor -> MINUS factor .)
    OR              reduce using rule 101 (factor -> MINUS factor .)
    SEMICOLON       reduce using rule 101 (factor -> MINUS factor .)
    ASSIGN          reduce using rule 101 (factor -> MINUS factor .)
    PLUS_ASSIGN     reduce using rule 101 (factor -> MINUS factor .)
    MINUS_ASSIGN    reduce using rule 101 (factor -> MINUS factor .)
    MUL_ASSIGN      reduce using rule 101 (factor -> MINUS factor .)
    DIV_ASSIGN      reduce using rule 101 (factor -> MINUS factor .)
    AND_ASSIGN      reduce using rule 101 (factor -> MINUS factor .)
    OR_ASSIGN       reduce using rule 101 (factor -> MINUS factor .)
    XOR_ASSIGN      reduce using rule 101 (factor -> MINUS factor .)
    MOD_ASSIGN      reduce using rule 101 (factor -> MINUS factor .)
    L_SHIFT_ASSIGN  reduce using rule 101 (factor -> MINUS factor .)
    R_SHIFT_ASSIGN  reduce using rule 101 (factor -> MINUS factor .)
    R_PAREN         reduce using rule 101 (factor -> MINUS factor .)
    COMMA           reduce using rule 101 (factor -> MINUS factor .)


state 88

    (99) factor -> NOT factor .

    MULTIPLY        reduce using rule 99 (factor -> NOT factor .)
    DIVIDE          reduce using rule 99 (factor -> NOT factor .)
    MOD             reduce using rule 99 (factor -> NOT factor .)
    PLUS            reduce using rule 99 (factor -> NOT factor .)
    MINUS           reduce using rule 99 (factor -> NOT factor .)
    L_SHIFT         reduce using rule 99 (factor -> NOT factor .)
    R_SHIFT         reduce using rule 99 (factor -> NOT factor .)
    LE              reduce using rule 99 (factor -> NOT factor .)
    LT              reduce using rule 99 (factor -> NOT factor .)
    GE              reduce using rule 99 (factor -> NOT factor .)
    GT              reduce using rule 99 (factor -> NOT factor .)
    EQ              reduce using rule 99 (factor -> NOT factor .)
    NE              reduce using rule 99 (factor -> NOT factor .)
    BIT_AND         reduce using rule 99 (factor -> NOT factor .)
    BIT_XOR         reduce using rule 99 (factor -> NOT factor .)
    BIT_OR          reduce using rule 99 (factor -> NOT factor .)
    AND             reduce using rule 99 (factor -> NOT factor .)
    OR              reduce using rule 99 (factor -> NOT factor .)
    SEMICOLON       reduce using rule 99 (factor -> NOT factor .)
    ASSIGN          reduce using rule 99 (factor -> NOT factor .)
    PLUS_ASSIGN     reduce using rule 99 (factor -> NOT factor .)
    MINUS_ASSIGN    reduce using rule 99 (factor -> NOT factor .)
    MUL_ASSIGN      reduce using rule 99 (factor -> NOT factor .)
    DIV_ASSIGN      reduce using rule 99 (factor -> NOT factor .)
    AND_ASSIGN      reduce using rule 99 (factor -> NOT factor .)
    OR_ASSIGN       reduce using rule 99 (factor -> NOT factor .)
    XOR_ASSIGN      reduce using rule 99 (factor -> NOT factor .)
    MOD_ASSIGN      reduce using rule 99 (factor -> NOT factor .)
    L_SHIFT_ASSIGN  reduce using rule 99 (factor -> NOT factor .)
    R_SHIFT_ASSIGN  reduce using rule 99 (factor -> NOT factor .)
    R_PAREN         reduce using rule 99 (factor -> NOT factor .)
    COMMA           reduce using rule 99 (factor -> NOT factor .)


state 89

    (102) factor -> PLUS_PLUS factor .

    MULTIPLY        reduce using rule 102 (factor -> PLUS_PLUS factor .)
    DIVIDE          reduce using rule 102 (factor -> PLUS_PLUS factor .)
    MOD             reduce using rule 102 (factor -> PLUS_PLUS factor .)
    PLUS            reduce using rule 102 (factor -> PLUS_PLUS factor .)
    MINUS           reduce using rule 102 (factor -> PLUS_PLUS factor .)
    L_SHIFT         reduce using rule 102 (factor -> PLUS_PLUS factor .)
    R_SHIFT         reduce using rule 102 (factor -> PLUS_PLUS factor .)
    LE              reduce using rule 102 (factor -> PLUS_PLUS factor .)
    LT              reduce using rule 102 (factor -> PLUS_PLUS factor .)
    GE              reduce using rule 102 (factor -> PLUS_PLUS factor .)
    GT              reduce using rule 102 (factor -> PLUS_PLUS factor .)
    EQ              reduce using rule 102 (factor -> PLUS_PLUS factor .)
    NE              reduce using rule 102 (factor -> PLUS_PLUS factor .)
    BIT_AND         reduce using rule 102 (factor -> PLUS_PLUS factor .)
    BIT_XOR         reduce using rule 102 (factor -> PLUS_PLUS factor .)
    BIT_OR          reduce using rule 102 (factor -> PLUS_PLUS factor .)
    AND             reduce using rule 102 (factor -> PLUS_PLUS factor .)
    OR              reduce using rule 102 (factor -> PLUS_PLUS factor .)
    SEMICOLON       reduce using rule 102 (factor -> PLUS_PLUS factor .)
    ASSIGN          reduce using rule 102 (factor -> PLUS_PLUS factor .)
    PLUS_ASSIGN     reduce using rule 102 (factor -> PLUS_PLUS factor .)
    MINUS_ASSIGN    reduce using rule 102 (factor -> PLUS_PLUS factor .)
    MUL_ASSIGN      reduce using rule 102 (factor -> PLUS_PLUS factor .)
    DIV_ASSIGN      reduce using rule 102 (factor -> PLUS_PLUS factor .)
    AND_ASSIGN      reduce using rule 102 (factor -> PLUS_PLUS factor .)
    OR_ASSIGN       reduce using rule 102 (factor -> PLUS_PLUS factor .)
    XOR_ASSIGN      reduce using rule 102 (factor -> PLUS_PLUS factor .)
    MOD_ASSIGN      reduce using rule 102 (factor -> PLUS_PLUS factor .)
    L_SHIFT_ASSIGN  reduce using rule 102 (factor -> PLUS_PLUS factor .)
    R_SHIFT_ASSIGN  reduce using rule 102 (factor -> PLUS_PLUS factor .)
    R_PAREN         reduce using rule 102 (factor -> PLUS_PLUS factor .)
    COMMA           reduce using rule 102 (factor -> PLUS_PLUS factor .)


state 90

    (103) factor -> MINUS_MINUS factor .

    MULTIPLY        reduce using rule 103 (factor -> MINUS_MINUS factor .)
    DIVIDE          reduce using rule 103 (factor -> MINUS_MINUS factor .)
    MOD             reduce using rule 103 (factor -> MINUS_MINUS factor .)
    PLUS            reduce using rule 103 (factor -> MINUS_MINUS factor .)
    MINUS           reduce using rule 103 (factor -> MINUS_MINUS factor .)
    L_SHIFT         reduce using rule 103 (factor -> MINUS_MINUS factor .)
    R_SHIFT         reduce using rule 103 (factor -> MINUS_MINUS factor .)
    LE              reduce using rule 103 (factor -> MINUS_MINUS factor .)
    LT              reduce using rule 103 (factor -> MINUS_MINUS factor .)
    GE              reduce using rule 103 (factor -> MINUS_MINUS factor .)
    GT              reduce using rule 103 (factor -> MINUS_MINUS factor .)
    EQ              reduce using rule 103 (factor -> MINUS_MINUS factor .)
    NE              reduce using rule 103 (factor -> MINUS_MINUS factor .)
    BIT_AND         reduce using rule 103 (factor -> MINUS_MINUS factor .)
    BIT_XOR         reduce using rule 103 (factor -> MINUS_MINUS factor .)
    BIT_OR          reduce using rule 103 (factor -> MINUS_MINUS factor .)
    AND             reduce using rule 103 (factor -> MINUS_MINUS factor .)
    OR              reduce using rule 103 (factor -> MINUS_MINUS factor .)
    SEMICOLON       reduce using rule 103 (factor -> MINUS_MINUS factor .)
    ASSIGN          reduce using rule 103 (factor -> MINUS_MINUS factor .)
    PLUS_ASSIGN     reduce using rule 103 (factor -> MINUS_MINUS factor .)
    MINUS_ASSIGN    reduce using rule 103 (factor -> MINUS_MINUS factor .)
    MUL_ASSIGN      reduce using rule 103 (factor -> MINUS_MINUS factor .)
    DIV_ASSIGN      reduce using rule 103 (factor -> MINUS_MINUS factor .)
    AND_ASSIGN      reduce using rule 103 (factor -> MINUS_MINUS factor .)
    OR_ASSIGN       reduce using rule 103 (factor -> MINUS_MINUS factor .)
    XOR_ASSIGN      reduce using rule 103 (factor -> MINUS_MINUS factor .)
    MOD_ASSIGN      reduce using rule 103 (factor -> MINUS_MINUS factor .)
    L_SHIFT_ASSIGN  reduce using rule 103 (factor -> MINUS_MINUS factor .)
    R_SHIFT_ASSIGN  reduce using rule 103 (factor -> MINUS_MINUS factor .)
    R_PAREN         reduce using rule 103 (factor -> MINUS_MINUS factor .)
    COMMA           reduce using rule 103 (factor -> MINUS_MINUS factor .)


state 91

    (106) brace -> brace PLUS_PLUS .

    PLUS_PLUS       reduce using rule 106 (brace -> brace PLUS_PLUS .)
    MINUS_MINUS     reduce using rule 106 (brace -> brace PLUS_PLUS .)
    MULTIPLY        reduce using rule 106 (brace -> brace PLUS_PLUS .)
    DIVIDE          reduce using rule 106 (brace -> brace PLUS_PLUS .)
    MOD             reduce using rule 106 (brace -> brace PLUS_PLUS .)
    PLUS            reduce using rule 106 (brace -> brace PLUS_PLUS .)
    MINUS           reduce using rule 106 (brace -> brace PLUS_PLUS .)
    L_SHIFT         reduce using rule 106 (brace -> brace PLUS_PLUS .)
    R_SHIFT         reduce using rule 106 (brace -> brace PLUS_PLUS .)
    LE              reduce using rule 106 (brace -> brace PLUS_PLUS .)
    LT              reduce using rule 106 (brace -> brace PLUS_PLUS .)
    GE              reduce using rule 106 (brace -> brace PLUS_PLUS .)
    GT              reduce using rule 106 (brace -> brace PLUS_PLUS .)
    EQ              reduce using rule 106 (brace -> brace PLUS_PLUS .)
    NE              reduce using rule 106 (brace -> brace PLUS_PLUS .)
    BIT_AND         reduce using rule 106 (brace -> brace PLUS_PLUS .)
    BIT_XOR         reduce using rule 106 (brace -> brace PLUS_PLUS .)
    BIT_OR          reduce using rule 106 (brace -> brace PLUS_PLUS .)
    AND             reduce using rule 106 (brace -> brace PLUS_PLUS .)
    OR              reduce using rule 106 (brace -> brace PLUS_PLUS .)
    SEMICOLON       reduce using rule 106 (brace -> brace PLUS_PLUS .)
    ASSIGN          reduce using rule 106 (brace -> brace PLUS_PLUS .)
    PLUS_ASSIGN     reduce using rule 106 (brace -> brace PLUS_PLUS .)
    MINUS_ASSIGN    reduce using rule 106 (brace -> brace PLUS_PLUS .)
    MUL_ASSIGN      reduce using rule 106 (brace -> brace PLUS_PLUS .)
    DIV_ASSIGN      reduce using rule 106 (brace -> brace PLUS_PLUS .)
    AND_ASSIGN      reduce using rule 106 (brace -> brace PLUS_PLUS .)
    OR_ASSIGN       reduce using rule 106 (brace -> brace PLUS_PLUS .)
    XOR_ASSIGN      reduce using rule 106 (brace -> brace PLUS_PLUS .)
    MOD_ASSIGN      reduce using rule 106 (brace -> brace PLUS_PLUS .)
    L_SHIFT_ASSIGN  reduce using rule 106 (brace -> brace PLUS_PLUS .)
    R_SHIFT_ASSIGN  reduce using rule 106 (brace -> brace PLUS_PLUS .)
    R_PAREN         reduce using rule 106 (brace -> brace PLUS_PLUS .)
    COMMA           reduce using rule 106 (brace -> brace PLUS_PLUS .)


state 92

    (107) brace -> brace MINUS_MINUS .

    PLUS_PLUS       reduce using rule 107 (brace -> brace MINUS_MINUS .)
    MINUS_MINUS     reduce using rule 107 (brace -> brace MINUS_MINUS .)
    MULTIPLY        reduce using rule 107 (brace -> brace MINUS_MINUS .)
    DIVIDE          reduce using rule 107 (brace -> brace MINUS_MINUS .)
    MOD             reduce using rule 107 (brace -> brace MINUS_MINUS .)
    PLUS            reduce using rule 107 (brace -> brace MINUS_MINUS .)
    MINUS           reduce using rule 107 (brace -> brace MINUS_MINUS .)
    L_SHIFT         reduce using rule 107 (brace -> brace MINUS_MINUS .)
    R_SHIFT         reduce using rule 107 (brace -> brace MINUS_MINUS .)
    LE              reduce using rule 107 (brace -> brace MINUS_MINUS .)
    LT              reduce using rule 107 (brace -> brace MINUS_MINUS .)
    GE              reduce using rule 107 (brace -> brace MINUS_MINUS .)
    GT              reduce using rule 107 (brace -> brace MINUS_MINUS .)
    EQ              reduce using rule 107 (brace -> brace MINUS_MINUS .)
    NE              reduce using rule 107 (brace -> brace MINUS_MINUS .)
    BIT_AND         reduce using rule 107 (brace -> brace MINUS_MINUS .)
    BIT_XOR         reduce using rule 107 (brace -> brace MINUS_MINUS .)
    BIT_OR          reduce using rule 107 (brace -> brace MINUS_MINUS .)
    AND             reduce using rule 107 (brace -> brace MINUS_MINUS .)
    OR              reduce using rule 107 (brace -> brace MINUS_MINUS .)
    SEMICOLON       reduce using rule 107 (brace -> brace MINUS_MINUS .)
    ASSIGN          reduce using rule 107 (brace -> brace MINUS_MINUS .)
    PLUS_ASSIGN     reduce using rule 107 (brace -> brace MINUS_MINUS .)
    MINUS_ASSIGN    reduce using rule 107 (brace -> brace MINUS_MINUS .)
    MUL_ASSIGN      reduce using rule 107 (brace -> brace MINUS_MINUS .)
    DIV_ASSIGN      reduce using rule 107 (brace -> brace MINUS_MINUS .)
    AND_ASSIGN      reduce using rule 107 (brace -> brace MINUS_MINUS .)
    OR_ASSIGN       reduce using rule 107 (brace -> brace MINUS_MINUS .)
    XOR_ASSIGN      reduce using rule 107 (brace -> brace MINUS_MINUS .)
    MOD_ASSIGN      reduce using rule 107 (brace -> brace MINUS_MINUS .)
    L_SHIFT_ASSIGN  reduce using rule 107 (brace -> brace MINUS_MINUS .)
    R_SHIFT_ASSIGN  reduce using rule 107 (brace -> brace MINUS_MINUS .)
    R_PAREN         reduce using rule 107 (brace -> brace MINUS_MINUS .)
    COMMA           reduce using rule 107 (brace -> brace MINUS_MINUS .)


state 93

    (12) closed -> IF . condition closed ELSE closed
    (6) open -> IF . condition statement
    (7) open -> IF . condition closed ELSE open
    (15) condition -> . L_PAREN expr R_PAREN

    L_PAREN         shift and go to state 42

    condition                      shift and go to state 139

state 94

    (6) open -> IF condition statement .

    IF              reduce using rule 6 (open -> IF condition statement .)
    WHILE           reduce using rule 6 (open -> IF condition statement .)
    FOR             reduce using rule 6 (open -> IF condition statement .)
    SEMICOLON       reduce using rule 6 (open -> IF condition statement .)
    RETURN          reduce using rule 6 (open -> IF condition statement .)
    L_FLOWBRACE     reduce using rule 6 (open -> IF condition statement .)
    TYPE            reduce using rule 6 (open -> IF condition statement .)
    ID              reduce using rule 6 (open -> IF condition statement .)
    NOT             reduce using rule 6 (open -> IF condition statement .)
    PLUS            reduce using rule 6 (open -> IF condition statement .)
    MINUS           reduce using rule 6 (open -> IF condition statement .)
    PLUS_PLUS       reduce using rule 6 (open -> IF condition statement .)
    MINUS_MINUS     reduce using rule 6 (open -> IF condition statement .)
    L_PAREN         reduce using rule 6 (open -> IF condition statement .)
    INT_NUM         reduce using rule 6 (open -> IF condition statement .)
    FLOAT_NUM       reduce using rule 6 (open -> IF condition statement .)
    $end            reduce using rule 6 (open -> IF condition statement .)
    R_FLOWBRACE     reduce using rule 6 (open -> IF condition statement .)


state 95

    (7) open -> IF condition closed . ELSE open
    (12) closed -> IF condition closed . ELSE closed
    (5) statement -> closed .

    ELSE            shift and go to state 140
    IF              reduce using rule 5 (statement -> closed .)
    WHILE           reduce using rule 5 (statement -> closed .)
    FOR             reduce using rule 5 (statement -> closed .)
    SEMICOLON       reduce using rule 5 (statement -> closed .)
    RETURN          reduce using rule 5 (statement -> closed .)
    L_FLOWBRACE     reduce using rule 5 (statement -> closed .)
    TYPE            reduce using rule 5 (statement -> closed .)
    ID              reduce using rule 5 (statement -> closed .)
    NOT             reduce using rule 5 (statement -> closed .)
    PLUS            reduce using rule 5 (statement -> closed .)
    MINUS           reduce using rule 5 (statement -> closed .)
    PLUS_PLUS       reduce using rule 5 (statement -> closed .)
    MINUS_MINUS     reduce using rule 5 (statement -> closed .)
    L_PAREN         reduce using rule 5 (statement -> closed .)
    INT_NUM         reduce using rule 5 (statement -> closed .)
    FLOAT_NUM       reduce using rule 5 (statement -> closed .)
    $end            reduce using rule 5 (statement -> closed .)
    R_FLOWBRACE     reduce using rule 5 (statement -> closed .)


state 96

    (13) closed -> WHILE . condition closed
    (8) open -> WHILE . condition open
    (15) condition -> . L_PAREN expr R_PAREN

    L_PAREN         shift and go to state 42

    condition                      shift and go to state 141

state 97

    (14) closed -> FOR . for_condition closed
    (9) open -> FOR . for_condition open
    (16) for_condition -> . L_PAREN declaration expr SEMICOLON expr R_PAREN
    (17) for_condition -> . L_PAREN expr SEMICOLON expr SEMICOLON expr R_PAREN

    L_PAREN         shift and go to state 45

    for_condition                  shift and go to state 142

state 98

    (15) condition -> L_PAREN expr . R_PAREN
    (56) expr -> expr . assignment exprOR
    (57) expr -> expr . assignment ID L_PAREN call_params R_PAREN
    (59) assignment -> . ASSIGN
    (60) assignment -> . PLUS_ASSIGN
    (61) assignment -> . MINUS_ASSIGN
    (62) assignment -> . MUL_ASSIGN
    (63) assignment -> . DIV_ASSIGN
    (64) assignment -> . AND_ASSIGN
    (65) assignment -> . OR_ASSIGN
    (66) assignment -> . XOR_ASSIGN
    (67) assignment -> . MOD_ASSIGN
    (68) assignment -> . L_SHIFT_ASSIGN
    (69) assignment -> . R_SHIFT_ASSIGN

    R_PAREN         shift and go to state 143
    ASSIGN          shift and go to state 48
    PLUS_ASSIGN     shift and go to state 49
    MINUS_ASSIGN    shift and go to state 50
    MUL_ASSIGN      shift and go to state 51
    DIV_ASSIGN      shift and go to state 52
    AND_ASSIGN      shift and go to state 53
    OR_ASSIGN       shift and go to state 54
    XOR_ASSIGN      shift and go to state 55
    MOD_ASSIGN      shift and go to state 56
    L_SHIFT_ASSIGN  shift and go to state 57
    R_SHIFT_ASSIGN  shift and go to state 58

    assignment                     shift and go to state 47

state 99

    (8) open -> WHILE condition open .

    IF              reduce using rule 8 (open -> WHILE condition open .)
    WHILE           reduce using rule 8 (open -> WHILE condition open .)
    FOR             reduce using rule 8 (open -> WHILE condition open .)
    SEMICOLON       reduce using rule 8 (open -> WHILE condition open .)
    RETURN          reduce using rule 8 (open -> WHILE condition open .)
    L_FLOWBRACE     reduce using rule 8 (open -> WHILE condition open .)
    TYPE            reduce using rule 8 (open -> WHILE condition open .)
    ID              reduce using rule 8 (open -> WHILE condition open .)
    NOT             reduce using rule 8 (open -> WHILE condition open .)
    PLUS            reduce using rule 8 (open -> WHILE condition open .)
    MINUS           reduce using rule 8 (open -> WHILE condition open .)
    PLUS_PLUS       reduce using rule 8 (open -> WHILE condition open .)
    MINUS_MINUS     reduce using rule 8 (open -> WHILE condition open .)
    L_PAREN         reduce using rule 8 (open -> WHILE condition open .)
    INT_NUM         reduce using rule 8 (open -> WHILE condition open .)
    FLOAT_NUM       reduce using rule 8 (open -> WHILE condition open .)
    $end            reduce using rule 8 (open -> WHILE condition open .)
    R_FLOWBRACE     reduce using rule 8 (open -> WHILE condition open .)


state 100

    (13) closed -> WHILE condition closed .

    IF              reduce using rule 13 (closed -> WHILE condition closed .)
    WHILE           reduce using rule 13 (closed -> WHILE condition closed .)
    FOR             reduce using rule 13 (closed -> WHILE condition closed .)
    SEMICOLON       reduce using rule 13 (closed -> WHILE condition closed .)
    RETURN          reduce using rule 13 (closed -> WHILE condition closed .)
    L_FLOWBRACE     reduce using rule 13 (closed -> WHILE condition closed .)
    TYPE            reduce using rule 13 (closed -> WHILE condition closed .)
    ID              reduce using rule 13 (closed -> WHILE condition closed .)
    NOT             reduce using rule 13 (closed -> WHILE condition closed .)
    PLUS            reduce using rule 13 (closed -> WHILE condition closed .)
    MINUS           reduce using rule 13 (closed -> WHILE condition closed .)
    PLUS_PLUS       reduce using rule 13 (closed -> WHILE condition closed .)
    MINUS_MINUS     reduce using rule 13 (closed -> WHILE condition closed .)
    L_PAREN         reduce using rule 13 (closed -> WHILE condition closed .)
    INT_NUM         reduce using rule 13 (closed -> WHILE condition closed .)
    FLOAT_NUM       reduce using rule 13 (closed -> WHILE condition closed .)
    $end            reduce using rule 13 (closed -> WHILE condition closed .)
    R_FLOWBRACE     reduce using rule 13 (closed -> WHILE condition closed .)
    ELSE            reduce using rule 13 (closed -> WHILE condition closed .)


state 101

    (9) open -> FOR for_condition open .

    IF              reduce using rule 9 (open -> FOR for_condition open .)
    WHILE           reduce using rule 9 (open -> FOR for_condition open .)
    FOR             reduce using rule 9 (open -> FOR for_condition open .)
    SEMICOLON       reduce using rule 9 (open -> FOR for_condition open .)
    RETURN          reduce using rule 9 (open -> FOR for_condition open .)
    L_FLOWBRACE     reduce using rule 9 (open -> FOR for_condition open .)
    TYPE            reduce using rule 9 (open -> FOR for_condition open .)
    ID              reduce using rule 9 (open -> FOR for_condition open .)
    NOT             reduce using rule 9 (open -> FOR for_condition open .)
    PLUS            reduce using rule 9 (open -> FOR for_condition open .)
    MINUS           reduce using rule 9 (open -> FOR for_condition open .)
    PLUS_PLUS       reduce using rule 9 (open -> FOR for_condition open .)
    MINUS_MINUS     reduce using rule 9 (open -> FOR for_condition open .)
    L_PAREN         reduce using rule 9 (open -> FOR for_condition open .)
    INT_NUM         reduce using rule 9 (open -> FOR for_condition open .)
    FLOAT_NUM       reduce using rule 9 (open -> FOR for_condition open .)
    $end            reduce using rule 9 (open -> FOR for_condition open .)
    R_FLOWBRACE     reduce using rule 9 (open -> FOR for_condition open .)


state 102

    (14) closed -> FOR for_condition closed .

    IF              reduce using rule 14 (closed -> FOR for_condition closed .)
    WHILE           reduce using rule 14 (closed -> FOR for_condition closed .)
    FOR             reduce using rule 14 (closed -> FOR for_condition closed .)
    SEMICOLON       reduce using rule 14 (closed -> FOR for_condition closed .)
    RETURN          reduce using rule 14 (closed -> FOR for_condition closed .)
    L_FLOWBRACE     reduce using rule 14 (closed -> FOR for_condition closed .)
    TYPE            reduce using rule 14 (closed -> FOR for_condition closed .)
    ID              reduce using rule 14 (closed -> FOR for_condition closed .)
    NOT             reduce using rule 14 (closed -> FOR for_condition closed .)
    PLUS            reduce using rule 14 (closed -> FOR for_condition closed .)
    MINUS           reduce using rule 14 (closed -> FOR for_condition closed .)
    PLUS_PLUS       reduce using rule 14 (closed -> FOR for_condition closed .)
    MINUS_MINUS     reduce using rule 14 (closed -> FOR for_condition closed .)
    L_PAREN         reduce using rule 14 (closed -> FOR for_condition closed .)
    INT_NUM         reduce using rule 14 (closed -> FOR for_condition closed .)
    FLOAT_NUM       reduce using rule 14 (closed -> FOR for_condition closed .)
    $end            reduce using rule 14 (closed -> FOR for_condition closed .)
    R_FLOWBRACE     reduce using rule 14 (closed -> FOR for_condition closed .)
    ELSE            reduce using rule 14 (closed -> FOR for_condition closed .)


state 103

    (16) for_condition -> L_PAREN declaration . expr SEMICOLON expr R_PAREN
    (56) expr -> . expr assignment exprOR
    (57) expr -> . expr assignment ID L_PAREN call_params R_PAREN
    (58) expr -> . exprOR
    (70) exprOR -> . exprOR OR exprAND
    (71) exprOR -> . exprAND
    (72) exprAND -> . exprAND AND exprBITOR
    (73) exprAND -> . exprBITOR
    (74) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (75) exprBITOR -> . exprBITXOR
    (76) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (77) exprBITXOR -> . exprBITAND
    (78) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (79) exprBITAND -> . exprEQ
    (80) exprEQ -> . exprEQ EQ exprRELOP
    (81) exprEQ -> . exprEQ NE exprRELOP
    (82) exprEQ -> . exprRELOP
    (83) exprRELOP -> . exprRELOP relop exprSHIFT
    (84) exprRELOP -> . exprSHIFT
    (89) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (90) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (91) exprSHIFT -> . exprOP
    (92) exprOP -> . exprOP PLUS term
    (93) exprOP -> . exprOP MINUS term
    (94) exprOP -> . term
    (95) term -> . term MULTIPLY factor
    (96) term -> . term DIVIDE factor
    (97) term -> . term MOD factor
    (98) term -> . factor
    (99) factor -> . NOT factor
    (100) factor -> . PLUS factor
    (101) factor -> . MINUS factor
    (102) factor -> . PLUS_PLUS factor
    (103) factor -> . MINUS_MINUS factor
    (104) factor -> . brace
    (105) brace -> . L_PAREN expr R_PAREN
    (106) brace -> . brace PLUS_PLUS
    (107) brace -> . brace MINUS_MINUS
    (108) brace -> . INT_NUM
    (109) brace -> . FLOAT_NUM
    (110) brace -> . ID

    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    INT_NUM         shift and go to state 18
    FLOAT_NUM       shift and go to state 39
    ID              shift and go to state 65

    expr                           shift and go to state 144
    exprOR                         shift and go to state 20
    exprAND                        shift and go to state 23
    exprBITOR                      shift and go to state 24
    exprBITXOR                     shift and go to state 25
    exprBITAND                     shift and go to state 26
    exprEQ                         shift and go to state 27
    exprRELOP                      shift and go to state 28
    exprSHIFT                      shift and go to state 29
    exprOP                         shift and go to state 30
    term                           shift and go to state 32
    factor                         shift and go to state 34
    brace                          shift and go to state 38

state 104

    (17) for_condition -> L_PAREN expr . SEMICOLON expr SEMICOLON expr R_PAREN
    (56) expr -> expr . assignment exprOR
    (57) expr -> expr . assignment ID L_PAREN call_params R_PAREN
    (59) assignment -> . ASSIGN
    (60) assignment -> . PLUS_ASSIGN
    (61) assignment -> . MINUS_ASSIGN
    (62) assignment -> . MUL_ASSIGN
    (63) assignment -> . DIV_ASSIGN
    (64) assignment -> . AND_ASSIGN
    (65) assignment -> . OR_ASSIGN
    (66) assignment -> . XOR_ASSIGN
    (67) assignment -> . MOD_ASSIGN
    (68) assignment -> . L_SHIFT_ASSIGN
    (69) assignment -> . R_SHIFT_ASSIGN

    SEMICOLON       shift and go to state 145
    ASSIGN          shift and go to state 48
    PLUS_ASSIGN     shift and go to state 49
    MINUS_ASSIGN    shift and go to state 50
    MUL_ASSIGN      shift and go to state 51
    DIV_ASSIGN      shift and go to state 52
    AND_ASSIGN      shift and go to state 53
    OR_ASSIGN       shift and go to state 54
    XOR_ASSIGN      shift and go to state 55
    MOD_ASSIGN      shift and go to state 56
    L_SHIFT_ASSIGN  shift and go to state 57
    R_SHIFT_ASSIGN  shift and go to state 58

    assignment                     shift and go to state 47

state 105

    (24) declaration -> TYPE . ID SEMICOLON
    (25) declaration -> TYPE . ID ASSIGN expr SEMICOLON
    (26) declaration -> TYPE . ID ASSIGN function_call
    (27) declaration -> TYPE . multi_declaration stop
    (18) multi_declaration -> . multi_declaration ID COMMA
    (19) multi_declaration -> . multi_declaration ID ASSIGN expr COMMA
    (20) multi_declaration -> . ID COMMA
    (21) multi_declaration -> . ID ASSIGN expr COMMA

    ID              shift and go to state 146

    multi_declaration              shift and go to state 67

state 106

    (56) expr -> expr assignment exprOR .
    (70) exprOR -> exprOR . OR exprAND

    SEMICOLON       reduce using rule 56 (expr -> expr assignment exprOR .)
    ASSIGN          reduce using rule 56 (expr -> expr assignment exprOR .)
    PLUS_ASSIGN     reduce using rule 56 (expr -> expr assignment exprOR .)
    MINUS_ASSIGN    reduce using rule 56 (expr -> expr assignment exprOR .)
    MUL_ASSIGN      reduce using rule 56 (expr -> expr assignment exprOR .)
    DIV_ASSIGN      reduce using rule 56 (expr -> expr assignment exprOR .)
    AND_ASSIGN      reduce using rule 56 (expr -> expr assignment exprOR .)
    OR_ASSIGN       reduce using rule 56 (expr -> expr assignment exprOR .)
    XOR_ASSIGN      reduce using rule 56 (expr -> expr assignment exprOR .)
    MOD_ASSIGN      reduce using rule 56 (expr -> expr assignment exprOR .)
    L_SHIFT_ASSIGN  reduce using rule 56 (expr -> expr assignment exprOR .)
    R_SHIFT_ASSIGN  reduce using rule 56 (expr -> expr assignment exprOR .)
    R_PAREN         reduce using rule 56 (expr -> expr assignment exprOR .)
    COMMA           reduce using rule 56 (expr -> expr assignment exprOR .)
    OR              shift and go to state 63


state 107

    (57) expr -> expr assignment ID . L_PAREN call_params R_PAREN
    (110) brace -> ID .

    L_PAREN         shift and go to state 147
    PLUS_PLUS       reduce using rule 110 (brace -> ID .)
    MINUS_MINUS     reduce using rule 110 (brace -> ID .)
    MULTIPLY        reduce using rule 110 (brace -> ID .)
    DIVIDE          reduce using rule 110 (brace -> ID .)
    MOD             reduce using rule 110 (brace -> ID .)
    PLUS            reduce using rule 110 (brace -> ID .)
    MINUS           reduce using rule 110 (brace -> ID .)
    L_SHIFT         reduce using rule 110 (brace -> ID .)
    R_SHIFT         reduce using rule 110 (brace -> ID .)
    LE              reduce using rule 110 (brace -> ID .)
    LT              reduce using rule 110 (brace -> ID .)
    GE              reduce using rule 110 (brace -> ID .)
    GT              reduce using rule 110 (brace -> ID .)
    EQ              reduce using rule 110 (brace -> ID .)
    NE              reduce using rule 110 (brace -> ID .)
    BIT_AND         reduce using rule 110 (brace -> ID .)
    BIT_XOR         reduce using rule 110 (brace -> ID .)
    BIT_OR          reduce using rule 110 (brace -> ID .)
    AND             reduce using rule 110 (brace -> ID .)
    OR              reduce using rule 110 (brace -> ID .)
    SEMICOLON       reduce using rule 110 (brace -> ID .)
    ASSIGN          reduce using rule 110 (brace -> ID .)
    PLUS_ASSIGN     reduce using rule 110 (brace -> ID .)
    MINUS_ASSIGN    reduce using rule 110 (brace -> ID .)
    MUL_ASSIGN      reduce using rule 110 (brace -> ID .)
    DIV_ASSIGN      reduce using rule 110 (brace -> ID .)
    AND_ASSIGN      reduce using rule 110 (brace -> ID .)
    OR_ASSIGN       reduce using rule 110 (brace -> ID .)
    XOR_ASSIGN      reduce using rule 110 (brace -> ID .)
    MOD_ASSIGN      reduce using rule 110 (brace -> ID .)
    L_SHIFT_ASSIGN  reduce using rule 110 (brace -> ID .)
    R_SHIFT_ASSIGN  reduce using rule 110 (brace -> ID .)
    R_PAREN         reduce using rule 110 (brace -> ID .)
    COMMA           reduce using rule 110 (brace -> ID .)


state 108

    (34) simple -> RETURN ID SEMICOLON .

    IF              reduce using rule 34 (simple -> RETURN ID SEMICOLON .)
    WHILE           reduce using rule 34 (simple -> RETURN ID SEMICOLON .)
    FOR             reduce using rule 34 (simple -> RETURN ID SEMICOLON .)
    SEMICOLON       reduce using rule 34 (simple -> RETURN ID SEMICOLON .)
    RETURN          reduce using rule 34 (simple -> RETURN ID SEMICOLON .)
    L_FLOWBRACE     reduce using rule 34 (simple -> RETURN ID SEMICOLON .)
    TYPE            reduce using rule 34 (simple -> RETURN ID SEMICOLON .)
    ID              reduce using rule 34 (simple -> RETURN ID SEMICOLON .)
    NOT             reduce using rule 34 (simple -> RETURN ID SEMICOLON .)
    PLUS            reduce using rule 34 (simple -> RETURN ID SEMICOLON .)
    MINUS           reduce using rule 34 (simple -> RETURN ID SEMICOLON .)
    PLUS_PLUS       reduce using rule 34 (simple -> RETURN ID SEMICOLON .)
    MINUS_MINUS     reduce using rule 34 (simple -> RETURN ID SEMICOLON .)
    L_PAREN         reduce using rule 34 (simple -> RETURN ID SEMICOLON .)
    INT_NUM         reduce using rule 34 (simple -> RETURN ID SEMICOLON .)
    FLOAT_NUM       reduce using rule 34 (simple -> RETURN ID SEMICOLON .)
    $end            reduce using rule 34 (simple -> RETURN ID SEMICOLON .)
    R_FLOWBRACE     reduce using rule 34 (simple -> RETURN ID SEMICOLON .)
    ELSE            reduce using rule 34 (simple -> RETURN ID SEMICOLON .)


state 109

    (35) simple -> RETURN INT_NUM SEMICOLON .

    IF              reduce using rule 35 (simple -> RETURN INT_NUM SEMICOLON .)
    WHILE           reduce using rule 35 (simple -> RETURN INT_NUM SEMICOLON .)
    FOR             reduce using rule 35 (simple -> RETURN INT_NUM SEMICOLON .)
    SEMICOLON       reduce using rule 35 (simple -> RETURN INT_NUM SEMICOLON .)
    RETURN          reduce using rule 35 (simple -> RETURN INT_NUM SEMICOLON .)
    L_FLOWBRACE     reduce using rule 35 (simple -> RETURN INT_NUM SEMICOLON .)
    TYPE            reduce using rule 35 (simple -> RETURN INT_NUM SEMICOLON .)
    ID              reduce using rule 35 (simple -> RETURN INT_NUM SEMICOLON .)
    NOT             reduce using rule 35 (simple -> RETURN INT_NUM SEMICOLON .)
    PLUS            reduce using rule 35 (simple -> RETURN INT_NUM SEMICOLON .)
    MINUS           reduce using rule 35 (simple -> RETURN INT_NUM SEMICOLON .)
    PLUS_PLUS       reduce using rule 35 (simple -> RETURN INT_NUM SEMICOLON .)
    MINUS_MINUS     reduce using rule 35 (simple -> RETURN INT_NUM SEMICOLON .)
    L_PAREN         reduce using rule 35 (simple -> RETURN INT_NUM SEMICOLON .)
    INT_NUM         reduce using rule 35 (simple -> RETURN INT_NUM SEMICOLON .)
    FLOAT_NUM       reduce using rule 35 (simple -> RETURN INT_NUM SEMICOLON .)
    $end            reduce using rule 35 (simple -> RETURN INT_NUM SEMICOLON .)
    R_FLOWBRACE     reduce using rule 35 (simple -> RETURN INT_NUM SEMICOLON .)
    ELSE            reduce using rule 35 (simple -> RETURN INT_NUM SEMICOLON .)


state 110

    (44) yes_call_params -> ID . COMMA
    (46) end_call_params -> ID .

    COMMA           shift and go to state 148
    R_PAREN         reduce using rule 46 (end_call_params -> ID .)


state 111

    (37) function_call -> ID L_PAREN call_params . R_PAREN SEMICOLON

    R_PAREN         shift and go to state 149


state 112

    (38) call_params -> empty .

    R_PAREN         reduce using rule 38 (call_params -> empty .)


state 113

    (39) call_params -> yes_call_params . end_call_params
    (41) yes_call_params -> yes_call_params . INT_NUM COMMA
    (42) yes_call_params -> yes_call_params . ID COMMA
    (45) end_call_params -> . INT_NUM
    (46) end_call_params -> . ID

    INT_NUM         shift and go to state 151
    ID              shift and go to state 152

    end_call_params                shift and go to state 150

state 114

    (40) call_params -> end_call_params .

    R_PAREN         reduce using rule 40 (call_params -> end_call_params .)


state 115

    (43) yes_call_params -> INT_NUM . COMMA
    (45) end_call_params -> INT_NUM .

    COMMA           shift and go to state 153
    R_PAREN         reduce using rule 45 (end_call_params -> INT_NUM .)


state 116

    (28) block -> L_FLOWBRACE multiple_statements R_FLOWBRACE .

    IF              reduce using rule 28 (block -> L_FLOWBRACE multiple_statements R_FLOWBRACE .)
    WHILE           reduce using rule 28 (block -> L_FLOWBRACE multiple_statements R_FLOWBRACE .)
    FOR             reduce using rule 28 (block -> L_FLOWBRACE multiple_statements R_FLOWBRACE .)
    SEMICOLON       reduce using rule 28 (block -> L_FLOWBRACE multiple_statements R_FLOWBRACE .)
    RETURN          reduce using rule 28 (block -> L_FLOWBRACE multiple_statements R_FLOWBRACE .)
    L_FLOWBRACE     reduce using rule 28 (block -> L_FLOWBRACE multiple_statements R_FLOWBRACE .)
    TYPE            reduce using rule 28 (block -> L_FLOWBRACE multiple_statements R_FLOWBRACE .)
    ID              reduce using rule 28 (block -> L_FLOWBRACE multiple_statements R_FLOWBRACE .)
    NOT             reduce using rule 28 (block -> L_FLOWBRACE multiple_statements R_FLOWBRACE .)
    PLUS            reduce using rule 28 (block -> L_FLOWBRACE multiple_statements R_FLOWBRACE .)
    MINUS           reduce using rule 28 (block -> L_FLOWBRACE multiple_statements R_FLOWBRACE .)
    PLUS_PLUS       reduce using rule 28 (block -> L_FLOWBRACE multiple_statements R_FLOWBRACE .)
    MINUS_MINUS     reduce using rule 28 (block -> L_FLOWBRACE multiple_statements R_FLOWBRACE .)
    L_PAREN         reduce using rule 28 (block -> L_FLOWBRACE multiple_statements R_FLOWBRACE .)
    INT_NUM         reduce using rule 28 (block -> L_FLOWBRACE multiple_statements R_FLOWBRACE .)
    FLOAT_NUM       reduce using rule 28 (block -> L_FLOWBRACE multiple_statements R_FLOWBRACE .)
    $end            reduce using rule 28 (block -> L_FLOWBRACE multiple_statements R_FLOWBRACE .)
    R_FLOWBRACE     reduce using rule 28 (block -> L_FLOWBRACE multiple_statements R_FLOWBRACE .)
    ELSE            reduce using rule 28 (block -> L_FLOWBRACE multiple_statements R_FLOWBRACE .)


state 117

    (70) exprOR -> exprOR OR exprAND .
    (72) exprAND -> exprAND . AND exprBITOR

    OR              reduce using rule 70 (exprOR -> exprOR OR exprAND .)
    SEMICOLON       reduce using rule 70 (exprOR -> exprOR OR exprAND .)
    ASSIGN          reduce using rule 70 (exprOR -> exprOR OR exprAND .)
    PLUS_ASSIGN     reduce using rule 70 (exprOR -> exprOR OR exprAND .)
    MINUS_ASSIGN    reduce using rule 70 (exprOR -> exprOR OR exprAND .)
    MUL_ASSIGN      reduce using rule 70 (exprOR -> exprOR OR exprAND .)
    DIV_ASSIGN      reduce using rule 70 (exprOR -> exprOR OR exprAND .)
    AND_ASSIGN      reduce using rule 70 (exprOR -> exprOR OR exprAND .)
    OR_ASSIGN       reduce using rule 70 (exprOR -> exprOR OR exprAND .)
    XOR_ASSIGN      reduce using rule 70 (exprOR -> exprOR OR exprAND .)
    MOD_ASSIGN      reduce using rule 70 (exprOR -> exprOR OR exprAND .)
    L_SHIFT_ASSIGN  reduce using rule 70 (exprOR -> exprOR OR exprAND .)
    R_SHIFT_ASSIGN  reduce using rule 70 (exprOR -> exprOR OR exprAND .)
    R_PAREN         reduce using rule 70 (exprOR -> exprOR OR exprAND .)
    COMMA           reduce using rule 70 (exprOR -> exprOR OR exprAND .)
    AND             shift and go to state 68


state 118

    (105) brace -> L_PAREN expr R_PAREN .

    PLUS_PLUS       reduce using rule 105 (brace -> L_PAREN expr R_PAREN .)
    MINUS_MINUS     reduce using rule 105 (brace -> L_PAREN expr R_PAREN .)
    MULTIPLY        reduce using rule 105 (brace -> L_PAREN expr R_PAREN .)
    DIVIDE          reduce using rule 105 (brace -> L_PAREN expr R_PAREN .)
    MOD             reduce using rule 105 (brace -> L_PAREN expr R_PAREN .)
    PLUS            reduce using rule 105 (brace -> L_PAREN expr R_PAREN .)
    MINUS           reduce using rule 105 (brace -> L_PAREN expr R_PAREN .)
    L_SHIFT         reduce using rule 105 (brace -> L_PAREN expr R_PAREN .)
    R_SHIFT         reduce using rule 105 (brace -> L_PAREN expr R_PAREN .)
    LE              reduce using rule 105 (brace -> L_PAREN expr R_PAREN .)
    LT              reduce using rule 105 (brace -> L_PAREN expr R_PAREN .)
    GE              reduce using rule 105 (brace -> L_PAREN expr R_PAREN .)
    GT              reduce using rule 105 (brace -> L_PAREN expr R_PAREN .)
    EQ              reduce using rule 105 (brace -> L_PAREN expr R_PAREN .)
    NE              reduce using rule 105 (brace -> L_PAREN expr R_PAREN .)
    BIT_AND         reduce using rule 105 (brace -> L_PAREN expr R_PAREN .)
    BIT_XOR         reduce using rule 105 (brace -> L_PAREN expr R_PAREN .)
    BIT_OR          reduce using rule 105 (brace -> L_PAREN expr R_PAREN .)
    AND             reduce using rule 105 (brace -> L_PAREN expr R_PAREN .)
    OR              reduce using rule 105 (brace -> L_PAREN expr R_PAREN .)
    SEMICOLON       reduce using rule 105 (brace -> L_PAREN expr R_PAREN .)
    ASSIGN          reduce using rule 105 (brace -> L_PAREN expr R_PAREN .)
    PLUS_ASSIGN     reduce using rule 105 (brace -> L_PAREN expr R_PAREN .)
    MINUS_ASSIGN    reduce using rule 105 (brace -> L_PAREN expr R_PAREN .)
    MUL_ASSIGN      reduce using rule 105 (brace -> L_PAREN expr R_PAREN .)
    DIV_ASSIGN      reduce using rule 105 (brace -> L_PAREN expr R_PAREN .)
    AND_ASSIGN      reduce using rule 105 (brace -> L_PAREN expr R_PAREN .)
    OR_ASSIGN       reduce using rule 105 (brace -> L_PAREN expr R_PAREN .)
    XOR_ASSIGN      reduce using rule 105 (brace -> L_PAREN expr R_PAREN .)
    MOD_ASSIGN      reduce using rule 105 (brace -> L_PAREN expr R_PAREN .)
    L_SHIFT_ASSIGN  reduce using rule 105 (brace -> L_PAREN expr R_PAREN .)
    R_SHIFT_ASSIGN  reduce using rule 105 (brace -> L_PAREN expr R_PAREN .)
    R_PAREN         reduce using rule 105 (brace -> L_PAREN expr R_PAREN .)
    COMMA           reduce using rule 105 (brace -> L_PAREN expr R_PAREN .)


state 119

    (24) declaration -> TYPE ID SEMICOLON .

    IF              reduce using rule 24 (declaration -> TYPE ID SEMICOLON .)
    WHILE           reduce using rule 24 (declaration -> TYPE ID SEMICOLON .)
    FOR             reduce using rule 24 (declaration -> TYPE ID SEMICOLON .)
    SEMICOLON       reduce using rule 24 (declaration -> TYPE ID SEMICOLON .)
    RETURN          reduce using rule 24 (declaration -> TYPE ID SEMICOLON .)
    L_FLOWBRACE     reduce using rule 24 (declaration -> TYPE ID SEMICOLON .)
    TYPE            reduce using rule 24 (declaration -> TYPE ID SEMICOLON .)
    ID              reduce using rule 24 (declaration -> TYPE ID SEMICOLON .)
    NOT             reduce using rule 24 (declaration -> TYPE ID SEMICOLON .)
    PLUS            reduce using rule 24 (declaration -> TYPE ID SEMICOLON .)
    MINUS           reduce using rule 24 (declaration -> TYPE ID SEMICOLON .)
    PLUS_PLUS       reduce using rule 24 (declaration -> TYPE ID SEMICOLON .)
    MINUS_MINUS     reduce using rule 24 (declaration -> TYPE ID SEMICOLON .)
    L_PAREN         reduce using rule 24 (declaration -> TYPE ID SEMICOLON .)
    INT_NUM         reduce using rule 24 (declaration -> TYPE ID SEMICOLON .)
    FLOAT_NUM       reduce using rule 24 (declaration -> TYPE ID SEMICOLON .)
    $end            reduce using rule 24 (declaration -> TYPE ID SEMICOLON .)
    R_FLOWBRACE     reduce using rule 24 (declaration -> TYPE ID SEMICOLON .)
    ELSE            reduce using rule 24 (declaration -> TYPE ID SEMICOLON .)


state 120

    (25) declaration -> TYPE ID ASSIGN . expr SEMICOLON
    (26) declaration -> TYPE ID ASSIGN . function_call
    (21) multi_declaration -> ID ASSIGN . expr COMMA
    (56) expr -> . expr assignment exprOR
    (57) expr -> . expr assignment ID L_PAREN call_params R_PAREN
    (58) expr -> . exprOR
    (37) function_call -> . ID L_PAREN call_params R_PAREN SEMICOLON
    (70) exprOR -> . exprOR OR exprAND
    (71) exprOR -> . exprAND
    (72) exprAND -> . exprAND AND exprBITOR
    (73) exprAND -> . exprBITOR
    (74) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (75) exprBITOR -> . exprBITXOR
    (76) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (77) exprBITXOR -> . exprBITAND
    (78) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (79) exprBITAND -> . exprEQ
    (80) exprEQ -> . exprEQ EQ exprRELOP
    (81) exprEQ -> . exprEQ NE exprRELOP
    (82) exprEQ -> . exprRELOP
    (83) exprRELOP -> . exprRELOP relop exprSHIFT
    (84) exprRELOP -> . exprSHIFT
    (89) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (90) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (91) exprSHIFT -> . exprOP
    (92) exprOP -> . exprOP PLUS term
    (93) exprOP -> . exprOP MINUS term
    (94) exprOP -> . term
    (95) term -> . term MULTIPLY factor
    (96) term -> . term DIVIDE factor
    (97) term -> . term MOD factor
    (98) term -> . factor
    (99) factor -> . NOT factor
    (100) factor -> . PLUS factor
    (101) factor -> . MINUS factor
    (102) factor -> . PLUS_PLUS factor
    (103) factor -> . MINUS_MINUS factor
    (104) factor -> . brace
    (105) brace -> . L_PAREN expr R_PAREN
    (106) brace -> . brace PLUS_PLUS
    (107) brace -> . brace MINUS_MINUS
    (108) brace -> . INT_NUM
    (109) brace -> . FLOAT_NUM
    (110) brace -> . ID

    ID              shift and go to state 17
    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    INT_NUM         shift and go to state 18
    FLOAT_NUM       shift and go to state 39

    expr                           shift and go to state 154
    function_call                  shift and go to state 155
    exprOR                         shift and go to state 20
    exprAND                        shift and go to state 23
    exprBITOR                      shift and go to state 24
    exprBITXOR                     shift and go to state 25
    exprBITAND                     shift and go to state 26
    exprEQ                         shift and go to state 27
    exprRELOP                      shift and go to state 28
    exprSHIFT                      shift and go to state 29
    exprOP                         shift and go to state 30
    term                           shift and go to state 32
    factor                         shift and go to state 34
    brace                          shift and go to state 38

state 121

    (53) function -> TYPE ID L_PAREN . dec_params R_PAREN function_2
    (50) dec_params -> . empty
    (51) dec_params -> . yes_dec_params end_dec_params
    (52) dec_params -> . end_dec_params
    (36) empty -> .
    (47) yes_dec_params -> . yes_dec_params TYPE ID COMMA
    (48) yes_dec_params -> . TYPE ID COMMA
    (49) end_dec_params -> . TYPE ID

    R_PAREN         reduce using rule 36 (empty -> .)
    TYPE            shift and go to state 156

    dec_params                     shift and go to state 157
    empty                          shift and go to state 158
    yes_dec_params                 shift and go to state 159
    end_dec_params                 shift and go to state 160

state 122

    (20) multi_declaration -> ID COMMA .

    ID              reduce using rule 20 (multi_declaration -> ID COMMA .)


state 123

    (27) declaration -> TYPE multi_declaration stop .

    IF              reduce using rule 27 (declaration -> TYPE multi_declaration stop .)
    WHILE           reduce using rule 27 (declaration -> TYPE multi_declaration stop .)
    FOR             reduce using rule 27 (declaration -> TYPE multi_declaration stop .)
    SEMICOLON       reduce using rule 27 (declaration -> TYPE multi_declaration stop .)
    RETURN          reduce using rule 27 (declaration -> TYPE multi_declaration stop .)
    L_FLOWBRACE     reduce using rule 27 (declaration -> TYPE multi_declaration stop .)
    TYPE            reduce using rule 27 (declaration -> TYPE multi_declaration stop .)
    ID              reduce using rule 27 (declaration -> TYPE multi_declaration stop .)
    NOT             reduce using rule 27 (declaration -> TYPE multi_declaration stop .)
    PLUS            reduce using rule 27 (declaration -> TYPE multi_declaration stop .)
    MINUS           reduce using rule 27 (declaration -> TYPE multi_declaration stop .)
    PLUS_PLUS       reduce using rule 27 (declaration -> TYPE multi_declaration stop .)
    MINUS_MINUS     reduce using rule 27 (declaration -> TYPE multi_declaration stop .)
    L_PAREN         reduce using rule 27 (declaration -> TYPE multi_declaration stop .)
    INT_NUM         reduce using rule 27 (declaration -> TYPE multi_declaration stop .)
    FLOAT_NUM       reduce using rule 27 (declaration -> TYPE multi_declaration stop .)
    $end            reduce using rule 27 (declaration -> TYPE multi_declaration stop .)
    R_FLOWBRACE     reduce using rule 27 (declaration -> TYPE multi_declaration stop .)
    ELSE            reduce using rule 27 (declaration -> TYPE multi_declaration stop .)


state 124

    (18) multi_declaration -> multi_declaration ID . COMMA
    (19) multi_declaration -> multi_declaration ID . ASSIGN expr COMMA
    (22) stop -> ID . SEMICOLON
    (23) stop -> ID . ASSIGN expr SEMICOLON

    COMMA           shift and go to state 161
    ASSIGN          shift and go to state 162
    SEMICOLON       shift and go to state 163


state 125

    (72) exprAND -> exprAND AND exprBITOR .
    (74) exprBITOR -> exprBITOR . BIT_OR exprBITXOR

    AND             reduce using rule 72 (exprAND -> exprAND AND exprBITOR .)
    OR              reduce using rule 72 (exprAND -> exprAND AND exprBITOR .)
    SEMICOLON       reduce using rule 72 (exprAND -> exprAND AND exprBITOR .)
    ASSIGN          reduce using rule 72 (exprAND -> exprAND AND exprBITOR .)
    PLUS_ASSIGN     reduce using rule 72 (exprAND -> exprAND AND exprBITOR .)
    MINUS_ASSIGN    reduce using rule 72 (exprAND -> exprAND AND exprBITOR .)
    MUL_ASSIGN      reduce using rule 72 (exprAND -> exprAND AND exprBITOR .)
    DIV_ASSIGN      reduce using rule 72 (exprAND -> exprAND AND exprBITOR .)
    AND_ASSIGN      reduce using rule 72 (exprAND -> exprAND AND exprBITOR .)
    OR_ASSIGN       reduce using rule 72 (exprAND -> exprAND AND exprBITOR .)
    XOR_ASSIGN      reduce using rule 72 (exprAND -> exprAND AND exprBITOR .)
    MOD_ASSIGN      reduce using rule 72 (exprAND -> exprAND AND exprBITOR .)
    L_SHIFT_ASSIGN  reduce using rule 72 (exprAND -> exprAND AND exprBITOR .)
    R_SHIFT_ASSIGN  reduce using rule 72 (exprAND -> exprAND AND exprBITOR .)
    R_PAREN         reduce using rule 72 (exprAND -> exprAND AND exprBITOR .)
    COMMA           reduce using rule 72 (exprAND -> exprAND AND exprBITOR .)
    BIT_OR          shift and go to state 69


state 126

    (74) exprBITOR -> exprBITOR BIT_OR exprBITXOR .
    (76) exprBITXOR -> exprBITXOR . BIT_XOR exprBITAND

    BIT_OR          reduce using rule 74 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    AND             reduce using rule 74 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    OR              reduce using rule 74 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    SEMICOLON       reduce using rule 74 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    ASSIGN          reduce using rule 74 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    PLUS_ASSIGN     reduce using rule 74 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    MINUS_ASSIGN    reduce using rule 74 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    MUL_ASSIGN      reduce using rule 74 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    DIV_ASSIGN      reduce using rule 74 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    AND_ASSIGN      reduce using rule 74 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    OR_ASSIGN       reduce using rule 74 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    XOR_ASSIGN      reduce using rule 74 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    MOD_ASSIGN      reduce using rule 74 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    L_SHIFT_ASSIGN  reduce using rule 74 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    R_SHIFT_ASSIGN  reduce using rule 74 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    R_PAREN         reduce using rule 74 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    COMMA           reduce using rule 74 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    BIT_XOR         shift and go to state 70


state 127

    (76) exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .
    (78) exprBITAND -> exprBITAND . BIT_AND exprEQ

    BIT_XOR         reduce using rule 76 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    BIT_OR          reduce using rule 76 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    AND             reduce using rule 76 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    OR              reduce using rule 76 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    SEMICOLON       reduce using rule 76 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    ASSIGN          reduce using rule 76 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    PLUS_ASSIGN     reduce using rule 76 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    MINUS_ASSIGN    reduce using rule 76 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    MUL_ASSIGN      reduce using rule 76 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    DIV_ASSIGN      reduce using rule 76 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    AND_ASSIGN      reduce using rule 76 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    OR_ASSIGN       reduce using rule 76 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    XOR_ASSIGN      reduce using rule 76 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    MOD_ASSIGN      reduce using rule 76 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    L_SHIFT_ASSIGN  reduce using rule 76 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    R_SHIFT_ASSIGN  reduce using rule 76 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    R_PAREN         reduce using rule 76 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    COMMA           reduce using rule 76 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    BIT_AND         shift and go to state 71


state 128

    (78) exprBITAND -> exprBITAND BIT_AND exprEQ .
    (80) exprEQ -> exprEQ . EQ exprRELOP
    (81) exprEQ -> exprEQ . NE exprRELOP

    BIT_AND         reduce using rule 78 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    BIT_XOR         reduce using rule 78 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    BIT_OR          reduce using rule 78 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    AND             reduce using rule 78 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    OR              reduce using rule 78 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    SEMICOLON       reduce using rule 78 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    ASSIGN          reduce using rule 78 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    PLUS_ASSIGN     reduce using rule 78 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    MINUS_ASSIGN    reduce using rule 78 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    MUL_ASSIGN      reduce using rule 78 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    DIV_ASSIGN      reduce using rule 78 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    AND_ASSIGN      reduce using rule 78 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    OR_ASSIGN       reduce using rule 78 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    XOR_ASSIGN      reduce using rule 78 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    MOD_ASSIGN      reduce using rule 78 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    L_SHIFT_ASSIGN  reduce using rule 78 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    R_SHIFT_ASSIGN  reduce using rule 78 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    R_PAREN         reduce using rule 78 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    COMMA           reduce using rule 78 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    EQ              shift and go to state 72
    NE              shift and go to state 73


state 129

    (80) exprEQ -> exprEQ EQ exprRELOP .
    (83) exprRELOP -> exprRELOP . relop exprSHIFT
    (85) relop -> . LE
    (86) relop -> . LT
    (87) relop -> . GE
    (88) relop -> . GT

    EQ              reduce using rule 80 (exprEQ -> exprEQ EQ exprRELOP .)
    NE              reduce using rule 80 (exprEQ -> exprEQ EQ exprRELOP .)
    BIT_AND         reduce using rule 80 (exprEQ -> exprEQ EQ exprRELOP .)
    BIT_XOR         reduce using rule 80 (exprEQ -> exprEQ EQ exprRELOP .)
    BIT_OR          reduce using rule 80 (exprEQ -> exprEQ EQ exprRELOP .)
    AND             reduce using rule 80 (exprEQ -> exprEQ EQ exprRELOP .)
    OR              reduce using rule 80 (exprEQ -> exprEQ EQ exprRELOP .)
    SEMICOLON       reduce using rule 80 (exprEQ -> exprEQ EQ exprRELOP .)
    ASSIGN          reduce using rule 80 (exprEQ -> exprEQ EQ exprRELOP .)
    PLUS_ASSIGN     reduce using rule 80 (exprEQ -> exprEQ EQ exprRELOP .)
    MINUS_ASSIGN    reduce using rule 80 (exprEQ -> exprEQ EQ exprRELOP .)
    MUL_ASSIGN      reduce using rule 80 (exprEQ -> exprEQ EQ exprRELOP .)
    DIV_ASSIGN      reduce using rule 80 (exprEQ -> exprEQ EQ exprRELOP .)
    AND_ASSIGN      reduce using rule 80 (exprEQ -> exprEQ EQ exprRELOP .)
    OR_ASSIGN       reduce using rule 80 (exprEQ -> exprEQ EQ exprRELOP .)
    XOR_ASSIGN      reduce using rule 80 (exprEQ -> exprEQ EQ exprRELOP .)
    MOD_ASSIGN      reduce using rule 80 (exprEQ -> exprEQ EQ exprRELOP .)
    L_SHIFT_ASSIGN  reduce using rule 80 (exprEQ -> exprEQ EQ exprRELOP .)
    R_SHIFT_ASSIGN  reduce using rule 80 (exprEQ -> exprEQ EQ exprRELOP .)
    R_PAREN         reduce using rule 80 (exprEQ -> exprEQ EQ exprRELOP .)
    COMMA           reduce using rule 80 (exprEQ -> exprEQ EQ exprRELOP .)
    LE              shift and go to state 75
    LT              shift and go to state 76
    GE              shift and go to state 77
    GT              shift and go to state 78

    relop                          shift and go to state 74

state 130

    (81) exprEQ -> exprEQ NE exprRELOP .
    (83) exprRELOP -> exprRELOP . relop exprSHIFT
    (85) relop -> . LE
    (86) relop -> . LT
    (87) relop -> . GE
    (88) relop -> . GT

    EQ              reduce using rule 81 (exprEQ -> exprEQ NE exprRELOP .)
    NE              reduce using rule 81 (exprEQ -> exprEQ NE exprRELOP .)
    BIT_AND         reduce using rule 81 (exprEQ -> exprEQ NE exprRELOP .)
    BIT_XOR         reduce using rule 81 (exprEQ -> exprEQ NE exprRELOP .)
    BIT_OR          reduce using rule 81 (exprEQ -> exprEQ NE exprRELOP .)
    AND             reduce using rule 81 (exprEQ -> exprEQ NE exprRELOP .)
    OR              reduce using rule 81 (exprEQ -> exprEQ NE exprRELOP .)
    SEMICOLON       reduce using rule 81 (exprEQ -> exprEQ NE exprRELOP .)
    ASSIGN          reduce using rule 81 (exprEQ -> exprEQ NE exprRELOP .)
    PLUS_ASSIGN     reduce using rule 81 (exprEQ -> exprEQ NE exprRELOP .)
    MINUS_ASSIGN    reduce using rule 81 (exprEQ -> exprEQ NE exprRELOP .)
    MUL_ASSIGN      reduce using rule 81 (exprEQ -> exprEQ NE exprRELOP .)
    DIV_ASSIGN      reduce using rule 81 (exprEQ -> exprEQ NE exprRELOP .)
    AND_ASSIGN      reduce using rule 81 (exprEQ -> exprEQ NE exprRELOP .)
    OR_ASSIGN       reduce using rule 81 (exprEQ -> exprEQ NE exprRELOP .)
    XOR_ASSIGN      reduce using rule 81 (exprEQ -> exprEQ NE exprRELOP .)
    MOD_ASSIGN      reduce using rule 81 (exprEQ -> exprEQ NE exprRELOP .)
    L_SHIFT_ASSIGN  reduce using rule 81 (exprEQ -> exprEQ NE exprRELOP .)
    R_SHIFT_ASSIGN  reduce using rule 81 (exprEQ -> exprEQ NE exprRELOP .)
    R_PAREN         reduce using rule 81 (exprEQ -> exprEQ NE exprRELOP .)
    COMMA           reduce using rule 81 (exprEQ -> exprEQ NE exprRELOP .)
    LE              shift and go to state 75
    LT              shift and go to state 76
    GE              shift and go to state 77
    GT              shift and go to state 78

    relop                          shift and go to state 74

state 131

    (83) exprRELOP -> exprRELOP relop exprSHIFT .
    (89) exprSHIFT -> exprSHIFT . L_SHIFT exprOP
    (90) exprSHIFT -> exprSHIFT . R_SHIFT exprOP

    LE              reduce using rule 83 (exprRELOP -> exprRELOP relop exprSHIFT .)
    LT              reduce using rule 83 (exprRELOP -> exprRELOP relop exprSHIFT .)
    GE              reduce using rule 83 (exprRELOP -> exprRELOP relop exprSHIFT .)
    GT              reduce using rule 83 (exprRELOP -> exprRELOP relop exprSHIFT .)
    EQ              reduce using rule 83 (exprRELOP -> exprRELOP relop exprSHIFT .)
    NE              reduce using rule 83 (exprRELOP -> exprRELOP relop exprSHIFT .)
    BIT_AND         reduce using rule 83 (exprRELOP -> exprRELOP relop exprSHIFT .)
    BIT_XOR         reduce using rule 83 (exprRELOP -> exprRELOP relop exprSHIFT .)
    BIT_OR          reduce using rule 83 (exprRELOP -> exprRELOP relop exprSHIFT .)
    AND             reduce using rule 83 (exprRELOP -> exprRELOP relop exprSHIFT .)
    OR              reduce using rule 83 (exprRELOP -> exprRELOP relop exprSHIFT .)
    SEMICOLON       reduce using rule 83 (exprRELOP -> exprRELOP relop exprSHIFT .)
    ASSIGN          reduce using rule 83 (exprRELOP -> exprRELOP relop exprSHIFT .)
    PLUS_ASSIGN     reduce using rule 83 (exprRELOP -> exprRELOP relop exprSHIFT .)
    MINUS_ASSIGN    reduce using rule 83 (exprRELOP -> exprRELOP relop exprSHIFT .)
    MUL_ASSIGN      reduce using rule 83 (exprRELOP -> exprRELOP relop exprSHIFT .)
    DIV_ASSIGN      reduce using rule 83 (exprRELOP -> exprRELOP relop exprSHIFT .)
    AND_ASSIGN      reduce using rule 83 (exprRELOP -> exprRELOP relop exprSHIFT .)
    OR_ASSIGN       reduce using rule 83 (exprRELOP -> exprRELOP relop exprSHIFT .)
    XOR_ASSIGN      reduce using rule 83 (exprRELOP -> exprRELOP relop exprSHIFT .)
    MOD_ASSIGN      reduce using rule 83 (exprRELOP -> exprRELOP relop exprSHIFT .)
    L_SHIFT_ASSIGN  reduce using rule 83 (exprRELOP -> exprRELOP relop exprSHIFT .)
    R_SHIFT_ASSIGN  reduce using rule 83 (exprRELOP -> exprRELOP relop exprSHIFT .)
    R_PAREN         reduce using rule 83 (exprRELOP -> exprRELOP relop exprSHIFT .)
    COMMA           reduce using rule 83 (exprRELOP -> exprRELOP relop exprSHIFT .)
    L_SHIFT         shift and go to state 79
    R_SHIFT         shift and go to state 80


state 132

    (89) exprSHIFT -> exprSHIFT L_SHIFT exprOP .
    (92) exprOP -> exprOP . PLUS term
    (93) exprOP -> exprOP . MINUS term

    L_SHIFT         reduce using rule 89 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    R_SHIFT         reduce using rule 89 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    LE              reduce using rule 89 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    LT              reduce using rule 89 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    GE              reduce using rule 89 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    GT              reduce using rule 89 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    EQ              reduce using rule 89 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    NE              reduce using rule 89 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    BIT_AND         reduce using rule 89 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    BIT_XOR         reduce using rule 89 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    BIT_OR          reduce using rule 89 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    AND             reduce using rule 89 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    OR              reduce using rule 89 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    SEMICOLON       reduce using rule 89 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    ASSIGN          reduce using rule 89 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    PLUS_ASSIGN     reduce using rule 89 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    MINUS_ASSIGN    reduce using rule 89 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    MUL_ASSIGN      reduce using rule 89 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    DIV_ASSIGN      reduce using rule 89 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    AND_ASSIGN      reduce using rule 89 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    OR_ASSIGN       reduce using rule 89 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    XOR_ASSIGN      reduce using rule 89 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    MOD_ASSIGN      reduce using rule 89 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    L_SHIFT_ASSIGN  reduce using rule 89 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    R_SHIFT_ASSIGN  reduce using rule 89 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    R_PAREN         reduce using rule 89 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    COMMA           reduce using rule 89 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    PLUS            shift and go to state 81
    MINUS           shift and go to state 82


state 133

    (90) exprSHIFT -> exprSHIFT R_SHIFT exprOP .
    (92) exprOP -> exprOP . PLUS term
    (93) exprOP -> exprOP . MINUS term

    L_SHIFT         reduce using rule 90 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    R_SHIFT         reduce using rule 90 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    LE              reduce using rule 90 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    LT              reduce using rule 90 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    GE              reduce using rule 90 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    GT              reduce using rule 90 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    EQ              reduce using rule 90 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    NE              reduce using rule 90 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    BIT_AND         reduce using rule 90 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    BIT_XOR         reduce using rule 90 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    BIT_OR          reduce using rule 90 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    AND             reduce using rule 90 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    OR              reduce using rule 90 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    SEMICOLON       reduce using rule 90 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    ASSIGN          reduce using rule 90 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    PLUS_ASSIGN     reduce using rule 90 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    MINUS_ASSIGN    reduce using rule 90 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    MUL_ASSIGN      reduce using rule 90 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    DIV_ASSIGN      reduce using rule 90 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    AND_ASSIGN      reduce using rule 90 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    OR_ASSIGN       reduce using rule 90 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    XOR_ASSIGN      reduce using rule 90 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    MOD_ASSIGN      reduce using rule 90 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    L_SHIFT_ASSIGN  reduce using rule 90 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    R_SHIFT_ASSIGN  reduce using rule 90 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    R_PAREN         reduce using rule 90 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    COMMA           reduce using rule 90 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    PLUS            shift and go to state 81
    MINUS           shift and go to state 82


state 134

    (92) exprOP -> exprOP PLUS term .
    (95) term -> term . MULTIPLY factor
    (96) term -> term . DIVIDE factor
    (97) term -> term . MOD factor

    PLUS            reduce using rule 92 (exprOP -> exprOP PLUS term .)
    MINUS           reduce using rule 92 (exprOP -> exprOP PLUS term .)
    L_SHIFT         reduce using rule 92 (exprOP -> exprOP PLUS term .)
    R_SHIFT         reduce using rule 92 (exprOP -> exprOP PLUS term .)
    LE              reduce using rule 92 (exprOP -> exprOP PLUS term .)
    LT              reduce using rule 92 (exprOP -> exprOP PLUS term .)
    GE              reduce using rule 92 (exprOP -> exprOP PLUS term .)
    GT              reduce using rule 92 (exprOP -> exprOP PLUS term .)
    EQ              reduce using rule 92 (exprOP -> exprOP PLUS term .)
    NE              reduce using rule 92 (exprOP -> exprOP PLUS term .)
    BIT_AND         reduce using rule 92 (exprOP -> exprOP PLUS term .)
    BIT_XOR         reduce using rule 92 (exprOP -> exprOP PLUS term .)
    BIT_OR          reduce using rule 92 (exprOP -> exprOP PLUS term .)
    AND             reduce using rule 92 (exprOP -> exprOP PLUS term .)
    OR              reduce using rule 92 (exprOP -> exprOP PLUS term .)
    SEMICOLON       reduce using rule 92 (exprOP -> exprOP PLUS term .)
    ASSIGN          reduce using rule 92 (exprOP -> exprOP PLUS term .)
    PLUS_ASSIGN     reduce using rule 92 (exprOP -> exprOP PLUS term .)
    MINUS_ASSIGN    reduce using rule 92 (exprOP -> exprOP PLUS term .)
    MUL_ASSIGN      reduce using rule 92 (exprOP -> exprOP PLUS term .)
    DIV_ASSIGN      reduce using rule 92 (exprOP -> exprOP PLUS term .)
    AND_ASSIGN      reduce using rule 92 (exprOP -> exprOP PLUS term .)
    OR_ASSIGN       reduce using rule 92 (exprOP -> exprOP PLUS term .)
    XOR_ASSIGN      reduce using rule 92 (exprOP -> exprOP PLUS term .)
    MOD_ASSIGN      reduce using rule 92 (exprOP -> exprOP PLUS term .)
    L_SHIFT_ASSIGN  reduce using rule 92 (exprOP -> exprOP PLUS term .)
    R_SHIFT_ASSIGN  reduce using rule 92 (exprOP -> exprOP PLUS term .)
    R_PAREN         reduce using rule 92 (exprOP -> exprOP PLUS term .)
    COMMA           reduce using rule 92 (exprOP -> exprOP PLUS term .)
    MULTIPLY        shift and go to state 84
    DIVIDE          shift and go to state 85
    MOD             shift and go to state 86


state 135

    (93) exprOP -> exprOP MINUS term .
    (95) term -> term . MULTIPLY factor
    (96) term -> term . DIVIDE factor
    (97) term -> term . MOD factor

    PLUS            reduce using rule 93 (exprOP -> exprOP MINUS term .)
    MINUS           reduce using rule 93 (exprOP -> exprOP MINUS term .)
    L_SHIFT         reduce using rule 93 (exprOP -> exprOP MINUS term .)
    R_SHIFT         reduce using rule 93 (exprOP -> exprOP MINUS term .)
    LE              reduce using rule 93 (exprOP -> exprOP MINUS term .)
    LT              reduce using rule 93 (exprOP -> exprOP MINUS term .)
    GE              reduce using rule 93 (exprOP -> exprOP MINUS term .)
    GT              reduce using rule 93 (exprOP -> exprOP MINUS term .)
    EQ              reduce using rule 93 (exprOP -> exprOP MINUS term .)
    NE              reduce using rule 93 (exprOP -> exprOP MINUS term .)
    BIT_AND         reduce using rule 93 (exprOP -> exprOP MINUS term .)
    BIT_XOR         reduce using rule 93 (exprOP -> exprOP MINUS term .)
    BIT_OR          reduce using rule 93 (exprOP -> exprOP MINUS term .)
    AND             reduce using rule 93 (exprOP -> exprOP MINUS term .)
    OR              reduce using rule 93 (exprOP -> exprOP MINUS term .)
    SEMICOLON       reduce using rule 93 (exprOP -> exprOP MINUS term .)
    ASSIGN          reduce using rule 93 (exprOP -> exprOP MINUS term .)
    PLUS_ASSIGN     reduce using rule 93 (exprOP -> exprOP MINUS term .)
    MINUS_ASSIGN    reduce using rule 93 (exprOP -> exprOP MINUS term .)
    MUL_ASSIGN      reduce using rule 93 (exprOP -> exprOP MINUS term .)
    DIV_ASSIGN      reduce using rule 93 (exprOP -> exprOP MINUS term .)
    AND_ASSIGN      reduce using rule 93 (exprOP -> exprOP MINUS term .)
    OR_ASSIGN       reduce using rule 93 (exprOP -> exprOP MINUS term .)
    XOR_ASSIGN      reduce using rule 93 (exprOP -> exprOP MINUS term .)
    MOD_ASSIGN      reduce using rule 93 (exprOP -> exprOP MINUS term .)
    L_SHIFT_ASSIGN  reduce using rule 93 (exprOP -> exprOP MINUS term .)
    R_SHIFT_ASSIGN  reduce using rule 93 (exprOP -> exprOP MINUS term .)
    R_PAREN         reduce using rule 93 (exprOP -> exprOP MINUS term .)
    COMMA           reduce using rule 93 (exprOP -> exprOP MINUS term .)
    MULTIPLY        shift and go to state 84
    DIVIDE          shift and go to state 85
    MOD             shift and go to state 86


state 136

    (95) term -> term MULTIPLY factor .

    MULTIPLY        reduce using rule 95 (term -> term MULTIPLY factor .)
    DIVIDE          reduce using rule 95 (term -> term MULTIPLY factor .)
    MOD             reduce using rule 95 (term -> term MULTIPLY factor .)
    PLUS            reduce using rule 95 (term -> term MULTIPLY factor .)
    MINUS           reduce using rule 95 (term -> term MULTIPLY factor .)
    L_SHIFT         reduce using rule 95 (term -> term MULTIPLY factor .)
    R_SHIFT         reduce using rule 95 (term -> term MULTIPLY factor .)
    LE              reduce using rule 95 (term -> term MULTIPLY factor .)
    LT              reduce using rule 95 (term -> term MULTIPLY factor .)
    GE              reduce using rule 95 (term -> term MULTIPLY factor .)
    GT              reduce using rule 95 (term -> term MULTIPLY factor .)
    EQ              reduce using rule 95 (term -> term MULTIPLY factor .)
    NE              reduce using rule 95 (term -> term MULTIPLY factor .)
    BIT_AND         reduce using rule 95 (term -> term MULTIPLY factor .)
    BIT_XOR         reduce using rule 95 (term -> term MULTIPLY factor .)
    BIT_OR          reduce using rule 95 (term -> term MULTIPLY factor .)
    AND             reduce using rule 95 (term -> term MULTIPLY factor .)
    OR              reduce using rule 95 (term -> term MULTIPLY factor .)
    SEMICOLON       reduce using rule 95 (term -> term MULTIPLY factor .)
    ASSIGN          reduce using rule 95 (term -> term MULTIPLY factor .)
    PLUS_ASSIGN     reduce using rule 95 (term -> term MULTIPLY factor .)
    MINUS_ASSIGN    reduce using rule 95 (term -> term MULTIPLY factor .)
    MUL_ASSIGN      reduce using rule 95 (term -> term MULTIPLY factor .)
    DIV_ASSIGN      reduce using rule 95 (term -> term MULTIPLY factor .)
    AND_ASSIGN      reduce using rule 95 (term -> term MULTIPLY factor .)
    OR_ASSIGN       reduce using rule 95 (term -> term MULTIPLY factor .)
    XOR_ASSIGN      reduce using rule 95 (term -> term MULTIPLY factor .)
    MOD_ASSIGN      reduce using rule 95 (term -> term MULTIPLY factor .)
    L_SHIFT_ASSIGN  reduce using rule 95 (term -> term MULTIPLY factor .)
    R_SHIFT_ASSIGN  reduce using rule 95 (term -> term MULTIPLY factor .)
    R_PAREN         reduce using rule 95 (term -> term MULTIPLY factor .)
    COMMA           reduce using rule 95 (term -> term MULTIPLY factor .)


state 137

    (96) term -> term DIVIDE factor .

    MULTIPLY        reduce using rule 96 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 96 (term -> term DIVIDE factor .)
    MOD             reduce using rule 96 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 96 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 96 (term -> term DIVIDE factor .)
    L_SHIFT         reduce using rule 96 (term -> term DIVIDE factor .)
    R_SHIFT         reduce using rule 96 (term -> term DIVIDE factor .)
    LE              reduce using rule 96 (term -> term DIVIDE factor .)
    LT              reduce using rule 96 (term -> term DIVIDE factor .)
    GE              reduce using rule 96 (term -> term DIVIDE factor .)
    GT              reduce using rule 96 (term -> term DIVIDE factor .)
    EQ              reduce using rule 96 (term -> term DIVIDE factor .)
    NE              reduce using rule 96 (term -> term DIVIDE factor .)
    BIT_AND         reduce using rule 96 (term -> term DIVIDE factor .)
    BIT_XOR         reduce using rule 96 (term -> term DIVIDE factor .)
    BIT_OR          reduce using rule 96 (term -> term DIVIDE factor .)
    AND             reduce using rule 96 (term -> term DIVIDE factor .)
    OR              reduce using rule 96 (term -> term DIVIDE factor .)
    SEMICOLON       reduce using rule 96 (term -> term DIVIDE factor .)
    ASSIGN          reduce using rule 96 (term -> term DIVIDE factor .)
    PLUS_ASSIGN     reduce using rule 96 (term -> term DIVIDE factor .)
    MINUS_ASSIGN    reduce using rule 96 (term -> term DIVIDE factor .)
    MUL_ASSIGN      reduce using rule 96 (term -> term DIVIDE factor .)
    DIV_ASSIGN      reduce using rule 96 (term -> term DIVIDE factor .)
    AND_ASSIGN      reduce using rule 96 (term -> term DIVIDE factor .)
    OR_ASSIGN       reduce using rule 96 (term -> term DIVIDE factor .)
    XOR_ASSIGN      reduce using rule 96 (term -> term DIVIDE factor .)
    MOD_ASSIGN      reduce using rule 96 (term -> term DIVIDE factor .)
    L_SHIFT_ASSIGN  reduce using rule 96 (term -> term DIVIDE factor .)
    R_SHIFT_ASSIGN  reduce using rule 96 (term -> term DIVIDE factor .)
    R_PAREN         reduce using rule 96 (term -> term DIVIDE factor .)
    COMMA           reduce using rule 96 (term -> term DIVIDE factor .)


state 138

    (97) term -> term MOD factor .

    MULTIPLY        reduce using rule 97 (term -> term MOD factor .)
    DIVIDE          reduce using rule 97 (term -> term MOD factor .)
    MOD             reduce using rule 97 (term -> term MOD factor .)
    PLUS            reduce using rule 97 (term -> term MOD factor .)
    MINUS           reduce using rule 97 (term -> term MOD factor .)
    L_SHIFT         reduce using rule 97 (term -> term MOD factor .)
    R_SHIFT         reduce using rule 97 (term -> term MOD factor .)
    LE              reduce using rule 97 (term -> term MOD factor .)
    LT              reduce using rule 97 (term -> term MOD factor .)
    GE              reduce using rule 97 (term -> term MOD factor .)
    GT              reduce using rule 97 (term -> term MOD factor .)
    EQ              reduce using rule 97 (term -> term MOD factor .)
    NE              reduce using rule 97 (term -> term MOD factor .)
    BIT_AND         reduce using rule 97 (term -> term MOD factor .)
    BIT_XOR         reduce using rule 97 (term -> term MOD factor .)
    BIT_OR          reduce using rule 97 (term -> term MOD factor .)
    AND             reduce using rule 97 (term -> term MOD factor .)
    OR              reduce using rule 97 (term -> term MOD factor .)
    SEMICOLON       reduce using rule 97 (term -> term MOD factor .)
    ASSIGN          reduce using rule 97 (term -> term MOD factor .)
    PLUS_ASSIGN     reduce using rule 97 (term -> term MOD factor .)
    MINUS_ASSIGN    reduce using rule 97 (term -> term MOD factor .)
    MUL_ASSIGN      reduce using rule 97 (term -> term MOD factor .)
    DIV_ASSIGN      reduce using rule 97 (term -> term MOD factor .)
    AND_ASSIGN      reduce using rule 97 (term -> term MOD factor .)
    OR_ASSIGN       reduce using rule 97 (term -> term MOD factor .)
    XOR_ASSIGN      reduce using rule 97 (term -> term MOD factor .)
    MOD_ASSIGN      reduce using rule 97 (term -> term MOD factor .)
    L_SHIFT_ASSIGN  reduce using rule 97 (term -> term MOD factor .)
    R_SHIFT_ASSIGN  reduce using rule 97 (term -> term MOD factor .)
    R_PAREN         reduce using rule 97 (term -> term MOD factor .)
    COMMA           reduce using rule 97 (term -> term MOD factor .)


state 139

    (12) closed -> IF condition . closed ELSE closed
    (6) open -> IF condition . statement
    (7) open -> IF condition . closed ELSE open
    (10) closed -> . simple
    (11) closed -> . block
    (12) closed -> . IF condition closed ELSE closed
    (13) closed -> . WHILE condition closed
    (14) closed -> . FOR for_condition closed
    (4) statement -> . open
    (5) statement -> . closed
    (29) simple -> . expr SEMICOLON
    (30) simple -> . declaration
    (31) simple -> . SEMICOLON
    (32) simple -> . function
    (33) simple -> . function_call
    (34) simple -> . RETURN ID SEMICOLON
    (35) simple -> . RETURN INT_NUM SEMICOLON
    (28) block -> . L_FLOWBRACE multiple_statements R_FLOWBRACE
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) open -> . FOR for_condition open
    (56) expr -> . expr assignment exprOR
    (57) expr -> . expr assignment ID L_PAREN call_params R_PAREN
    (58) expr -> . exprOR
    (24) declaration -> . TYPE ID SEMICOLON
    (25) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (26) declaration -> . TYPE ID ASSIGN function_call
    (27) declaration -> . TYPE multi_declaration stop
    (53) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (37) function_call -> . ID L_PAREN call_params R_PAREN SEMICOLON
    (70) exprOR -> . exprOR OR exprAND
    (71) exprOR -> . exprAND
    (72) exprAND -> . exprAND AND exprBITOR
    (73) exprAND -> . exprBITOR
    (74) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (75) exprBITOR -> . exprBITXOR
    (76) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (77) exprBITXOR -> . exprBITAND
    (78) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (79) exprBITAND -> . exprEQ
    (80) exprEQ -> . exprEQ EQ exprRELOP
    (81) exprEQ -> . exprEQ NE exprRELOP
    (82) exprEQ -> . exprRELOP
    (83) exprRELOP -> . exprRELOP relop exprSHIFT
    (84) exprRELOP -> . exprSHIFT
    (89) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (90) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (91) exprSHIFT -> . exprOP
    (92) exprOP -> . exprOP PLUS term
    (93) exprOP -> . exprOP MINUS term
    (94) exprOP -> . term
    (95) term -> . term MULTIPLY factor
    (96) term -> . term DIVIDE factor
    (97) term -> . term MOD factor
    (98) term -> . factor
    (99) factor -> . NOT factor
    (100) factor -> . PLUS factor
    (101) factor -> . MINUS factor
    (102) factor -> . PLUS_PLUS factor
    (103) factor -> . MINUS_MINUS factor
    (104) factor -> . brace
    (105) brace -> . L_PAREN expr R_PAREN
    (106) brace -> . brace PLUS_PLUS
    (107) brace -> . brace MINUS_MINUS
    (108) brace -> . INT_NUM
    (109) brace -> . FLOAT_NUM
    (110) brace -> . ID

    IF              shift and go to state 93
    WHILE           shift and go to state 96
    FOR             shift and go to state 97
    SEMICOLON       shift and go to state 12
    RETURN          shift and go to state 16
    L_FLOWBRACE     shift and go to state 19
    TYPE            shift and go to state 22
    ID              shift and go to state 17
    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    INT_NUM         shift and go to state 18
    FLOAT_NUM       shift and go to state 39

    closed                         shift and go to state 164
    statement                      shift and go to state 94
    open                           shift and go to state 4
    simple                         shift and go to state 9
    block                          shift and go to state 10
    expr                           shift and go to state 11
    declaration                    shift and go to state 13
    function                       shift and go to state 14
    function_call                  shift and go to state 15
    exprOR                         shift and go to state 20
    exprAND                        shift and go to state 23
    exprBITOR                      shift and go to state 24
    exprBITXOR                     shift and go to state 25
    exprBITAND                     shift and go to state 26
    exprEQ                         shift and go to state 27
    exprRELOP                      shift and go to state 28
    exprSHIFT                      shift and go to state 29
    exprOP                         shift and go to state 30
    term                           shift and go to state 32
    factor                         shift and go to state 34
    brace                          shift and go to state 38

state 140

    (7) open -> IF condition closed ELSE . open
    (12) closed -> IF condition closed ELSE . closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) open -> . FOR for_condition open
    (10) closed -> . simple
    (11) closed -> . block
    (12) closed -> . IF condition closed ELSE closed
    (13) closed -> . WHILE condition closed
    (14) closed -> . FOR for_condition closed
    (29) simple -> . expr SEMICOLON
    (30) simple -> . declaration
    (31) simple -> . SEMICOLON
    (32) simple -> . function
    (33) simple -> . function_call
    (34) simple -> . RETURN ID SEMICOLON
    (35) simple -> . RETURN INT_NUM SEMICOLON
    (28) block -> . L_FLOWBRACE multiple_statements R_FLOWBRACE
    (56) expr -> . expr assignment exprOR
    (57) expr -> . expr assignment ID L_PAREN call_params R_PAREN
    (58) expr -> . exprOR
    (24) declaration -> . TYPE ID SEMICOLON
    (25) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (26) declaration -> . TYPE ID ASSIGN function_call
    (27) declaration -> . TYPE multi_declaration stop
    (53) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (37) function_call -> . ID L_PAREN call_params R_PAREN SEMICOLON
    (70) exprOR -> . exprOR OR exprAND
    (71) exprOR -> . exprAND
    (72) exprAND -> . exprAND AND exprBITOR
    (73) exprAND -> . exprBITOR
    (74) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (75) exprBITOR -> . exprBITXOR
    (76) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (77) exprBITXOR -> . exprBITAND
    (78) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (79) exprBITAND -> . exprEQ
    (80) exprEQ -> . exprEQ EQ exprRELOP
    (81) exprEQ -> . exprEQ NE exprRELOP
    (82) exprEQ -> . exprRELOP
    (83) exprRELOP -> . exprRELOP relop exprSHIFT
    (84) exprRELOP -> . exprSHIFT
    (89) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (90) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (91) exprSHIFT -> . exprOP
    (92) exprOP -> . exprOP PLUS term
    (93) exprOP -> . exprOP MINUS term
    (94) exprOP -> . term
    (95) term -> . term MULTIPLY factor
    (96) term -> . term DIVIDE factor
    (97) term -> . term MOD factor
    (98) term -> . factor
    (99) factor -> . NOT factor
    (100) factor -> . PLUS factor
    (101) factor -> . MINUS factor
    (102) factor -> . PLUS_PLUS factor
    (103) factor -> . MINUS_MINUS factor
    (104) factor -> . brace
    (105) brace -> . L_PAREN expr R_PAREN
    (106) brace -> . brace PLUS_PLUS
    (107) brace -> . brace MINUS_MINUS
    (108) brace -> . INT_NUM
    (109) brace -> . FLOAT_NUM
    (110) brace -> . ID

    IF              shift and go to state 6
    WHILE           shift and go to state 7
    FOR             shift and go to state 8
    SEMICOLON       shift and go to state 12
    RETURN          shift and go to state 16
    L_FLOWBRACE     shift and go to state 19
    TYPE            shift and go to state 22
    ID              shift and go to state 17
    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    INT_NUM         shift and go to state 18
    FLOAT_NUM       shift and go to state 39

    closed                         shift and go to state 165
    open                           shift and go to state 166
    simple                         shift and go to state 9
    block                          shift and go to state 10
    expr                           shift and go to state 11
    declaration                    shift and go to state 13
    function                       shift and go to state 14
    function_call                  shift and go to state 15
    exprOR                         shift and go to state 20
    exprAND                        shift and go to state 23
    exprBITOR                      shift and go to state 24
    exprBITXOR                     shift and go to state 25
    exprBITAND                     shift and go to state 26
    exprEQ                         shift and go to state 27
    exprRELOP                      shift and go to state 28
    exprSHIFT                      shift and go to state 29
    exprOP                         shift and go to state 30
    term                           shift and go to state 32
    factor                         shift and go to state 34
    brace                          shift and go to state 38

state 141

    (13) closed -> WHILE condition . closed
    (8) open -> WHILE condition . open
    (10) closed -> . simple
    (11) closed -> . block
    (12) closed -> . IF condition closed ELSE closed
    (13) closed -> . WHILE condition closed
    (14) closed -> . FOR for_condition closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) open -> . FOR for_condition open
    (29) simple -> . expr SEMICOLON
    (30) simple -> . declaration
    (31) simple -> . SEMICOLON
    (32) simple -> . function
    (33) simple -> . function_call
    (34) simple -> . RETURN ID SEMICOLON
    (35) simple -> . RETURN INT_NUM SEMICOLON
    (28) block -> . L_FLOWBRACE multiple_statements R_FLOWBRACE
    (56) expr -> . expr assignment exprOR
    (57) expr -> . expr assignment ID L_PAREN call_params R_PAREN
    (58) expr -> . exprOR
    (24) declaration -> . TYPE ID SEMICOLON
    (25) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (26) declaration -> . TYPE ID ASSIGN function_call
    (27) declaration -> . TYPE multi_declaration stop
    (53) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (37) function_call -> . ID L_PAREN call_params R_PAREN SEMICOLON
    (70) exprOR -> . exprOR OR exprAND
    (71) exprOR -> . exprAND
    (72) exprAND -> . exprAND AND exprBITOR
    (73) exprAND -> . exprBITOR
    (74) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (75) exprBITOR -> . exprBITXOR
    (76) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (77) exprBITXOR -> . exprBITAND
    (78) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (79) exprBITAND -> . exprEQ
    (80) exprEQ -> . exprEQ EQ exprRELOP
    (81) exprEQ -> . exprEQ NE exprRELOP
    (82) exprEQ -> . exprRELOP
    (83) exprRELOP -> . exprRELOP relop exprSHIFT
    (84) exprRELOP -> . exprSHIFT
    (89) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (90) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (91) exprSHIFT -> . exprOP
    (92) exprOP -> . exprOP PLUS term
    (93) exprOP -> . exprOP MINUS term
    (94) exprOP -> . term
    (95) term -> . term MULTIPLY factor
    (96) term -> . term DIVIDE factor
    (97) term -> . term MOD factor
    (98) term -> . factor
    (99) factor -> . NOT factor
    (100) factor -> . PLUS factor
    (101) factor -> . MINUS factor
    (102) factor -> . PLUS_PLUS factor
    (103) factor -> . MINUS_MINUS factor
    (104) factor -> . brace
    (105) brace -> . L_PAREN expr R_PAREN
    (106) brace -> . brace PLUS_PLUS
    (107) brace -> . brace MINUS_MINUS
    (108) brace -> . INT_NUM
    (109) brace -> . FLOAT_NUM
    (110) brace -> . ID

    IF              shift and go to state 93
    WHILE           shift and go to state 96
    FOR             shift and go to state 97
    SEMICOLON       shift and go to state 12
    RETURN          shift and go to state 16
    L_FLOWBRACE     shift and go to state 19
    TYPE            shift and go to state 22
    ID              shift and go to state 17
    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    INT_NUM         shift and go to state 18
    FLOAT_NUM       shift and go to state 39

    closed                         shift and go to state 100
    open                           shift and go to state 99
    simple                         shift and go to state 9
    block                          shift and go to state 10
    expr                           shift and go to state 11
    declaration                    shift and go to state 13
    function                       shift and go to state 14
    function_call                  shift and go to state 15
    exprOR                         shift and go to state 20
    exprAND                        shift and go to state 23
    exprBITOR                      shift and go to state 24
    exprBITXOR                     shift and go to state 25
    exprBITAND                     shift and go to state 26
    exprEQ                         shift and go to state 27
    exprRELOP                      shift and go to state 28
    exprSHIFT                      shift and go to state 29
    exprOP                         shift and go to state 30
    term                           shift and go to state 32
    factor                         shift and go to state 34
    brace                          shift and go to state 38

state 142

    (14) closed -> FOR for_condition . closed
    (9) open -> FOR for_condition . open
    (10) closed -> . simple
    (11) closed -> . block
    (12) closed -> . IF condition closed ELSE closed
    (13) closed -> . WHILE condition closed
    (14) closed -> . FOR for_condition closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) open -> . FOR for_condition open
    (29) simple -> . expr SEMICOLON
    (30) simple -> . declaration
    (31) simple -> . SEMICOLON
    (32) simple -> . function
    (33) simple -> . function_call
    (34) simple -> . RETURN ID SEMICOLON
    (35) simple -> . RETURN INT_NUM SEMICOLON
    (28) block -> . L_FLOWBRACE multiple_statements R_FLOWBRACE
    (56) expr -> . expr assignment exprOR
    (57) expr -> . expr assignment ID L_PAREN call_params R_PAREN
    (58) expr -> . exprOR
    (24) declaration -> . TYPE ID SEMICOLON
    (25) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (26) declaration -> . TYPE ID ASSIGN function_call
    (27) declaration -> . TYPE multi_declaration stop
    (53) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (37) function_call -> . ID L_PAREN call_params R_PAREN SEMICOLON
    (70) exprOR -> . exprOR OR exprAND
    (71) exprOR -> . exprAND
    (72) exprAND -> . exprAND AND exprBITOR
    (73) exprAND -> . exprBITOR
    (74) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (75) exprBITOR -> . exprBITXOR
    (76) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (77) exprBITXOR -> . exprBITAND
    (78) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (79) exprBITAND -> . exprEQ
    (80) exprEQ -> . exprEQ EQ exprRELOP
    (81) exprEQ -> . exprEQ NE exprRELOP
    (82) exprEQ -> . exprRELOP
    (83) exprRELOP -> . exprRELOP relop exprSHIFT
    (84) exprRELOP -> . exprSHIFT
    (89) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (90) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (91) exprSHIFT -> . exprOP
    (92) exprOP -> . exprOP PLUS term
    (93) exprOP -> . exprOP MINUS term
    (94) exprOP -> . term
    (95) term -> . term MULTIPLY factor
    (96) term -> . term DIVIDE factor
    (97) term -> . term MOD factor
    (98) term -> . factor
    (99) factor -> . NOT factor
    (100) factor -> . PLUS factor
    (101) factor -> . MINUS factor
    (102) factor -> . PLUS_PLUS factor
    (103) factor -> . MINUS_MINUS factor
    (104) factor -> . brace
    (105) brace -> . L_PAREN expr R_PAREN
    (106) brace -> . brace PLUS_PLUS
    (107) brace -> . brace MINUS_MINUS
    (108) brace -> . INT_NUM
    (109) brace -> . FLOAT_NUM
    (110) brace -> . ID

    IF              shift and go to state 93
    WHILE           shift and go to state 96
    FOR             shift and go to state 97
    SEMICOLON       shift and go to state 12
    RETURN          shift and go to state 16
    L_FLOWBRACE     shift and go to state 19
    TYPE            shift and go to state 22
    ID              shift and go to state 17
    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    INT_NUM         shift and go to state 18
    FLOAT_NUM       shift and go to state 39

    closed                         shift and go to state 102
    open                           shift and go to state 101
    simple                         shift and go to state 9
    block                          shift and go to state 10
    expr                           shift and go to state 11
    declaration                    shift and go to state 13
    function                       shift and go to state 14
    function_call                  shift and go to state 15
    exprOR                         shift and go to state 20
    exprAND                        shift and go to state 23
    exprBITOR                      shift and go to state 24
    exprBITXOR                     shift and go to state 25
    exprBITAND                     shift and go to state 26
    exprEQ                         shift and go to state 27
    exprRELOP                      shift and go to state 28
    exprSHIFT                      shift and go to state 29
    exprOP                         shift and go to state 30
    term                           shift and go to state 32
    factor                         shift and go to state 34
    brace                          shift and go to state 38

state 143

    (15) condition -> L_PAREN expr R_PAREN .

    IF              reduce using rule 15 (condition -> L_PAREN expr R_PAREN .)
    WHILE           reduce using rule 15 (condition -> L_PAREN expr R_PAREN .)
    FOR             reduce using rule 15 (condition -> L_PAREN expr R_PAREN .)
    SEMICOLON       reduce using rule 15 (condition -> L_PAREN expr R_PAREN .)
    RETURN          reduce using rule 15 (condition -> L_PAREN expr R_PAREN .)
    L_FLOWBRACE     reduce using rule 15 (condition -> L_PAREN expr R_PAREN .)
    TYPE            reduce using rule 15 (condition -> L_PAREN expr R_PAREN .)
    ID              reduce using rule 15 (condition -> L_PAREN expr R_PAREN .)
    NOT             reduce using rule 15 (condition -> L_PAREN expr R_PAREN .)
    PLUS            reduce using rule 15 (condition -> L_PAREN expr R_PAREN .)
    MINUS           reduce using rule 15 (condition -> L_PAREN expr R_PAREN .)
    PLUS_PLUS       reduce using rule 15 (condition -> L_PAREN expr R_PAREN .)
    MINUS_MINUS     reduce using rule 15 (condition -> L_PAREN expr R_PAREN .)
    L_PAREN         reduce using rule 15 (condition -> L_PAREN expr R_PAREN .)
    INT_NUM         reduce using rule 15 (condition -> L_PAREN expr R_PAREN .)
    FLOAT_NUM       reduce using rule 15 (condition -> L_PAREN expr R_PAREN .)


state 144

    (16) for_condition -> L_PAREN declaration expr . SEMICOLON expr R_PAREN
    (56) expr -> expr . assignment exprOR
    (57) expr -> expr . assignment ID L_PAREN call_params R_PAREN
    (59) assignment -> . ASSIGN
    (60) assignment -> . PLUS_ASSIGN
    (61) assignment -> . MINUS_ASSIGN
    (62) assignment -> . MUL_ASSIGN
    (63) assignment -> . DIV_ASSIGN
    (64) assignment -> . AND_ASSIGN
    (65) assignment -> . OR_ASSIGN
    (66) assignment -> . XOR_ASSIGN
    (67) assignment -> . MOD_ASSIGN
    (68) assignment -> . L_SHIFT_ASSIGN
    (69) assignment -> . R_SHIFT_ASSIGN

    SEMICOLON       shift and go to state 167
    ASSIGN          shift and go to state 48
    PLUS_ASSIGN     shift and go to state 49
    MINUS_ASSIGN    shift and go to state 50
    MUL_ASSIGN      shift and go to state 51
    DIV_ASSIGN      shift and go to state 52
    AND_ASSIGN      shift and go to state 53
    OR_ASSIGN       shift and go to state 54
    XOR_ASSIGN      shift and go to state 55
    MOD_ASSIGN      shift and go to state 56
    L_SHIFT_ASSIGN  shift and go to state 57
    R_SHIFT_ASSIGN  shift and go to state 58

    assignment                     shift and go to state 47

state 145

    (17) for_condition -> L_PAREN expr SEMICOLON . expr SEMICOLON expr R_PAREN
    (56) expr -> . expr assignment exprOR
    (57) expr -> . expr assignment ID L_PAREN call_params R_PAREN
    (58) expr -> . exprOR
    (70) exprOR -> . exprOR OR exprAND
    (71) exprOR -> . exprAND
    (72) exprAND -> . exprAND AND exprBITOR
    (73) exprAND -> . exprBITOR
    (74) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (75) exprBITOR -> . exprBITXOR
    (76) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (77) exprBITXOR -> . exprBITAND
    (78) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (79) exprBITAND -> . exprEQ
    (80) exprEQ -> . exprEQ EQ exprRELOP
    (81) exprEQ -> . exprEQ NE exprRELOP
    (82) exprEQ -> . exprRELOP
    (83) exprRELOP -> . exprRELOP relop exprSHIFT
    (84) exprRELOP -> . exprSHIFT
    (89) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (90) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (91) exprSHIFT -> . exprOP
    (92) exprOP -> . exprOP PLUS term
    (93) exprOP -> . exprOP MINUS term
    (94) exprOP -> . term
    (95) term -> . term MULTIPLY factor
    (96) term -> . term DIVIDE factor
    (97) term -> . term MOD factor
    (98) term -> . factor
    (99) factor -> . NOT factor
    (100) factor -> . PLUS factor
    (101) factor -> . MINUS factor
    (102) factor -> . PLUS_PLUS factor
    (103) factor -> . MINUS_MINUS factor
    (104) factor -> . brace
    (105) brace -> . L_PAREN expr R_PAREN
    (106) brace -> . brace PLUS_PLUS
    (107) brace -> . brace MINUS_MINUS
    (108) brace -> . INT_NUM
    (109) brace -> . FLOAT_NUM
    (110) brace -> . ID

    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    INT_NUM         shift and go to state 18
    FLOAT_NUM       shift and go to state 39
    ID              shift and go to state 65

    expr                           shift and go to state 168
    exprOR                         shift and go to state 20
    exprAND                        shift and go to state 23
    exprBITOR                      shift and go to state 24
    exprBITXOR                     shift and go to state 25
    exprBITAND                     shift and go to state 26
    exprEQ                         shift and go to state 27
    exprRELOP                      shift and go to state 28
    exprSHIFT                      shift and go to state 29
    exprOP                         shift and go to state 30
    term                           shift and go to state 32
    factor                         shift and go to state 34
    brace                          shift and go to state 38

state 146

    (24) declaration -> TYPE ID . SEMICOLON
    (25) declaration -> TYPE ID . ASSIGN expr SEMICOLON
    (26) declaration -> TYPE ID . ASSIGN function_call
    (20) multi_declaration -> ID . COMMA
    (21) multi_declaration -> ID . ASSIGN expr COMMA

    SEMICOLON       shift and go to state 119
    ASSIGN          shift and go to state 120
    COMMA           shift and go to state 122


state 147

    (57) expr -> expr assignment ID L_PAREN . call_params R_PAREN
    (38) call_params -> . empty
    (39) call_params -> . yes_call_params end_call_params
    (40) call_params -> . end_call_params
    (36) empty -> .
    (41) yes_call_params -> . yes_call_params INT_NUM COMMA
    (42) yes_call_params -> . yes_call_params ID COMMA
    (43) yes_call_params -> . INT_NUM COMMA
    (44) yes_call_params -> . ID COMMA
    (45) end_call_params -> . INT_NUM
    (46) end_call_params -> . ID

    R_PAREN         reduce using rule 36 (empty -> .)
    INT_NUM         shift and go to state 115
    ID              shift and go to state 110

    call_params                    shift and go to state 169
    empty                          shift and go to state 112
    yes_call_params                shift and go to state 113
    end_call_params                shift and go to state 114

state 148

    (44) yes_call_params -> ID COMMA .

    INT_NUM         reduce using rule 44 (yes_call_params -> ID COMMA .)
    ID              reduce using rule 44 (yes_call_params -> ID COMMA .)


state 149

    (37) function_call -> ID L_PAREN call_params R_PAREN . SEMICOLON

    SEMICOLON       shift and go to state 170


state 150

    (39) call_params -> yes_call_params end_call_params .

    R_PAREN         reduce using rule 39 (call_params -> yes_call_params end_call_params .)


state 151

    (41) yes_call_params -> yes_call_params INT_NUM . COMMA
    (45) end_call_params -> INT_NUM .

    COMMA           shift and go to state 171
    R_PAREN         reduce using rule 45 (end_call_params -> INT_NUM .)


state 152

    (42) yes_call_params -> yes_call_params ID . COMMA
    (46) end_call_params -> ID .

    COMMA           shift and go to state 172
    R_PAREN         reduce using rule 46 (end_call_params -> ID .)


state 153

    (43) yes_call_params -> INT_NUM COMMA .

    INT_NUM         reduce using rule 43 (yes_call_params -> INT_NUM COMMA .)
    ID              reduce using rule 43 (yes_call_params -> INT_NUM COMMA .)


state 154

    (25) declaration -> TYPE ID ASSIGN expr . SEMICOLON
    (21) multi_declaration -> ID ASSIGN expr . COMMA
    (56) expr -> expr . assignment exprOR
    (57) expr -> expr . assignment ID L_PAREN call_params R_PAREN
    (59) assignment -> . ASSIGN
    (60) assignment -> . PLUS_ASSIGN
    (61) assignment -> . MINUS_ASSIGN
    (62) assignment -> . MUL_ASSIGN
    (63) assignment -> . DIV_ASSIGN
    (64) assignment -> . AND_ASSIGN
    (65) assignment -> . OR_ASSIGN
    (66) assignment -> . XOR_ASSIGN
    (67) assignment -> . MOD_ASSIGN
    (68) assignment -> . L_SHIFT_ASSIGN
    (69) assignment -> . R_SHIFT_ASSIGN

    SEMICOLON       shift and go to state 173
    COMMA           shift and go to state 174
    ASSIGN          shift and go to state 48
    PLUS_ASSIGN     shift and go to state 49
    MINUS_ASSIGN    shift and go to state 50
    MUL_ASSIGN      shift and go to state 51
    DIV_ASSIGN      shift and go to state 52
    AND_ASSIGN      shift and go to state 53
    OR_ASSIGN       shift and go to state 54
    XOR_ASSIGN      shift and go to state 55
    MOD_ASSIGN      shift and go to state 56
    L_SHIFT_ASSIGN  shift and go to state 57
    R_SHIFT_ASSIGN  shift and go to state 58

    assignment                     shift and go to state 47

state 155

    (26) declaration -> TYPE ID ASSIGN function_call .

    IF              reduce using rule 26 (declaration -> TYPE ID ASSIGN function_call .)
    WHILE           reduce using rule 26 (declaration -> TYPE ID ASSIGN function_call .)
    FOR             reduce using rule 26 (declaration -> TYPE ID ASSIGN function_call .)
    SEMICOLON       reduce using rule 26 (declaration -> TYPE ID ASSIGN function_call .)
    RETURN          reduce using rule 26 (declaration -> TYPE ID ASSIGN function_call .)
    L_FLOWBRACE     reduce using rule 26 (declaration -> TYPE ID ASSIGN function_call .)
    TYPE            reduce using rule 26 (declaration -> TYPE ID ASSIGN function_call .)
    ID              reduce using rule 26 (declaration -> TYPE ID ASSIGN function_call .)
    NOT             reduce using rule 26 (declaration -> TYPE ID ASSIGN function_call .)
    PLUS            reduce using rule 26 (declaration -> TYPE ID ASSIGN function_call .)
    MINUS           reduce using rule 26 (declaration -> TYPE ID ASSIGN function_call .)
    PLUS_PLUS       reduce using rule 26 (declaration -> TYPE ID ASSIGN function_call .)
    MINUS_MINUS     reduce using rule 26 (declaration -> TYPE ID ASSIGN function_call .)
    L_PAREN         reduce using rule 26 (declaration -> TYPE ID ASSIGN function_call .)
    INT_NUM         reduce using rule 26 (declaration -> TYPE ID ASSIGN function_call .)
    FLOAT_NUM       reduce using rule 26 (declaration -> TYPE ID ASSIGN function_call .)
    $end            reduce using rule 26 (declaration -> TYPE ID ASSIGN function_call .)
    R_FLOWBRACE     reduce using rule 26 (declaration -> TYPE ID ASSIGN function_call .)
    ELSE            reduce using rule 26 (declaration -> TYPE ID ASSIGN function_call .)


state 156

    (48) yes_dec_params -> TYPE . ID COMMA
    (49) end_dec_params -> TYPE . ID

    ID              shift and go to state 175


state 157

    (53) function -> TYPE ID L_PAREN dec_params . R_PAREN function_2

    R_PAREN         shift and go to state 176


state 158

    (50) dec_params -> empty .

    R_PAREN         reduce using rule 50 (dec_params -> empty .)


state 159

    (51) dec_params -> yes_dec_params . end_dec_params
    (47) yes_dec_params -> yes_dec_params . TYPE ID COMMA
    (49) end_dec_params -> . TYPE ID

    TYPE            shift and go to state 178

    end_dec_params                 shift and go to state 177

state 160

    (52) dec_params -> end_dec_params .

    R_PAREN         reduce using rule 52 (dec_params -> end_dec_params .)


state 161

    (18) multi_declaration -> multi_declaration ID COMMA .

    ID              reduce using rule 18 (multi_declaration -> multi_declaration ID COMMA .)


state 162

    (19) multi_declaration -> multi_declaration ID ASSIGN . expr COMMA
    (23) stop -> ID ASSIGN . expr SEMICOLON
    (56) expr -> . expr assignment exprOR
    (57) expr -> . expr assignment ID L_PAREN call_params R_PAREN
    (58) expr -> . exprOR
    (70) exprOR -> . exprOR OR exprAND
    (71) exprOR -> . exprAND
    (72) exprAND -> . exprAND AND exprBITOR
    (73) exprAND -> . exprBITOR
    (74) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (75) exprBITOR -> . exprBITXOR
    (76) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (77) exprBITXOR -> . exprBITAND
    (78) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (79) exprBITAND -> . exprEQ
    (80) exprEQ -> . exprEQ EQ exprRELOP
    (81) exprEQ -> . exprEQ NE exprRELOP
    (82) exprEQ -> . exprRELOP
    (83) exprRELOP -> . exprRELOP relop exprSHIFT
    (84) exprRELOP -> . exprSHIFT
    (89) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (90) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (91) exprSHIFT -> . exprOP
    (92) exprOP -> . exprOP PLUS term
    (93) exprOP -> . exprOP MINUS term
    (94) exprOP -> . term
    (95) term -> . term MULTIPLY factor
    (96) term -> . term DIVIDE factor
    (97) term -> . term MOD factor
    (98) term -> . factor
    (99) factor -> . NOT factor
    (100) factor -> . PLUS factor
    (101) factor -> . MINUS factor
    (102) factor -> . PLUS_PLUS factor
    (103) factor -> . MINUS_MINUS factor
    (104) factor -> . brace
    (105) brace -> . L_PAREN expr R_PAREN
    (106) brace -> . brace PLUS_PLUS
    (107) brace -> . brace MINUS_MINUS
    (108) brace -> . INT_NUM
    (109) brace -> . FLOAT_NUM
    (110) brace -> . ID

    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    INT_NUM         shift and go to state 18
    FLOAT_NUM       shift and go to state 39
    ID              shift and go to state 65

    expr                           shift and go to state 179
    exprOR                         shift and go to state 20
    exprAND                        shift and go to state 23
    exprBITOR                      shift and go to state 24
    exprBITXOR                     shift and go to state 25
    exprBITAND                     shift and go to state 26
    exprEQ                         shift and go to state 27
    exprRELOP                      shift and go to state 28
    exprSHIFT                      shift and go to state 29
    exprOP                         shift and go to state 30
    term                           shift and go to state 32
    factor                         shift and go to state 34
    brace                          shift and go to state 38

state 163

    (22) stop -> ID SEMICOLON .

    IF              reduce using rule 22 (stop -> ID SEMICOLON .)
    WHILE           reduce using rule 22 (stop -> ID SEMICOLON .)
    FOR             reduce using rule 22 (stop -> ID SEMICOLON .)
    SEMICOLON       reduce using rule 22 (stop -> ID SEMICOLON .)
    RETURN          reduce using rule 22 (stop -> ID SEMICOLON .)
    L_FLOWBRACE     reduce using rule 22 (stop -> ID SEMICOLON .)
    TYPE            reduce using rule 22 (stop -> ID SEMICOLON .)
    ID              reduce using rule 22 (stop -> ID SEMICOLON .)
    NOT             reduce using rule 22 (stop -> ID SEMICOLON .)
    PLUS            reduce using rule 22 (stop -> ID SEMICOLON .)
    MINUS           reduce using rule 22 (stop -> ID SEMICOLON .)
    PLUS_PLUS       reduce using rule 22 (stop -> ID SEMICOLON .)
    MINUS_MINUS     reduce using rule 22 (stop -> ID SEMICOLON .)
    L_PAREN         reduce using rule 22 (stop -> ID SEMICOLON .)
    INT_NUM         reduce using rule 22 (stop -> ID SEMICOLON .)
    FLOAT_NUM       reduce using rule 22 (stop -> ID SEMICOLON .)
    $end            reduce using rule 22 (stop -> ID SEMICOLON .)
    R_FLOWBRACE     reduce using rule 22 (stop -> ID SEMICOLON .)
    ELSE            reduce using rule 22 (stop -> ID SEMICOLON .)


state 164

    (12) closed -> IF condition closed . ELSE closed
    (7) open -> IF condition closed . ELSE open
    (5) statement -> closed .

    ELSE            shift and go to state 180
    IF              reduce using rule 5 (statement -> closed .)
    WHILE           reduce using rule 5 (statement -> closed .)
    FOR             reduce using rule 5 (statement -> closed .)
    SEMICOLON       reduce using rule 5 (statement -> closed .)
    RETURN          reduce using rule 5 (statement -> closed .)
    L_FLOWBRACE     reduce using rule 5 (statement -> closed .)
    TYPE            reduce using rule 5 (statement -> closed .)
    ID              reduce using rule 5 (statement -> closed .)
    NOT             reduce using rule 5 (statement -> closed .)
    PLUS            reduce using rule 5 (statement -> closed .)
    MINUS           reduce using rule 5 (statement -> closed .)
    PLUS_PLUS       reduce using rule 5 (statement -> closed .)
    MINUS_MINUS     reduce using rule 5 (statement -> closed .)
    L_PAREN         reduce using rule 5 (statement -> closed .)
    INT_NUM         reduce using rule 5 (statement -> closed .)
    FLOAT_NUM       reduce using rule 5 (statement -> closed .)
    $end            reduce using rule 5 (statement -> closed .)
    R_FLOWBRACE     reduce using rule 5 (statement -> closed .)


state 165

    (12) closed -> IF condition closed ELSE closed .

    IF              reduce using rule 12 (closed -> IF condition closed ELSE closed .)
    WHILE           reduce using rule 12 (closed -> IF condition closed ELSE closed .)
    FOR             reduce using rule 12 (closed -> IF condition closed ELSE closed .)
    SEMICOLON       reduce using rule 12 (closed -> IF condition closed ELSE closed .)
    RETURN          reduce using rule 12 (closed -> IF condition closed ELSE closed .)
    L_FLOWBRACE     reduce using rule 12 (closed -> IF condition closed ELSE closed .)
    TYPE            reduce using rule 12 (closed -> IF condition closed ELSE closed .)
    ID              reduce using rule 12 (closed -> IF condition closed ELSE closed .)
    NOT             reduce using rule 12 (closed -> IF condition closed ELSE closed .)
    PLUS            reduce using rule 12 (closed -> IF condition closed ELSE closed .)
    MINUS           reduce using rule 12 (closed -> IF condition closed ELSE closed .)
    PLUS_PLUS       reduce using rule 12 (closed -> IF condition closed ELSE closed .)
    MINUS_MINUS     reduce using rule 12 (closed -> IF condition closed ELSE closed .)
    L_PAREN         reduce using rule 12 (closed -> IF condition closed ELSE closed .)
    INT_NUM         reduce using rule 12 (closed -> IF condition closed ELSE closed .)
    FLOAT_NUM       reduce using rule 12 (closed -> IF condition closed ELSE closed .)
    $end            reduce using rule 12 (closed -> IF condition closed ELSE closed .)
    R_FLOWBRACE     reduce using rule 12 (closed -> IF condition closed ELSE closed .)
    ELSE            reduce using rule 12 (closed -> IF condition closed ELSE closed .)


state 166

    (7) open -> IF condition closed ELSE open .

    IF              reduce using rule 7 (open -> IF condition closed ELSE open .)
    WHILE           reduce using rule 7 (open -> IF condition closed ELSE open .)
    FOR             reduce using rule 7 (open -> IF condition closed ELSE open .)
    SEMICOLON       reduce using rule 7 (open -> IF condition closed ELSE open .)
    RETURN          reduce using rule 7 (open -> IF condition closed ELSE open .)
    L_FLOWBRACE     reduce using rule 7 (open -> IF condition closed ELSE open .)
    TYPE            reduce using rule 7 (open -> IF condition closed ELSE open .)
    ID              reduce using rule 7 (open -> IF condition closed ELSE open .)
    NOT             reduce using rule 7 (open -> IF condition closed ELSE open .)
    PLUS            reduce using rule 7 (open -> IF condition closed ELSE open .)
    MINUS           reduce using rule 7 (open -> IF condition closed ELSE open .)
    PLUS_PLUS       reduce using rule 7 (open -> IF condition closed ELSE open .)
    MINUS_MINUS     reduce using rule 7 (open -> IF condition closed ELSE open .)
    L_PAREN         reduce using rule 7 (open -> IF condition closed ELSE open .)
    INT_NUM         reduce using rule 7 (open -> IF condition closed ELSE open .)
    FLOAT_NUM       reduce using rule 7 (open -> IF condition closed ELSE open .)
    $end            reduce using rule 7 (open -> IF condition closed ELSE open .)
    R_FLOWBRACE     reduce using rule 7 (open -> IF condition closed ELSE open .)


state 167

    (16) for_condition -> L_PAREN declaration expr SEMICOLON . expr R_PAREN
    (56) expr -> . expr assignment exprOR
    (57) expr -> . expr assignment ID L_PAREN call_params R_PAREN
    (58) expr -> . exprOR
    (70) exprOR -> . exprOR OR exprAND
    (71) exprOR -> . exprAND
    (72) exprAND -> . exprAND AND exprBITOR
    (73) exprAND -> . exprBITOR
    (74) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (75) exprBITOR -> . exprBITXOR
    (76) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (77) exprBITXOR -> . exprBITAND
    (78) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (79) exprBITAND -> . exprEQ
    (80) exprEQ -> . exprEQ EQ exprRELOP
    (81) exprEQ -> . exprEQ NE exprRELOP
    (82) exprEQ -> . exprRELOP
    (83) exprRELOP -> . exprRELOP relop exprSHIFT
    (84) exprRELOP -> . exprSHIFT
    (89) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (90) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (91) exprSHIFT -> . exprOP
    (92) exprOP -> . exprOP PLUS term
    (93) exprOP -> . exprOP MINUS term
    (94) exprOP -> . term
    (95) term -> . term MULTIPLY factor
    (96) term -> . term DIVIDE factor
    (97) term -> . term MOD factor
    (98) term -> . factor
    (99) factor -> . NOT factor
    (100) factor -> . PLUS factor
    (101) factor -> . MINUS factor
    (102) factor -> . PLUS_PLUS factor
    (103) factor -> . MINUS_MINUS factor
    (104) factor -> . brace
    (105) brace -> . L_PAREN expr R_PAREN
    (106) brace -> . brace PLUS_PLUS
    (107) brace -> . brace MINUS_MINUS
    (108) brace -> . INT_NUM
    (109) brace -> . FLOAT_NUM
    (110) brace -> . ID

    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    INT_NUM         shift and go to state 18
    FLOAT_NUM       shift and go to state 39
    ID              shift and go to state 65

    expr                           shift and go to state 181
    exprOR                         shift and go to state 20
    exprAND                        shift and go to state 23
    exprBITOR                      shift and go to state 24
    exprBITXOR                     shift and go to state 25
    exprBITAND                     shift and go to state 26
    exprEQ                         shift and go to state 27
    exprRELOP                      shift and go to state 28
    exprSHIFT                      shift and go to state 29
    exprOP                         shift and go to state 30
    term                           shift and go to state 32
    factor                         shift and go to state 34
    brace                          shift and go to state 38

state 168

    (17) for_condition -> L_PAREN expr SEMICOLON expr . SEMICOLON expr R_PAREN
    (56) expr -> expr . assignment exprOR
    (57) expr -> expr . assignment ID L_PAREN call_params R_PAREN
    (59) assignment -> . ASSIGN
    (60) assignment -> . PLUS_ASSIGN
    (61) assignment -> . MINUS_ASSIGN
    (62) assignment -> . MUL_ASSIGN
    (63) assignment -> . DIV_ASSIGN
    (64) assignment -> . AND_ASSIGN
    (65) assignment -> . OR_ASSIGN
    (66) assignment -> . XOR_ASSIGN
    (67) assignment -> . MOD_ASSIGN
    (68) assignment -> . L_SHIFT_ASSIGN
    (69) assignment -> . R_SHIFT_ASSIGN

    SEMICOLON       shift and go to state 182
    ASSIGN          shift and go to state 48
    PLUS_ASSIGN     shift and go to state 49
    MINUS_ASSIGN    shift and go to state 50
    MUL_ASSIGN      shift and go to state 51
    DIV_ASSIGN      shift and go to state 52
    AND_ASSIGN      shift and go to state 53
    OR_ASSIGN       shift and go to state 54
    XOR_ASSIGN      shift and go to state 55
    MOD_ASSIGN      shift and go to state 56
    L_SHIFT_ASSIGN  shift and go to state 57
    R_SHIFT_ASSIGN  shift and go to state 58

    assignment                     shift and go to state 47

state 169

    (57) expr -> expr assignment ID L_PAREN call_params . R_PAREN

    R_PAREN         shift and go to state 183


state 170

    (37) function_call -> ID L_PAREN call_params R_PAREN SEMICOLON .

    IF              reduce using rule 37 (function_call -> ID L_PAREN call_params R_PAREN SEMICOLON .)
    WHILE           reduce using rule 37 (function_call -> ID L_PAREN call_params R_PAREN SEMICOLON .)
    FOR             reduce using rule 37 (function_call -> ID L_PAREN call_params R_PAREN SEMICOLON .)
    SEMICOLON       reduce using rule 37 (function_call -> ID L_PAREN call_params R_PAREN SEMICOLON .)
    RETURN          reduce using rule 37 (function_call -> ID L_PAREN call_params R_PAREN SEMICOLON .)
    L_FLOWBRACE     reduce using rule 37 (function_call -> ID L_PAREN call_params R_PAREN SEMICOLON .)
    TYPE            reduce using rule 37 (function_call -> ID L_PAREN call_params R_PAREN SEMICOLON .)
    ID              reduce using rule 37 (function_call -> ID L_PAREN call_params R_PAREN SEMICOLON .)
    NOT             reduce using rule 37 (function_call -> ID L_PAREN call_params R_PAREN SEMICOLON .)
    PLUS            reduce using rule 37 (function_call -> ID L_PAREN call_params R_PAREN SEMICOLON .)
    MINUS           reduce using rule 37 (function_call -> ID L_PAREN call_params R_PAREN SEMICOLON .)
    PLUS_PLUS       reduce using rule 37 (function_call -> ID L_PAREN call_params R_PAREN SEMICOLON .)
    MINUS_MINUS     reduce using rule 37 (function_call -> ID L_PAREN call_params R_PAREN SEMICOLON .)
    L_PAREN         reduce using rule 37 (function_call -> ID L_PAREN call_params R_PAREN SEMICOLON .)
    INT_NUM         reduce using rule 37 (function_call -> ID L_PAREN call_params R_PAREN SEMICOLON .)
    FLOAT_NUM       reduce using rule 37 (function_call -> ID L_PAREN call_params R_PAREN SEMICOLON .)
    $end            reduce using rule 37 (function_call -> ID L_PAREN call_params R_PAREN SEMICOLON .)
    R_FLOWBRACE     reduce using rule 37 (function_call -> ID L_PAREN call_params R_PAREN SEMICOLON .)
    ELSE            reduce using rule 37 (function_call -> ID L_PAREN call_params R_PAREN SEMICOLON .)


state 171

    (41) yes_call_params -> yes_call_params INT_NUM COMMA .

    INT_NUM         reduce using rule 41 (yes_call_params -> yes_call_params INT_NUM COMMA .)
    ID              reduce using rule 41 (yes_call_params -> yes_call_params INT_NUM COMMA .)


state 172

    (42) yes_call_params -> yes_call_params ID COMMA .

    INT_NUM         reduce using rule 42 (yes_call_params -> yes_call_params ID COMMA .)
    ID              reduce using rule 42 (yes_call_params -> yes_call_params ID COMMA .)


state 173

    (25) declaration -> TYPE ID ASSIGN expr SEMICOLON .

    IF              reduce using rule 25 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    WHILE           reduce using rule 25 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    FOR             reduce using rule 25 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    SEMICOLON       reduce using rule 25 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    RETURN          reduce using rule 25 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    L_FLOWBRACE     reduce using rule 25 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    TYPE            reduce using rule 25 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    ID              reduce using rule 25 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    NOT             reduce using rule 25 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    PLUS            reduce using rule 25 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    MINUS           reduce using rule 25 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    PLUS_PLUS       reduce using rule 25 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    MINUS_MINUS     reduce using rule 25 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    L_PAREN         reduce using rule 25 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    INT_NUM         reduce using rule 25 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    FLOAT_NUM       reduce using rule 25 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    $end            reduce using rule 25 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    R_FLOWBRACE     reduce using rule 25 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    ELSE            reduce using rule 25 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)


state 174

    (21) multi_declaration -> ID ASSIGN expr COMMA .

    ID              reduce using rule 21 (multi_declaration -> ID ASSIGN expr COMMA .)


state 175

    (48) yes_dec_params -> TYPE ID . COMMA
    (49) end_dec_params -> TYPE ID .

    COMMA           shift and go to state 184
    R_PAREN         reduce using rule 49 (end_dec_params -> TYPE ID .)


state 176

    (53) function -> TYPE ID L_PAREN dec_params R_PAREN . function_2
    (54) function_2 -> . SEMICOLON
    (55) function_2 -> . block
    (28) block -> . L_FLOWBRACE multiple_statements R_FLOWBRACE

    SEMICOLON       shift and go to state 186
    L_FLOWBRACE     shift and go to state 19

    function_2                     shift and go to state 185
    block                          shift and go to state 187

state 177

    (51) dec_params -> yes_dec_params end_dec_params .

    R_PAREN         reduce using rule 51 (dec_params -> yes_dec_params end_dec_params .)


state 178

    (47) yes_dec_params -> yes_dec_params TYPE . ID COMMA
    (49) end_dec_params -> TYPE . ID

    ID              shift and go to state 188


state 179

    (19) multi_declaration -> multi_declaration ID ASSIGN expr . COMMA
    (23) stop -> ID ASSIGN expr . SEMICOLON
    (56) expr -> expr . assignment exprOR
    (57) expr -> expr . assignment ID L_PAREN call_params R_PAREN
    (59) assignment -> . ASSIGN
    (60) assignment -> . PLUS_ASSIGN
    (61) assignment -> . MINUS_ASSIGN
    (62) assignment -> . MUL_ASSIGN
    (63) assignment -> . DIV_ASSIGN
    (64) assignment -> . AND_ASSIGN
    (65) assignment -> . OR_ASSIGN
    (66) assignment -> . XOR_ASSIGN
    (67) assignment -> . MOD_ASSIGN
    (68) assignment -> . L_SHIFT_ASSIGN
    (69) assignment -> . R_SHIFT_ASSIGN

    COMMA           shift and go to state 189
    SEMICOLON       shift and go to state 190
    ASSIGN          shift and go to state 48
    PLUS_ASSIGN     shift and go to state 49
    MINUS_ASSIGN    shift and go to state 50
    MUL_ASSIGN      shift and go to state 51
    DIV_ASSIGN      shift and go to state 52
    AND_ASSIGN      shift and go to state 53
    OR_ASSIGN       shift and go to state 54
    XOR_ASSIGN      shift and go to state 55
    MOD_ASSIGN      shift and go to state 56
    L_SHIFT_ASSIGN  shift and go to state 57
    R_SHIFT_ASSIGN  shift and go to state 58

    assignment                     shift and go to state 47

state 180

    (12) closed -> IF condition closed ELSE . closed
    (7) open -> IF condition closed ELSE . open
    (10) closed -> . simple
    (11) closed -> . block
    (12) closed -> . IF condition closed ELSE closed
    (13) closed -> . WHILE condition closed
    (14) closed -> . FOR for_condition closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) open -> . FOR for_condition open
    (29) simple -> . expr SEMICOLON
    (30) simple -> . declaration
    (31) simple -> . SEMICOLON
    (32) simple -> . function
    (33) simple -> . function_call
    (34) simple -> . RETURN ID SEMICOLON
    (35) simple -> . RETURN INT_NUM SEMICOLON
    (28) block -> . L_FLOWBRACE multiple_statements R_FLOWBRACE
    (56) expr -> . expr assignment exprOR
    (57) expr -> . expr assignment ID L_PAREN call_params R_PAREN
    (58) expr -> . exprOR
    (24) declaration -> . TYPE ID SEMICOLON
    (25) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (26) declaration -> . TYPE ID ASSIGN function_call
    (27) declaration -> . TYPE multi_declaration stop
    (53) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (37) function_call -> . ID L_PAREN call_params R_PAREN SEMICOLON
    (70) exprOR -> . exprOR OR exprAND
    (71) exprOR -> . exprAND
    (72) exprAND -> . exprAND AND exprBITOR
    (73) exprAND -> . exprBITOR
    (74) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (75) exprBITOR -> . exprBITXOR
    (76) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (77) exprBITXOR -> . exprBITAND
    (78) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (79) exprBITAND -> . exprEQ
    (80) exprEQ -> . exprEQ EQ exprRELOP
    (81) exprEQ -> . exprEQ NE exprRELOP
    (82) exprEQ -> . exprRELOP
    (83) exprRELOP -> . exprRELOP relop exprSHIFT
    (84) exprRELOP -> . exprSHIFT
    (89) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (90) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (91) exprSHIFT -> . exprOP
    (92) exprOP -> . exprOP PLUS term
    (93) exprOP -> . exprOP MINUS term
    (94) exprOP -> . term
    (95) term -> . term MULTIPLY factor
    (96) term -> . term DIVIDE factor
    (97) term -> . term MOD factor
    (98) term -> . factor
    (99) factor -> . NOT factor
    (100) factor -> . PLUS factor
    (101) factor -> . MINUS factor
    (102) factor -> . PLUS_PLUS factor
    (103) factor -> . MINUS_MINUS factor
    (104) factor -> . brace
    (105) brace -> . L_PAREN expr R_PAREN
    (106) brace -> . brace PLUS_PLUS
    (107) brace -> . brace MINUS_MINUS
    (108) brace -> . INT_NUM
    (109) brace -> . FLOAT_NUM
    (110) brace -> . ID

    IF              shift and go to state 93
    WHILE           shift and go to state 96
    FOR             shift and go to state 97
    SEMICOLON       shift and go to state 12
    RETURN          shift and go to state 16
    L_FLOWBRACE     shift and go to state 19
    TYPE            shift and go to state 22
    ID              shift and go to state 17
    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    INT_NUM         shift and go to state 18
    FLOAT_NUM       shift and go to state 39

    closed                         shift and go to state 165
    open                           shift and go to state 166
    simple                         shift and go to state 9
    block                          shift and go to state 10
    expr                           shift and go to state 11
    declaration                    shift and go to state 13
    function                       shift and go to state 14
    function_call                  shift and go to state 15
    exprOR                         shift and go to state 20
    exprAND                        shift and go to state 23
    exprBITOR                      shift and go to state 24
    exprBITXOR                     shift and go to state 25
    exprBITAND                     shift and go to state 26
    exprEQ                         shift and go to state 27
    exprRELOP                      shift and go to state 28
    exprSHIFT                      shift and go to state 29
    exprOP                         shift and go to state 30
    term                           shift and go to state 32
    factor                         shift and go to state 34
    brace                          shift and go to state 38

state 181

    (16) for_condition -> L_PAREN declaration expr SEMICOLON expr . R_PAREN
    (56) expr -> expr . assignment exprOR
    (57) expr -> expr . assignment ID L_PAREN call_params R_PAREN
    (59) assignment -> . ASSIGN
    (60) assignment -> . PLUS_ASSIGN
    (61) assignment -> . MINUS_ASSIGN
    (62) assignment -> . MUL_ASSIGN
    (63) assignment -> . DIV_ASSIGN
    (64) assignment -> . AND_ASSIGN
    (65) assignment -> . OR_ASSIGN
    (66) assignment -> . XOR_ASSIGN
    (67) assignment -> . MOD_ASSIGN
    (68) assignment -> . L_SHIFT_ASSIGN
    (69) assignment -> . R_SHIFT_ASSIGN

    R_PAREN         shift and go to state 191
    ASSIGN          shift and go to state 48
    PLUS_ASSIGN     shift and go to state 49
    MINUS_ASSIGN    shift and go to state 50
    MUL_ASSIGN      shift and go to state 51
    DIV_ASSIGN      shift and go to state 52
    AND_ASSIGN      shift and go to state 53
    OR_ASSIGN       shift and go to state 54
    XOR_ASSIGN      shift and go to state 55
    MOD_ASSIGN      shift and go to state 56
    L_SHIFT_ASSIGN  shift and go to state 57
    R_SHIFT_ASSIGN  shift and go to state 58

    assignment                     shift and go to state 47

state 182

    (17) for_condition -> L_PAREN expr SEMICOLON expr SEMICOLON . expr R_PAREN
    (56) expr -> . expr assignment exprOR
    (57) expr -> . expr assignment ID L_PAREN call_params R_PAREN
    (58) expr -> . exprOR
    (70) exprOR -> . exprOR OR exprAND
    (71) exprOR -> . exprAND
    (72) exprAND -> . exprAND AND exprBITOR
    (73) exprAND -> . exprBITOR
    (74) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (75) exprBITOR -> . exprBITXOR
    (76) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (77) exprBITXOR -> . exprBITAND
    (78) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (79) exprBITAND -> . exprEQ
    (80) exprEQ -> . exprEQ EQ exprRELOP
    (81) exprEQ -> . exprEQ NE exprRELOP
    (82) exprEQ -> . exprRELOP
    (83) exprRELOP -> . exprRELOP relop exprSHIFT
    (84) exprRELOP -> . exprSHIFT
    (89) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (90) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (91) exprSHIFT -> . exprOP
    (92) exprOP -> . exprOP PLUS term
    (93) exprOP -> . exprOP MINUS term
    (94) exprOP -> . term
    (95) term -> . term MULTIPLY factor
    (96) term -> . term DIVIDE factor
    (97) term -> . term MOD factor
    (98) term -> . factor
    (99) factor -> . NOT factor
    (100) factor -> . PLUS factor
    (101) factor -> . MINUS factor
    (102) factor -> . PLUS_PLUS factor
    (103) factor -> . MINUS_MINUS factor
    (104) factor -> . brace
    (105) brace -> . L_PAREN expr R_PAREN
    (106) brace -> . brace PLUS_PLUS
    (107) brace -> . brace MINUS_MINUS
    (108) brace -> . INT_NUM
    (109) brace -> . FLOAT_NUM
    (110) brace -> . ID

    NOT             shift and go to state 35
    PLUS            shift and go to state 31
    MINUS           shift and go to state 33
    PLUS_PLUS       shift and go to state 36
    MINUS_MINUS     shift and go to state 37
    L_PAREN         shift and go to state 21
    INT_NUM         shift and go to state 18
    FLOAT_NUM       shift and go to state 39
    ID              shift and go to state 65

    expr                           shift and go to state 192
    exprOR                         shift and go to state 20
    exprAND                        shift and go to state 23
    exprBITOR                      shift and go to state 24
    exprBITXOR                     shift and go to state 25
    exprBITAND                     shift and go to state 26
    exprEQ                         shift and go to state 27
    exprRELOP                      shift and go to state 28
    exprSHIFT                      shift and go to state 29
    exprOP                         shift and go to state 30
    term                           shift and go to state 32
    factor                         shift and go to state 34
    brace                          shift and go to state 38

state 183

    (57) expr -> expr assignment ID L_PAREN call_params R_PAREN .

    SEMICOLON       reduce using rule 57 (expr -> expr assignment ID L_PAREN call_params R_PAREN .)
    ASSIGN          reduce using rule 57 (expr -> expr assignment ID L_PAREN call_params R_PAREN .)
    PLUS_ASSIGN     reduce using rule 57 (expr -> expr assignment ID L_PAREN call_params R_PAREN .)
    MINUS_ASSIGN    reduce using rule 57 (expr -> expr assignment ID L_PAREN call_params R_PAREN .)
    MUL_ASSIGN      reduce using rule 57 (expr -> expr assignment ID L_PAREN call_params R_PAREN .)
    DIV_ASSIGN      reduce using rule 57 (expr -> expr assignment ID L_PAREN call_params R_PAREN .)
    AND_ASSIGN      reduce using rule 57 (expr -> expr assignment ID L_PAREN call_params R_PAREN .)
    OR_ASSIGN       reduce using rule 57 (expr -> expr assignment ID L_PAREN call_params R_PAREN .)
    XOR_ASSIGN      reduce using rule 57 (expr -> expr assignment ID L_PAREN call_params R_PAREN .)
    MOD_ASSIGN      reduce using rule 57 (expr -> expr assignment ID L_PAREN call_params R_PAREN .)
    L_SHIFT_ASSIGN  reduce using rule 57 (expr -> expr assignment ID L_PAREN call_params R_PAREN .)
    R_SHIFT_ASSIGN  reduce using rule 57 (expr -> expr assignment ID L_PAREN call_params R_PAREN .)
    R_PAREN         reduce using rule 57 (expr -> expr assignment ID L_PAREN call_params R_PAREN .)
    COMMA           reduce using rule 57 (expr -> expr assignment ID L_PAREN call_params R_PAREN .)


state 184

    (48) yes_dec_params -> TYPE ID COMMA .

    TYPE            reduce using rule 48 (yes_dec_params -> TYPE ID COMMA .)


state 185

    (53) function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .

    IF              reduce using rule 53 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    WHILE           reduce using rule 53 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    FOR             reduce using rule 53 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    SEMICOLON       reduce using rule 53 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    RETURN          reduce using rule 53 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    L_FLOWBRACE     reduce using rule 53 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    TYPE            reduce using rule 53 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    ID              reduce using rule 53 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    NOT             reduce using rule 53 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    PLUS            reduce using rule 53 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    MINUS           reduce using rule 53 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    PLUS_PLUS       reduce using rule 53 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    MINUS_MINUS     reduce using rule 53 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    L_PAREN         reduce using rule 53 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    INT_NUM         reduce using rule 53 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    FLOAT_NUM       reduce using rule 53 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    $end            reduce using rule 53 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    R_FLOWBRACE     reduce using rule 53 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    ELSE            reduce using rule 53 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)


state 186

    (54) function_2 -> SEMICOLON .

    IF              reduce using rule 54 (function_2 -> SEMICOLON .)
    WHILE           reduce using rule 54 (function_2 -> SEMICOLON .)
    FOR             reduce using rule 54 (function_2 -> SEMICOLON .)
    SEMICOLON       reduce using rule 54 (function_2 -> SEMICOLON .)
    RETURN          reduce using rule 54 (function_2 -> SEMICOLON .)
    L_FLOWBRACE     reduce using rule 54 (function_2 -> SEMICOLON .)
    TYPE            reduce using rule 54 (function_2 -> SEMICOLON .)
    ID              reduce using rule 54 (function_2 -> SEMICOLON .)
    NOT             reduce using rule 54 (function_2 -> SEMICOLON .)
    PLUS            reduce using rule 54 (function_2 -> SEMICOLON .)
    MINUS           reduce using rule 54 (function_2 -> SEMICOLON .)
    PLUS_PLUS       reduce using rule 54 (function_2 -> SEMICOLON .)
    MINUS_MINUS     reduce using rule 54 (function_2 -> SEMICOLON .)
    L_PAREN         reduce using rule 54 (function_2 -> SEMICOLON .)
    INT_NUM         reduce using rule 54 (function_2 -> SEMICOLON .)
    FLOAT_NUM       reduce using rule 54 (function_2 -> SEMICOLON .)
    $end            reduce using rule 54 (function_2 -> SEMICOLON .)
    R_FLOWBRACE     reduce using rule 54 (function_2 -> SEMICOLON .)
    ELSE            reduce using rule 54 (function_2 -> SEMICOLON .)


state 187

    (55) function_2 -> block .

    IF              reduce using rule 55 (function_2 -> block .)
    WHILE           reduce using rule 55 (function_2 -> block .)
    FOR             reduce using rule 55 (function_2 -> block .)
    SEMICOLON       reduce using rule 55 (function_2 -> block .)
    RETURN          reduce using rule 55 (function_2 -> block .)
    L_FLOWBRACE     reduce using rule 55 (function_2 -> block .)
    TYPE            reduce using rule 55 (function_2 -> block .)
    ID              reduce using rule 55 (function_2 -> block .)
    NOT             reduce using rule 55 (function_2 -> block .)
    PLUS            reduce using rule 55 (function_2 -> block .)
    MINUS           reduce using rule 55 (function_2 -> block .)
    PLUS_PLUS       reduce using rule 55 (function_2 -> block .)
    MINUS_MINUS     reduce using rule 55 (function_2 -> block .)
    L_PAREN         reduce using rule 55 (function_2 -> block .)
    INT_NUM         reduce using rule 55 (function_2 -> block .)
    FLOAT_NUM       reduce using rule 55 (function_2 -> block .)
    $end            reduce using rule 55 (function_2 -> block .)
    R_FLOWBRACE     reduce using rule 55 (function_2 -> block .)
    ELSE            reduce using rule 55 (function_2 -> block .)


state 188

    (47) yes_dec_params -> yes_dec_params TYPE ID . COMMA
    (49) end_dec_params -> TYPE ID .

    COMMA           shift and go to state 193
    R_PAREN         reduce using rule 49 (end_dec_params -> TYPE ID .)


state 189

    (19) multi_declaration -> multi_declaration ID ASSIGN expr COMMA .

    ID              reduce using rule 19 (multi_declaration -> multi_declaration ID ASSIGN expr COMMA .)


state 190

    (23) stop -> ID ASSIGN expr SEMICOLON .

    IF              reduce using rule 23 (stop -> ID ASSIGN expr SEMICOLON .)
    WHILE           reduce using rule 23 (stop -> ID ASSIGN expr SEMICOLON .)
    FOR             reduce using rule 23 (stop -> ID ASSIGN expr SEMICOLON .)
    SEMICOLON       reduce using rule 23 (stop -> ID ASSIGN expr SEMICOLON .)
    RETURN          reduce using rule 23 (stop -> ID ASSIGN expr SEMICOLON .)
    L_FLOWBRACE     reduce using rule 23 (stop -> ID ASSIGN expr SEMICOLON .)
    TYPE            reduce using rule 23 (stop -> ID ASSIGN expr SEMICOLON .)
    ID              reduce using rule 23 (stop -> ID ASSIGN expr SEMICOLON .)
    NOT             reduce using rule 23 (stop -> ID ASSIGN expr SEMICOLON .)
    PLUS            reduce using rule 23 (stop -> ID ASSIGN expr SEMICOLON .)
    MINUS           reduce using rule 23 (stop -> ID ASSIGN expr SEMICOLON .)
    PLUS_PLUS       reduce using rule 23 (stop -> ID ASSIGN expr SEMICOLON .)
    MINUS_MINUS     reduce using rule 23 (stop -> ID ASSIGN expr SEMICOLON .)
    L_PAREN         reduce using rule 23 (stop -> ID ASSIGN expr SEMICOLON .)
    INT_NUM         reduce using rule 23 (stop -> ID ASSIGN expr SEMICOLON .)
    FLOAT_NUM       reduce using rule 23 (stop -> ID ASSIGN expr SEMICOLON .)
    $end            reduce using rule 23 (stop -> ID ASSIGN expr SEMICOLON .)
    R_FLOWBRACE     reduce using rule 23 (stop -> ID ASSIGN expr SEMICOLON .)
    ELSE            reduce using rule 23 (stop -> ID ASSIGN expr SEMICOLON .)


state 191

    (16) for_condition -> L_PAREN declaration expr SEMICOLON expr R_PAREN .

    IF              reduce using rule 16 (for_condition -> L_PAREN declaration expr SEMICOLON expr R_PAREN .)
    WHILE           reduce using rule 16 (for_condition -> L_PAREN declaration expr SEMICOLON expr R_PAREN .)
    FOR             reduce using rule 16 (for_condition -> L_PAREN declaration expr SEMICOLON expr R_PAREN .)
    SEMICOLON       reduce using rule 16 (for_condition -> L_PAREN declaration expr SEMICOLON expr R_PAREN .)
    RETURN          reduce using rule 16 (for_condition -> L_PAREN declaration expr SEMICOLON expr R_PAREN .)
    L_FLOWBRACE     reduce using rule 16 (for_condition -> L_PAREN declaration expr SEMICOLON expr R_PAREN .)
    TYPE            reduce using rule 16 (for_condition -> L_PAREN declaration expr SEMICOLON expr R_PAREN .)
    ID              reduce using rule 16 (for_condition -> L_PAREN declaration expr SEMICOLON expr R_PAREN .)
    NOT             reduce using rule 16 (for_condition -> L_PAREN declaration expr SEMICOLON expr R_PAREN .)
    PLUS            reduce using rule 16 (for_condition -> L_PAREN declaration expr SEMICOLON expr R_PAREN .)
    MINUS           reduce using rule 16 (for_condition -> L_PAREN declaration expr SEMICOLON expr R_PAREN .)
    PLUS_PLUS       reduce using rule 16 (for_condition -> L_PAREN declaration expr SEMICOLON expr R_PAREN .)
    MINUS_MINUS     reduce using rule 16 (for_condition -> L_PAREN declaration expr SEMICOLON expr R_PAREN .)
    L_PAREN         reduce using rule 16 (for_condition -> L_PAREN declaration expr SEMICOLON expr R_PAREN .)
    INT_NUM         reduce using rule 16 (for_condition -> L_PAREN declaration expr SEMICOLON expr R_PAREN .)
    FLOAT_NUM       reduce using rule 16 (for_condition -> L_PAREN declaration expr SEMICOLON expr R_PAREN .)


state 192

    (17) for_condition -> L_PAREN expr SEMICOLON expr SEMICOLON expr . R_PAREN
    (56) expr -> expr . assignment exprOR
    (57) expr -> expr . assignment ID L_PAREN call_params R_PAREN
    (59) assignment -> . ASSIGN
    (60) assignment -> . PLUS_ASSIGN
    (61) assignment -> . MINUS_ASSIGN
    (62) assignment -> . MUL_ASSIGN
    (63) assignment -> . DIV_ASSIGN
    (64) assignment -> . AND_ASSIGN
    (65) assignment -> . OR_ASSIGN
    (66) assignment -> . XOR_ASSIGN
    (67) assignment -> . MOD_ASSIGN
    (68) assignment -> . L_SHIFT_ASSIGN
    (69) assignment -> . R_SHIFT_ASSIGN

    R_PAREN         shift and go to state 194
    ASSIGN          shift and go to state 48
    PLUS_ASSIGN     shift and go to state 49
    MINUS_ASSIGN    shift and go to state 50
    MUL_ASSIGN      shift and go to state 51
    DIV_ASSIGN      shift and go to state 52
    AND_ASSIGN      shift and go to state 53
    OR_ASSIGN       shift and go to state 54
    XOR_ASSIGN      shift and go to state 55
    MOD_ASSIGN      shift and go to state 56
    L_SHIFT_ASSIGN  shift and go to state 57
    R_SHIFT_ASSIGN  shift and go to state 58

    assignment                     shift and go to state 47

state 193

    (47) yes_dec_params -> yes_dec_params TYPE ID COMMA .

    TYPE            reduce using rule 47 (yes_dec_params -> yes_dec_params TYPE ID COMMA .)


state 194

    (17) for_condition -> L_PAREN expr SEMICOLON expr SEMICOLON expr R_PAREN .

    IF              reduce using rule 17 (for_condition -> L_PAREN expr SEMICOLON expr SEMICOLON expr R_PAREN .)
    WHILE           reduce using rule 17 (for_condition -> L_PAREN expr SEMICOLON expr SEMICOLON expr R_PAREN .)
    FOR             reduce using rule 17 (for_condition -> L_PAREN expr SEMICOLON expr SEMICOLON expr R_PAREN .)
    SEMICOLON       reduce using rule 17 (for_condition -> L_PAREN expr SEMICOLON expr SEMICOLON expr R_PAREN .)
    RETURN          reduce using rule 17 (for_condition -> L_PAREN expr SEMICOLON expr SEMICOLON expr R_PAREN .)
    L_FLOWBRACE     reduce using rule 17 (for_condition -> L_PAREN expr SEMICOLON expr SEMICOLON expr R_PAREN .)
    TYPE            reduce using rule 17 (for_condition -> L_PAREN expr SEMICOLON expr SEMICOLON expr R_PAREN .)
    ID              reduce using rule 17 (for_condition -> L_PAREN expr SEMICOLON expr SEMICOLON expr R_PAREN .)
    NOT             reduce using rule 17 (for_condition -> L_PAREN expr SEMICOLON expr SEMICOLON expr R_PAREN .)
    PLUS            reduce using rule 17 (for_condition -> L_PAREN expr SEMICOLON expr SEMICOLON expr R_PAREN .)
    MINUS           reduce using rule 17 (for_condition -> L_PAREN expr SEMICOLON expr SEMICOLON expr R_PAREN .)
    PLUS_PLUS       reduce using rule 17 (for_condition -> L_PAREN expr SEMICOLON expr SEMICOLON expr R_PAREN .)
    MINUS_MINUS     reduce using rule 17 (for_condition -> L_PAREN expr SEMICOLON expr SEMICOLON expr R_PAREN .)
    L_PAREN         reduce using rule 17 (for_condition -> L_PAREN expr SEMICOLON expr SEMICOLON expr R_PAREN .)
    INT_NUM         reduce using rule 17 (for_condition -> L_PAREN expr SEMICOLON expr SEMICOLON expr R_PAREN .)
    FLOAT_NUM       reduce using rule 17 (for_condition -> L_PAREN expr SEMICOLON expr SEMICOLON expr R_PAREN .)

