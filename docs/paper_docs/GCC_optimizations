Optimizations levels and options in GCC:

Without optimization ==> compiler tries to reduce the cost of compilation and deliver the expected results.

With optimization ==> compiler attempts to improve performance and/or code size but at the cost of compile time.


Levels: /* the flags at each level are numerous and the ones given here do not cover all of them */

(each level turns on several flags)
(options of the form -fflag are machine independent options which are what we are interested in)


1) -O0

- most optimization are completely disabled at this level.

2) -O1 / -O

- compilation takes little more time
- takes a lot of memory for a large function
- tries to reduce code size and execution time at the cost of increasing the compile time as little as possible.

  flags:

       -fauto-inc-dec : combine increments or decrements of addresses with memory accesses.
       -fbranch-count-reg : optimization pass scanning for "decrement and branch" instructions instead of sequences that decrement a register, compare the result with 0 and then depending on the comparison result, branch.
       -fcombine-stack-adjustments :  Tracks pushes and pops and finds ways to combine them.
       -fdce : perform dead code elimination
       -fdefer-pop : allows the compiler to let arguments accumulate on the stack for several function calls and pop them all at once
       -fdelayed-branch : attempt to reorder instructions to exploit instruction slots available after delayed branch instructions.
       -fdse : performs dead store elimination.
       -fforward-propagate : Perform a forward propagation pass on RTL. The pass tries to combine two instructions and checks if the result can be simplified. If loop unrolling is active, two passes are performed and the second is scheduled after loop unrolling
       -fguess-branch-probability :  GCC uses heuristics to guess branch probabilities if they are not provided by profiling feedback (-fprofile-arcs).
       -fif-conversion : Attempt to transform conditional jumps into branch-less equivalents. This includes use of conditional moves, min, max, set flags and abs instructions, and some tricks doable by standard arithmetics.
       -fif-conversion2 : Use conditional execution (where available) to transform conditional jumps into branch-less equivalents
       -finline-functions-called-once : Consider all static functions called once for inlining into their caller even if they are not marked inline.
       -fipa-modref : This optimization analyzes the side effects of functions (memory locations that are modified or referenced) and enables better optimization across the function call boundary.
       -fipa-profile : Cold functions and loop less parts of functions executed once are optimized for size.
       -fipa-pure-const : Discover which functions are pure or constant.
       -fipa-reference : Discover which static variables do not escape the compilation unit.
       -fipa-reference-addressable : Discover read-only, write-only and non-addressable static variables.
       -fmerge-constants : Attempt to merge identical constants (string constants and floating-point constants) across compilation units.
       -fomit-frame-pointer : Omit the frame pointer in functions that donâ€™t need one. This avoids the instructions to save, set up and restore the frame pointer; on many targets it also makes an extra register available.
       -freorder-blocks : Reorder basic blocks in the compiled function in order to reduce number of taken branches and improve code locality.
       -fsplit-wide-types : When using a type that occupies multiple registers, such as long long on a 32-bit system, split the registers apart and allocate them independently.
       -fssa-backprop : Propagate information about uses of a value up the definition chain in order to simplify the definitions. For example, this pass strips sign operations if the sign of a value never matters.
       -fssa-phiopt : Perform pattern matching on SSA PHI nodes to optimize conditional code.
       -ftree-bit-ccp : Perform sparse conditional bit constant propagation on trees and propagate pointer alignment information.
       -ftree-ccp : Perform sparse conditional constant propagation (CCP) on trees.
       -ftree-ch : Perform loop header copying on trees. This is beneficial since it increases effectiveness of code motion optimizations. It also saves one jump.
       -ftree-coalesce-vars : While transforming the program out of the SSA representation, attempt to reduce copying by coalescing versions of different user-defined variables, instead of just compiler temporaries.
       -ftree-copy-prop : Perform copy propagation on trees. This pass eliminates unnecessary copy operations.
       -ftree-dce : Perform dead code elimination (DCE) on trees.
       -ftree-dominator-opts : Perform a variety of simple scalar cleanups (constant/copy propagation, redundancy elimination, range propagation and expression simplification) based on a dominator tree traversal. This also performs jump threading (to reduce jumps to jumps).
       -ftree-dse : Perform dead store elimination (DSE) on trees. A dead store is a store into a memory location that is later overwritten by another store without any intervening loads. In this case the earlier store can be deleted.
       -ftree-forwprop : Perform forward propagation on trees.
       -funit-at-a-time : implies top level reordering is enabled.

3) -O2

-perform all optimizationsm that do not involve a space-speed tradeoff
-All flags that are turned on in the -o option along with others.

  flags:

      -falign-functions  :  Align the start of functions to the next power-of-two greater than or equal to n, skipping up to m-1 bytes. This ensures that at least the first m bytes of the function can be fetched by the CPU without crossing an n-byte alignment boundary.
      -falign-jumps  : Align branch targets to a power-of-two boundary, for branch targets where the targets can only be reached by jumping. In this case, no dummy operations need be executed.
      -falign-labels  : Align all branch targets to a power-of-two boundary.
      -falign-loops : Align loops to a power-of-two boundary. If the loops are executed many times, this makes up for any execution of the dummy padding instructions.
      -fcaller-saves : Enable allocation of values to registers that are clobbered by function calls, by emitting extra instructions to save and restore the registers around such calls. Such allocation is done only when it seems to result in better code.
      -fcode-hoisting : Perform code hoisting. Code hoisting tries to move the evaluation of expressions executed on all paths to the function exit as early as possible. This is especially useful as a code size optimization, but it often helps for code speed as well.
      -fcrossjumping : This transformation unifies equivalent code and saves code size. The resulting code may or may not perform better than without cross-jumping.
      -fcse-follow-jumps :  In common subexpression elimination (CSE), scan through jump instructions when the target of the jump is not reached by any other path. For example, when CSE encounters an if statement with an else clause, CSE follows the jump when the condition tested is false.
      -fcse-skip-blocks : This is similar to -fcse-follow-jumps, but causes CSE to follow jumps that conditionally skip over blocks.
      -fdelete-null-pointer-checks : eliminate useless checks for null pointers
      -fdevirtualize : Attempt to convert calls to virtual functions to direct calls.
      -fdevirtualize-speculatively : Attempt to convert calls to virtual functions to speculative direct calls.
      -fexpensive-optimizations : Perform a number of minor optimizations that are relatively expensive
      -ffinite-loops : Assume that a loop with an exit will eventually take the exit and not loop indefinitely. This allows the compiler to remove loops that otherwise have no side-effects, not considering eventual endless looping as such.

4) -O3

-optimize yet more
-builds on o2

flags:

      -fgcse-after-reload
      -fipa-cp-clone
      -floop-interchange
      -floop-unroll-and-jam
      -fpeel-loops
      -fpredictive-commoning
      -fsplit-loops
      -fsplit-paths
      -ftree-loop-distribution
      -ftree-loop-vectorize
      -ftree-partial-pre
      -ftree-slp-vectorize
      -funswitch-loops
      -fvect-cost-model
      -fvect-cost-model=dynamic
      -fversion-loops-for-strides


other optimization options:

-Os : optimize for size
-Ofast : all o3 optimizations along with ones that are not valid for all standard compliant programs
-Og : optimize debugging experience. offering a reasonable level of optimization while maintaining fast compilation and a good debugging experience. It is a better choice than -O0 for producing debuggable code because some compiler passes that collect debug information are disabled at -O0.



/* GCC optimizations VS Bentley's rules */

  our observations:

  1. Slight overlap between optimizations done by gcc and those suggested by Jon bentley. Especially in the category of loops.
     Examples : loop unrolling, jamming. Also dead code elimination, code motion, code hoisting.

  2. However many of GCC optimizations are to do with lower levels. Such as optimizations of stack operations, register usage , function inlining, memory allocation etc.

  3. Bentley's Rules on the other hand, are more to do with the higher level structure of code. They relate more to how programmers view code rather than how the machine views it.

  4. Implementing Bentley's rules may in turn lead to better optimization at the lower level.

  5. Many rules not implemented by gcc compilers. Examples : Tail end recursion elimination, Combining of tests, Reordering of tests, Short-Circuiting etc.
