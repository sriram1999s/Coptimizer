Index: if_switch/code/parser_file.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from lexer_file import *\r\nfrom ply.yacc import yacc\r\n\r\nfrom regenerator import *\r\nfrom loop_unrolling import *\r\nfrom function_inline import *\r\n\r\n\r\n# --------------------------------parser------------------------------------ #\r\n\r\n# defining precedence of operators\r\n# precedence = (\r\n#     ('left', 'PLUS', 'MINUS'),\r\n#     ('left', 'MULTIPLY', 'DIVIDE')\r\n# )\r\n\r\n# start = 'start'\r\ndef p_start(p):\r\n    '''\r\n    start : multiple_statements\r\n    '''\r\n    p[0] = p[1]\r\n\r\n\r\ndef p_multiple_statements(p):\r\n    '''\r\n    multiple_statements : multiple_statements statement\r\n                        | statement\r\n    '''\r\n    if (len(p) == 3):\r\n        p[0] = p[1] + [p[2]]\r\n    else:\r\n        p[0] = p[1]\r\n\r\n\r\ndef p_statement(p):\r\n    '''\r\n    statement : open\r\n              | closed\r\n    '''\r\n    p[0] = p[1]\r\n\r\n\r\ndef p_open(p):\r\n    '''\r\n    open : IF condition statement\r\n         | IF condition closed ELSE open\r\n         | WHILE condition open\r\n         | FOR for_condition open\r\n    '''\r\n    if (len(p) == 4):\r\n        p[0] = [' ', p[1], p[2], '{', p[3], '}']\r\n\r\n    else:\r\n        p[0] = [' ', p[1], [p[2], '{', p[3], '}'], p[4], ' ', '{', p[5], '}']\r\n\r\n\r\ndef p_closed(p):\r\n    '''\r\n    closed : simple\r\n           | block\r\n           | IF condition closed ELSE closed\r\n           | WHILE condition closed\r\n           | FOR for_condition closed\r\n    '''\r\n    if (len(p) == 2):\r\n        p[0] = p[1]\r\n\r\n    elif (len(p) == 4):\r\n        if (p[1] == 'for'):\r\n            print(\"for detected\")\r\n            p[0] = for_unroll_validate([p[1], p[2], p[3]])\r\n        else:\r\n            print(\"while detected\")\r\n            p[0] = [p[1], p[2], p[3]]\r\n\r\n    else:\r\n        p[0] = [' ', p[1], [p[2], '{', p[3], '}'], p[4], ' ', '{', p[5], '}']\r\n\r\n\r\ndef p_condition(p):\r\n    '''\r\n    condition : L_PAREN expr R_PAREN\r\n    '''\r\n    p[0] = [p[1], p[2], p[3]]\r\n\r\n\r\ndef p_for_condition(p):\r\n    '''\r\n    for_condition : L_PAREN declaration expr SEMICOLON expr R_PAREN\r\n                | L_PAREN expr SEMICOLON expr SEMICOLON expr R_PAREN\r\n    '''\r\n    if (len(p) == 7):\r\n        p[0] = [p[1], p[2], p[3], p[4], p[5], p[6]]\r\n    else:\r\n        p[0] = [p[1], p[2], p[3], p[4], p[5], p[6], p[7]]\r\n\r\n\r\ndef p_multi_declaration(p):\r\n    '''\r\n    multi_declaration : multi_declaration ID COMMA\r\n    \t\t      | multi_declaration ID ASSIGN expr COMMA\r\n\t\t      | ID COMMA\r\n    \t\t      | ID ASSIGN expr COMMA\r\n    '''\r\n    if (len(p) == 3):\r\n        p[0] = [p[1], p[2]]\r\n    elif (len(p) == 4):\r\n        p[0] = p[1] + [p[2], p[3]]\r\n    elif (len(p) == 6):\r\n        p[0] = p[1] + [p[2], p[3], p[4], p[5]]\r\n    else:\r\n        p[0] = [p[1], p[2], p[3], p[4]]\r\n\r\n\r\ndef p_stop(p):\r\n    '''\r\n     stop : ID SEMICOLON\r\n\t      | ID ASSIGN expr SEMICOLON\r\n     '''\r\n    if (len(p) == 3):\r\n        p[0] = [p[1], p[2]]\r\n    else:\r\n        p[0] = [p[1], p[2], p[3], p[4]]\r\n\r\n\r\ndef p_declaration(p):\r\n    '''\r\n    declaration : TYPE ID SEMICOLON\r\n                | TYPE ID ASSIGN expr SEMICOLON\r\n                | TYPE ID ASSIGN ID L_PAREN call_params R_PAREN SEMICOLON\r\n\t\t        | TYPE multi_declaration stop\r\n    '''\r\n    if (len(p) == 4):\r\n        p[0] = [p[1], p[2], p[3]]\r\n    elif (len(p) == 9):\r\n        p[0] = [p[1], p[2], p[3], p[4], p[5], p[6], p[7], p[8]]\r\n        call_helper(p[0], p[4])\r\n        p[0] = [(p[4], p[0][3:7], \"call\", p[1], p[2])]\r\n    else:\r\n        p[0] = [p[1], p[2], p[3], p[4], p[5]]\r\n\r\n\r\ndef p_block(p):\r\n    '''\r\n    block : L_FLOWBRACE multiple_statements R_FLOWBRACE\r\n    '''\r\n    p[0] = [p[1], p[2], p[3]]\r\n\r\n\r\ndef p_simple(p):\r\n    '''\r\n    simple : expr SEMICOLON\r\n           | declaration\r\n           | SEMICOLON\r\n\t       | function\r\n\t       | function_call\r\n\t       | RETURN ID SEMICOLON\r\n\t       | RETURN INT_NUM SEMICOLON\r\n           | RETURN ID L_PAREN call_params R_PAREN SEMICOLON\r\n           | RETURN SEMICOLON\r\n    '''\r\n    if (len(p) == 3):\r\n        if (p[1] != \"return\"):\r\n            p[1].append(';')\r\n            p[0] = [p[1]]\r\n        else:\r\n            p[0] = [p[1], p[2]]\r\n    elif (len(p) == 7):\r\n        p[0] = [p[1], p[2], p[3], p[4], p[5], p[6]]\r\n        call_helper(p[0], p[2])\r\n        p[0] = [(p[2], [p[2], p[3], p[4], p[5], p[6]], \"call\", \"ret\", \"ret\", \"return\")]\r\n    elif (len(p) == 4):\r\n        p[0] = [p[1], p[2], p[3]]\r\n    else:\r\n        p[0] = p[1]\r\n\r\n\r\ndef p_empty(p):\r\n    'empty :'\r\n    p[0] = []\r\n\r\n\r\ndef p_function_call(p):\r\n    '''\r\n    function_call : ID L_PAREN call_params R_PAREN SEMICOLON\r\n    '''\r\n    if (len(p) == 6):\r\n        p[0] = [p[1], p[2], p[3], p[4], p[5]]\r\n        call_helper(p[0], p[1])\r\n        p[0] = [(p[1], p[0], 'call')]\r\n\r\n\r\ndef p_call_params(p):\r\n    '''\r\n    \tcall_params : empty\r\n\t\t            | yes_call_params end_call_params\r\n\t\t            | end_call_params\r\n    '''\r\n    if (len(p) == 3):\r\n        p[0] = p[1] + [p[2]]\r\n    elif (len(p) == 2):\r\n        p[0] = p[1]\r\n\r\n\r\ndef p_yes_call_params(p):\r\n    '''\r\n    yes_call_params : yes_call_params expr COMMA\r\n                    | expr COMMA\r\n    '''\r\n    if (len(p) == 3):\r\n        p[0] = [p[1], p[2]]\r\n    else:\r\n        p[0] = p[1] + [p[2], p[3]]\r\n\r\n\r\ndef p_end_call_params(p):\r\n    '''\r\n    end_call_params : expr\r\n    '''\r\n    p[0] = p[1]\r\n\r\n\r\ndef p_yes_dec_params(p):\r\n    '''\r\n    yes_dec_params : yes_dec_params TYPE ID COMMA\r\n               | yes_dec_params TYPE COMMA\r\n           | yes_dec_params TYPE ID ASSIGN NUM COMMA\r\n                   | TYPE ID COMMA\r\n              | TYPE COMMA\r\n           | TYPE ID ASSIGN NUM COMMA\r\n    '''\r\n    if (len(p) == 5):\r\n        p[0] = p[1] + [p[2], p[3], p[4]]\r\n    elif (len(p) == 4):\r\n        p[0] = [p[1], p[2], p[3]]\r\n    elif (len(p) == 7):\r\n        p[0] = [p[1], p[2], p[3], p[4], p[5], p[6]]\r\n    elif (len(p) == 3):\r\n        p[0] = [p[1], p[2]]\r\n    else:\r\n        p[0] = [p[1], p[2], p[3], p[4], p[5]]\r\n\r\n\r\ndef p_end_dec_params(p):\r\n    '''\r\n    end_dec_params : TYPE ID\r\n           | TYPE ID ASSIGN NUM\r\n           | TYPE\r\n    '''\r\n    if (len(p) == 3):\r\n        p[0] = [p[1], p[2]]\r\n    elif (len(p) == 5):\r\n        p[0] = [p[1], p[2], p[3], p[4]]\r\n    else:\r\n        p[0] = p[1]\r\n\r\n\r\ndef p_dec_params(p):\r\n    '''\r\n    dec_params : empty\r\n\t       | yes_dec_params end_dec_params\r\n\t       | end_dec_params\r\n    '''\r\n    if (len(p) == 3):\r\n        p[0] = [p[1], p[2]]\r\n    elif (len(p) == 2):\r\n        p[0] = p[1]\r\n\r\n\r\ndef p_function(p):\r\n    '''\r\n    function : TYPE ID L_PAREN dec_params R_PAREN function_2\r\n    '''\r\n    p[0] = [p[1], p[2], p[3], p[4], p[5], p[6]]\r\n    if p[2] != 'main':\r\n        if (p[6][0] != ';'):\r\n            temp = inline_defn_helper(p[0], p[2])\r\n            if type(temp) is tuple:\r\n                p[0] = [temp]\r\n            else:  # check\r\n                p[0] = []\r\n\r\n\r\ndef p_function_2(p):\r\n    '''\r\n    function_2 : SEMICOLON\r\n    \t       | block\r\n    '''\r\n    p[0] = [p[1]]\r\n\r\n\r\ndef p_expr(p):\r\n    '''\r\n    expr : expr assignment exprOR\r\n         | expr assignment ID L_PAREN call_params R_PAREN\r\n         | exprOR\r\n    '''\r\n    if (len(p) == 4):\r\n        p[0] = [p[1], p[2], p[3]]\r\n    elif (len(p) == 7):\r\n        p[0] = [p[1], p[2], p[3], p[4], p[5], p[6]]\r\n        call_helper(p[0], p[3])\r\n        p[0] = [(p[3], p[0][2:], \"call\", p[1])]\r\n    else:\r\n        p[0] = p[1]\r\n\r\n\r\ndef p_assignment(p):\r\n    '''\r\n    assignment : ASSIGN\r\n               | PLUS_ASSIGN\r\n               | MINUS_ASSIGN\r\n               | MUL_ASSIGN\r\n               | DIV_ASSIGN\r\n               | AND_ASSIGN\r\n               | OR_ASSIGN\r\n               | XOR_ASSIGN\r\n               | MOD_ASSIGN\r\n               | L_SHIFT_ASSIGN\r\n               | R_SHIFT_ASSIGN\r\n    '''\r\n    p[0] = p[1]\r\n\r\n\r\ndef p_exprOR(p):\r\n    '''\r\n    exprOR : exprOR OR exprAND\r\n           | exprAND\r\n    '''\r\n    if (len(p) == 4):\r\n        p[0] = [p[1], p[2], p[3]]\r\n    else:\r\n        p[0] = p[1]\r\n\r\n\r\ndef p_exprAND(p):\r\n    '''\r\n    exprAND : exprAND AND exprBITOR\r\n            | exprBITOR\r\n    '''\r\n    if (len(p) == 4):\r\n        p[0] = [p[1], p[2], p[3]]\r\n    else:\r\n        p[0] = p[1]\r\n\r\n\r\ndef p_exprBITOR(p):\r\n    '''\r\n    exprBITOR : exprBITOR BIT_OR exprBITXOR\r\n              | exprBITXOR\r\n    '''\r\n    if (len(p) == 4):\r\n        p[0] = [p[1], p[2], p[3]]\r\n    else:\r\n        p[0] = p[1]\r\n\r\n\r\ndef p_exprBITXOR(p):\r\n    '''\r\n    exprBITXOR : exprBITXOR BIT_XOR exprBITAND\r\n               | exprBITAND\r\n    '''\r\n    if (len(p) == 4):\r\n        p[0] = [p[1], p[2], p[3]]\r\n    else:\r\n        p[0] = p[1]\r\n\r\n\r\ndef p_exprBITAND(p):\r\n    '''\r\n    exprBITAND : exprBITAND BIT_AND exprEQ\r\n               | exprEQ\r\n    '''\r\n    if (len(p) == 4):\r\n        p[0] = [p[1], p[2], p[3]]\r\n    else:\r\n        p[0] = p[1]\r\n\r\n\r\ndef p_exprEQ(p):\r\n    '''\r\n    exprEQ : exprEQ EQ exprRELOP\r\n           | exprEQ NE exprRELOP\r\n           | exprRELOP\r\n    '''\r\n    if (len(p) == 4):\r\n        p[0] = [p[1], p[2], p[3]]\r\n    else:\r\n        p[0] = p[1]\r\n\r\n\r\ndef p_exprRELOP(p):\r\n    '''\r\n    exprRELOP : exprRELOP relop exprSHIFT\r\n              | exprSHIFT\r\n    '''\r\n    if (len(p) == 4):\r\n        p[0] = [p[1], p[2], p[3]]\r\n    else:\r\n        p[0] = p[1]\r\n\r\n\r\ndef p_relop(p):\r\n    '''\r\n    relop : LE\r\n          | LT\r\n          | GE\r\n          | GT\r\n    '''\r\n    p[0] = p[1]\r\n\r\n\r\ndef p_exprSHIFT(p):\r\n    '''\r\n    exprSHIFT : exprSHIFT L_SHIFT exprOP\r\n              | exprSHIFT R_SHIFT exprOP\r\n              | exprOP\r\n    '''\r\n    if (len(p) == 4):\r\n        p[0] = [p[1], p[2], p[3]]\r\n    else:\r\n        p[0] = p[1]\r\n\r\n\r\ndef p_exprOP(p):\r\n    '''\r\n    exprOP : exprOP PLUS term\r\n         | exprOP MINUS term\r\n         | term\r\n    '''\r\n    if (len(p) == 4):\r\n        p[0] = [p[1], p[2], p[3]]\r\n    else:\r\n        p[0] = p[1]\r\n\r\n\r\ndef p_term(p):\r\n    '''\r\n    term : term MULTIPLY factor\r\n         | term DIVIDE factor\r\n         | term MOD factor\r\n         | factor\r\n    '''\r\n    if (len(p) == 4):\r\n        p[0] = [p[1], p[2], p[3]]\r\n    else:\r\n        p[0] = p[1]\r\n\r\n\r\ndef p_factor(p):\r\n    '''\r\n    factor : NOT factor\r\n           | PLUS factor\r\n           | MINUS factor\r\n           | PLUS_PLUS factor\r\n           | MINUS_MINUS factor\r\n           | brace\r\n    '''\r\n    if (len(p) == 3):\r\n        p[0] = [p[1], p[2]]\r\n    else:\r\n        p[0] = p[1]\r\n\r\n\r\ndef p_brace(p):\r\n    '''\r\n    brace  : L_PAREN expr R_PAREN\r\n           | brace PLUS_PLUS\r\n           | brace MINUS_MINUS\r\n           | NUM\r\n           | ID\r\n    '''\r\n    if (len(p) == 4):\r\n        p[0] = [p[1], p[2], p[3]]\r\n    elif (len(p) == 3):\r\n        p[0] = [p[1], p[2]]\r\n    else:\r\n        p[0] = p[1]\r\n\r\n\r\ndef p_NUM(p):\r\n    '''\r\n    NUM : INT_NUM\r\n    | FLOAT_NUM\r\n    '''\r\n    p[0] = p[1]\r\n\r\n# def p_error(p):\r\n#   print('ERROR!!')
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/if_switch/code/parser_file.py b/if_switch/code/parser_file.py
--- a/if_switch/code/parser_file.py	(revision b26bb3c3327922fb1661b060ad4530782e55c5e7)
+++ b/if_switch/code/parser_file.py	(date 1617438289037)
@@ -3,7 +3,9 @@
 
 from regenerator import *
 from loop_unrolling import *
-from function_inline import *
+from symboltable import *
+from compile_time_init import *
+from collections import defaultdict
 
 
 # --------------------------------parser------------------------------------ #
@@ -19,6 +21,19 @@
     '''
     start : multiple_statements
     '''
+    print('printing symbol table....')
+    for i in symbol_table:
+        if (symbol_table[i] != 'garbage'):
+            print(f"\t{i}------->{symbol_table[i]}")
+    print('printing array hashmap....')
+    for i in array_hashmap:
+        if (array_hashmap[i] != -1):
+            print(f'\t{i}-------->{array_hashmap[i]}')
+
+    print('printing array values....')
+    for i in array_value:
+        if (array_value[i] != -1):
+            print(f'\t{i}-------->{array_value[i]}')
     p[0] = p[1]
 
 
@@ -48,12 +63,30 @@
          | WHILE condition open
          | FOR for_condition open
     '''
+    # if (len(p) == 4):
+    #     p[0] = [p[1], p[2], p[3]]
+    #     lookahead(0, len(p[3]), p[3])
+    # else:
+    #     p[0] = [p[1], [p[2], p[3]], p[4], p[5]]
+    #     lookahead(0, len(p[3]), p[3])
+    #     lookahead(0, len(p[5]), p[5])
+
+    # if (len(p) == 4):
+    #     p[0] = [[' '], p[1], p[2], ['{'], p[3], ['}']]
+    #     lookahead(0, len(p[3]), p[3])
+    #
+    # else:
+    #     p[0] = [[' '], p[1], [p[2], ['{'], p[3], ['}']], p[4], [' '], ['{'], p[5], ['}']]
+    #     lookahead(0, len(p[3]), p[3])
+    #     lookahead(0, len(p[5]), p[5])
     if (len(p) == 4):
         p[0] = [' ', p[1], p[2], '{', p[3], '}']
+        lookahead(0, len(p[3]), p[3])
 
     else:
         p[0] = [' ', p[1], [p[2], '{', p[3], '}'], p[4], ' ', '{', p[5], '}']
-
+        lookahead(0, len(p[3]), p[3])
+        lookahead(0, len(p[5]), p[5])
 
 def p_closed(p):
     '''
@@ -65,18 +98,25 @@
     '''
     if (len(p) == 2):
         p[0] = p[1]
-
     elif (len(p) == 4):
         if (p[1] == 'for'):
-            print("for detected")
+            print("for detected\n")
+            compile_init_validate([p[1], p[2], p[3]])
             p[0] = for_unroll_validate([p[1], p[2], p[3]])
+            lookahead(0, len(p[3]), p[3])
         else:
-            print("while detected")
+            print("while detected\n")
             p[0] = [p[1], p[2], p[3]]
-
+            lookahead(0, len(p[3]), p[3])
     else:
+        # p[0] = [p[1], [p[2], p[3]], p[4], p[5]]
+
+        # p[0] = [[' '], p[1], [p[2], ['{'], p[3], ['}']], p[4], [' ', '{'], p[5], ['}']]
         p[0] = [' ', p[1], [p[2], '{', p[3], '}'], p[4], ' ', '{', p[5], '}']
 
+        lookahead(0, len(p[3]), p[3])
+        lookahead(0, len(p[5]), p[5])
+
 
 def p_condition(p):
     '''
@@ -87,95 +127,239 @@
 
 def p_for_condition(p):
     '''
-    for_condition : L_PAREN declaration expr SEMICOLON expr R_PAREN
-                | L_PAREN expr SEMICOLON expr SEMICOLON expr R_PAREN
+    for_condition : L_PAREN simple simple expr R_PAREN
+                  | L_PAREN simple simple R_PAREN
     '''
-    if (len(p) == 7):
-        p[0] = [p[1], p[2], p[3], p[4], p[5], p[6]]
+    if (len(p) == 6):
+        if (p[2] != ';' and p[3] != ';'):
+            ids = dict()
+            find_id(0, len(p[3]), p[3], ids)
+            loop_var = list(ids.keys())[0]
+            solve_substi_id(0, len(p[2]), p[2], [loop_var])
+        p[0] = [p[1], p[2], p[3], p[4], p[5]]
     else:
-        p[0] = [p[1], p[2], p[3], p[4], p[5], p[6], p[7]]
+        p[0] = [p[1], p[2], p[3], p[4]]
 
 
 def p_multi_declaration(p):
     '''
     multi_declaration : multi_declaration ID COMMA
-    		      | multi_declaration ID ASSIGN expr COMMA
-		      | ID COMMA
-    		      | ID ASSIGN expr COMMA
+                      | multi_declaration MULTIPLY ID COMMA
+    		          | multi_declaration ID ASSIGN expr COMMA
+                      | multi_declaration MULTIPLY ID ASSIGN expr COMMA
+		              | ID COMMA
+    		          | ID ASSIGN expr COMMA
+                      | MULTIPLY ID COMMA
+                      | MULTIPLY ID ASSIGN expr COMMA
     '''
     if (len(p) == 3):
         p[0] = [p[1], p[2]]
     elif (len(p) == 4):
-        p[0] = p[1] + [p[2], p[3]]
+        if (p[1] == '*'):
+            p[0] = [p[1], p[2], p[3]]
+        else:
+            p[0] = p[1] + [p[2], p[3]]
+    elif (len(p) == 5):
+        # p[0] = p[1] + [p[2], p[3], p[4]]
+
+        p[0] = [p[1]] + [p[2], p[3], p[4]]
+
     elif (len(p) == 6):
-        p[0] = p[1] + [p[2], p[3], p[4], p[5]]
+        if (p[1] == '*'):
+            p[0] = [p[1], p[2], p[3], p[4], p[5]]
+        else:
+            p[0] = p[1] + [p[2], p[3], p[4], p[5]]
+    elif (len(p) == 7):
+        p[0] = p[1] + [p[2], p[3], p[4], p[5], p[6]]
     else:
         p[0] = [p[1], p[2], p[3], p[4]]
 
 
 def p_stop(p):
     '''
-     stop : ID SEMICOLON
-	      | ID ASSIGN expr SEMICOLON
-     '''
+    stop : ID SEMICOLON
+         | MULTIPLY ID SEMICOLON
+         | ID ASSIGN expr SEMICOLON
+         | MULTIPLY ID ASSIGN expr SEMICOLON
+    '''
     if (len(p) == 3):
         p[0] = [p[1], p[2]]
-    else:
+    elif (len(p) == 4):
+        p[0] = [p[1], p[2], p[3]]
+    elif (len(p) == 5):
         p[0] = [p[1], p[2], p[3], p[4]]
+    else:
+        p[0] = [p[1], p[2], p[3], p[4], p[5]]
 
 
 def p_declaration(p):
     '''
     declaration : TYPE ID SEMICOLON
+                | TYPE MULTIPLY ID SEMICOLON
                 | TYPE ID ASSIGN expr SEMICOLON
-                | TYPE ID ASSIGN ID L_PAREN call_params R_PAREN SEMICOLON
+                | TYPE MULTIPLY ID ASSIGN expr SEMICOLON
 		        | TYPE multi_declaration stop
+    			| TYPE ID L_SQBRACE index R_SQBRACE SEMICOLON
+    			| TYPE ID L_SQBRACE index R_SQBRACE ASSIGN L_FLOWBRACE init_list R_FLOWBRACE SEMICOLON
+
     '''
+    global level
+    global level_str
+    global symbol_table
+
+    if (p[2] == "*"):
+        search_string = '*' + p[3] + '_'.join(level_str)
+        if (p[4] == '='):
+            if (type(p[5]) == str):
+                dynamic_string = '*' + p[5] + '_'.join(level_str)
+                copy_level_str = level_str.copy()
+                while (symbol_table[dynamic_string] == 'garbage' and len(copy_level_str) > 1):
+                    copy_level_str.pop()
+                    dynamic_string = '*' + p[5] + '_'.join(copy_level_str)
+                if (symbol_table[dynamic_string] != 'garbage' and symbol_table[dynamic_string] != 'declared'):
+                    symbol_table[search_string] = symbol_table[dynamic_string]
+                else:
+                    symbol_table[search_string] = p[5]
+            else:
+                temp = []
+                solve(0, len(p[5]), p[5], temp)
+                rhs = ''.join(temp).strip('&')
+                dynamic_string = rhs + '_'.join(level_str)
+                copy_level_str = level_str.copy()
+                while (symbol_table[dynamic_string] == 'garbage' and len(copy_level_str) > 1):
+                    copy_level_str.pop()
+                    dynamic_string = rhs + '_'.join(copy_level_str)
+                if (symbol_table[dynamic_string] != 'garbage' and symbol_table[dynamic_string] != 'declared'):
+                    if (re.search(r'(?:\d+\.\d+)|(?:\d+)|(?:".*?")|(?:\'.\')', str(symbol_table[dynamic_string]))):
+                        symbol_table[search_string] = rhs
+                    else:
+                        symbol_table[search_string] = symbol_table[dynamic_string]
+                else:
+                    symbol_table[search_string] = rhs
+
+        elif (p[4] == ';'):
+            symbol_table[search_string] = 'declared'
+
+        if (symbol_table[search_string] != 'garbage' and symbol_table[search_string] != 'declared'):
+            for var in symbol_table:
+                if (symbol_table[var] == p[3]):
+                    symbol_table[var] = symbol_table[search_string]
+
+    elif (type(p[2]) == str):
+        if (p[3] == '='):
+            search_string = p[2] + '_'.join(level_str)
+            if (type(p[4]) == int):
+                symbol_table[search_string] = p[4]
+            elif (type(p[4]) == str and re.search(r'[A-Za-z_][A-Za-z_0-9]*', p[4])):
+                dynamic_string = p[4] + '_'.join(level_str)
+                copy_level_str = level_str.copy()
+                while (symbol_table[dynamic_string] == 'garbage' and len(copy_level_str) > 1):
+                    copy_level_str.pop()
+                    dynamic_string = p[4] + '_'.join(copy_level_str)
+                if (symbol_table[dynamic_string] != 'garbage' and symbol_table[dynamic_string] != 'declared'):
+                    symbol_table[search_string] = symbol_table[dynamic_string]
+                else:
+                    symbol_table[search_string] = p[4]
+            else:
+                symbol_table[search_string] = p[4]
+
+            if (symbol_table[search_string] != 'garbage' and symbol_table[search_string] != 'declared'):
+                for var in symbol_table:
+                    if (symbol_table[var] == p[2]):
+                        symbol_table[var] = symbol_table[search_string]
+
+
+
+        elif (p[3] == ';'):
+            symbol_table[p[2] + '_'.join(level_str)] = 'declared'
+
     if (len(p) == 4):
         p[0] = [p[1], p[2], p[3]]
-    elif (len(p) == 9):
-        p[0] = [p[1], p[2], p[3], p[4], p[5], p[6], p[7], p[8]]
-        call_helper(p[0], p[4])
-        p[0] = [(p[4], p[0][3:7], "call", p[1], p[2])]
-    else:
+    if (len(p) == 5):
+        p[0] = [p[1], p[2], p[3], p[4]]
+    if (len(p) == 6):
         p[0] = [p[1], p[2], p[3], p[4], p[5]]
+    if (len(p) == 7):
+        p[0] = [p[1], p[2], p[3], p[4], p[5], p[6]]
+        if (p[3] == '['):
+            add_array(p[0])
+    if (len(p) == 11):
+        p[0] = [p[1], p[2], p[3], p[4], p[5], p[6], p[7], p[8], p[9], p[10]]
+
+
+def p_init_list(p):
+    '''
+    init_list : expr COMMA init_list
+    	      | expr
+    '''
+    if (len(p) == 4):
+        p[0] = [p[1], p[2], p[3]]
+    if (len(p) == 2):
+        p[0] = [p[1]]
+
+
+def p_index(p):
+    '''
+    index : expr
+    	    | empty
+    '''
+    if (p[1] != None):
+        p[0] = p[1]
 
 
 def p_block(p):
     '''
-    block : L_FLOWBRACE multiple_statements R_FLOWBRACE
+    block : left_flower multiple_statements right_flower
     '''
     p[0] = [p[1], p[2], p[3]]
 
 
+def p_left_flower(p):
+    '''
+    left_flower : L_FLOWBRACE
+    '''
+    global level
+    global level_str
+    level = '%'
+    level_str.append(level)
+    p[0] = p[1]
+
+
+def p_right_flower(p):
+    '''
+    right_flower : R_FLOWBRACE
+    '''
+    global level
+    global level_str
+    level_str.pop()
+    p[0] = p[1]
+
+
 def p_simple(p):
     '''
     simple : expr SEMICOLON
+	   | header
            | declaration
            | SEMICOLON
 	       | function
-	       | function_call
-	       | RETURN ID SEMICOLON
-	       | RETURN INT_NUM SEMICOLON
-           | RETURN ID L_PAREN call_params R_PAREN SEMICOLON
-           | RETURN SEMICOLON
+	       | RETURN expr SEMICOLON
     '''
     if (len(p) == 3):
-        if (p[1] != "return"):
-            p[1].append(';')
-            p[0] = [p[1]]
-        else:
-            p[0] = [p[1], p[2]]
-    elif (len(p) == 7):
-        p[0] = [p[1], p[2], p[3], p[4], p[5], p[6]]
-        call_helper(p[0], p[2])
-        p[0] = [(p[2], [p[2], p[3], p[4], p[5], p[6]], "call", "ret", "ret", "return")]
+        p[0] = [p[1], p[2]]
     elif (len(p) == 4):
         p[0] = [p[1], p[2], p[3]]
     else:
         p[0] = p[1]
 
 
+def p_header(p):
+    '''
+    header : HASH INCLUDE STRING
+	   | HASH INCLUDE HEADER_FILE
+    '''
+    p[0] = [p[1], p[2], p[3] + '\n']
+
+
 def p_empty(p):
     'empty :'
     p[0] = []
@@ -183,12 +367,9 @@
 
 def p_function_call(p):
     '''
-    function_call : ID L_PAREN call_params R_PAREN SEMICOLON
+    function_call : ID L_PAREN call_params R_PAREN
     '''
-    if (len(p) == 6):
-        p[0] = [p[1], p[2], p[3], p[4], p[5]]
-        call_helper(p[0], p[1])
-        p[0] = [(p[1], p[0], 'call')]
+    p[0] = [p[1], p[2], p[3], p[4]]
 
 
 def p_call_params(p):
@@ -206,7 +387,7 @@
 def p_yes_call_params(p):
     '''
     yes_call_params : yes_call_params expr COMMA
-                    | expr COMMA
+		            | expr COMMA
     '''
     if (len(p) == 3):
         p[0] = [p[1], p[2]]
@@ -224,14 +405,23 @@
 def p_yes_dec_params(p):
     '''
     yes_dec_params : yes_dec_params TYPE ID COMMA
-               | yes_dec_params TYPE COMMA
-           | yes_dec_params TYPE ID ASSIGN NUM COMMA
+                   | yes_dec_params TYPE MULTIPLY ID COMMA
+    		       | yes_dec_params TYPE COMMA
+                   | yes_dec_params TYPE MULTIPLY COMMA
+		           | yes_dec_params TYPE ID ASSIGN NUM COMMA
                    | TYPE ID COMMA
-              | TYPE COMMA
-           | TYPE ID ASSIGN NUM COMMA
+                   | TYPE MULTIPLY ID COMMA
+   		           | TYPE COMMA
+                   | TYPE MULTIPLY COMMA
+		           | TYPE ID ASSIGN NUM COMMA
     '''
     if (len(p) == 5):
-        p[0] = p[1] + [p[2], p[3], p[4]]
+        if (type(p[1]) == str):
+            p[0] = [p[1], p[2], p[3], p[4]]
+        else:
+            p[0] = p[1] + [p[2], p[3], p[4]]
+    elif (len(p) == 6):
+        p[0] = p[1] + [p[2], p[3], p[4], p[5]]
     elif (len(p) == 4):
         p[0] = [p[1], p[2], p[3]]
     elif (len(p) == 7):
@@ -245,11 +435,15 @@
 def p_end_dec_params(p):
     '''
     end_dec_params : TYPE ID
-           | TYPE ID ASSIGN NUM
-           | TYPE
+		           | TYPE ID ASSIGN NUM
+		           | TYPE
+                   | TYPE MULTIPLY ID
+                   | TYPE MULTIPLY
     '''
     if (len(p) == 3):
         p[0] = [p[1], p[2]]
+    elif (len(p) == 4):
+        p[0] = [p[1], p[2], p[3]]
     elif (len(p) == 5):
         p[0] = [p[1], p[2], p[3], p[4]]
     else:
@@ -259,8 +453,8 @@
 def p_dec_params(p):
     '''
     dec_params : empty
-	       | yes_dec_params end_dec_params
-	       | end_dec_params
+	           | yes_dec_params end_dec_params
+	           | end_dec_params
     '''
     if (len(p) == 3):
         p[0] = [p[1], p[2]]
@@ -273,13 +467,6 @@
     function : TYPE ID L_PAREN dec_params R_PAREN function_2
     '''
     p[0] = [p[1], p[2], p[3], p[4], p[5], p[6]]
-    if p[2] != 'main':
-        if (p[6][0] != ';'):
-            temp = inline_defn_helper(p[0], p[2])
-            if type(temp) is tuple:
-                p[0] = [temp]
-            else:  # check
-                p[0] = []
 
 
 def p_function_2(p):
@@ -293,15 +480,82 @@
 def p_expr(p):
     '''
     expr : expr assignment exprOR
-         | expr assignment ID L_PAREN call_params R_PAREN
          | exprOR
     '''
+    if (len(p) > 2 and type(p[1]) == str):
+        search_string = p[1] + "_".join(level_str)
+        # print("search_string : ", search_string)
+        if (len(level_str) != 0):
+            copy_level_str = level_str.copy()
+            while ((symbol_table[search_string] == 'garbage' and symbol_table[
+                '*' + search_string] == 'garbage') and len(copy_level_str) > 1):
+                copy_level_str.pop()
+                # print("copy_level_str", copy_level_str)
+                search_string = p[1] + "_".join(copy_level_str)
+                # print("search_string : ", search_string)
+        # print("* search", '*' + search_string , symbol_table['*' + search_string ])
+        # print("search",search_string , symbol_table[ search_string ])
+        # print("p[3]", p[3])
+        if (type(p[3]) == str and re.search(r'[A-Za-z_][A-Za-z_0-9]*', p[3])):
+            if (symbol_table['*' + search_string] == "garbage"):
+                print("here")
+                dynamic_string = p[3] + '_'.join(level_str)
+                copy_level_str = level_str.copy()
+                while (symbol_table[dynamic_string] == 'garbage' and len(copy_level_str) > 1):
+                    copy_level_str.pop()
+                    dynamic_string = p[3] + '_'.join(copy_level_str)
+                if (symbol_table[dynamic_string] != 'garbage' and symbol_table[dynamic_string] != 'declared'):
+                    symbol_table[search_string] = symbol_table[dynamic_string]
+                else:
+                    symbol_table[search_string] = p[3]
+            else:
+                dynamic_string = "*" + p[3] + '_'.join(level_str)
+                copy_level_str = level_str.copy()
+                while (symbol_table[dynamic_string] == 'garbage' and len(copy_level_str) > 1):
+                    copy_level_str.pop()
+                    dynamic_string = "*" + p[3] + '_'.join(copy_level_str)
+                if (symbol_table[dynamic_string] != 'garbage' and symbol_table[dynamic_string] != 'declared'):
+                    symbol_table['*' + search_string] = symbol_table[dynamic_string]
+                else:
+                    symbol_table['*' + search_string] = p[3]
+
+        elif (symbol_table['*' + search_string] != "garbage" and type(p[3]) == list):
+            temp = []
+            solve(0, len(p[3]), p[3], temp)
+            rhs = ''.join(temp).strip('&')
+            dynamic_string = rhs + '_'.join(level_str)
+            copy_level_str = level_str.copy()
+            while (symbol_table[dynamic_string] == 'garbage' and len(copy_level_str) > 1):
+                copy_level_str.pop()
+                dynamic_string = rhs + '_'.join(copy_level_str)
+            if (symbol_table[dynamic_string] != 'garbage' and symbol_table[dynamic_string] != 'declared'):
+                if (re.search(r'(?:\d+\.\d+)|(?:\d+)|(?:".*?")|(?:\'.\')', str(symbol_table[dynamic_string]))):
+                    symbol_table['*' + search_string] = rhs
+                else:
+                    symbol_table['*' + search_string] = symbol_table[dynamic_string]
+            else:
+                symbol_table['*' + search_string] = rhs
+        else:
+            symbol_table[search_string] = p[3]
+
+        # for i in symbol_table:
+        #   print(f'{i}---->{symbol_table[i]}')
+
+        if (symbol_table[search_string] != 'garbage' and symbol_table[search_string] != 'declared'):
+            for var in symbol_table:
+                if (symbol_table[var] == p[1]):
+                    # print(var,symbol_table[search_string])
+                    symbol_table[var] = symbol_table[search_string]
+
+        if (symbol_table['*' + search_string] != 'garbage' and symbol_table['*' + search_string] != 'declared'):
+            for var in symbol_table:
+                if (symbol_table[var] == p[1]):
+                    symbol_table[var] = symbol_table['*' + search_string]
+
     if (len(p) == 4):
         p[0] = [p[1], p[2], p[3]]
     elif (len(p) == 7):
         p[0] = [p[1], p[2], p[3], p[4], p[5], p[6]]
-        call_helper(p[0], p[3])
-        p[0] = [(p[3], p[0][2:], "call", p[1])]
     else:
         p[0] = p[1]
 
@@ -458,7 +712,19 @@
            | brace
     '''
     if (len(p) == 3):
-        p[0] = [p[1], p[2]]
+        if (p[1] == '++' or p[1] == '--'):
+            if (type(p[2]) == str):
+                symbol_table[make_level_string(p[2])] = 'declared'
+                p[0] = [p[1], p[2]]
+            else:
+                var_dict = {}
+                find_id(0, len(p[2]), p[2], var_dict)
+                var = list(var_dict.keys())[0]
+                print("rhs: ", p[2], p[2][-1], symbol_table[make_level_string('*' + var)])
+                symbol_table[make_level_string(symbol_table[make_level_string('*' + var)])] = 'declared'
+                p[0] = [p[1], p[2]]
+        elif (p[1] == '-' and type(p[2]) != list and type(p[2]) != str):
+            p[0] = -1 * p[2]
     else:
         p[0] = p[1]
 
@@ -469,11 +735,30 @@
            | brace PLUS_PLUS
            | brace MINUS_MINUS
            | NUM
+           | STRING
+           | MULTIPLY ID
+           | BIT_AND ID
            | ID
+    	   | CHAR
+           | function_call
+    	   | ID L_SQBRACE index R_SQBRACE
     '''
     if (len(p) == 4):
         p[0] = [p[1], p[2], p[3]]
+    elif (len(p) == 5):
+        p[0] = [p[1], p[2], p[3], p[4]]
     elif (len(p) == 3):
+        if (p[2] == '++' or p[2] == '--'):
+            if (type(p[1]) == str):
+                symbol_table[make_level_string(p[1])] = 'declared'
+            else:
+                if (p[1][0] == '*'):
+                    symbol_table[make_level_string('*' + p[1][-1])] = 'declared'
+                else:
+                    var_dict = {}
+                    find_id(0, len(p[1]), p[1], var_dict)
+                    var = list(var_dict.keys())[0]
+                    symbol_table[make_level_string(symbol_table[make_level_string('*' + var)])] = 'declared'
         p[0] = [p[1], p[2]]
     else:
         p[0] = p[1]
@@ -482,9 +767,10 @@
 def p_NUM(p):
     '''
     NUM : INT_NUM
-    | FLOAT_NUM
+	    | FLOAT_NUM
     '''
     p[0] = p[1]
 
-# def p_error(p):
-#   print('ERROR!!')
\ No newline at end of file
+
+def p_error(p):
+    print(f"an error occurred ::: token {p} , char {p.value}")
Index: if_switch/code/makefile
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>default:\r\n\tpy detector.py \"C:/Users/KR/PycharmProjects/Capstone/if_switch/testing/t7\"\r\nclean:\r\n\tdel parser.out parsetab.py temp.c\r\n\trmdir /S /Q __pycache__\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/if_switch/code/makefile b/if_switch/code/makefile
--- a/if_switch/code/makefile	(revision b26bb3c3327922fb1661b060ad4530782e55c5e7)
+++ b/if_switch/code/makefile	(date 1617438707288)
@@ -1,5 +1,5 @@
 default:
-	py detector.py "C:/Users/KR/PycharmProjects/Capstone/if_switch/testing/t7"
+	py detector.py "C:/Users/KR/PycharmProjects/Capstone/if_switch/testing/t8"
 clean:
 	del parser.out parsetab.py temp.c
 	rmdir /S /Q __pycache__
