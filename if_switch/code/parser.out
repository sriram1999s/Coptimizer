Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    DOT

Grammar

Rule 0     S' -> start
Rule 1     start -> multiple_statements
Rule 2     multiple_statements -> multiple_statements statement
Rule 3     multiple_statements -> statement
Rule 4     statement -> open
Rule 5     statement -> closed
Rule 6     open -> IF condition statement
Rule 7     open -> IF condition closed ELSE open
Rule 8     open -> WHILE condition open
Rule 9     open -> for for_condition open
Rule 10    for -> FOR
Rule 11    closed -> simple
Rule 12    closed -> block
Rule 13    closed -> IF condition closed ELSE closed
Rule 14    closed -> WHILE condition closed
Rule 15    closed -> for for_condition closed
Rule 16    condition -> L_PAREN expr R_PAREN
Rule 17    for_condition -> L_PAREN simple simple expr R_PAREN
Rule 18    for_condition -> L_PAREN simple simple R_PAREN
Rule 19    multi_declaration -> multi_declaration ID COMMA
Rule 20    multi_declaration -> multi_declaration MULTIPLY ID COMMA
Rule 21    multi_declaration -> multi_declaration ID ASSIGN expr COMMA
Rule 22    multi_declaration -> multi_declaration MULTIPLY ID ASSIGN expr COMMA
Rule 23    multi_declaration -> ID COMMA
Rule 24    multi_declaration -> ID ASSIGN expr COMMA
Rule 25    multi_declaration -> MULTIPLY ID COMMA
Rule 26    multi_declaration -> MULTIPLY ID ASSIGN expr COMMA
Rule 27    stop -> ID SEMICOLON
Rule 28    stop -> MULTIPLY ID SEMICOLON
Rule 29    stop -> ID ASSIGN expr SEMICOLON
Rule 30    stop -> MULTIPLY ID ASSIGN expr SEMICOLON
Rule 31    arrayindex -> L_SQBRACE index R_SQBRACE
Rule 32    narrayindex -> narrayindex arrayindex
Rule 33    narrayindex -> arrayindex
Rule 34    declaration -> TYPE ID SEMICOLON
Rule 35    declaration -> TYPE MULTIPLY ID SEMICOLON
Rule 36    declaration -> TYPE ID ASSIGN expr SEMICOLON
Rule 37    declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON
Rule 38    declaration -> TYPE multi_declaration stop
Rule 39    declaration -> TYPE ID narrayindex SEMICOLON
Rule 40    declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON
Rule 41    init -> expr COMMA init
Rule 42    init -> expr
Rule 43    init_list -> L_FLOWBRACE init_list R_FLOWBRACE COMMA init_list
Rule 44    init_list -> L_FLOWBRACE init R_FLOWBRACE COMMA init_list
Rule 45    init_list -> L_FLOWBRACE init R_FLOWBRACE
Rule 46    init_list -> L_FLOWBRACE init_list R_FLOWBRACE
Rule 47    index -> expr
Rule 48    index -> empty
Rule 49    block -> left_flower multiple_statements right_flower
Rule 50    block -> left_flower right_flower
Rule 51    left_flower -> L_FLOWBRACE
Rule 52    right_flower -> R_FLOWBRACE
Rule 53    simple -> expr SEMICOLON
Rule 54    simple -> header
Rule 55    simple -> declaration
Rule 56    simple -> SEMICOLON
Rule 57    simple -> function
Rule 58    simple -> RETURN expr SEMICOLON
Rule 59    simple -> RETURN SEMICOLON
Rule 60    header -> HASH INCLUDE STRING
Rule 61    header -> HASH INCLUDE HEADER_FILE
Rule 62    empty -> <empty>
Rule 63    function_call -> ID L_PAREN call_params R_PAREN
Rule 64    call_params -> empty
Rule 65    call_params -> yes_call_params end_call_params
Rule 66    call_params -> end_call_params
Rule 67    yes_call_params -> yes_call_params expr COMMA
Rule 68    yes_call_params -> expr COMMA
Rule 69    end_call_params -> expr
Rule 70    yes_dec_params -> yes_dec_params TYPE ID COMMA
Rule 71    yes_dec_params -> yes_dec_params TYPE MULTIPLY ID COMMA
Rule 72    yes_dec_params -> yes_dec_params TYPE COMMA
Rule 73    yes_dec_params -> yes_dec_params TYPE MULTIPLY COMMA
Rule 74    yes_dec_params -> yes_dec_params TYPE ID ASSIGN NUM COMMA
Rule 75    yes_dec_params -> TYPE ID COMMA
Rule 76    yes_dec_params -> TYPE MULTIPLY ID COMMA
Rule 77    yes_dec_params -> TYPE COMMA
Rule 78    yes_dec_params -> TYPE MULTIPLY COMMA
Rule 79    yes_dec_params -> TYPE ID ASSIGN NUM COMMA
Rule 80    end_dec_params -> TYPE ID
Rule 81    end_dec_params -> TYPE ID ASSIGN NUM
Rule 82    end_dec_params -> TYPE
Rule 83    end_dec_params -> TYPE MULTIPLY ID
Rule 84    end_dec_params -> TYPE MULTIPLY
Rule 85    dec_params -> empty
Rule 86    dec_params -> yes_dec_params end_dec_params
Rule 87    dec_params -> end_dec_params
Rule 88    function -> TYPE ID L_PAREN dec_params R_PAREN function_2
Rule 89    function_2 -> SEMICOLON
Rule 90    function_2 -> block
Rule 91    expr -> expr assignment exprOR
Rule 92    expr -> exprOR
Rule 93    assignment -> ASSIGN
Rule 94    assignment -> PLUS_ASSIGN
Rule 95    assignment -> MINUS_ASSIGN
Rule 96    assignment -> MUL_ASSIGN
Rule 97    assignment -> DIV_ASSIGN
Rule 98    assignment -> AND_ASSIGN
Rule 99    assignment -> OR_ASSIGN
Rule 100   assignment -> XOR_ASSIGN
Rule 101   assignment -> MOD_ASSIGN
Rule 102   assignment -> L_SHIFT_ASSIGN
Rule 103   assignment -> R_SHIFT_ASSIGN
Rule 104   exprOR -> exprOR OR exprAND
Rule 105   exprOR -> exprAND
Rule 106   exprAND -> exprAND AND exprBITOR
Rule 107   exprAND -> exprBITOR
Rule 108   exprBITOR -> exprBITOR BIT_OR exprBITXOR
Rule 109   exprBITOR -> exprBITXOR
Rule 110   exprBITXOR -> exprBITXOR BIT_XOR exprBITAND
Rule 111   exprBITXOR -> exprBITAND
Rule 112   exprBITAND -> exprBITAND BIT_AND exprEQ
Rule 113   exprBITAND -> exprEQ
Rule 114   exprEQ -> exprEQ EQ exprRELOP
Rule 115   exprEQ -> exprEQ NE exprRELOP
Rule 116   exprEQ -> exprRELOP
Rule 117   exprRELOP -> exprRELOP relop exprSHIFT
Rule 118   exprRELOP -> exprSHIFT
Rule 119   relop -> LE
Rule 120   relop -> LT
Rule 121   relop -> GE
Rule 122   relop -> GT
Rule 123   exprSHIFT -> exprSHIFT L_SHIFT exprOP
Rule 124   exprSHIFT -> exprSHIFT R_SHIFT exprOP
Rule 125   exprSHIFT -> exprOP
Rule 126   exprOP -> exprOP PLUS term
Rule 127   exprOP -> exprOP MINUS term
Rule 128   exprOP -> term
Rule 129   term -> term MULTIPLY factor
Rule 130   term -> term DIVIDE factor
Rule 131   term -> term MOD factor
Rule 132   term -> factor
Rule 133   factor -> NOT factor
Rule 134   factor -> PLUS factor
Rule 135   factor -> MINUS factor
Rule 136   factor -> PLUS_PLUS factor
Rule 137   factor -> MINUS_MINUS factor
Rule 138   factor -> cast brace
Rule 139   factor -> brace
Rule 140   cast -> L_PAREN TYPE R_PAREN
Rule 141   cast -> L_PAREN TYPE MULTIPLY R_PAREN
Rule 142   brace -> L_PAREN expr R_PAREN
Rule 143   brace -> brace PLUS_PLUS
Rule 144   brace -> brace MINUS_MINUS
Rule 145   brace -> NUM
Rule 146   brace -> STRING
Rule 147   brace -> MULTIPLY ID
Rule 148   brace -> BIT_AND ID
Rule 149   brace -> ID
Rule 150   brace -> CHAR
Rule 151   brace -> function_call
Rule 152   brace -> ID narrayindex
Rule 153   NUM -> INT_NUM
Rule 154   NUM -> FLOAT_NUM

Terminals, with rules where they appear

AND                  : 106
AND_ASSIGN           : 98
ASSIGN               : 21 22 24 26 29 30 36 37 40 74 79 81 93
BIT_AND              : 112 148
BIT_OR               : 108
BIT_XOR              : 110
CHAR                 : 150
COMMA                : 19 20 21 22 23 24 25 26 41 43 44 67 68 70 71 72 73 74 75 76 77 78 79
DIVIDE               : 130
DIV_ASSIGN           : 97
DOT                  : 
ELSE                 : 7 13
EQ                   : 114
FLOAT_NUM            : 154
FOR                  : 10
GE                   : 121
GT                   : 122
HASH                 : 60 61
HEADER_FILE          : 61
ID                   : 19 20 21 22 23 24 25 26 27 28 29 30 34 35 36 37 39 40 63 70 71 74 75 76 79 80 81 83 88 147 148 149 152
IF                   : 6 7 13
INCLUDE              : 60 61
INT_NUM              : 153
LE                   : 119
LT                   : 120
L_FLOWBRACE          : 43 44 45 46 51
L_PAREN              : 16 17 18 63 88 140 141 142
L_SHIFT              : 123
L_SHIFT_ASSIGN       : 102
L_SQBRACE            : 31
MINUS                : 127 135
MINUS_ASSIGN         : 95
MINUS_MINUS          : 137 144
MOD                  : 131
MOD_ASSIGN           : 101
MULTIPLY             : 20 22 25 26 28 30 35 37 71 73 76 78 83 84 129 141 147
MUL_ASSIGN           : 96
NE                   : 115
NOT                  : 133
OR                   : 104
OR_ASSIGN            : 99
PLUS                 : 126 134
PLUS_ASSIGN          : 94
PLUS_PLUS            : 136 143
RETURN               : 58 59
R_FLOWBRACE          : 43 44 45 46 52
R_PAREN              : 16 17 18 63 88 140 141 142
R_SHIFT              : 124
R_SHIFT_ASSIGN       : 103
R_SQBRACE            : 31
SEMICOLON            : 27 28 29 30 34 35 36 37 39 40 53 56 58 59 89
STRING               : 60 146
TYPE                 : 34 35 36 37 38 39 40 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 88 140 141
WHILE                : 8 14
XOR_ASSIGN           : 100
error                : 

Nonterminals, with rules where they appear

NUM                  : 74 79 81 145
arrayindex           : 32 33
assignment           : 91
block                : 12 90
brace                : 138 139 143 144
call_params          : 63
cast                 : 138
closed               : 5 7 13 13 14 15
condition            : 6 7 8 13 14
dec_params           : 88
declaration          : 55
empty                : 48 64 85
end_call_params      : 65 66
end_dec_params       : 86 87
expr                 : 16 17 21 22 24 26 29 30 36 37 41 42 47 53 58 67 68 69 91 142
exprAND              : 104 105 106
exprBITAND           : 110 111 112
exprBITOR            : 106 107 108
exprBITXOR           : 108 109 110
exprEQ               : 112 113 114 115
exprOP               : 123 124 125 126 127
exprOR               : 91 92 104
exprRELOP            : 114 115 116 117
exprSHIFT            : 117 118 123 124
factor               : 129 130 131 132 133 134 135 136 137
for                  : 9 15
for_condition        : 9 15
function             : 57
function_2           : 88
function_call        : 151
header               : 54
index                : 31
init                 : 41 44 45
init_list            : 40 43 43 44 46
left_flower          : 49 50
multi_declaration    : 19 20 21 22 38
multiple_statements  : 1 2 49
narrayindex          : 32 39 40 152
open                 : 4 7 8 9
relop                : 117
right_flower         : 49 50
simple               : 11 17 17 18 18
start                : 0
statement            : 2 3 6
stop                 : 38
term                 : 126 127 128 129 130 131
yes_call_params      : 65 67
yes_dec_params       : 70 71 72 73 74 86

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . multiple_statements
    (2) multiple_statements -> . multiple_statements statement
    (3) multiple_statements -> . statement
    (4) statement -> . open
    (5) statement -> . closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) open -> . for for_condition open
    (11) closed -> . simple
    (12) closed -> . block
    (13) closed -> . IF condition closed ELSE closed
    (14) closed -> . WHILE condition closed
    (15) closed -> . for for_condition closed
    (10) for -> . FOR
    (53) simple -> . expr SEMICOLON
    (54) simple -> . header
    (55) simple -> . declaration
    (56) simple -> . SEMICOLON
    (57) simple -> . function
    (58) simple -> . RETURN expr SEMICOLON
    (59) simple -> . RETURN SEMICOLON
    (49) block -> . left_flower multiple_statements right_flower
    (50) block -> . left_flower right_flower
    (91) expr -> . expr assignment exprOR
    (92) expr -> . exprOR
    (60) header -> . HASH INCLUDE STRING
    (61) header -> . HASH INCLUDE HEADER_FILE
    (34) declaration -> . TYPE ID SEMICOLON
    (35) declaration -> . TYPE MULTIPLY ID SEMICOLON
    (36) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (37) declaration -> . TYPE MULTIPLY ID ASSIGN expr SEMICOLON
    (38) declaration -> . TYPE multi_declaration stop
    (39) declaration -> . TYPE ID narrayindex SEMICOLON
    (40) declaration -> . TYPE ID narrayindex ASSIGN init_list SEMICOLON
    (88) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (51) left_flower -> . L_FLOWBRACE
    (104) exprOR -> . exprOR OR exprAND
    (105) exprOR -> . exprAND
    (106) exprAND -> . exprAND AND exprBITOR
    (107) exprAND -> . exprBITOR
    (108) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (109) exprBITOR -> . exprBITXOR
    (110) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (111) exprBITXOR -> . exprBITAND
    (112) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (113) exprBITAND -> . exprEQ
    (114) exprEQ -> . exprEQ EQ exprRELOP
    (115) exprEQ -> . exprEQ NE exprRELOP
    (116) exprEQ -> . exprRELOP
    (117) exprRELOP -> . exprRELOP relop exprSHIFT
    (118) exprRELOP -> . exprSHIFT
    (123) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (124) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (125) exprSHIFT -> . exprOP
    (126) exprOP -> . exprOP PLUS term
    (127) exprOP -> . exprOP MINUS term
    (128) exprOP -> . term
    (129) term -> . term MULTIPLY factor
    (130) term -> . term DIVIDE factor
    (131) term -> . term MOD factor
    (132) term -> . factor
    (133) factor -> . NOT factor
    (134) factor -> . PLUS factor
    (135) factor -> . MINUS factor
    (136) factor -> . PLUS_PLUS factor
    (137) factor -> . MINUS_MINUS factor
    (138) factor -> . cast brace
    (139) factor -> . brace
    (140) cast -> . L_PAREN TYPE R_PAREN
    (141) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (142) brace -> . L_PAREN expr R_PAREN
    (143) brace -> . brace PLUS_PLUS
    (144) brace -> . brace MINUS_MINUS
    (145) brace -> . NUM
    (146) brace -> . STRING
    (147) brace -> . MULTIPLY ID
    (148) brace -> . BIT_AND ID
    (149) brace -> . ID
    (150) brace -> . CHAR
    (151) brace -> . function_call
    (152) brace -> . ID narrayindex
    (153) NUM -> . INT_NUM
    (154) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    IF              shift and go to state 6
    WHILE           shift and go to state 7
    FOR             shift and go to state 11
    SEMICOLON       shift and go to state 13
    RETURN          shift and go to state 17
    HASH            shift and go to state 20
    TYPE            shift and go to state 22
    L_FLOWBRACE     shift and go to state 26
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    start                          shift and go to state 1
    multiple_statements            shift and go to state 2
    statement                      shift and go to state 3
    open                           shift and go to state 4
    closed                         shift and go to state 5
    for                            shift and go to state 8
    simple                         shift and go to state 9
    block                          shift and go to state 10
    expr                           shift and go to state 12
    header                         shift and go to state 14
    declaration                    shift and go to state 15
    function                       shift and go to state 16
    left_flower                    shift and go to state 18
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 1

    (0) S' -> start .



state 2

    (1) start -> multiple_statements .
    (2) multiple_statements -> multiple_statements . statement
    (4) statement -> . open
    (5) statement -> . closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) open -> . for for_condition open
    (11) closed -> . simple
    (12) closed -> . block
    (13) closed -> . IF condition closed ELSE closed
    (14) closed -> . WHILE condition closed
    (15) closed -> . for for_condition closed
    (10) for -> . FOR
    (53) simple -> . expr SEMICOLON
    (54) simple -> . header
    (55) simple -> . declaration
    (56) simple -> . SEMICOLON
    (57) simple -> . function
    (58) simple -> . RETURN expr SEMICOLON
    (59) simple -> . RETURN SEMICOLON
    (49) block -> . left_flower multiple_statements right_flower
    (50) block -> . left_flower right_flower
    (91) expr -> . expr assignment exprOR
    (92) expr -> . exprOR
    (60) header -> . HASH INCLUDE STRING
    (61) header -> . HASH INCLUDE HEADER_FILE
    (34) declaration -> . TYPE ID SEMICOLON
    (35) declaration -> . TYPE MULTIPLY ID SEMICOLON
    (36) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (37) declaration -> . TYPE MULTIPLY ID ASSIGN expr SEMICOLON
    (38) declaration -> . TYPE multi_declaration stop
    (39) declaration -> . TYPE ID narrayindex SEMICOLON
    (40) declaration -> . TYPE ID narrayindex ASSIGN init_list SEMICOLON
    (88) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (51) left_flower -> . L_FLOWBRACE
    (104) exprOR -> . exprOR OR exprAND
    (105) exprOR -> . exprAND
    (106) exprAND -> . exprAND AND exprBITOR
    (107) exprAND -> . exprBITOR
    (108) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (109) exprBITOR -> . exprBITXOR
    (110) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (111) exprBITXOR -> . exprBITAND
    (112) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (113) exprBITAND -> . exprEQ
    (114) exprEQ -> . exprEQ EQ exprRELOP
    (115) exprEQ -> . exprEQ NE exprRELOP
    (116) exprEQ -> . exprRELOP
    (117) exprRELOP -> . exprRELOP relop exprSHIFT
    (118) exprRELOP -> . exprSHIFT
    (123) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (124) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (125) exprSHIFT -> . exprOP
    (126) exprOP -> . exprOP PLUS term
    (127) exprOP -> . exprOP MINUS term
    (128) exprOP -> . term
    (129) term -> . term MULTIPLY factor
    (130) term -> . term DIVIDE factor
    (131) term -> . term MOD factor
    (132) term -> . factor
    (133) factor -> . NOT factor
    (134) factor -> . PLUS factor
    (135) factor -> . MINUS factor
    (136) factor -> . PLUS_PLUS factor
    (137) factor -> . MINUS_MINUS factor
    (138) factor -> . cast brace
    (139) factor -> . brace
    (140) cast -> . L_PAREN TYPE R_PAREN
    (141) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (142) brace -> . L_PAREN expr R_PAREN
    (143) brace -> . brace PLUS_PLUS
    (144) brace -> . brace MINUS_MINUS
    (145) brace -> . NUM
    (146) brace -> . STRING
    (147) brace -> . MULTIPLY ID
    (148) brace -> . BIT_AND ID
    (149) brace -> . ID
    (150) brace -> . CHAR
    (151) brace -> . function_call
    (152) brace -> . ID narrayindex
    (153) NUM -> . INT_NUM
    (154) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    $end            reduce using rule 1 (start -> multiple_statements .)
    IF              shift and go to state 6
    WHILE           shift and go to state 7
    FOR             shift and go to state 11
    SEMICOLON       shift and go to state 13
    RETURN          shift and go to state 17
    HASH            shift and go to state 20
    TYPE            shift and go to state 22
    L_FLOWBRACE     shift and go to state 26
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    statement                      shift and go to state 50
    open                           shift and go to state 4
    closed                         shift and go to state 5
    for                            shift and go to state 8
    simple                         shift and go to state 9
    block                          shift and go to state 10
    expr                           shift and go to state 12
    header                         shift and go to state 14
    declaration                    shift and go to state 15
    function                       shift and go to state 16
    left_flower                    shift and go to state 18
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 3

    (3) multiple_statements -> statement .

    IF              reduce using rule 3 (multiple_statements -> statement .)
    WHILE           reduce using rule 3 (multiple_statements -> statement .)
    FOR             reduce using rule 3 (multiple_statements -> statement .)
    SEMICOLON       reduce using rule 3 (multiple_statements -> statement .)
    RETURN          reduce using rule 3 (multiple_statements -> statement .)
    HASH            reduce using rule 3 (multiple_statements -> statement .)
    TYPE            reduce using rule 3 (multiple_statements -> statement .)
    L_FLOWBRACE     reduce using rule 3 (multiple_statements -> statement .)
    NOT             reduce using rule 3 (multiple_statements -> statement .)
    PLUS            reduce using rule 3 (multiple_statements -> statement .)
    MINUS           reduce using rule 3 (multiple_statements -> statement .)
    PLUS_PLUS       reduce using rule 3 (multiple_statements -> statement .)
    MINUS_MINUS     reduce using rule 3 (multiple_statements -> statement .)
    L_PAREN         reduce using rule 3 (multiple_statements -> statement .)
    STRING          reduce using rule 3 (multiple_statements -> statement .)
    MULTIPLY        reduce using rule 3 (multiple_statements -> statement .)
    BIT_AND         reduce using rule 3 (multiple_statements -> statement .)
    ID              reduce using rule 3 (multiple_statements -> statement .)
    CHAR            reduce using rule 3 (multiple_statements -> statement .)
    INT_NUM         reduce using rule 3 (multiple_statements -> statement .)
    FLOAT_NUM       reduce using rule 3 (multiple_statements -> statement .)
    $end            reduce using rule 3 (multiple_statements -> statement .)
    R_FLOWBRACE     reduce using rule 3 (multiple_statements -> statement .)


state 4

    (4) statement -> open .

    IF              reduce using rule 4 (statement -> open .)
    WHILE           reduce using rule 4 (statement -> open .)
    FOR             reduce using rule 4 (statement -> open .)
    SEMICOLON       reduce using rule 4 (statement -> open .)
    RETURN          reduce using rule 4 (statement -> open .)
    HASH            reduce using rule 4 (statement -> open .)
    TYPE            reduce using rule 4 (statement -> open .)
    L_FLOWBRACE     reduce using rule 4 (statement -> open .)
    NOT             reduce using rule 4 (statement -> open .)
    PLUS            reduce using rule 4 (statement -> open .)
    MINUS           reduce using rule 4 (statement -> open .)
    PLUS_PLUS       reduce using rule 4 (statement -> open .)
    MINUS_MINUS     reduce using rule 4 (statement -> open .)
    L_PAREN         reduce using rule 4 (statement -> open .)
    STRING          reduce using rule 4 (statement -> open .)
    MULTIPLY        reduce using rule 4 (statement -> open .)
    BIT_AND         reduce using rule 4 (statement -> open .)
    ID              reduce using rule 4 (statement -> open .)
    CHAR            reduce using rule 4 (statement -> open .)
    INT_NUM         reduce using rule 4 (statement -> open .)
    FLOAT_NUM       reduce using rule 4 (statement -> open .)
    $end            reduce using rule 4 (statement -> open .)
    R_FLOWBRACE     reduce using rule 4 (statement -> open .)


state 5

    (5) statement -> closed .

    IF              reduce using rule 5 (statement -> closed .)
    WHILE           reduce using rule 5 (statement -> closed .)
    FOR             reduce using rule 5 (statement -> closed .)
    SEMICOLON       reduce using rule 5 (statement -> closed .)
    RETURN          reduce using rule 5 (statement -> closed .)
    HASH            reduce using rule 5 (statement -> closed .)
    TYPE            reduce using rule 5 (statement -> closed .)
    L_FLOWBRACE     reduce using rule 5 (statement -> closed .)
    NOT             reduce using rule 5 (statement -> closed .)
    PLUS            reduce using rule 5 (statement -> closed .)
    MINUS           reduce using rule 5 (statement -> closed .)
    PLUS_PLUS       reduce using rule 5 (statement -> closed .)
    MINUS_MINUS     reduce using rule 5 (statement -> closed .)
    L_PAREN         reduce using rule 5 (statement -> closed .)
    STRING          reduce using rule 5 (statement -> closed .)
    MULTIPLY        reduce using rule 5 (statement -> closed .)
    BIT_AND         reduce using rule 5 (statement -> closed .)
    ID              reduce using rule 5 (statement -> closed .)
    CHAR            reduce using rule 5 (statement -> closed .)
    INT_NUM         reduce using rule 5 (statement -> closed .)
    FLOAT_NUM       reduce using rule 5 (statement -> closed .)
    $end            reduce using rule 5 (statement -> closed .)
    R_FLOWBRACE     reduce using rule 5 (statement -> closed .)


state 6

    (6) open -> IF . condition statement
    (7) open -> IF . condition closed ELSE open
    (13) closed -> IF . condition closed ELSE closed
    (16) condition -> . L_PAREN expr R_PAREN

    L_PAREN         shift and go to state 52

    condition                      shift and go to state 51

state 7

    (8) open -> WHILE . condition open
    (14) closed -> WHILE . condition closed
    (16) condition -> . L_PAREN expr R_PAREN

    L_PAREN         shift and go to state 52

    condition                      shift and go to state 53

state 8

    (9) open -> for . for_condition open
    (15) closed -> for . for_condition closed
    (17) for_condition -> . L_PAREN simple simple expr R_PAREN
    (18) for_condition -> . L_PAREN simple simple R_PAREN

    L_PAREN         shift and go to state 55

    for_condition                  shift and go to state 54

state 9

    (11) closed -> simple .

    IF              reduce using rule 11 (closed -> simple .)
    WHILE           reduce using rule 11 (closed -> simple .)
    FOR             reduce using rule 11 (closed -> simple .)
    SEMICOLON       reduce using rule 11 (closed -> simple .)
    RETURN          reduce using rule 11 (closed -> simple .)
    HASH            reduce using rule 11 (closed -> simple .)
    TYPE            reduce using rule 11 (closed -> simple .)
    L_FLOWBRACE     reduce using rule 11 (closed -> simple .)
    NOT             reduce using rule 11 (closed -> simple .)
    PLUS            reduce using rule 11 (closed -> simple .)
    MINUS           reduce using rule 11 (closed -> simple .)
    PLUS_PLUS       reduce using rule 11 (closed -> simple .)
    MINUS_MINUS     reduce using rule 11 (closed -> simple .)
    L_PAREN         reduce using rule 11 (closed -> simple .)
    STRING          reduce using rule 11 (closed -> simple .)
    MULTIPLY        reduce using rule 11 (closed -> simple .)
    BIT_AND         reduce using rule 11 (closed -> simple .)
    ID              reduce using rule 11 (closed -> simple .)
    CHAR            reduce using rule 11 (closed -> simple .)
    INT_NUM         reduce using rule 11 (closed -> simple .)
    FLOAT_NUM       reduce using rule 11 (closed -> simple .)
    $end            reduce using rule 11 (closed -> simple .)
    R_FLOWBRACE     reduce using rule 11 (closed -> simple .)
    ELSE            reduce using rule 11 (closed -> simple .)


state 10

    (12) closed -> block .

    IF              reduce using rule 12 (closed -> block .)
    WHILE           reduce using rule 12 (closed -> block .)
    FOR             reduce using rule 12 (closed -> block .)
    SEMICOLON       reduce using rule 12 (closed -> block .)
    RETURN          reduce using rule 12 (closed -> block .)
    HASH            reduce using rule 12 (closed -> block .)
    TYPE            reduce using rule 12 (closed -> block .)
    L_FLOWBRACE     reduce using rule 12 (closed -> block .)
    NOT             reduce using rule 12 (closed -> block .)
    PLUS            reduce using rule 12 (closed -> block .)
    MINUS           reduce using rule 12 (closed -> block .)
    PLUS_PLUS       reduce using rule 12 (closed -> block .)
    MINUS_MINUS     reduce using rule 12 (closed -> block .)
    L_PAREN         reduce using rule 12 (closed -> block .)
    STRING          reduce using rule 12 (closed -> block .)
    MULTIPLY        reduce using rule 12 (closed -> block .)
    BIT_AND         reduce using rule 12 (closed -> block .)
    ID              reduce using rule 12 (closed -> block .)
    CHAR            reduce using rule 12 (closed -> block .)
    INT_NUM         reduce using rule 12 (closed -> block .)
    FLOAT_NUM       reduce using rule 12 (closed -> block .)
    $end            reduce using rule 12 (closed -> block .)
    R_FLOWBRACE     reduce using rule 12 (closed -> block .)
    ELSE            reduce using rule 12 (closed -> block .)


state 11

    (10) for -> FOR .

    L_PAREN         reduce using rule 10 (for -> FOR .)


state 12

    (53) simple -> expr . SEMICOLON
    (91) expr -> expr . assignment exprOR
    (93) assignment -> . ASSIGN
    (94) assignment -> . PLUS_ASSIGN
    (95) assignment -> . MINUS_ASSIGN
    (96) assignment -> . MUL_ASSIGN
    (97) assignment -> . DIV_ASSIGN
    (98) assignment -> . AND_ASSIGN
    (99) assignment -> . OR_ASSIGN
    (100) assignment -> . XOR_ASSIGN
    (101) assignment -> . MOD_ASSIGN
    (102) assignment -> . L_SHIFT_ASSIGN
    (103) assignment -> . R_SHIFT_ASSIGN

    SEMICOLON       shift and go to state 56
    ASSIGN          shift and go to state 58
    PLUS_ASSIGN     shift and go to state 59
    MINUS_ASSIGN    shift and go to state 60
    MUL_ASSIGN      shift and go to state 61
    DIV_ASSIGN      shift and go to state 62
    AND_ASSIGN      shift and go to state 63
    OR_ASSIGN       shift and go to state 64
    XOR_ASSIGN      shift and go to state 65
    MOD_ASSIGN      shift and go to state 66
    L_SHIFT_ASSIGN  shift and go to state 67
    R_SHIFT_ASSIGN  shift and go to state 68

    assignment                     shift and go to state 57

state 13

    (56) simple -> SEMICOLON .

    IF              reduce using rule 56 (simple -> SEMICOLON .)
    WHILE           reduce using rule 56 (simple -> SEMICOLON .)
    FOR             reduce using rule 56 (simple -> SEMICOLON .)
    SEMICOLON       reduce using rule 56 (simple -> SEMICOLON .)
    RETURN          reduce using rule 56 (simple -> SEMICOLON .)
    HASH            reduce using rule 56 (simple -> SEMICOLON .)
    TYPE            reduce using rule 56 (simple -> SEMICOLON .)
    L_FLOWBRACE     reduce using rule 56 (simple -> SEMICOLON .)
    NOT             reduce using rule 56 (simple -> SEMICOLON .)
    PLUS            reduce using rule 56 (simple -> SEMICOLON .)
    MINUS           reduce using rule 56 (simple -> SEMICOLON .)
    PLUS_PLUS       reduce using rule 56 (simple -> SEMICOLON .)
    MINUS_MINUS     reduce using rule 56 (simple -> SEMICOLON .)
    L_PAREN         reduce using rule 56 (simple -> SEMICOLON .)
    STRING          reduce using rule 56 (simple -> SEMICOLON .)
    MULTIPLY        reduce using rule 56 (simple -> SEMICOLON .)
    BIT_AND         reduce using rule 56 (simple -> SEMICOLON .)
    ID              reduce using rule 56 (simple -> SEMICOLON .)
    CHAR            reduce using rule 56 (simple -> SEMICOLON .)
    INT_NUM         reduce using rule 56 (simple -> SEMICOLON .)
    FLOAT_NUM       reduce using rule 56 (simple -> SEMICOLON .)
    $end            reduce using rule 56 (simple -> SEMICOLON .)
    R_FLOWBRACE     reduce using rule 56 (simple -> SEMICOLON .)
    ELSE            reduce using rule 56 (simple -> SEMICOLON .)
    R_PAREN         reduce using rule 56 (simple -> SEMICOLON .)


state 14

    (54) simple -> header .

    IF              reduce using rule 54 (simple -> header .)
    WHILE           reduce using rule 54 (simple -> header .)
    FOR             reduce using rule 54 (simple -> header .)
    SEMICOLON       reduce using rule 54 (simple -> header .)
    RETURN          reduce using rule 54 (simple -> header .)
    HASH            reduce using rule 54 (simple -> header .)
    TYPE            reduce using rule 54 (simple -> header .)
    L_FLOWBRACE     reduce using rule 54 (simple -> header .)
    NOT             reduce using rule 54 (simple -> header .)
    PLUS            reduce using rule 54 (simple -> header .)
    MINUS           reduce using rule 54 (simple -> header .)
    PLUS_PLUS       reduce using rule 54 (simple -> header .)
    MINUS_MINUS     reduce using rule 54 (simple -> header .)
    L_PAREN         reduce using rule 54 (simple -> header .)
    STRING          reduce using rule 54 (simple -> header .)
    MULTIPLY        reduce using rule 54 (simple -> header .)
    BIT_AND         reduce using rule 54 (simple -> header .)
    ID              reduce using rule 54 (simple -> header .)
    CHAR            reduce using rule 54 (simple -> header .)
    INT_NUM         reduce using rule 54 (simple -> header .)
    FLOAT_NUM       reduce using rule 54 (simple -> header .)
    $end            reduce using rule 54 (simple -> header .)
    R_FLOWBRACE     reduce using rule 54 (simple -> header .)
    ELSE            reduce using rule 54 (simple -> header .)
    R_PAREN         reduce using rule 54 (simple -> header .)


state 15

    (55) simple -> declaration .

    IF              reduce using rule 55 (simple -> declaration .)
    WHILE           reduce using rule 55 (simple -> declaration .)
    FOR             reduce using rule 55 (simple -> declaration .)
    SEMICOLON       reduce using rule 55 (simple -> declaration .)
    RETURN          reduce using rule 55 (simple -> declaration .)
    HASH            reduce using rule 55 (simple -> declaration .)
    TYPE            reduce using rule 55 (simple -> declaration .)
    L_FLOWBRACE     reduce using rule 55 (simple -> declaration .)
    NOT             reduce using rule 55 (simple -> declaration .)
    PLUS            reduce using rule 55 (simple -> declaration .)
    MINUS           reduce using rule 55 (simple -> declaration .)
    PLUS_PLUS       reduce using rule 55 (simple -> declaration .)
    MINUS_MINUS     reduce using rule 55 (simple -> declaration .)
    L_PAREN         reduce using rule 55 (simple -> declaration .)
    STRING          reduce using rule 55 (simple -> declaration .)
    MULTIPLY        reduce using rule 55 (simple -> declaration .)
    BIT_AND         reduce using rule 55 (simple -> declaration .)
    ID              reduce using rule 55 (simple -> declaration .)
    CHAR            reduce using rule 55 (simple -> declaration .)
    INT_NUM         reduce using rule 55 (simple -> declaration .)
    FLOAT_NUM       reduce using rule 55 (simple -> declaration .)
    $end            reduce using rule 55 (simple -> declaration .)
    R_FLOWBRACE     reduce using rule 55 (simple -> declaration .)
    ELSE            reduce using rule 55 (simple -> declaration .)
    R_PAREN         reduce using rule 55 (simple -> declaration .)


state 16

    (57) simple -> function .

    IF              reduce using rule 57 (simple -> function .)
    WHILE           reduce using rule 57 (simple -> function .)
    FOR             reduce using rule 57 (simple -> function .)
    SEMICOLON       reduce using rule 57 (simple -> function .)
    RETURN          reduce using rule 57 (simple -> function .)
    HASH            reduce using rule 57 (simple -> function .)
    TYPE            reduce using rule 57 (simple -> function .)
    L_FLOWBRACE     reduce using rule 57 (simple -> function .)
    NOT             reduce using rule 57 (simple -> function .)
    PLUS            reduce using rule 57 (simple -> function .)
    MINUS           reduce using rule 57 (simple -> function .)
    PLUS_PLUS       reduce using rule 57 (simple -> function .)
    MINUS_MINUS     reduce using rule 57 (simple -> function .)
    L_PAREN         reduce using rule 57 (simple -> function .)
    STRING          reduce using rule 57 (simple -> function .)
    MULTIPLY        reduce using rule 57 (simple -> function .)
    BIT_AND         reduce using rule 57 (simple -> function .)
    ID              reduce using rule 57 (simple -> function .)
    CHAR            reduce using rule 57 (simple -> function .)
    INT_NUM         reduce using rule 57 (simple -> function .)
    FLOAT_NUM       reduce using rule 57 (simple -> function .)
    $end            reduce using rule 57 (simple -> function .)
    R_FLOWBRACE     reduce using rule 57 (simple -> function .)
    ELSE            reduce using rule 57 (simple -> function .)
    R_PAREN         reduce using rule 57 (simple -> function .)


state 17

    (58) simple -> RETURN . expr SEMICOLON
    (59) simple -> RETURN . SEMICOLON
    (91) expr -> . expr assignment exprOR
    (92) expr -> . exprOR
    (104) exprOR -> . exprOR OR exprAND
    (105) exprOR -> . exprAND
    (106) exprAND -> . exprAND AND exprBITOR
    (107) exprAND -> . exprBITOR
    (108) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (109) exprBITOR -> . exprBITXOR
    (110) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (111) exprBITXOR -> . exprBITAND
    (112) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (113) exprBITAND -> . exprEQ
    (114) exprEQ -> . exprEQ EQ exprRELOP
    (115) exprEQ -> . exprEQ NE exprRELOP
    (116) exprEQ -> . exprRELOP
    (117) exprRELOP -> . exprRELOP relop exprSHIFT
    (118) exprRELOP -> . exprSHIFT
    (123) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (124) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (125) exprSHIFT -> . exprOP
    (126) exprOP -> . exprOP PLUS term
    (127) exprOP -> . exprOP MINUS term
    (128) exprOP -> . term
    (129) term -> . term MULTIPLY factor
    (130) term -> . term DIVIDE factor
    (131) term -> . term MOD factor
    (132) term -> . factor
    (133) factor -> . NOT factor
    (134) factor -> . PLUS factor
    (135) factor -> . MINUS factor
    (136) factor -> . PLUS_PLUS factor
    (137) factor -> . MINUS_MINUS factor
    (138) factor -> . cast brace
    (139) factor -> . brace
    (140) cast -> . L_PAREN TYPE R_PAREN
    (141) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (142) brace -> . L_PAREN expr R_PAREN
    (143) brace -> . brace PLUS_PLUS
    (144) brace -> . brace MINUS_MINUS
    (145) brace -> . NUM
    (146) brace -> . STRING
    (147) brace -> . MULTIPLY ID
    (148) brace -> . BIT_AND ID
    (149) brace -> . ID
    (150) brace -> . CHAR
    (151) brace -> . function_call
    (152) brace -> . ID narrayindex
    (153) NUM -> . INT_NUM
    (154) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    SEMICOLON       shift and go to state 70
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    expr                           shift and go to state 69
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 18

    (49) block -> left_flower . multiple_statements right_flower
    (50) block -> left_flower . right_flower
    (2) multiple_statements -> . multiple_statements statement
    (3) multiple_statements -> . statement
    (52) right_flower -> . R_FLOWBRACE
    (4) statement -> . open
    (5) statement -> . closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) open -> . for for_condition open
    (11) closed -> . simple
    (12) closed -> . block
    (13) closed -> . IF condition closed ELSE closed
    (14) closed -> . WHILE condition closed
    (15) closed -> . for for_condition closed
    (10) for -> . FOR
    (53) simple -> . expr SEMICOLON
    (54) simple -> . header
    (55) simple -> . declaration
    (56) simple -> . SEMICOLON
    (57) simple -> . function
    (58) simple -> . RETURN expr SEMICOLON
    (59) simple -> . RETURN SEMICOLON
    (49) block -> . left_flower multiple_statements right_flower
    (50) block -> . left_flower right_flower
    (91) expr -> . expr assignment exprOR
    (92) expr -> . exprOR
    (60) header -> . HASH INCLUDE STRING
    (61) header -> . HASH INCLUDE HEADER_FILE
    (34) declaration -> . TYPE ID SEMICOLON
    (35) declaration -> . TYPE MULTIPLY ID SEMICOLON
    (36) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (37) declaration -> . TYPE MULTIPLY ID ASSIGN expr SEMICOLON
    (38) declaration -> . TYPE multi_declaration stop
    (39) declaration -> . TYPE ID narrayindex SEMICOLON
    (40) declaration -> . TYPE ID narrayindex ASSIGN init_list SEMICOLON
    (88) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (51) left_flower -> . L_FLOWBRACE
    (104) exprOR -> . exprOR OR exprAND
    (105) exprOR -> . exprAND
    (106) exprAND -> . exprAND AND exprBITOR
    (107) exprAND -> . exprBITOR
    (108) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (109) exprBITOR -> . exprBITXOR
    (110) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (111) exprBITXOR -> . exprBITAND
    (112) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (113) exprBITAND -> . exprEQ
    (114) exprEQ -> . exprEQ EQ exprRELOP
    (115) exprEQ -> . exprEQ NE exprRELOP
    (116) exprEQ -> . exprRELOP
    (117) exprRELOP -> . exprRELOP relop exprSHIFT
    (118) exprRELOP -> . exprSHIFT
    (123) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (124) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (125) exprSHIFT -> . exprOP
    (126) exprOP -> . exprOP PLUS term
    (127) exprOP -> . exprOP MINUS term
    (128) exprOP -> . term
    (129) term -> . term MULTIPLY factor
    (130) term -> . term DIVIDE factor
    (131) term -> . term MOD factor
    (132) term -> . factor
    (133) factor -> . NOT factor
    (134) factor -> . PLUS factor
    (135) factor -> . MINUS factor
    (136) factor -> . PLUS_PLUS factor
    (137) factor -> . MINUS_MINUS factor
    (138) factor -> . cast brace
    (139) factor -> . brace
    (140) cast -> . L_PAREN TYPE R_PAREN
    (141) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (142) brace -> . L_PAREN expr R_PAREN
    (143) brace -> . brace PLUS_PLUS
    (144) brace -> . brace MINUS_MINUS
    (145) brace -> . NUM
    (146) brace -> . STRING
    (147) brace -> . MULTIPLY ID
    (148) brace -> . BIT_AND ID
    (149) brace -> . ID
    (150) brace -> . CHAR
    (151) brace -> . function_call
    (152) brace -> . ID narrayindex
    (153) NUM -> . INT_NUM
    (154) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    R_FLOWBRACE     shift and go to state 73
    IF              shift and go to state 6
    WHILE           shift and go to state 7
    FOR             shift and go to state 11
    SEMICOLON       shift and go to state 13
    RETURN          shift and go to state 17
    HASH            shift and go to state 20
    TYPE            shift and go to state 22
    L_FLOWBRACE     shift and go to state 26
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    left_flower                    shift and go to state 18
    multiple_statements            shift and go to state 71
    right_flower                   shift and go to state 72
    statement                      shift and go to state 3
    open                           shift and go to state 4
    closed                         shift and go to state 5
    for                            shift and go to state 8
    simple                         shift and go to state 9
    block                          shift and go to state 10
    expr                           shift and go to state 12
    header                         shift and go to state 14
    declaration                    shift and go to state 15
    function                       shift and go to state 16
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 19

    (92) expr -> exprOR .
    (104) exprOR -> exprOR . OR exprAND

    SEMICOLON       reduce using rule 92 (expr -> exprOR .)
    ASSIGN          reduce using rule 92 (expr -> exprOR .)
    PLUS_ASSIGN     reduce using rule 92 (expr -> exprOR .)
    MINUS_ASSIGN    reduce using rule 92 (expr -> exprOR .)
    MUL_ASSIGN      reduce using rule 92 (expr -> exprOR .)
    DIV_ASSIGN      reduce using rule 92 (expr -> exprOR .)
    AND_ASSIGN      reduce using rule 92 (expr -> exprOR .)
    OR_ASSIGN       reduce using rule 92 (expr -> exprOR .)
    XOR_ASSIGN      reduce using rule 92 (expr -> exprOR .)
    MOD_ASSIGN      reduce using rule 92 (expr -> exprOR .)
    L_SHIFT_ASSIGN  reduce using rule 92 (expr -> exprOR .)
    R_SHIFT_ASSIGN  reduce using rule 92 (expr -> exprOR .)
    R_PAREN         reduce using rule 92 (expr -> exprOR .)
    COMMA           reduce using rule 92 (expr -> exprOR .)
    R_SQBRACE       reduce using rule 92 (expr -> exprOR .)
    R_FLOWBRACE     reduce using rule 92 (expr -> exprOR .)
    OR              shift and go to state 74


state 20

    (60) header -> HASH . INCLUDE STRING
    (61) header -> HASH . INCLUDE HEADER_FILE

    INCLUDE         shift and go to state 75


state 21

    (146) brace -> STRING .

    PLUS_PLUS       reduce using rule 146 (brace -> STRING .)
    MINUS_MINUS     reduce using rule 146 (brace -> STRING .)
    MULTIPLY        reduce using rule 146 (brace -> STRING .)
    DIVIDE          reduce using rule 146 (brace -> STRING .)
    MOD             reduce using rule 146 (brace -> STRING .)
    PLUS            reduce using rule 146 (brace -> STRING .)
    MINUS           reduce using rule 146 (brace -> STRING .)
    L_SHIFT         reduce using rule 146 (brace -> STRING .)
    R_SHIFT         reduce using rule 146 (brace -> STRING .)
    LE              reduce using rule 146 (brace -> STRING .)
    LT              reduce using rule 146 (brace -> STRING .)
    GE              reduce using rule 146 (brace -> STRING .)
    GT              reduce using rule 146 (brace -> STRING .)
    EQ              reduce using rule 146 (brace -> STRING .)
    NE              reduce using rule 146 (brace -> STRING .)
    BIT_AND         reduce using rule 146 (brace -> STRING .)
    BIT_XOR         reduce using rule 146 (brace -> STRING .)
    BIT_OR          reduce using rule 146 (brace -> STRING .)
    AND             reduce using rule 146 (brace -> STRING .)
    OR              reduce using rule 146 (brace -> STRING .)
    SEMICOLON       reduce using rule 146 (brace -> STRING .)
    ASSIGN          reduce using rule 146 (brace -> STRING .)
    PLUS_ASSIGN     reduce using rule 146 (brace -> STRING .)
    MINUS_ASSIGN    reduce using rule 146 (brace -> STRING .)
    MUL_ASSIGN      reduce using rule 146 (brace -> STRING .)
    DIV_ASSIGN      reduce using rule 146 (brace -> STRING .)
    AND_ASSIGN      reduce using rule 146 (brace -> STRING .)
    OR_ASSIGN       reduce using rule 146 (brace -> STRING .)
    XOR_ASSIGN      reduce using rule 146 (brace -> STRING .)
    MOD_ASSIGN      reduce using rule 146 (brace -> STRING .)
    L_SHIFT_ASSIGN  reduce using rule 146 (brace -> STRING .)
    R_SHIFT_ASSIGN  reduce using rule 146 (brace -> STRING .)
    R_PAREN         reduce using rule 146 (brace -> STRING .)
    COMMA           reduce using rule 146 (brace -> STRING .)
    R_SQBRACE       reduce using rule 146 (brace -> STRING .)
    R_FLOWBRACE     reduce using rule 146 (brace -> STRING .)


state 22

    (34) declaration -> TYPE . ID SEMICOLON
    (35) declaration -> TYPE . MULTIPLY ID SEMICOLON
    (36) declaration -> TYPE . ID ASSIGN expr SEMICOLON
    (37) declaration -> TYPE . MULTIPLY ID ASSIGN expr SEMICOLON
    (38) declaration -> TYPE . multi_declaration stop
    (39) declaration -> TYPE . ID narrayindex SEMICOLON
    (40) declaration -> TYPE . ID narrayindex ASSIGN init_list SEMICOLON
    (88) function -> TYPE . ID L_PAREN dec_params R_PAREN function_2
    (19) multi_declaration -> . multi_declaration ID COMMA
    (20) multi_declaration -> . multi_declaration MULTIPLY ID COMMA
    (21) multi_declaration -> . multi_declaration ID ASSIGN expr COMMA
    (22) multi_declaration -> . multi_declaration MULTIPLY ID ASSIGN expr COMMA
    (23) multi_declaration -> . ID COMMA
    (24) multi_declaration -> . ID ASSIGN expr COMMA
    (25) multi_declaration -> . MULTIPLY ID COMMA
    (26) multi_declaration -> . MULTIPLY ID ASSIGN expr COMMA

    ID              shift and go to state 76
    MULTIPLY        shift and go to state 77

    multi_declaration              shift and go to state 78

state 23

    (149) brace -> ID .
    (152) brace -> ID . narrayindex
    (63) function_call -> ID . L_PAREN call_params R_PAREN
    (32) narrayindex -> . narrayindex arrayindex
    (33) narrayindex -> . arrayindex
    (31) arrayindex -> . L_SQBRACE index R_SQBRACE

    PLUS_PLUS       reduce using rule 149 (brace -> ID .)
    MINUS_MINUS     reduce using rule 149 (brace -> ID .)
    MULTIPLY        reduce using rule 149 (brace -> ID .)
    DIVIDE          reduce using rule 149 (brace -> ID .)
    MOD             reduce using rule 149 (brace -> ID .)
    PLUS            reduce using rule 149 (brace -> ID .)
    MINUS           reduce using rule 149 (brace -> ID .)
    L_SHIFT         reduce using rule 149 (brace -> ID .)
    R_SHIFT         reduce using rule 149 (brace -> ID .)
    LE              reduce using rule 149 (brace -> ID .)
    LT              reduce using rule 149 (brace -> ID .)
    GE              reduce using rule 149 (brace -> ID .)
    GT              reduce using rule 149 (brace -> ID .)
    EQ              reduce using rule 149 (brace -> ID .)
    NE              reduce using rule 149 (brace -> ID .)
    BIT_AND         reduce using rule 149 (brace -> ID .)
    BIT_XOR         reduce using rule 149 (brace -> ID .)
    BIT_OR          reduce using rule 149 (brace -> ID .)
    AND             reduce using rule 149 (brace -> ID .)
    OR              reduce using rule 149 (brace -> ID .)
    SEMICOLON       reduce using rule 149 (brace -> ID .)
    ASSIGN          reduce using rule 149 (brace -> ID .)
    PLUS_ASSIGN     reduce using rule 149 (brace -> ID .)
    MINUS_ASSIGN    reduce using rule 149 (brace -> ID .)
    MUL_ASSIGN      reduce using rule 149 (brace -> ID .)
    DIV_ASSIGN      reduce using rule 149 (brace -> ID .)
    AND_ASSIGN      reduce using rule 149 (brace -> ID .)
    OR_ASSIGN       reduce using rule 149 (brace -> ID .)
    XOR_ASSIGN      reduce using rule 149 (brace -> ID .)
    MOD_ASSIGN      reduce using rule 149 (brace -> ID .)
    L_SHIFT_ASSIGN  reduce using rule 149 (brace -> ID .)
    R_SHIFT_ASSIGN  reduce using rule 149 (brace -> ID .)
    R_PAREN         reduce using rule 149 (brace -> ID .)
    COMMA           reduce using rule 149 (brace -> ID .)
    R_SQBRACE       reduce using rule 149 (brace -> ID .)
    R_FLOWBRACE     reduce using rule 149 (brace -> ID .)
    L_PAREN         shift and go to state 80
    L_SQBRACE       shift and go to state 82

    narrayindex                    shift and go to state 79
    arrayindex                     shift and go to state 81

state 24

    (147) brace -> MULTIPLY . ID

    ID              shift and go to state 83


state 25

    (140) cast -> L_PAREN . TYPE R_PAREN
    (141) cast -> L_PAREN . TYPE MULTIPLY R_PAREN
    (142) brace -> L_PAREN . expr R_PAREN
    (91) expr -> . expr assignment exprOR
    (92) expr -> . exprOR
    (104) exprOR -> . exprOR OR exprAND
    (105) exprOR -> . exprAND
    (106) exprAND -> . exprAND AND exprBITOR
    (107) exprAND -> . exprBITOR
    (108) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (109) exprBITOR -> . exprBITXOR
    (110) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (111) exprBITXOR -> . exprBITAND
    (112) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (113) exprBITAND -> . exprEQ
    (114) exprEQ -> . exprEQ EQ exprRELOP
    (115) exprEQ -> . exprEQ NE exprRELOP
    (116) exprEQ -> . exprRELOP
    (117) exprRELOP -> . exprRELOP relop exprSHIFT
    (118) exprRELOP -> . exprSHIFT
    (123) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (124) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (125) exprSHIFT -> . exprOP
    (126) exprOP -> . exprOP PLUS term
    (127) exprOP -> . exprOP MINUS term
    (128) exprOP -> . term
    (129) term -> . term MULTIPLY factor
    (130) term -> . term DIVIDE factor
    (131) term -> . term MOD factor
    (132) term -> . factor
    (133) factor -> . NOT factor
    (134) factor -> . PLUS factor
    (135) factor -> . MINUS factor
    (136) factor -> . PLUS_PLUS factor
    (137) factor -> . MINUS_MINUS factor
    (138) factor -> . cast brace
    (139) factor -> . brace
    (140) cast -> . L_PAREN TYPE R_PAREN
    (141) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (142) brace -> . L_PAREN expr R_PAREN
    (143) brace -> . brace PLUS_PLUS
    (144) brace -> . brace MINUS_MINUS
    (145) brace -> . NUM
    (146) brace -> . STRING
    (147) brace -> . MULTIPLY ID
    (148) brace -> . BIT_AND ID
    (149) brace -> . ID
    (150) brace -> . CHAR
    (151) brace -> . function_call
    (152) brace -> . ID narrayindex
    (153) NUM -> . INT_NUM
    (154) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    TYPE            shift and go to state 84
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    expr                           shift and go to state 85
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 26

    (51) left_flower -> L_FLOWBRACE .

    R_FLOWBRACE     reduce using rule 51 (left_flower -> L_FLOWBRACE .)
    IF              reduce using rule 51 (left_flower -> L_FLOWBRACE .)
    WHILE           reduce using rule 51 (left_flower -> L_FLOWBRACE .)
    FOR             reduce using rule 51 (left_flower -> L_FLOWBRACE .)
    SEMICOLON       reduce using rule 51 (left_flower -> L_FLOWBRACE .)
    RETURN          reduce using rule 51 (left_flower -> L_FLOWBRACE .)
    HASH            reduce using rule 51 (left_flower -> L_FLOWBRACE .)
    TYPE            reduce using rule 51 (left_flower -> L_FLOWBRACE .)
    L_FLOWBRACE     reduce using rule 51 (left_flower -> L_FLOWBRACE .)
    NOT             reduce using rule 51 (left_flower -> L_FLOWBRACE .)
    PLUS            reduce using rule 51 (left_flower -> L_FLOWBRACE .)
    MINUS           reduce using rule 51 (left_flower -> L_FLOWBRACE .)
    PLUS_PLUS       reduce using rule 51 (left_flower -> L_FLOWBRACE .)
    MINUS_MINUS     reduce using rule 51 (left_flower -> L_FLOWBRACE .)
    L_PAREN         reduce using rule 51 (left_flower -> L_FLOWBRACE .)
    STRING          reduce using rule 51 (left_flower -> L_FLOWBRACE .)
    MULTIPLY        reduce using rule 51 (left_flower -> L_FLOWBRACE .)
    BIT_AND         reduce using rule 51 (left_flower -> L_FLOWBRACE .)
    ID              reduce using rule 51 (left_flower -> L_FLOWBRACE .)
    CHAR            reduce using rule 51 (left_flower -> L_FLOWBRACE .)
    INT_NUM         reduce using rule 51 (left_flower -> L_FLOWBRACE .)
    FLOAT_NUM       reduce using rule 51 (left_flower -> L_FLOWBRACE .)


state 27

    (105) exprOR -> exprAND .
    (106) exprAND -> exprAND . AND exprBITOR

    OR              reduce using rule 105 (exprOR -> exprAND .)
    SEMICOLON       reduce using rule 105 (exprOR -> exprAND .)
    ASSIGN          reduce using rule 105 (exprOR -> exprAND .)
    PLUS_ASSIGN     reduce using rule 105 (exprOR -> exprAND .)
    MINUS_ASSIGN    reduce using rule 105 (exprOR -> exprAND .)
    MUL_ASSIGN      reduce using rule 105 (exprOR -> exprAND .)
    DIV_ASSIGN      reduce using rule 105 (exprOR -> exprAND .)
    AND_ASSIGN      reduce using rule 105 (exprOR -> exprAND .)
    OR_ASSIGN       reduce using rule 105 (exprOR -> exprAND .)
    XOR_ASSIGN      reduce using rule 105 (exprOR -> exprAND .)
    MOD_ASSIGN      reduce using rule 105 (exprOR -> exprAND .)
    L_SHIFT_ASSIGN  reduce using rule 105 (exprOR -> exprAND .)
    R_SHIFT_ASSIGN  reduce using rule 105 (exprOR -> exprAND .)
    R_PAREN         reduce using rule 105 (exprOR -> exprAND .)
    COMMA           reduce using rule 105 (exprOR -> exprAND .)
    R_SQBRACE       reduce using rule 105 (exprOR -> exprAND .)
    R_FLOWBRACE     reduce using rule 105 (exprOR -> exprAND .)
    AND             shift and go to state 86


state 28

    (107) exprAND -> exprBITOR .
    (108) exprBITOR -> exprBITOR . BIT_OR exprBITXOR

    AND             reduce using rule 107 (exprAND -> exprBITOR .)
    OR              reduce using rule 107 (exprAND -> exprBITOR .)
    SEMICOLON       reduce using rule 107 (exprAND -> exprBITOR .)
    ASSIGN          reduce using rule 107 (exprAND -> exprBITOR .)
    PLUS_ASSIGN     reduce using rule 107 (exprAND -> exprBITOR .)
    MINUS_ASSIGN    reduce using rule 107 (exprAND -> exprBITOR .)
    MUL_ASSIGN      reduce using rule 107 (exprAND -> exprBITOR .)
    DIV_ASSIGN      reduce using rule 107 (exprAND -> exprBITOR .)
    AND_ASSIGN      reduce using rule 107 (exprAND -> exprBITOR .)
    OR_ASSIGN       reduce using rule 107 (exprAND -> exprBITOR .)
    XOR_ASSIGN      reduce using rule 107 (exprAND -> exprBITOR .)
    MOD_ASSIGN      reduce using rule 107 (exprAND -> exprBITOR .)
    L_SHIFT_ASSIGN  reduce using rule 107 (exprAND -> exprBITOR .)
    R_SHIFT_ASSIGN  reduce using rule 107 (exprAND -> exprBITOR .)
    R_PAREN         reduce using rule 107 (exprAND -> exprBITOR .)
    COMMA           reduce using rule 107 (exprAND -> exprBITOR .)
    R_SQBRACE       reduce using rule 107 (exprAND -> exprBITOR .)
    R_FLOWBRACE     reduce using rule 107 (exprAND -> exprBITOR .)
    BIT_OR          shift and go to state 87


state 29

    (109) exprBITOR -> exprBITXOR .
    (110) exprBITXOR -> exprBITXOR . BIT_XOR exprBITAND

    BIT_OR          reduce using rule 109 (exprBITOR -> exprBITXOR .)
    AND             reduce using rule 109 (exprBITOR -> exprBITXOR .)
    OR              reduce using rule 109 (exprBITOR -> exprBITXOR .)
    SEMICOLON       reduce using rule 109 (exprBITOR -> exprBITXOR .)
    ASSIGN          reduce using rule 109 (exprBITOR -> exprBITXOR .)
    PLUS_ASSIGN     reduce using rule 109 (exprBITOR -> exprBITXOR .)
    MINUS_ASSIGN    reduce using rule 109 (exprBITOR -> exprBITXOR .)
    MUL_ASSIGN      reduce using rule 109 (exprBITOR -> exprBITXOR .)
    DIV_ASSIGN      reduce using rule 109 (exprBITOR -> exprBITXOR .)
    AND_ASSIGN      reduce using rule 109 (exprBITOR -> exprBITXOR .)
    OR_ASSIGN       reduce using rule 109 (exprBITOR -> exprBITXOR .)
    XOR_ASSIGN      reduce using rule 109 (exprBITOR -> exprBITXOR .)
    MOD_ASSIGN      reduce using rule 109 (exprBITOR -> exprBITXOR .)
    L_SHIFT_ASSIGN  reduce using rule 109 (exprBITOR -> exprBITXOR .)
    R_SHIFT_ASSIGN  reduce using rule 109 (exprBITOR -> exprBITXOR .)
    R_PAREN         reduce using rule 109 (exprBITOR -> exprBITXOR .)
    COMMA           reduce using rule 109 (exprBITOR -> exprBITXOR .)
    R_SQBRACE       reduce using rule 109 (exprBITOR -> exprBITXOR .)
    R_FLOWBRACE     reduce using rule 109 (exprBITOR -> exprBITXOR .)
    BIT_XOR         shift and go to state 88


state 30

    (111) exprBITXOR -> exprBITAND .
    (112) exprBITAND -> exprBITAND . BIT_AND exprEQ

    BIT_XOR         reduce using rule 111 (exprBITXOR -> exprBITAND .)
    BIT_OR          reduce using rule 111 (exprBITXOR -> exprBITAND .)
    AND             reduce using rule 111 (exprBITXOR -> exprBITAND .)
    OR              reduce using rule 111 (exprBITXOR -> exprBITAND .)
    SEMICOLON       reduce using rule 111 (exprBITXOR -> exprBITAND .)
    ASSIGN          reduce using rule 111 (exprBITXOR -> exprBITAND .)
    PLUS_ASSIGN     reduce using rule 111 (exprBITXOR -> exprBITAND .)
    MINUS_ASSIGN    reduce using rule 111 (exprBITXOR -> exprBITAND .)
    MUL_ASSIGN      reduce using rule 111 (exprBITXOR -> exprBITAND .)
    DIV_ASSIGN      reduce using rule 111 (exprBITXOR -> exprBITAND .)
    AND_ASSIGN      reduce using rule 111 (exprBITXOR -> exprBITAND .)
    OR_ASSIGN       reduce using rule 111 (exprBITXOR -> exprBITAND .)
    XOR_ASSIGN      reduce using rule 111 (exprBITXOR -> exprBITAND .)
    MOD_ASSIGN      reduce using rule 111 (exprBITXOR -> exprBITAND .)
    L_SHIFT_ASSIGN  reduce using rule 111 (exprBITXOR -> exprBITAND .)
    R_SHIFT_ASSIGN  reduce using rule 111 (exprBITXOR -> exprBITAND .)
    R_PAREN         reduce using rule 111 (exprBITXOR -> exprBITAND .)
    COMMA           reduce using rule 111 (exprBITXOR -> exprBITAND .)
    R_SQBRACE       reduce using rule 111 (exprBITXOR -> exprBITAND .)
    R_FLOWBRACE     reduce using rule 111 (exprBITXOR -> exprBITAND .)
    BIT_AND         shift and go to state 89


state 31

    (148) brace -> BIT_AND . ID

    ID              shift and go to state 90


state 32

    (113) exprBITAND -> exprEQ .
    (114) exprEQ -> exprEQ . EQ exprRELOP
    (115) exprEQ -> exprEQ . NE exprRELOP

    BIT_AND         reduce using rule 113 (exprBITAND -> exprEQ .)
    BIT_XOR         reduce using rule 113 (exprBITAND -> exprEQ .)
    BIT_OR          reduce using rule 113 (exprBITAND -> exprEQ .)
    AND             reduce using rule 113 (exprBITAND -> exprEQ .)
    OR              reduce using rule 113 (exprBITAND -> exprEQ .)
    SEMICOLON       reduce using rule 113 (exprBITAND -> exprEQ .)
    ASSIGN          reduce using rule 113 (exprBITAND -> exprEQ .)
    PLUS_ASSIGN     reduce using rule 113 (exprBITAND -> exprEQ .)
    MINUS_ASSIGN    reduce using rule 113 (exprBITAND -> exprEQ .)
    MUL_ASSIGN      reduce using rule 113 (exprBITAND -> exprEQ .)
    DIV_ASSIGN      reduce using rule 113 (exprBITAND -> exprEQ .)
    AND_ASSIGN      reduce using rule 113 (exprBITAND -> exprEQ .)
    OR_ASSIGN       reduce using rule 113 (exprBITAND -> exprEQ .)
    XOR_ASSIGN      reduce using rule 113 (exprBITAND -> exprEQ .)
    MOD_ASSIGN      reduce using rule 113 (exprBITAND -> exprEQ .)
    L_SHIFT_ASSIGN  reduce using rule 113 (exprBITAND -> exprEQ .)
    R_SHIFT_ASSIGN  reduce using rule 113 (exprBITAND -> exprEQ .)
    R_PAREN         reduce using rule 113 (exprBITAND -> exprEQ .)
    COMMA           reduce using rule 113 (exprBITAND -> exprEQ .)
    R_SQBRACE       reduce using rule 113 (exprBITAND -> exprEQ .)
    R_FLOWBRACE     reduce using rule 113 (exprBITAND -> exprEQ .)
    EQ              shift and go to state 91
    NE              shift and go to state 92


state 33

    (116) exprEQ -> exprRELOP .
    (117) exprRELOP -> exprRELOP . relop exprSHIFT
    (119) relop -> . LE
    (120) relop -> . LT
    (121) relop -> . GE
    (122) relop -> . GT

    EQ              reduce using rule 116 (exprEQ -> exprRELOP .)
    NE              reduce using rule 116 (exprEQ -> exprRELOP .)
    BIT_AND         reduce using rule 116 (exprEQ -> exprRELOP .)
    BIT_XOR         reduce using rule 116 (exprEQ -> exprRELOP .)
    BIT_OR          reduce using rule 116 (exprEQ -> exprRELOP .)
    AND             reduce using rule 116 (exprEQ -> exprRELOP .)
    OR              reduce using rule 116 (exprEQ -> exprRELOP .)
    SEMICOLON       reduce using rule 116 (exprEQ -> exprRELOP .)
    ASSIGN          reduce using rule 116 (exprEQ -> exprRELOP .)
    PLUS_ASSIGN     reduce using rule 116 (exprEQ -> exprRELOP .)
    MINUS_ASSIGN    reduce using rule 116 (exprEQ -> exprRELOP .)
    MUL_ASSIGN      reduce using rule 116 (exprEQ -> exprRELOP .)
    DIV_ASSIGN      reduce using rule 116 (exprEQ -> exprRELOP .)
    AND_ASSIGN      reduce using rule 116 (exprEQ -> exprRELOP .)
    OR_ASSIGN       reduce using rule 116 (exprEQ -> exprRELOP .)
    XOR_ASSIGN      reduce using rule 116 (exprEQ -> exprRELOP .)
    MOD_ASSIGN      reduce using rule 116 (exprEQ -> exprRELOP .)
    L_SHIFT_ASSIGN  reduce using rule 116 (exprEQ -> exprRELOP .)
    R_SHIFT_ASSIGN  reduce using rule 116 (exprEQ -> exprRELOP .)
    R_PAREN         reduce using rule 116 (exprEQ -> exprRELOP .)
    COMMA           reduce using rule 116 (exprEQ -> exprRELOP .)
    R_SQBRACE       reduce using rule 116 (exprEQ -> exprRELOP .)
    R_FLOWBRACE     reduce using rule 116 (exprEQ -> exprRELOP .)
    LE              shift and go to state 94
    LT              shift and go to state 95
    GE              shift and go to state 96
    GT              shift and go to state 97

    relop                          shift and go to state 93

state 34

    (118) exprRELOP -> exprSHIFT .
    (123) exprSHIFT -> exprSHIFT . L_SHIFT exprOP
    (124) exprSHIFT -> exprSHIFT . R_SHIFT exprOP

    LE              reduce using rule 118 (exprRELOP -> exprSHIFT .)
    LT              reduce using rule 118 (exprRELOP -> exprSHIFT .)
    GE              reduce using rule 118 (exprRELOP -> exprSHIFT .)
    GT              reduce using rule 118 (exprRELOP -> exprSHIFT .)
    EQ              reduce using rule 118 (exprRELOP -> exprSHIFT .)
    NE              reduce using rule 118 (exprRELOP -> exprSHIFT .)
    BIT_AND         reduce using rule 118 (exprRELOP -> exprSHIFT .)
    BIT_XOR         reduce using rule 118 (exprRELOP -> exprSHIFT .)
    BIT_OR          reduce using rule 118 (exprRELOP -> exprSHIFT .)
    AND             reduce using rule 118 (exprRELOP -> exprSHIFT .)
    OR              reduce using rule 118 (exprRELOP -> exprSHIFT .)
    SEMICOLON       reduce using rule 118 (exprRELOP -> exprSHIFT .)
    ASSIGN          reduce using rule 118 (exprRELOP -> exprSHIFT .)
    PLUS_ASSIGN     reduce using rule 118 (exprRELOP -> exprSHIFT .)
    MINUS_ASSIGN    reduce using rule 118 (exprRELOP -> exprSHIFT .)
    MUL_ASSIGN      reduce using rule 118 (exprRELOP -> exprSHIFT .)
    DIV_ASSIGN      reduce using rule 118 (exprRELOP -> exprSHIFT .)
    AND_ASSIGN      reduce using rule 118 (exprRELOP -> exprSHIFT .)
    OR_ASSIGN       reduce using rule 118 (exprRELOP -> exprSHIFT .)
    XOR_ASSIGN      reduce using rule 118 (exprRELOP -> exprSHIFT .)
    MOD_ASSIGN      reduce using rule 118 (exprRELOP -> exprSHIFT .)
    L_SHIFT_ASSIGN  reduce using rule 118 (exprRELOP -> exprSHIFT .)
    R_SHIFT_ASSIGN  reduce using rule 118 (exprRELOP -> exprSHIFT .)
    R_PAREN         reduce using rule 118 (exprRELOP -> exprSHIFT .)
    COMMA           reduce using rule 118 (exprRELOP -> exprSHIFT .)
    R_SQBRACE       reduce using rule 118 (exprRELOP -> exprSHIFT .)
    R_FLOWBRACE     reduce using rule 118 (exprRELOP -> exprSHIFT .)
    L_SHIFT         shift and go to state 98
    R_SHIFT         shift and go to state 99


state 35

    (125) exprSHIFT -> exprOP .
    (126) exprOP -> exprOP . PLUS term
    (127) exprOP -> exprOP . MINUS term

    L_SHIFT         reduce using rule 125 (exprSHIFT -> exprOP .)
    R_SHIFT         reduce using rule 125 (exprSHIFT -> exprOP .)
    LE              reduce using rule 125 (exprSHIFT -> exprOP .)
    LT              reduce using rule 125 (exprSHIFT -> exprOP .)
    GE              reduce using rule 125 (exprSHIFT -> exprOP .)
    GT              reduce using rule 125 (exprSHIFT -> exprOP .)
    EQ              reduce using rule 125 (exprSHIFT -> exprOP .)
    NE              reduce using rule 125 (exprSHIFT -> exprOP .)
    BIT_AND         reduce using rule 125 (exprSHIFT -> exprOP .)
    BIT_XOR         reduce using rule 125 (exprSHIFT -> exprOP .)
    BIT_OR          reduce using rule 125 (exprSHIFT -> exprOP .)
    AND             reduce using rule 125 (exprSHIFT -> exprOP .)
    OR              reduce using rule 125 (exprSHIFT -> exprOP .)
    SEMICOLON       reduce using rule 125 (exprSHIFT -> exprOP .)
    ASSIGN          reduce using rule 125 (exprSHIFT -> exprOP .)
    PLUS_ASSIGN     reduce using rule 125 (exprSHIFT -> exprOP .)
    MINUS_ASSIGN    reduce using rule 125 (exprSHIFT -> exprOP .)
    MUL_ASSIGN      reduce using rule 125 (exprSHIFT -> exprOP .)
    DIV_ASSIGN      reduce using rule 125 (exprSHIFT -> exprOP .)
    AND_ASSIGN      reduce using rule 125 (exprSHIFT -> exprOP .)
    OR_ASSIGN       reduce using rule 125 (exprSHIFT -> exprOP .)
    XOR_ASSIGN      reduce using rule 125 (exprSHIFT -> exprOP .)
    MOD_ASSIGN      reduce using rule 125 (exprSHIFT -> exprOP .)
    L_SHIFT_ASSIGN  reduce using rule 125 (exprSHIFT -> exprOP .)
    R_SHIFT_ASSIGN  reduce using rule 125 (exprSHIFT -> exprOP .)
    R_PAREN         reduce using rule 125 (exprSHIFT -> exprOP .)
    COMMA           reduce using rule 125 (exprSHIFT -> exprOP .)
    R_SQBRACE       reduce using rule 125 (exprSHIFT -> exprOP .)
    R_FLOWBRACE     reduce using rule 125 (exprSHIFT -> exprOP .)
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101


state 36

    (134) factor -> PLUS . factor
    (133) factor -> . NOT factor
    (134) factor -> . PLUS factor
    (135) factor -> . MINUS factor
    (136) factor -> . PLUS_PLUS factor
    (137) factor -> . MINUS_MINUS factor
    (138) factor -> . cast brace
    (139) factor -> . brace
    (140) cast -> . L_PAREN TYPE R_PAREN
    (141) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (142) brace -> . L_PAREN expr R_PAREN
    (143) brace -> . brace PLUS_PLUS
    (144) brace -> . brace MINUS_MINUS
    (145) brace -> . NUM
    (146) brace -> . STRING
    (147) brace -> . MULTIPLY ID
    (148) brace -> . BIT_AND ID
    (149) brace -> . ID
    (150) brace -> . CHAR
    (151) brace -> . function_call
    (152) brace -> . ID narrayindex
    (153) NUM -> . INT_NUM
    (154) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    factor                         shift and go to state 102
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 37

    (128) exprOP -> term .
    (129) term -> term . MULTIPLY factor
    (130) term -> term . DIVIDE factor
    (131) term -> term . MOD factor

    PLUS            reduce using rule 128 (exprOP -> term .)
    MINUS           reduce using rule 128 (exprOP -> term .)
    L_SHIFT         reduce using rule 128 (exprOP -> term .)
    R_SHIFT         reduce using rule 128 (exprOP -> term .)
    LE              reduce using rule 128 (exprOP -> term .)
    LT              reduce using rule 128 (exprOP -> term .)
    GE              reduce using rule 128 (exprOP -> term .)
    GT              reduce using rule 128 (exprOP -> term .)
    EQ              reduce using rule 128 (exprOP -> term .)
    NE              reduce using rule 128 (exprOP -> term .)
    BIT_AND         reduce using rule 128 (exprOP -> term .)
    BIT_XOR         reduce using rule 128 (exprOP -> term .)
    BIT_OR          reduce using rule 128 (exprOP -> term .)
    AND             reduce using rule 128 (exprOP -> term .)
    OR              reduce using rule 128 (exprOP -> term .)
    SEMICOLON       reduce using rule 128 (exprOP -> term .)
    ASSIGN          reduce using rule 128 (exprOP -> term .)
    PLUS_ASSIGN     reduce using rule 128 (exprOP -> term .)
    MINUS_ASSIGN    reduce using rule 128 (exprOP -> term .)
    MUL_ASSIGN      reduce using rule 128 (exprOP -> term .)
    DIV_ASSIGN      reduce using rule 128 (exprOP -> term .)
    AND_ASSIGN      reduce using rule 128 (exprOP -> term .)
    OR_ASSIGN       reduce using rule 128 (exprOP -> term .)
    XOR_ASSIGN      reduce using rule 128 (exprOP -> term .)
    MOD_ASSIGN      reduce using rule 128 (exprOP -> term .)
    L_SHIFT_ASSIGN  reduce using rule 128 (exprOP -> term .)
    R_SHIFT_ASSIGN  reduce using rule 128 (exprOP -> term .)
    R_PAREN         reduce using rule 128 (exprOP -> term .)
    COMMA           reduce using rule 128 (exprOP -> term .)
    R_SQBRACE       reduce using rule 128 (exprOP -> term .)
    R_FLOWBRACE     reduce using rule 128 (exprOP -> term .)
    MULTIPLY        shift and go to state 103
    DIVIDE          shift and go to state 104
    MOD             shift and go to state 105


state 38

    (135) factor -> MINUS . factor
    (133) factor -> . NOT factor
    (134) factor -> . PLUS factor
    (135) factor -> . MINUS factor
    (136) factor -> . PLUS_PLUS factor
    (137) factor -> . MINUS_MINUS factor
    (138) factor -> . cast brace
    (139) factor -> . brace
    (140) cast -> . L_PAREN TYPE R_PAREN
    (141) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (142) brace -> . L_PAREN expr R_PAREN
    (143) brace -> . brace PLUS_PLUS
    (144) brace -> . brace MINUS_MINUS
    (145) brace -> . NUM
    (146) brace -> . STRING
    (147) brace -> . MULTIPLY ID
    (148) brace -> . BIT_AND ID
    (149) brace -> . ID
    (150) brace -> . CHAR
    (151) brace -> . function_call
    (152) brace -> . ID narrayindex
    (153) NUM -> . INT_NUM
    (154) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    factor                         shift and go to state 106
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 39

    (132) term -> factor .

    MULTIPLY        reduce using rule 132 (term -> factor .)
    DIVIDE          reduce using rule 132 (term -> factor .)
    MOD             reduce using rule 132 (term -> factor .)
    PLUS            reduce using rule 132 (term -> factor .)
    MINUS           reduce using rule 132 (term -> factor .)
    L_SHIFT         reduce using rule 132 (term -> factor .)
    R_SHIFT         reduce using rule 132 (term -> factor .)
    LE              reduce using rule 132 (term -> factor .)
    LT              reduce using rule 132 (term -> factor .)
    GE              reduce using rule 132 (term -> factor .)
    GT              reduce using rule 132 (term -> factor .)
    EQ              reduce using rule 132 (term -> factor .)
    NE              reduce using rule 132 (term -> factor .)
    BIT_AND         reduce using rule 132 (term -> factor .)
    BIT_XOR         reduce using rule 132 (term -> factor .)
    BIT_OR          reduce using rule 132 (term -> factor .)
    AND             reduce using rule 132 (term -> factor .)
    OR              reduce using rule 132 (term -> factor .)
    SEMICOLON       reduce using rule 132 (term -> factor .)
    ASSIGN          reduce using rule 132 (term -> factor .)
    PLUS_ASSIGN     reduce using rule 132 (term -> factor .)
    MINUS_ASSIGN    reduce using rule 132 (term -> factor .)
    MUL_ASSIGN      reduce using rule 132 (term -> factor .)
    DIV_ASSIGN      reduce using rule 132 (term -> factor .)
    AND_ASSIGN      reduce using rule 132 (term -> factor .)
    OR_ASSIGN       reduce using rule 132 (term -> factor .)
    XOR_ASSIGN      reduce using rule 132 (term -> factor .)
    MOD_ASSIGN      reduce using rule 132 (term -> factor .)
    L_SHIFT_ASSIGN  reduce using rule 132 (term -> factor .)
    R_SHIFT_ASSIGN  reduce using rule 132 (term -> factor .)
    R_PAREN         reduce using rule 132 (term -> factor .)
    COMMA           reduce using rule 132 (term -> factor .)
    R_SQBRACE       reduce using rule 132 (term -> factor .)
    R_FLOWBRACE     reduce using rule 132 (term -> factor .)


state 40

    (133) factor -> NOT . factor
    (133) factor -> . NOT factor
    (134) factor -> . PLUS factor
    (135) factor -> . MINUS factor
    (136) factor -> . PLUS_PLUS factor
    (137) factor -> . MINUS_MINUS factor
    (138) factor -> . cast brace
    (139) factor -> . brace
    (140) cast -> . L_PAREN TYPE R_PAREN
    (141) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (142) brace -> . L_PAREN expr R_PAREN
    (143) brace -> . brace PLUS_PLUS
    (144) brace -> . brace MINUS_MINUS
    (145) brace -> . NUM
    (146) brace -> . STRING
    (147) brace -> . MULTIPLY ID
    (148) brace -> . BIT_AND ID
    (149) brace -> . ID
    (150) brace -> . CHAR
    (151) brace -> . function_call
    (152) brace -> . ID narrayindex
    (153) NUM -> . INT_NUM
    (154) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    factor                         shift and go to state 107
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 41

    (136) factor -> PLUS_PLUS . factor
    (133) factor -> . NOT factor
    (134) factor -> . PLUS factor
    (135) factor -> . MINUS factor
    (136) factor -> . PLUS_PLUS factor
    (137) factor -> . MINUS_MINUS factor
    (138) factor -> . cast brace
    (139) factor -> . brace
    (140) cast -> . L_PAREN TYPE R_PAREN
    (141) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (142) brace -> . L_PAREN expr R_PAREN
    (143) brace -> . brace PLUS_PLUS
    (144) brace -> . brace MINUS_MINUS
    (145) brace -> . NUM
    (146) brace -> . STRING
    (147) brace -> . MULTIPLY ID
    (148) brace -> . BIT_AND ID
    (149) brace -> . ID
    (150) brace -> . CHAR
    (151) brace -> . function_call
    (152) brace -> . ID narrayindex
    (153) NUM -> . INT_NUM
    (154) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    factor                         shift and go to state 108
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 42

    (137) factor -> MINUS_MINUS . factor
    (133) factor -> . NOT factor
    (134) factor -> . PLUS factor
    (135) factor -> . MINUS factor
    (136) factor -> . PLUS_PLUS factor
    (137) factor -> . MINUS_MINUS factor
    (138) factor -> . cast brace
    (139) factor -> . brace
    (140) cast -> . L_PAREN TYPE R_PAREN
    (141) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (142) brace -> . L_PAREN expr R_PAREN
    (143) brace -> . brace PLUS_PLUS
    (144) brace -> . brace MINUS_MINUS
    (145) brace -> . NUM
    (146) brace -> . STRING
    (147) brace -> . MULTIPLY ID
    (148) brace -> . BIT_AND ID
    (149) brace -> . ID
    (150) brace -> . CHAR
    (151) brace -> . function_call
    (152) brace -> . ID narrayindex
    (153) NUM -> . INT_NUM
    (154) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    factor                         shift and go to state 109
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 43

    (138) factor -> cast . brace
    (142) brace -> . L_PAREN expr R_PAREN
    (143) brace -> . brace PLUS_PLUS
    (144) brace -> . brace MINUS_MINUS
    (145) brace -> . NUM
    (146) brace -> . STRING
    (147) brace -> . MULTIPLY ID
    (148) brace -> . BIT_AND ID
    (149) brace -> . ID
    (150) brace -> . CHAR
    (151) brace -> . function_call
    (152) brace -> . ID narrayindex
    (153) NUM -> . INT_NUM
    (154) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    L_PAREN         shift and go to state 111
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    brace                          shift and go to state 110
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 44

    (139) factor -> brace .
    (143) brace -> brace . PLUS_PLUS
    (144) brace -> brace . MINUS_MINUS

    MULTIPLY        reduce using rule 139 (factor -> brace .)
    DIVIDE          reduce using rule 139 (factor -> brace .)
    MOD             reduce using rule 139 (factor -> brace .)
    PLUS            reduce using rule 139 (factor -> brace .)
    MINUS           reduce using rule 139 (factor -> brace .)
    L_SHIFT         reduce using rule 139 (factor -> brace .)
    R_SHIFT         reduce using rule 139 (factor -> brace .)
    LE              reduce using rule 139 (factor -> brace .)
    LT              reduce using rule 139 (factor -> brace .)
    GE              reduce using rule 139 (factor -> brace .)
    GT              reduce using rule 139 (factor -> brace .)
    EQ              reduce using rule 139 (factor -> brace .)
    NE              reduce using rule 139 (factor -> brace .)
    BIT_AND         reduce using rule 139 (factor -> brace .)
    BIT_XOR         reduce using rule 139 (factor -> brace .)
    BIT_OR          reduce using rule 139 (factor -> brace .)
    AND             reduce using rule 139 (factor -> brace .)
    OR              reduce using rule 139 (factor -> brace .)
    SEMICOLON       reduce using rule 139 (factor -> brace .)
    ASSIGN          reduce using rule 139 (factor -> brace .)
    PLUS_ASSIGN     reduce using rule 139 (factor -> brace .)
    MINUS_ASSIGN    reduce using rule 139 (factor -> brace .)
    MUL_ASSIGN      reduce using rule 139 (factor -> brace .)
    DIV_ASSIGN      reduce using rule 139 (factor -> brace .)
    AND_ASSIGN      reduce using rule 139 (factor -> brace .)
    OR_ASSIGN       reduce using rule 139 (factor -> brace .)
    XOR_ASSIGN      reduce using rule 139 (factor -> brace .)
    MOD_ASSIGN      reduce using rule 139 (factor -> brace .)
    L_SHIFT_ASSIGN  reduce using rule 139 (factor -> brace .)
    R_SHIFT_ASSIGN  reduce using rule 139 (factor -> brace .)
    R_PAREN         reduce using rule 139 (factor -> brace .)
    COMMA           reduce using rule 139 (factor -> brace .)
    R_SQBRACE       reduce using rule 139 (factor -> brace .)
    R_FLOWBRACE     reduce using rule 139 (factor -> brace .)
    PLUS_PLUS       shift and go to state 112
    MINUS_MINUS     shift and go to state 113


state 45

    (145) brace -> NUM .

    PLUS_PLUS       reduce using rule 145 (brace -> NUM .)
    MINUS_MINUS     reduce using rule 145 (brace -> NUM .)
    MULTIPLY        reduce using rule 145 (brace -> NUM .)
    DIVIDE          reduce using rule 145 (brace -> NUM .)
    MOD             reduce using rule 145 (brace -> NUM .)
    PLUS            reduce using rule 145 (brace -> NUM .)
    MINUS           reduce using rule 145 (brace -> NUM .)
    L_SHIFT         reduce using rule 145 (brace -> NUM .)
    R_SHIFT         reduce using rule 145 (brace -> NUM .)
    LE              reduce using rule 145 (brace -> NUM .)
    LT              reduce using rule 145 (brace -> NUM .)
    GE              reduce using rule 145 (brace -> NUM .)
    GT              reduce using rule 145 (brace -> NUM .)
    EQ              reduce using rule 145 (brace -> NUM .)
    NE              reduce using rule 145 (brace -> NUM .)
    BIT_AND         reduce using rule 145 (brace -> NUM .)
    BIT_XOR         reduce using rule 145 (brace -> NUM .)
    BIT_OR          reduce using rule 145 (brace -> NUM .)
    AND             reduce using rule 145 (brace -> NUM .)
    OR              reduce using rule 145 (brace -> NUM .)
    SEMICOLON       reduce using rule 145 (brace -> NUM .)
    ASSIGN          reduce using rule 145 (brace -> NUM .)
    PLUS_ASSIGN     reduce using rule 145 (brace -> NUM .)
    MINUS_ASSIGN    reduce using rule 145 (brace -> NUM .)
    MUL_ASSIGN      reduce using rule 145 (brace -> NUM .)
    DIV_ASSIGN      reduce using rule 145 (brace -> NUM .)
    AND_ASSIGN      reduce using rule 145 (brace -> NUM .)
    OR_ASSIGN       reduce using rule 145 (brace -> NUM .)
    XOR_ASSIGN      reduce using rule 145 (brace -> NUM .)
    MOD_ASSIGN      reduce using rule 145 (brace -> NUM .)
    L_SHIFT_ASSIGN  reduce using rule 145 (brace -> NUM .)
    R_SHIFT_ASSIGN  reduce using rule 145 (brace -> NUM .)
    R_PAREN         reduce using rule 145 (brace -> NUM .)
    COMMA           reduce using rule 145 (brace -> NUM .)
    R_SQBRACE       reduce using rule 145 (brace -> NUM .)
    R_FLOWBRACE     reduce using rule 145 (brace -> NUM .)


state 46

    (150) brace -> CHAR .

    PLUS_PLUS       reduce using rule 150 (brace -> CHAR .)
    MINUS_MINUS     reduce using rule 150 (brace -> CHAR .)
    MULTIPLY        reduce using rule 150 (brace -> CHAR .)
    DIVIDE          reduce using rule 150 (brace -> CHAR .)
    MOD             reduce using rule 150 (brace -> CHAR .)
    PLUS            reduce using rule 150 (brace -> CHAR .)
    MINUS           reduce using rule 150 (brace -> CHAR .)
    L_SHIFT         reduce using rule 150 (brace -> CHAR .)
    R_SHIFT         reduce using rule 150 (brace -> CHAR .)
    LE              reduce using rule 150 (brace -> CHAR .)
    LT              reduce using rule 150 (brace -> CHAR .)
    GE              reduce using rule 150 (brace -> CHAR .)
    GT              reduce using rule 150 (brace -> CHAR .)
    EQ              reduce using rule 150 (brace -> CHAR .)
    NE              reduce using rule 150 (brace -> CHAR .)
    BIT_AND         reduce using rule 150 (brace -> CHAR .)
    BIT_XOR         reduce using rule 150 (brace -> CHAR .)
    BIT_OR          reduce using rule 150 (brace -> CHAR .)
    AND             reduce using rule 150 (brace -> CHAR .)
    OR              reduce using rule 150 (brace -> CHAR .)
    SEMICOLON       reduce using rule 150 (brace -> CHAR .)
    ASSIGN          reduce using rule 150 (brace -> CHAR .)
    PLUS_ASSIGN     reduce using rule 150 (brace -> CHAR .)
    MINUS_ASSIGN    reduce using rule 150 (brace -> CHAR .)
    MUL_ASSIGN      reduce using rule 150 (brace -> CHAR .)
    DIV_ASSIGN      reduce using rule 150 (brace -> CHAR .)
    AND_ASSIGN      reduce using rule 150 (brace -> CHAR .)
    OR_ASSIGN       reduce using rule 150 (brace -> CHAR .)
    XOR_ASSIGN      reduce using rule 150 (brace -> CHAR .)
    MOD_ASSIGN      reduce using rule 150 (brace -> CHAR .)
    L_SHIFT_ASSIGN  reduce using rule 150 (brace -> CHAR .)
    R_SHIFT_ASSIGN  reduce using rule 150 (brace -> CHAR .)
    R_PAREN         reduce using rule 150 (brace -> CHAR .)
    COMMA           reduce using rule 150 (brace -> CHAR .)
    R_SQBRACE       reduce using rule 150 (brace -> CHAR .)
    R_FLOWBRACE     reduce using rule 150 (brace -> CHAR .)


state 47

    (151) brace -> function_call .

    PLUS_PLUS       reduce using rule 151 (brace -> function_call .)
    MINUS_MINUS     reduce using rule 151 (brace -> function_call .)
    MULTIPLY        reduce using rule 151 (brace -> function_call .)
    DIVIDE          reduce using rule 151 (brace -> function_call .)
    MOD             reduce using rule 151 (brace -> function_call .)
    PLUS            reduce using rule 151 (brace -> function_call .)
    MINUS           reduce using rule 151 (brace -> function_call .)
    L_SHIFT         reduce using rule 151 (brace -> function_call .)
    R_SHIFT         reduce using rule 151 (brace -> function_call .)
    LE              reduce using rule 151 (brace -> function_call .)
    LT              reduce using rule 151 (brace -> function_call .)
    GE              reduce using rule 151 (brace -> function_call .)
    GT              reduce using rule 151 (brace -> function_call .)
    EQ              reduce using rule 151 (brace -> function_call .)
    NE              reduce using rule 151 (brace -> function_call .)
    BIT_AND         reduce using rule 151 (brace -> function_call .)
    BIT_XOR         reduce using rule 151 (brace -> function_call .)
    BIT_OR          reduce using rule 151 (brace -> function_call .)
    AND             reduce using rule 151 (brace -> function_call .)
    OR              reduce using rule 151 (brace -> function_call .)
    SEMICOLON       reduce using rule 151 (brace -> function_call .)
    ASSIGN          reduce using rule 151 (brace -> function_call .)
    PLUS_ASSIGN     reduce using rule 151 (brace -> function_call .)
    MINUS_ASSIGN    reduce using rule 151 (brace -> function_call .)
    MUL_ASSIGN      reduce using rule 151 (brace -> function_call .)
    DIV_ASSIGN      reduce using rule 151 (brace -> function_call .)
    AND_ASSIGN      reduce using rule 151 (brace -> function_call .)
    OR_ASSIGN       reduce using rule 151 (brace -> function_call .)
    XOR_ASSIGN      reduce using rule 151 (brace -> function_call .)
    MOD_ASSIGN      reduce using rule 151 (brace -> function_call .)
    L_SHIFT_ASSIGN  reduce using rule 151 (brace -> function_call .)
    R_SHIFT_ASSIGN  reduce using rule 151 (brace -> function_call .)
    R_PAREN         reduce using rule 151 (brace -> function_call .)
    COMMA           reduce using rule 151 (brace -> function_call .)
    R_SQBRACE       reduce using rule 151 (brace -> function_call .)
    R_FLOWBRACE     reduce using rule 151 (brace -> function_call .)


state 48

    (153) NUM -> INT_NUM .

    PLUS_PLUS       reduce using rule 153 (NUM -> INT_NUM .)
    MINUS_MINUS     reduce using rule 153 (NUM -> INT_NUM .)
    MULTIPLY        reduce using rule 153 (NUM -> INT_NUM .)
    DIVIDE          reduce using rule 153 (NUM -> INT_NUM .)
    MOD             reduce using rule 153 (NUM -> INT_NUM .)
    PLUS            reduce using rule 153 (NUM -> INT_NUM .)
    MINUS           reduce using rule 153 (NUM -> INT_NUM .)
    L_SHIFT         reduce using rule 153 (NUM -> INT_NUM .)
    R_SHIFT         reduce using rule 153 (NUM -> INT_NUM .)
    LE              reduce using rule 153 (NUM -> INT_NUM .)
    LT              reduce using rule 153 (NUM -> INT_NUM .)
    GE              reduce using rule 153 (NUM -> INT_NUM .)
    GT              reduce using rule 153 (NUM -> INT_NUM .)
    EQ              reduce using rule 153 (NUM -> INT_NUM .)
    NE              reduce using rule 153 (NUM -> INT_NUM .)
    BIT_AND         reduce using rule 153 (NUM -> INT_NUM .)
    BIT_XOR         reduce using rule 153 (NUM -> INT_NUM .)
    BIT_OR          reduce using rule 153 (NUM -> INT_NUM .)
    AND             reduce using rule 153 (NUM -> INT_NUM .)
    OR              reduce using rule 153 (NUM -> INT_NUM .)
    SEMICOLON       reduce using rule 153 (NUM -> INT_NUM .)
    ASSIGN          reduce using rule 153 (NUM -> INT_NUM .)
    PLUS_ASSIGN     reduce using rule 153 (NUM -> INT_NUM .)
    MINUS_ASSIGN    reduce using rule 153 (NUM -> INT_NUM .)
    MUL_ASSIGN      reduce using rule 153 (NUM -> INT_NUM .)
    DIV_ASSIGN      reduce using rule 153 (NUM -> INT_NUM .)
    AND_ASSIGN      reduce using rule 153 (NUM -> INT_NUM .)
    OR_ASSIGN       reduce using rule 153 (NUM -> INT_NUM .)
    XOR_ASSIGN      reduce using rule 153 (NUM -> INT_NUM .)
    MOD_ASSIGN      reduce using rule 153 (NUM -> INT_NUM .)
    L_SHIFT_ASSIGN  reduce using rule 153 (NUM -> INT_NUM .)
    R_SHIFT_ASSIGN  reduce using rule 153 (NUM -> INT_NUM .)
    R_PAREN         reduce using rule 153 (NUM -> INT_NUM .)
    COMMA           reduce using rule 153 (NUM -> INT_NUM .)
    R_SQBRACE       reduce using rule 153 (NUM -> INT_NUM .)
    R_FLOWBRACE     reduce using rule 153 (NUM -> INT_NUM .)


state 49

    (154) NUM -> FLOAT_NUM .

    PLUS_PLUS       reduce using rule 154 (NUM -> FLOAT_NUM .)
    MINUS_MINUS     reduce using rule 154 (NUM -> FLOAT_NUM .)
    MULTIPLY        reduce using rule 154 (NUM -> FLOAT_NUM .)
    DIVIDE          reduce using rule 154 (NUM -> FLOAT_NUM .)
    MOD             reduce using rule 154 (NUM -> FLOAT_NUM .)
    PLUS            reduce using rule 154 (NUM -> FLOAT_NUM .)
    MINUS           reduce using rule 154 (NUM -> FLOAT_NUM .)
    L_SHIFT         reduce using rule 154 (NUM -> FLOAT_NUM .)
    R_SHIFT         reduce using rule 154 (NUM -> FLOAT_NUM .)
    LE              reduce using rule 154 (NUM -> FLOAT_NUM .)
    LT              reduce using rule 154 (NUM -> FLOAT_NUM .)
    GE              reduce using rule 154 (NUM -> FLOAT_NUM .)
    GT              reduce using rule 154 (NUM -> FLOAT_NUM .)
    EQ              reduce using rule 154 (NUM -> FLOAT_NUM .)
    NE              reduce using rule 154 (NUM -> FLOAT_NUM .)
    BIT_AND         reduce using rule 154 (NUM -> FLOAT_NUM .)
    BIT_XOR         reduce using rule 154 (NUM -> FLOAT_NUM .)
    BIT_OR          reduce using rule 154 (NUM -> FLOAT_NUM .)
    AND             reduce using rule 154 (NUM -> FLOAT_NUM .)
    OR              reduce using rule 154 (NUM -> FLOAT_NUM .)
    SEMICOLON       reduce using rule 154 (NUM -> FLOAT_NUM .)
    ASSIGN          reduce using rule 154 (NUM -> FLOAT_NUM .)
    PLUS_ASSIGN     reduce using rule 154 (NUM -> FLOAT_NUM .)
    MINUS_ASSIGN    reduce using rule 154 (NUM -> FLOAT_NUM .)
    MUL_ASSIGN      reduce using rule 154 (NUM -> FLOAT_NUM .)
    DIV_ASSIGN      reduce using rule 154 (NUM -> FLOAT_NUM .)
    AND_ASSIGN      reduce using rule 154 (NUM -> FLOAT_NUM .)
    OR_ASSIGN       reduce using rule 154 (NUM -> FLOAT_NUM .)
    XOR_ASSIGN      reduce using rule 154 (NUM -> FLOAT_NUM .)
    MOD_ASSIGN      reduce using rule 154 (NUM -> FLOAT_NUM .)
    L_SHIFT_ASSIGN  reduce using rule 154 (NUM -> FLOAT_NUM .)
    R_SHIFT_ASSIGN  reduce using rule 154 (NUM -> FLOAT_NUM .)
    R_PAREN         reduce using rule 154 (NUM -> FLOAT_NUM .)
    COMMA           reduce using rule 154 (NUM -> FLOAT_NUM .)
    R_SQBRACE       reduce using rule 154 (NUM -> FLOAT_NUM .)
    R_FLOWBRACE     reduce using rule 154 (NUM -> FLOAT_NUM .)


state 50

    (2) multiple_statements -> multiple_statements statement .

    IF              reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    WHILE           reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    FOR             reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    SEMICOLON       reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    RETURN          reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    HASH            reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    TYPE            reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    L_FLOWBRACE     reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    NOT             reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    PLUS            reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    MINUS           reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    PLUS_PLUS       reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    MINUS_MINUS     reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    L_PAREN         reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    STRING          reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    MULTIPLY        reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    BIT_AND         reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    ID              reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    CHAR            reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    INT_NUM         reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    FLOAT_NUM       reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    $end            reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    R_FLOWBRACE     reduce using rule 2 (multiple_statements -> multiple_statements statement .)


state 51

    (6) open -> IF condition . statement
    (7) open -> IF condition . closed ELSE open
    (13) closed -> IF condition . closed ELSE closed
    (4) statement -> . open
    (5) statement -> . closed
    (11) closed -> . simple
    (12) closed -> . block
    (13) closed -> . IF condition closed ELSE closed
    (14) closed -> . WHILE condition closed
    (15) closed -> . for for_condition closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) open -> . for for_condition open
    (53) simple -> . expr SEMICOLON
    (54) simple -> . header
    (55) simple -> . declaration
    (56) simple -> . SEMICOLON
    (57) simple -> . function
    (58) simple -> . RETURN expr SEMICOLON
    (59) simple -> . RETURN SEMICOLON
    (49) block -> . left_flower multiple_statements right_flower
    (50) block -> . left_flower right_flower
    (10) for -> . FOR
    (91) expr -> . expr assignment exprOR
    (92) expr -> . exprOR
    (60) header -> . HASH INCLUDE STRING
    (61) header -> . HASH INCLUDE HEADER_FILE
    (34) declaration -> . TYPE ID SEMICOLON
    (35) declaration -> . TYPE MULTIPLY ID SEMICOLON
    (36) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (37) declaration -> . TYPE MULTIPLY ID ASSIGN expr SEMICOLON
    (38) declaration -> . TYPE multi_declaration stop
    (39) declaration -> . TYPE ID narrayindex SEMICOLON
    (40) declaration -> . TYPE ID narrayindex ASSIGN init_list SEMICOLON
    (88) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (51) left_flower -> . L_FLOWBRACE
    (104) exprOR -> . exprOR OR exprAND
    (105) exprOR -> . exprAND
    (106) exprAND -> . exprAND AND exprBITOR
    (107) exprAND -> . exprBITOR
    (108) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (109) exprBITOR -> . exprBITXOR
    (110) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (111) exprBITXOR -> . exprBITAND
    (112) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (113) exprBITAND -> . exprEQ
    (114) exprEQ -> . exprEQ EQ exprRELOP
    (115) exprEQ -> . exprEQ NE exprRELOP
    (116) exprEQ -> . exprRELOP
    (117) exprRELOP -> . exprRELOP relop exprSHIFT
    (118) exprRELOP -> . exprSHIFT
    (123) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (124) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (125) exprSHIFT -> . exprOP
    (126) exprOP -> . exprOP PLUS term
    (127) exprOP -> . exprOP MINUS term
    (128) exprOP -> . term
    (129) term -> . term MULTIPLY factor
    (130) term -> . term DIVIDE factor
    (131) term -> . term MOD factor
    (132) term -> . factor
    (133) factor -> . NOT factor
    (134) factor -> . PLUS factor
    (135) factor -> . MINUS factor
    (136) factor -> . PLUS_PLUS factor
    (137) factor -> . MINUS_MINUS factor
    (138) factor -> . cast brace
    (139) factor -> . brace
    (140) cast -> . L_PAREN TYPE R_PAREN
    (141) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (142) brace -> . L_PAREN expr R_PAREN
    (143) brace -> . brace PLUS_PLUS
    (144) brace -> . brace MINUS_MINUS
    (145) brace -> . NUM
    (146) brace -> . STRING
    (147) brace -> . MULTIPLY ID
    (148) brace -> . BIT_AND ID
    (149) brace -> . ID
    (150) brace -> . CHAR
    (151) brace -> . function_call
    (152) brace -> . ID narrayindex
    (153) NUM -> . INT_NUM
    (154) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    IF              shift and go to state 114
    WHILE           shift and go to state 117
    SEMICOLON       shift and go to state 13
    RETURN          shift and go to state 17
    FOR             shift and go to state 11
    HASH            shift and go to state 20
    TYPE            shift and go to state 22
    L_FLOWBRACE     shift and go to state 26
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    statement                      shift and go to state 115
    closed                         shift and go to state 116
    open                           shift and go to state 4
    simple                         shift and go to state 9
    block                          shift and go to state 10
    for                            shift and go to state 118
    expr                           shift and go to state 12
    header                         shift and go to state 14
    declaration                    shift and go to state 15
    function                       shift and go to state 16
    left_flower                    shift and go to state 18
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 52

    (16) condition -> L_PAREN . expr R_PAREN
    (91) expr -> . expr assignment exprOR
    (92) expr -> . exprOR
    (104) exprOR -> . exprOR OR exprAND
    (105) exprOR -> . exprAND
    (106) exprAND -> . exprAND AND exprBITOR
    (107) exprAND -> . exprBITOR
    (108) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (109) exprBITOR -> . exprBITXOR
    (110) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (111) exprBITXOR -> . exprBITAND
    (112) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (113) exprBITAND -> . exprEQ
    (114) exprEQ -> . exprEQ EQ exprRELOP
    (115) exprEQ -> . exprEQ NE exprRELOP
    (116) exprEQ -> . exprRELOP
    (117) exprRELOP -> . exprRELOP relop exprSHIFT
    (118) exprRELOP -> . exprSHIFT
    (123) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (124) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (125) exprSHIFT -> . exprOP
    (126) exprOP -> . exprOP PLUS term
    (127) exprOP -> . exprOP MINUS term
    (128) exprOP -> . term
    (129) term -> . term MULTIPLY factor
    (130) term -> . term DIVIDE factor
    (131) term -> . term MOD factor
    (132) term -> . factor
    (133) factor -> . NOT factor
    (134) factor -> . PLUS factor
    (135) factor -> . MINUS factor
    (136) factor -> . PLUS_PLUS factor
    (137) factor -> . MINUS_MINUS factor
    (138) factor -> . cast brace
    (139) factor -> . brace
    (140) cast -> . L_PAREN TYPE R_PAREN
    (141) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (142) brace -> . L_PAREN expr R_PAREN
    (143) brace -> . brace PLUS_PLUS
    (144) brace -> . brace MINUS_MINUS
    (145) brace -> . NUM
    (146) brace -> . STRING
    (147) brace -> . MULTIPLY ID
    (148) brace -> . BIT_AND ID
    (149) brace -> . ID
    (150) brace -> . CHAR
    (151) brace -> . function_call
    (152) brace -> . ID narrayindex
    (153) NUM -> . INT_NUM
    (154) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    expr                           shift and go to state 119
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 53

    (8) open -> WHILE condition . open
    (14) closed -> WHILE condition . closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) open -> . for for_condition open
    (11) closed -> . simple
    (12) closed -> . block
    (13) closed -> . IF condition closed ELSE closed
    (14) closed -> . WHILE condition closed
    (15) closed -> . for for_condition closed
    (10) for -> . FOR
    (53) simple -> . expr SEMICOLON
    (54) simple -> . header
    (55) simple -> . declaration
    (56) simple -> . SEMICOLON
    (57) simple -> . function
    (58) simple -> . RETURN expr SEMICOLON
    (59) simple -> . RETURN SEMICOLON
    (49) block -> . left_flower multiple_statements right_flower
    (50) block -> . left_flower right_flower
    (91) expr -> . expr assignment exprOR
    (92) expr -> . exprOR
    (60) header -> . HASH INCLUDE STRING
    (61) header -> . HASH INCLUDE HEADER_FILE
    (34) declaration -> . TYPE ID SEMICOLON
    (35) declaration -> . TYPE MULTIPLY ID SEMICOLON
    (36) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (37) declaration -> . TYPE MULTIPLY ID ASSIGN expr SEMICOLON
    (38) declaration -> . TYPE multi_declaration stop
    (39) declaration -> . TYPE ID narrayindex SEMICOLON
    (40) declaration -> . TYPE ID narrayindex ASSIGN init_list SEMICOLON
    (88) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (51) left_flower -> . L_FLOWBRACE
    (104) exprOR -> . exprOR OR exprAND
    (105) exprOR -> . exprAND
    (106) exprAND -> . exprAND AND exprBITOR
    (107) exprAND -> . exprBITOR
    (108) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (109) exprBITOR -> . exprBITXOR
    (110) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (111) exprBITXOR -> . exprBITAND
    (112) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (113) exprBITAND -> . exprEQ
    (114) exprEQ -> . exprEQ EQ exprRELOP
    (115) exprEQ -> . exprEQ NE exprRELOP
    (116) exprEQ -> . exprRELOP
    (117) exprRELOP -> . exprRELOP relop exprSHIFT
    (118) exprRELOP -> . exprSHIFT
    (123) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (124) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (125) exprSHIFT -> . exprOP
    (126) exprOP -> . exprOP PLUS term
    (127) exprOP -> . exprOP MINUS term
    (128) exprOP -> . term
    (129) term -> . term MULTIPLY factor
    (130) term -> . term DIVIDE factor
    (131) term -> . term MOD factor
    (132) term -> . factor
    (133) factor -> . NOT factor
    (134) factor -> . PLUS factor
    (135) factor -> . MINUS factor
    (136) factor -> . PLUS_PLUS factor
    (137) factor -> . MINUS_MINUS factor
    (138) factor -> . cast brace
    (139) factor -> . brace
    (140) cast -> . L_PAREN TYPE R_PAREN
    (141) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (142) brace -> . L_PAREN expr R_PAREN
    (143) brace -> . brace PLUS_PLUS
    (144) brace -> . brace MINUS_MINUS
    (145) brace -> . NUM
    (146) brace -> . STRING
    (147) brace -> . MULTIPLY ID
    (148) brace -> . BIT_AND ID
    (149) brace -> . ID
    (150) brace -> . CHAR
    (151) brace -> . function_call
    (152) brace -> . ID narrayindex
    (153) NUM -> . INT_NUM
    (154) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    IF              shift and go to state 6
    WHILE           shift and go to state 7
    FOR             shift and go to state 11
    SEMICOLON       shift and go to state 13
    RETURN          shift and go to state 17
    HASH            shift and go to state 20
    TYPE            shift and go to state 22
    L_FLOWBRACE     shift and go to state 26
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    open                           shift and go to state 120
    closed                         shift and go to state 121
    for                            shift and go to state 8
    simple                         shift and go to state 9
    block                          shift and go to state 10
    expr                           shift and go to state 12
    header                         shift and go to state 14
    declaration                    shift and go to state 15
    function                       shift and go to state 16
    left_flower                    shift and go to state 18
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 54

    (9) open -> for for_condition . open
    (15) closed -> for for_condition . closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) open -> . for for_condition open
    (11) closed -> . simple
    (12) closed -> . block
    (13) closed -> . IF condition closed ELSE closed
    (14) closed -> . WHILE condition closed
    (15) closed -> . for for_condition closed
    (10) for -> . FOR
    (53) simple -> . expr SEMICOLON
    (54) simple -> . header
    (55) simple -> . declaration
    (56) simple -> . SEMICOLON
    (57) simple -> . function
    (58) simple -> . RETURN expr SEMICOLON
    (59) simple -> . RETURN SEMICOLON
    (49) block -> . left_flower multiple_statements right_flower
    (50) block -> . left_flower right_flower
    (91) expr -> . expr assignment exprOR
    (92) expr -> . exprOR
    (60) header -> . HASH INCLUDE STRING
    (61) header -> . HASH INCLUDE HEADER_FILE
    (34) declaration -> . TYPE ID SEMICOLON
    (35) declaration -> . TYPE MULTIPLY ID SEMICOLON
    (36) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (37) declaration -> . TYPE MULTIPLY ID ASSIGN expr SEMICOLON
    (38) declaration -> . TYPE multi_declaration stop
    (39) declaration -> . TYPE ID narrayindex SEMICOLON
    (40) declaration -> . TYPE ID narrayindex ASSIGN init_list SEMICOLON
    (88) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (51) left_flower -> . L_FLOWBRACE
    (104) exprOR -> . exprOR OR exprAND
    (105) exprOR -> . exprAND
    (106) exprAND -> . exprAND AND exprBITOR
    (107) exprAND -> . exprBITOR
    (108) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (109) exprBITOR -> . exprBITXOR
    (110) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (111) exprBITXOR -> . exprBITAND
    (112) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (113) exprBITAND -> . exprEQ
    (114) exprEQ -> . exprEQ EQ exprRELOP
    (115) exprEQ -> . exprEQ NE exprRELOP
    (116) exprEQ -> . exprRELOP
    (117) exprRELOP -> . exprRELOP relop exprSHIFT
    (118) exprRELOP -> . exprSHIFT
    (123) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (124) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (125) exprSHIFT -> . exprOP
    (126) exprOP -> . exprOP PLUS term
    (127) exprOP -> . exprOP MINUS term
    (128) exprOP -> . term
    (129) term -> . term MULTIPLY factor
    (130) term -> . term DIVIDE factor
    (131) term -> . term MOD factor
    (132) term -> . factor
    (133) factor -> . NOT factor
    (134) factor -> . PLUS factor
    (135) factor -> . MINUS factor
    (136) factor -> . PLUS_PLUS factor
    (137) factor -> . MINUS_MINUS factor
    (138) factor -> . cast brace
    (139) factor -> . brace
    (140) cast -> . L_PAREN TYPE R_PAREN
    (141) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (142) brace -> . L_PAREN expr R_PAREN
    (143) brace -> . brace PLUS_PLUS
    (144) brace -> . brace MINUS_MINUS
    (145) brace -> . NUM
    (146) brace -> . STRING
    (147) brace -> . MULTIPLY ID
    (148) brace -> . BIT_AND ID
    (149) brace -> . ID
    (150) brace -> . CHAR
    (151) brace -> . function_call
    (152) brace -> . ID narrayindex
    (153) NUM -> . INT_NUM
    (154) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    IF              shift and go to state 6
    WHILE           shift and go to state 7
    FOR             shift and go to state 11
    SEMICOLON       shift and go to state 13
    RETURN          shift and go to state 17
    HASH            shift and go to state 20
    TYPE            shift and go to state 22
    L_FLOWBRACE     shift and go to state 26
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    for                            shift and go to state 8
    open                           shift and go to state 122
    closed                         shift and go to state 123
    simple                         shift and go to state 9
    block                          shift and go to state 10
    expr                           shift and go to state 12
    header                         shift and go to state 14
    declaration                    shift and go to state 15
    function                       shift and go to state 16
    left_flower                    shift and go to state 18
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 55

    (17) for_condition -> L_PAREN . simple simple expr R_PAREN
    (18) for_condition -> L_PAREN . simple simple R_PAREN
    (53) simple -> . expr SEMICOLON
    (54) simple -> . header
    (55) simple -> . declaration
    (56) simple -> . SEMICOLON
    (57) simple -> . function
    (58) simple -> . RETURN expr SEMICOLON
    (59) simple -> . RETURN SEMICOLON
    (91) expr -> . expr assignment exprOR
    (92) expr -> . exprOR
    (60) header -> . HASH INCLUDE STRING
    (61) header -> . HASH INCLUDE HEADER_FILE
    (34) declaration -> . TYPE ID SEMICOLON
    (35) declaration -> . TYPE MULTIPLY ID SEMICOLON
    (36) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (37) declaration -> . TYPE MULTIPLY ID ASSIGN expr SEMICOLON
    (38) declaration -> . TYPE multi_declaration stop
    (39) declaration -> . TYPE ID narrayindex SEMICOLON
    (40) declaration -> . TYPE ID narrayindex ASSIGN init_list SEMICOLON
    (88) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (104) exprOR -> . exprOR OR exprAND
    (105) exprOR -> . exprAND
    (106) exprAND -> . exprAND AND exprBITOR
    (107) exprAND -> . exprBITOR
    (108) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (109) exprBITOR -> . exprBITXOR
    (110) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (111) exprBITXOR -> . exprBITAND
    (112) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (113) exprBITAND -> . exprEQ
    (114) exprEQ -> . exprEQ EQ exprRELOP
    (115) exprEQ -> . exprEQ NE exprRELOP
    (116) exprEQ -> . exprRELOP
    (117) exprRELOP -> . exprRELOP relop exprSHIFT
    (118) exprRELOP -> . exprSHIFT
    (123) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (124) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (125) exprSHIFT -> . exprOP
    (126) exprOP -> . exprOP PLUS term
    (127) exprOP -> . exprOP MINUS term
    (128) exprOP -> . term
    (129) term -> . term MULTIPLY factor
    (130) term -> . term DIVIDE factor
    (131) term -> . term MOD factor
    (132) term -> . factor
    (133) factor -> . NOT factor
    (134) factor -> . PLUS factor
    (135) factor -> . MINUS factor
    (136) factor -> . PLUS_PLUS factor
    (137) factor -> . MINUS_MINUS factor
    (138) factor -> . cast brace
    (139) factor -> . brace
    (140) cast -> . L_PAREN TYPE R_PAREN
    (141) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (142) brace -> . L_PAREN expr R_PAREN
    (143) brace -> . brace PLUS_PLUS
    (144) brace -> . brace MINUS_MINUS
    (145) brace -> . NUM
    (146) brace -> . STRING
    (147) brace -> . MULTIPLY ID
    (148) brace -> . BIT_AND ID
    (149) brace -> . ID
    (150) brace -> . CHAR
    (151) brace -> . function_call
    (152) brace -> . ID narrayindex
    (153) NUM -> . INT_NUM
    (154) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    SEMICOLON       shift and go to state 13
    RETURN          shift and go to state 17
    HASH            shift and go to state 20
    TYPE            shift and go to state 22
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    simple                         shift and go to state 124
    expr                           shift and go to state 12
    header                         shift and go to state 14
    declaration                    shift and go to state 15
    function                       shift and go to state 16
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 56

    (53) simple -> expr SEMICOLON .

    IF              reduce using rule 53 (simple -> expr SEMICOLON .)
    WHILE           reduce using rule 53 (simple -> expr SEMICOLON .)
    FOR             reduce using rule 53 (simple -> expr SEMICOLON .)
    SEMICOLON       reduce using rule 53 (simple -> expr SEMICOLON .)
    RETURN          reduce using rule 53 (simple -> expr SEMICOLON .)
    HASH            reduce using rule 53 (simple -> expr SEMICOLON .)
    TYPE            reduce using rule 53 (simple -> expr SEMICOLON .)
    L_FLOWBRACE     reduce using rule 53 (simple -> expr SEMICOLON .)
    NOT             reduce using rule 53 (simple -> expr SEMICOLON .)
    PLUS            reduce using rule 53 (simple -> expr SEMICOLON .)
    MINUS           reduce using rule 53 (simple -> expr SEMICOLON .)
    PLUS_PLUS       reduce using rule 53 (simple -> expr SEMICOLON .)
    MINUS_MINUS     reduce using rule 53 (simple -> expr SEMICOLON .)
    L_PAREN         reduce using rule 53 (simple -> expr SEMICOLON .)
    STRING          reduce using rule 53 (simple -> expr SEMICOLON .)
    MULTIPLY        reduce using rule 53 (simple -> expr SEMICOLON .)
    BIT_AND         reduce using rule 53 (simple -> expr SEMICOLON .)
    ID              reduce using rule 53 (simple -> expr SEMICOLON .)
    CHAR            reduce using rule 53 (simple -> expr SEMICOLON .)
    INT_NUM         reduce using rule 53 (simple -> expr SEMICOLON .)
    FLOAT_NUM       reduce using rule 53 (simple -> expr SEMICOLON .)
    $end            reduce using rule 53 (simple -> expr SEMICOLON .)
    R_FLOWBRACE     reduce using rule 53 (simple -> expr SEMICOLON .)
    ELSE            reduce using rule 53 (simple -> expr SEMICOLON .)
    R_PAREN         reduce using rule 53 (simple -> expr SEMICOLON .)


state 57

    (91) expr -> expr assignment . exprOR
    (104) exprOR -> . exprOR OR exprAND
    (105) exprOR -> . exprAND
    (106) exprAND -> . exprAND AND exprBITOR
    (107) exprAND -> . exprBITOR
    (108) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (109) exprBITOR -> . exprBITXOR
    (110) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (111) exprBITXOR -> . exprBITAND
    (112) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (113) exprBITAND -> . exprEQ
    (114) exprEQ -> . exprEQ EQ exprRELOP
    (115) exprEQ -> . exprEQ NE exprRELOP
    (116) exprEQ -> . exprRELOP
    (117) exprRELOP -> . exprRELOP relop exprSHIFT
    (118) exprRELOP -> . exprSHIFT
    (123) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (124) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (125) exprSHIFT -> . exprOP
    (126) exprOP -> . exprOP PLUS term
    (127) exprOP -> . exprOP MINUS term
    (128) exprOP -> . term
    (129) term -> . term MULTIPLY factor
    (130) term -> . term DIVIDE factor
    (131) term -> . term MOD factor
    (132) term -> . factor
    (133) factor -> . NOT factor
    (134) factor -> . PLUS factor
    (135) factor -> . MINUS factor
    (136) factor -> . PLUS_PLUS factor
    (137) factor -> . MINUS_MINUS factor
    (138) factor -> . cast brace
    (139) factor -> . brace
    (140) cast -> . L_PAREN TYPE R_PAREN
    (141) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (142) brace -> . L_PAREN expr R_PAREN
    (143) brace -> . brace PLUS_PLUS
    (144) brace -> . brace MINUS_MINUS
    (145) brace -> . NUM
    (146) brace -> . STRING
    (147) brace -> . MULTIPLY ID
    (148) brace -> . BIT_AND ID
    (149) brace -> . ID
    (150) brace -> . CHAR
    (151) brace -> . function_call
    (152) brace -> . ID narrayindex
    (153) NUM -> . INT_NUM
    (154) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    exprOR                         shift and go to state 125
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 58

    (93) assignment -> ASSIGN .

    NOT             reduce using rule 93 (assignment -> ASSIGN .)
    PLUS            reduce using rule 93 (assignment -> ASSIGN .)
    MINUS           reduce using rule 93 (assignment -> ASSIGN .)
    PLUS_PLUS       reduce using rule 93 (assignment -> ASSIGN .)
    MINUS_MINUS     reduce using rule 93 (assignment -> ASSIGN .)
    L_PAREN         reduce using rule 93 (assignment -> ASSIGN .)
    STRING          reduce using rule 93 (assignment -> ASSIGN .)
    MULTIPLY        reduce using rule 93 (assignment -> ASSIGN .)
    BIT_AND         reduce using rule 93 (assignment -> ASSIGN .)
    ID              reduce using rule 93 (assignment -> ASSIGN .)
    CHAR            reduce using rule 93 (assignment -> ASSIGN .)
    INT_NUM         reduce using rule 93 (assignment -> ASSIGN .)
    FLOAT_NUM       reduce using rule 93 (assignment -> ASSIGN .)


state 59

    (94) assignment -> PLUS_ASSIGN .

    NOT             reduce using rule 94 (assignment -> PLUS_ASSIGN .)
    PLUS            reduce using rule 94 (assignment -> PLUS_ASSIGN .)
    MINUS           reduce using rule 94 (assignment -> PLUS_ASSIGN .)
    PLUS_PLUS       reduce using rule 94 (assignment -> PLUS_ASSIGN .)
    MINUS_MINUS     reduce using rule 94 (assignment -> PLUS_ASSIGN .)
    L_PAREN         reduce using rule 94 (assignment -> PLUS_ASSIGN .)
    STRING          reduce using rule 94 (assignment -> PLUS_ASSIGN .)
    MULTIPLY        reduce using rule 94 (assignment -> PLUS_ASSIGN .)
    BIT_AND         reduce using rule 94 (assignment -> PLUS_ASSIGN .)
    ID              reduce using rule 94 (assignment -> PLUS_ASSIGN .)
    CHAR            reduce using rule 94 (assignment -> PLUS_ASSIGN .)
    INT_NUM         reduce using rule 94 (assignment -> PLUS_ASSIGN .)
    FLOAT_NUM       reduce using rule 94 (assignment -> PLUS_ASSIGN .)


state 60

    (95) assignment -> MINUS_ASSIGN .

    NOT             reduce using rule 95 (assignment -> MINUS_ASSIGN .)
    PLUS            reduce using rule 95 (assignment -> MINUS_ASSIGN .)
    MINUS           reduce using rule 95 (assignment -> MINUS_ASSIGN .)
    PLUS_PLUS       reduce using rule 95 (assignment -> MINUS_ASSIGN .)
    MINUS_MINUS     reduce using rule 95 (assignment -> MINUS_ASSIGN .)
    L_PAREN         reduce using rule 95 (assignment -> MINUS_ASSIGN .)
    STRING          reduce using rule 95 (assignment -> MINUS_ASSIGN .)
    MULTIPLY        reduce using rule 95 (assignment -> MINUS_ASSIGN .)
    BIT_AND         reduce using rule 95 (assignment -> MINUS_ASSIGN .)
    ID              reduce using rule 95 (assignment -> MINUS_ASSIGN .)
    CHAR            reduce using rule 95 (assignment -> MINUS_ASSIGN .)
    INT_NUM         reduce using rule 95 (assignment -> MINUS_ASSIGN .)
    FLOAT_NUM       reduce using rule 95 (assignment -> MINUS_ASSIGN .)


state 61

    (96) assignment -> MUL_ASSIGN .

    NOT             reduce using rule 96 (assignment -> MUL_ASSIGN .)
    PLUS            reduce using rule 96 (assignment -> MUL_ASSIGN .)
    MINUS           reduce using rule 96 (assignment -> MUL_ASSIGN .)
    PLUS_PLUS       reduce using rule 96 (assignment -> MUL_ASSIGN .)
    MINUS_MINUS     reduce using rule 96 (assignment -> MUL_ASSIGN .)
    L_PAREN         reduce using rule 96 (assignment -> MUL_ASSIGN .)
    STRING          reduce using rule 96 (assignment -> MUL_ASSIGN .)
    MULTIPLY        reduce using rule 96 (assignment -> MUL_ASSIGN .)
    BIT_AND         reduce using rule 96 (assignment -> MUL_ASSIGN .)
    ID              reduce using rule 96 (assignment -> MUL_ASSIGN .)
    CHAR            reduce using rule 96 (assignment -> MUL_ASSIGN .)
    INT_NUM         reduce using rule 96 (assignment -> MUL_ASSIGN .)
    FLOAT_NUM       reduce using rule 96 (assignment -> MUL_ASSIGN .)


state 62

    (97) assignment -> DIV_ASSIGN .

    NOT             reduce using rule 97 (assignment -> DIV_ASSIGN .)
    PLUS            reduce using rule 97 (assignment -> DIV_ASSIGN .)
    MINUS           reduce using rule 97 (assignment -> DIV_ASSIGN .)
    PLUS_PLUS       reduce using rule 97 (assignment -> DIV_ASSIGN .)
    MINUS_MINUS     reduce using rule 97 (assignment -> DIV_ASSIGN .)
    L_PAREN         reduce using rule 97 (assignment -> DIV_ASSIGN .)
    STRING          reduce using rule 97 (assignment -> DIV_ASSIGN .)
    MULTIPLY        reduce using rule 97 (assignment -> DIV_ASSIGN .)
    BIT_AND         reduce using rule 97 (assignment -> DIV_ASSIGN .)
    ID              reduce using rule 97 (assignment -> DIV_ASSIGN .)
    CHAR            reduce using rule 97 (assignment -> DIV_ASSIGN .)
    INT_NUM         reduce using rule 97 (assignment -> DIV_ASSIGN .)
    FLOAT_NUM       reduce using rule 97 (assignment -> DIV_ASSIGN .)


state 63

    (98) assignment -> AND_ASSIGN .

    NOT             reduce using rule 98 (assignment -> AND_ASSIGN .)
    PLUS            reduce using rule 98 (assignment -> AND_ASSIGN .)
    MINUS           reduce using rule 98 (assignment -> AND_ASSIGN .)
    PLUS_PLUS       reduce using rule 98 (assignment -> AND_ASSIGN .)
    MINUS_MINUS     reduce using rule 98 (assignment -> AND_ASSIGN .)
    L_PAREN         reduce using rule 98 (assignment -> AND_ASSIGN .)
    STRING          reduce using rule 98 (assignment -> AND_ASSIGN .)
    MULTIPLY        reduce using rule 98 (assignment -> AND_ASSIGN .)
    BIT_AND         reduce using rule 98 (assignment -> AND_ASSIGN .)
    ID              reduce using rule 98 (assignment -> AND_ASSIGN .)
    CHAR            reduce using rule 98 (assignment -> AND_ASSIGN .)
    INT_NUM         reduce using rule 98 (assignment -> AND_ASSIGN .)
    FLOAT_NUM       reduce using rule 98 (assignment -> AND_ASSIGN .)


state 64

    (99) assignment -> OR_ASSIGN .

    NOT             reduce using rule 99 (assignment -> OR_ASSIGN .)
    PLUS            reduce using rule 99 (assignment -> OR_ASSIGN .)
    MINUS           reduce using rule 99 (assignment -> OR_ASSIGN .)
    PLUS_PLUS       reduce using rule 99 (assignment -> OR_ASSIGN .)
    MINUS_MINUS     reduce using rule 99 (assignment -> OR_ASSIGN .)
    L_PAREN         reduce using rule 99 (assignment -> OR_ASSIGN .)
    STRING          reduce using rule 99 (assignment -> OR_ASSIGN .)
    MULTIPLY        reduce using rule 99 (assignment -> OR_ASSIGN .)
    BIT_AND         reduce using rule 99 (assignment -> OR_ASSIGN .)
    ID              reduce using rule 99 (assignment -> OR_ASSIGN .)
    CHAR            reduce using rule 99 (assignment -> OR_ASSIGN .)
    INT_NUM         reduce using rule 99 (assignment -> OR_ASSIGN .)
    FLOAT_NUM       reduce using rule 99 (assignment -> OR_ASSIGN .)


state 65

    (100) assignment -> XOR_ASSIGN .

    NOT             reduce using rule 100 (assignment -> XOR_ASSIGN .)
    PLUS            reduce using rule 100 (assignment -> XOR_ASSIGN .)
    MINUS           reduce using rule 100 (assignment -> XOR_ASSIGN .)
    PLUS_PLUS       reduce using rule 100 (assignment -> XOR_ASSIGN .)
    MINUS_MINUS     reduce using rule 100 (assignment -> XOR_ASSIGN .)
    L_PAREN         reduce using rule 100 (assignment -> XOR_ASSIGN .)
    STRING          reduce using rule 100 (assignment -> XOR_ASSIGN .)
    MULTIPLY        reduce using rule 100 (assignment -> XOR_ASSIGN .)
    BIT_AND         reduce using rule 100 (assignment -> XOR_ASSIGN .)
    ID              reduce using rule 100 (assignment -> XOR_ASSIGN .)
    CHAR            reduce using rule 100 (assignment -> XOR_ASSIGN .)
    INT_NUM         reduce using rule 100 (assignment -> XOR_ASSIGN .)
    FLOAT_NUM       reduce using rule 100 (assignment -> XOR_ASSIGN .)


state 66

    (101) assignment -> MOD_ASSIGN .

    NOT             reduce using rule 101 (assignment -> MOD_ASSIGN .)
    PLUS            reduce using rule 101 (assignment -> MOD_ASSIGN .)
    MINUS           reduce using rule 101 (assignment -> MOD_ASSIGN .)
    PLUS_PLUS       reduce using rule 101 (assignment -> MOD_ASSIGN .)
    MINUS_MINUS     reduce using rule 101 (assignment -> MOD_ASSIGN .)
    L_PAREN         reduce using rule 101 (assignment -> MOD_ASSIGN .)
    STRING          reduce using rule 101 (assignment -> MOD_ASSIGN .)
    MULTIPLY        reduce using rule 101 (assignment -> MOD_ASSIGN .)
    BIT_AND         reduce using rule 101 (assignment -> MOD_ASSIGN .)
    ID              reduce using rule 101 (assignment -> MOD_ASSIGN .)
    CHAR            reduce using rule 101 (assignment -> MOD_ASSIGN .)
    INT_NUM         reduce using rule 101 (assignment -> MOD_ASSIGN .)
    FLOAT_NUM       reduce using rule 101 (assignment -> MOD_ASSIGN .)


state 67

    (102) assignment -> L_SHIFT_ASSIGN .

    NOT             reduce using rule 102 (assignment -> L_SHIFT_ASSIGN .)
    PLUS            reduce using rule 102 (assignment -> L_SHIFT_ASSIGN .)
    MINUS           reduce using rule 102 (assignment -> L_SHIFT_ASSIGN .)
    PLUS_PLUS       reduce using rule 102 (assignment -> L_SHIFT_ASSIGN .)
    MINUS_MINUS     reduce using rule 102 (assignment -> L_SHIFT_ASSIGN .)
    L_PAREN         reduce using rule 102 (assignment -> L_SHIFT_ASSIGN .)
    STRING          reduce using rule 102 (assignment -> L_SHIFT_ASSIGN .)
    MULTIPLY        reduce using rule 102 (assignment -> L_SHIFT_ASSIGN .)
    BIT_AND         reduce using rule 102 (assignment -> L_SHIFT_ASSIGN .)
    ID              reduce using rule 102 (assignment -> L_SHIFT_ASSIGN .)
    CHAR            reduce using rule 102 (assignment -> L_SHIFT_ASSIGN .)
    INT_NUM         reduce using rule 102 (assignment -> L_SHIFT_ASSIGN .)
    FLOAT_NUM       reduce using rule 102 (assignment -> L_SHIFT_ASSIGN .)


state 68

    (103) assignment -> R_SHIFT_ASSIGN .

    NOT             reduce using rule 103 (assignment -> R_SHIFT_ASSIGN .)
    PLUS            reduce using rule 103 (assignment -> R_SHIFT_ASSIGN .)
    MINUS           reduce using rule 103 (assignment -> R_SHIFT_ASSIGN .)
    PLUS_PLUS       reduce using rule 103 (assignment -> R_SHIFT_ASSIGN .)
    MINUS_MINUS     reduce using rule 103 (assignment -> R_SHIFT_ASSIGN .)
    L_PAREN         reduce using rule 103 (assignment -> R_SHIFT_ASSIGN .)
    STRING          reduce using rule 103 (assignment -> R_SHIFT_ASSIGN .)
    MULTIPLY        reduce using rule 103 (assignment -> R_SHIFT_ASSIGN .)
    BIT_AND         reduce using rule 103 (assignment -> R_SHIFT_ASSIGN .)
    ID              reduce using rule 103 (assignment -> R_SHIFT_ASSIGN .)
    CHAR            reduce using rule 103 (assignment -> R_SHIFT_ASSIGN .)
    INT_NUM         reduce using rule 103 (assignment -> R_SHIFT_ASSIGN .)
    FLOAT_NUM       reduce using rule 103 (assignment -> R_SHIFT_ASSIGN .)


state 69

    (58) simple -> RETURN expr . SEMICOLON
    (91) expr -> expr . assignment exprOR
    (93) assignment -> . ASSIGN
    (94) assignment -> . PLUS_ASSIGN
    (95) assignment -> . MINUS_ASSIGN
    (96) assignment -> . MUL_ASSIGN
    (97) assignment -> . DIV_ASSIGN
    (98) assignment -> . AND_ASSIGN
    (99) assignment -> . OR_ASSIGN
    (100) assignment -> . XOR_ASSIGN
    (101) assignment -> . MOD_ASSIGN
    (102) assignment -> . L_SHIFT_ASSIGN
    (103) assignment -> . R_SHIFT_ASSIGN

    SEMICOLON       shift and go to state 126
    ASSIGN          shift and go to state 58
    PLUS_ASSIGN     shift and go to state 59
    MINUS_ASSIGN    shift and go to state 60
    MUL_ASSIGN      shift and go to state 61
    DIV_ASSIGN      shift and go to state 62
    AND_ASSIGN      shift and go to state 63
    OR_ASSIGN       shift and go to state 64
    XOR_ASSIGN      shift and go to state 65
    MOD_ASSIGN      shift and go to state 66
    L_SHIFT_ASSIGN  shift and go to state 67
    R_SHIFT_ASSIGN  shift and go to state 68

    assignment                     shift and go to state 57

state 70

    (59) simple -> RETURN SEMICOLON .

    IF              reduce using rule 59 (simple -> RETURN SEMICOLON .)
    WHILE           reduce using rule 59 (simple -> RETURN SEMICOLON .)
    FOR             reduce using rule 59 (simple -> RETURN SEMICOLON .)
    SEMICOLON       reduce using rule 59 (simple -> RETURN SEMICOLON .)
    RETURN          reduce using rule 59 (simple -> RETURN SEMICOLON .)
    HASH            reduce using rule 59 (simple -> RETURN SEMICOLON .)
    TYPE            reduce using rule 59 (simple -> RETURN SEMICOLON .)
    L_FLOWBRACE     reduce using rule 59 (simple -> RETURN SEMICOLON .)
    NOT             reduce using rule 59 (simple -> RETURN SEMICOLON .)
    PLUS            reduce using rule 59 (simple -> RETURN SEMICOLON .)
    MINUS           reduce using rule 59 (simple -> RETURN SEMICOLON .)
    PLUS_PLUS       reduce using rule 59 (simple -> RETURN SEMICOLON .)
    MINUS_MINUS     reduce using rule 59 (simple -> RETURN SEMICOLON .)
    L_PAREN         reduce using rule 59 (simple -> RETURN SEMICOLON .)
    STRING          reduce using rule 59 (simple -> RETURN SEMICOLON .)
    MULTIPLY        reduce using rule 59 (simple -> RETURN SEMICOLON .)
    BIT_AND         reduce using rule 59 (simple -> RETURN SEMICOLON .)
    ID              reduce using rule 59 (simple -> RETURN SEMICOLON .)
    CHAR            reduce using rule 59 (simple -> RETURN SEMICOLON .)
    INT_NUM         reduce using rule 59 (simple -> RETURN SEMICOLON .)
    FLOAT_NUM       reduce using rule 59 (simple -> RETURN SEMICOLON .)
    $end            reduce using rule 59 (simple -> RETURN SEMICOLON .)
    R_FLOWBRACE     reduce using rule 59 (simple -> RETURN SEMICOLON .)
    ELSE            reduce using rule 59 (simple -> RETURN SEMICOLON .)
    R_PAREN         reduce using rule 59 (simple -> RETURN SEMICOLON .)


state 71

    (49) block -> left_flower multiple_statements . right_flower
    (2) multiple_statements -> multiple_statements . statement
    (52) right_flower -> . R_FLOWBRACE
    (4) statement -> . open
    (5) statement -> . closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) open -> . for for_condition open
    (11) closed -> . simple
    (12) closed -> . block
    (13) closed -> . IF condition closed ELSE closed
    (14) closed -> . WHILE condition closed
    (15) closed -> . for for_condition closed
    (10) for -> . FOR
    (53) simple -> . expr SEMICOLON
    (54) simple -> . header
    (55) simple -> . declaration
    (56) simple -> . SEMICOLON
    (57) simple -> . function
    (58) simple -> . RETURN expr SEMICOLON
    (59) simple -> . RETURN SEMICOLON
    (49) block -> . left_flower multiple_statements right_flower
    (50) block -> . left_flower right_flower
    (91) expr -> . expr assignment exprOR
    (92) expr -> . exprOR
    (60) header -> . HASH INCLUDE STRING
    (61) header -> . HASH INCLUDE HEADER_FILE
    (34) declaration -> . TYPE ID SEMICOLON
    (35) declaration -> . TYPE MULTIPLY ID SEMICOLON
    (36) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (37) declaration -> . TYPE MULTIPLY ID ASSIGN expr SEMICOLON
    (38) declaration -> . TYPE multi_declaration stop
    (39) declaration -> . TYPE ID narrayindex SEMICOLON
    (40) declaration -> . TYPE ID narrayindex ASSIGN init_list SEMICOLON
    (88) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (51) left_flower -> . L_FLOWBRACE
    (104) exprOR -> . exprOR OR exprAND
    (105) exprOR -> . exprAND
    (106) exprAND -> . exprAND AND exprBITOR
    (107) exprAND -> . exprBITOR
    (108) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (109) exprBITOR -> . exprBITXOR
    (110) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (111) exprBITXOR -> . exprBITAND
    (112) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (113) exprBITAND -> . exprEQ
    (114) exprEQ -> . exprEQ EQ exprRELOP
    (115) exprEQ -> . exprEQ NE exprRELOP
    (116) exprEQ -> . exprRELOP
    (117) exprRELOP -> . exprRELOP relop exprSHIFT
    (118) exprRELOP -> . exprSHIFT
    (123) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (124) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (125) exprSHIFT -> . exprOP
    (126) exprOP -> . exprOP PLUS term
    (127) exprOP -> . exprOP MINUS term
    (128) exprOP -> . term
    (129) term -> . term MULTIPLY factor
    (130) term -> . term DIVIDE factor
    (131) term -> . term MOD factor
    (132) term -> . factor
    (133) factor -> . NOT factor
    (134) factor -> . PLUS factor
    (135) factor -> . MINUS factor
    (136) factor -> . PLUS_PLUS factor
    (137) factor -> . MINUS_MINUS factor
    (138) factor -> . cast brace
    (139) factor -> . brace
    (140) cast -> . L_PAREN TYPE R_PAREN
    (141) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (142) brace -> . L_PAREN expr R_PAREN
    (143) brace -> . brace PLUS_PLUS
    (144) brace -> . brace MINUS_MINUS
    (145) brace -> . NUM
    (146) brace -> . STRING
    (147) brace -> . MULTIPLY ID
    (148) brace -> . BIT_AND ID
    (149) brace -> . ID
    (150) brace -> . CHAR
    (151) brace -> . function_call
    (152) brace -> . ID narrayindex
    (153) NUM -> . INT_NUM
    (154) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    R_FLOWBRACE     shift and go to state 73
    IF              shift and go to state 6
    WHILE           shift and go to state 7
    FOR             shift and go to state 11
    SEMICOLON       shift and go to state 13
    RETURN          shift and go to state 17
    HASH            shift and go to state 20
    TYPE            shift and go to state 22
    L_FLOWBRACE     shift and go to state 26
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    left_flower                    shift and go to state 18
    right_flower                   shift and go to state 127
    statement                      shift and go to state 50
    open                           shift and go to state 4
    closed                         shift and go to state 5
    for                            shift and go to state 8
    simple                         shift and go to state 9
    block                          shift and go to state 10
    expr                           shift and go to state 12
    header                         shift and go to state 14
    declaration                    shift and go to state 15
    function                       shift and go to state 16
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 72

    (50) block -> left_flower right_flower .

    IF              reduce using rule 50 (block -> left_flower right_flower .)
    WHILE           reduce using rule 50 (block -> left_flower right_flower .)
    FOR             reduce using rule 50 (block -> left_flower right_flower .)
    SEMICOLON       reduce using rule 50 (block -> left_flower right_flower .)
    RETURN          reduce using rule 50 (block -> left_flower right_flower .)
    HASH            reduce using rule 50 (block -> left_flower right_flower .)
    TYPE            reduce using rule 50 (block -> left_flower right_flower .)
    L_FLOWBRACE     reduce using rule 50 (block -> left_flower right_flower .)
    NOT             reduce using rule 50 (block -> left_flower right_flower .)
    PLUS            reduce using rule 50 (block -> left_flower right_flower .)
    MINUS           reduce using rule 50 (block -> left_flower right_flower .)
    PLUS_PLUS       reduce using rule 50 (block -> left_flower right_flower .)
    MINUS_MINUS     reduce using rule 50 (block -> left_flower right_flower .)
    L_PAREN         reduce using rule 50 (block -> left_flower right_flower .)
    STRING          reduce using rule 50 (block -> left_flower right_flower .)
    MULTIPLY        reduce using rule 50 (block -> left_flower right_flower .)
    BIT_AND         reduce using rule 50 (block -> left_flower right_flower .)
    ID              reduce using rule 50 (block -> left_flower right_flower .)
    CHAR            reduce using rule 50 (block -> left_flower right_flower .)
    INT_NUM         reduce using rule 50 (block -> left_flower right_flower .)
    FLOAT_NUM       reduce using rule 50 (block -> left_flower right_flower .)
    $end            reduce using rule 50 (block -> left_flower right_flower .)
    R_FLOWBRACE     reduce using rule 50 (block -> left_flower right_flower .)
    ELSE            reduce using rule 50 (block -> left_flower right_flower .)
    R_PAREN         reduce using rule 50 (block -> left_flower right_flower .)


state 73

    (52) right_flower -> R_FLOWBRACE .

    IF              reduce using rule 52 (right_flower -> R_FLOWBRACE .)
    WHILE           reduce using rule 52 (right_flower -> R_FLOWBRACE .)
    FOR             reduce using rule 52 (right_flower -> R_FLOWBRACE .)
    SEMICOLON       reduce using rule 52 (right_flower -> R_FLOWBRACE .)
    RETURN          reduce using rule 52 (right_flower -> R_FLOWBRACE .)
    HASH            reduce using rule 52 (right_flower -> R_FLOWBRACE .)
    TYPE            reduce using rule 52 (right_flower -> R_FLOWBRACE .)
    L_FLOWBRACE     reduce using rule 52 (right_flower -> R_FLOWBRACE .)
    NOT             reduce using rule 52 (right_flower -> R_FLOWBRACE .)
    PLUS            reduce using rule 52 (right_flower -> R_FLOWBRACE .)
    MINUS           reduce using rule 52 (right_flower -> R_FLOWBRACE .)
    PLUS_PLUS       reduce using rule 52 (right_flower -> R_FLOWBRACE .)
    MINUS_MINUS     reduce using rule 52 (right_flower -> R_FLOWBRACE .)
    L_PAREN         reduce using rule 52 (right_flower -> R_FLOWBRACE .)
    STRING          reduce using rule 52 (right_flower -> R_FLOWBRACE .)
    MULTIPLY        reduce using rule 52 (right_flower -> R_FLOWBRACE .)
    BIT_AND         reduce using rule 52 (right_flower -> R_FLOWBRACE .)
    ID              reduce using rule 52 (right_flower -> R_FLOWBRACE .)
    CHAR            reduce using rule 52 (right_flower -> R_FLOWBRACE .)
    INT_NUM         reduce using rule 52 (right_flower -> R_FLOWBRACE .)
    FLOAT_NUM       reduce using rule 52 (right_flower -> R_FLOWBRACE .)
    $end            reduce using rule 52 (right_flower -> R_FLOWBRACE .)
    R_FLOWBRACE     reduce using rule 52 (right_flower -> R_FLOWBRACE .)
    ELSE            reduce using rule 52 (right_flower -> R_FLOWBRACE .)
    R_PAREN         reduce using rule 52 (right_flower -> R_FLOWBRACE .)


state 74

    (104) exprOR -> exprOR OR . exprAND
    (106) exprAND -> . exprAND AND exprBITOR
    (107) exprAND -> . exprBITOR
    (108) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (109) exprBITOR -> . exprBITXOR
    (110) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (111) exprBITXOR -> . exprBITAND
    (112) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (113) exprBITAND -> . exprEQ
    (114) exprEQ -> . exprEQ EQ exprRELOP
    (115) exprEQ -> . exprEQ NE exprRELOP
    (116) exprEQ -> . exprRELOP
    (117) exprRELOP -> . exprRELOP relop exprSHIFT
    (118) exprRELOP -> . exprSHIFT
    (123) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (124) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (125) exprSHIFT -> . exprOP
    (126) exprOP -> . exprOP PLUS term
    (127) exprOP -> . exprOP MINUS term
    (128) exprOP -> . term
    (129) term -> . term MULTIPLY factor
    (130) term -> . term DIVIDE factor
    (131) term -> . term MOD factor
    (132) term -> . factor
    (133) factor -> . NOT factor
    (134) factor -> . PLUS factor
    (135) factor -> . MINUS factor
    (136) factor -> . PLUS_PLUS factor
    (137) factor -> . MINUS_MINUS factor
    (138) factor -> . cast brace
    (139) factor -> . brace
    (140) cast -> . L_PAREN TYPE R_PAREN
    (141) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (142) brace -> . L_PAREN expr R_PAREN
    (143) brace -> . brace PLUS_PLUS
    (144) brace -> . brace MINUS_MINUS
    (145) brace -> . NUM
    (146) brace -> . STRING
    (147) brace -> . MULTIPLY ID
    (148) brace -> . BIT_AND ID
    (149) brace -> . ID
    (150) brace -> . CHAR
    (151) brace -> . function_call
    (152) brace -> . ID narrayindex
    (153) NUM -> . INT_NUM
    (154) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    exprAND                        shift and go to state 128
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 75

    (60) header -> HASH INCLUDE . STRING
    (61) header -> HASH INCLUDE . HEADER_FILE

    STRING          shift and go to state 129
    HEADER_FILE     shift and go to state 130


state 76

    (34) declaration -> TYPE ID . SEMICOLON
    (36) declaration -> TYPE ID . ASSIGN expr SEMICOLON
    (39) declaration -> TYPE ID . narrayindex SEMICOLON
    (40) declaration -> TYPE ID . narrayindex ASSIGN init_list SEMICOLON
    (88) function -> TYPE ID . L_PAREN dec_params R_PAREN function_2
    (23) multi_declaration -> ID . COMMA
    (24) multi_declaration -> ID . ASSIGN expr COMMA
    (32) narrayindex -> . narrayindex arrayindex
    (33) narrayindex -> . arrayindex
    (31) arrayindex -> . L_SQBRACE index R_SQBRACE

    SEMICOLON       shift and go to state 131
    ASSIGN          shift and go to state 132
    L_PAREN         shift and go to state 134
    COMMA           shift and go to state 135
    L_SQBRACE       shift and go to state 82

    narrayindex                    shift and go to state 133
    arrayindex                     shift and go to state 81

state 77

    (35) declaration -> TYPE MULTIPLY . ID SEMICOLON
    (37) declaration -> TYPE MULTIPLY . ID ASSIGN expr SEMICOLON
    (25) multi_declaration -> MULTIPLY . ID COMMA
    (26) multi_declaration -> MULTIPLY . ID ASSIGN expr COMMA

    ID              shift and go to state 136


state 78

    (38) declaration -> TYPE multi_declaration . stop
    (19) multi_declaration -> multi_declaration . ID COMMA
    (20) multi_declaration -> multi_declaration . MULTIPLY ID COMMA
    (21) multi_declaration -> multi_declaration . ID ASSIGN expr COMMA
    (22) multi_declaration -> multi_declaration . MULTIPLY ID ASSIGN expr COMMA
    (27) stop -> . ID SEMICOLON
    (28) stop -> . MULTIPLY ID SEMICOLON
    (29) stop -> . ID ASSIGN expr SEMICOLON
    (30) stop -> . MULTIPLY ID ASSIGN expr SEMICOLON

    ID              shift and go to state 138
    MULTIPLY        shift and go to state 139

    stop                           shift and go to state 137

state 79

    (152) brace -> ID narrayindex .
    (32) narrayindex -> narrayindex . arrayindex
    (31) arrayindex -> . L_SQBRACE index R_SQBRACE

    PLUS_PLUS       reduce using rule 152 (brace -> ID narrayindex .)
    MINUS_MINUS     reduce using rule 152 (brace -> ID narrayindex .)
    MULTIPLY        reduce using rule 152 (brace -> ID narrayindex .)
    DIVIDE          reduce using rule 152 (brace -> ID narrayindex .)
    MOD             reduce using rule 152 (brace -> ID narrayindex .)
    PLUS            reduce using rule 152 (brace -> ID narrayindex .)
    MINUS           reduce using rule 152 (brace -> ID narrayindex .)
    L_SHIFT         reduce using rule 152 (brace -> ID narrayindex .)
    R_SHIFT         reduce using rule 152 (brace -> ID narrayindex .)
    LE              reduce using rule 152 (brace -> ID narrayindex .)
    LT              reduce using rule 152 (brace -> ID narrayindex .)
    GE              reduce using rule 152 (brace -> ID narrayindex .)
    GT              reduce using rule 152 (brace -> ID narrayindex .)
    EQ              reduce using rule 152 (brace -> ID narrayindex .)
    NE              reduce using rule 152 (brace -> ID narrayindex .)
    BIT_AND         reduce using rule 152 (brace -> ID narrayindex .)
    BIT_XOR         reduce using rule 152 (brace -> ID narrayindex .)
    BIT_OR          reduce using rule 152 (brace -> ID narrayindex .)
    AND             reduce using rule 152 (brace -> ID narrayindex .)
    OR              reduce using rule 152 (brace -> ID narrayindex .)
    SEMICOLON       reduce using rule 152 (brace -> ID narrayindex .)
    ASSIGN          reduce using rule 152 (brace -> ID narrayindex .)
    PLUS_ASSIGN     reduce using rule 152 (brace -> ID narrayindex .)
    MINUS_ASSIGN    reduce using rule 152 (brace -> ID narrayindex .)
    MUL_ASSIGN      reduce using rule 152 (brace -> ID narrayindex .)
    DIV_ASSIGN      reduce using rule 152 (brace -> ID narrayindex .)
    AND_ASSIGN      reduce using rule 152 (brace -> ID narrayindex .)
    OR_ASSIGN       reduce using rule 152 (brace -> ID narrayindex .)
    XOR_ASSIGN      reduce using rule 152 (brace -> ID narrayindex .)
    MOD_ASSIGN      reduce using rule 152 (brace -> ID narrayindex .)
    L_SHIFT_ASSIGN  reduce using rule 152 (brace -> ID narrayindex .)
    R_SHIFT_ASSIGN  reduce using rule 152 (brace -> ID narrayindex .)
    R_PAREN         reduce using rule 152 (brace -> ID narrayindex .)
    COMMA           reduce using rule 152 (brace -> ID narrayindex .)
    R_SQBRACE       reduce using rule 152 (brace -> ID narrayindex .)
    R_FLOWBRACE     reduce using rule 152 (brace -> ID narrayindex .)
    L_SQBRACE       shift and go to state 82

    arrayindex                     shift and go to state 140

state 80

    (63) function_call -> ID L_PAREN . call_params R_PAREN
    (64) call_params -> . empty
    (65) call_params -> . yes_call_params end_call_params
    (66) call_params -> . end_call_params
    (62) empty -> .
    (67) yes_call_params -> . yes_call_params expr COMMA
    (68) yes_call_params -> . expr COMMA
    (69) end_call_params -> . expr
    (91) expr -> . expr assignment exprOR
    (92) expr -> . exprOR
    (104) exprOR -> . exprOR OR exprAND
    (105) exprOR -> . exprAND
    (106) exprAND -> . exprAND AND exprBITOR
    (107) exprAND -> . exprBITOR
    (108) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (109) exprBITOR -> . exprBITXOR
    (110) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (111) exprBITXOR -> . exprBITAND
    (112) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (113) exprBITAND -> . exprEQ
    (114) exprEQ -> . exprEQ EQ exprRELOP
    (115) exprEQ -> . exprEQ NE exprRELOP
    (116) exprEQ -> . exprRELOP
    (117) exprRELOP -> . exprRELOP relop exprSHIFT
    (118) exprRELOP -> . exprSHIFT
    (123) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (124) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (125) exprSHIFT -> . exprOP
    (126) exprOP -> . exprOP PLUS term
    (127) exprOP -> . exprOP MINUS term
    (128) exprOP -> . term
    (129) term -> . term MULTIPLY factor
    (130) term -> . term DIVIDE factor
    (131) term -> . term MOD factor
    (132) term -> . factor
    (133) factor -> . NOT factor
    (134) factor -> . PLUS factor
    (135) factor -> . MINUS factor
    (136) factor -> . PLUS_PLUS factor
    (137) factor -> . MINUS_MINUS factor
    (138) factor -> . cast brace
    (139) factor -> . brace
    (140) cast -> . L_PAREN TYPE R_PAREN
    (141) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (142) brace -> . L_PAREN expr R_PAREN
    (143) brace -> . brace PLUS_PLUS
    (144) brace -> . brace MINUS_MINUS
    (145) brace -> . NUM
    (146) brace -> . STRING
    (147) brace -> . MULTIPLY ID
    (148) brace -> . BIT_AND ID
    (149) brace -> . ID
    (150) brace -> . CHAR
    (151) brace -> . function_call
    (152) brace -> . ID narrayindex
    (153) NUM -> . INT_NUM
    (154) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    R_PAREN         reduce using rule 62 (empty -> .)
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    call_params                    shift and go to state 141
    empty                          shift and go to state 142
    yes_call_params                shift and go to state 143
    end_call_params                shift and go to state 144
    expr                           shift and go to state 145
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 81

    (33) narrayindex -> arrayindex .

    L_SQBRACE       reduce using rule 33 (narrayindex -> arrayindex .)
    PLUS_PLUS       reduce using rule 33 (narrayindex -> arrayindex .)
    MINUS_MINUS     reduce using rule 33 (narrayindex -> arrayindex .)
    MULTIPLY        reduce using rule 33 (narrayindex -> arrayindex .)
    DIVIDE          reduce using rule 33 (narrayindex -> arrayindex .)
    MOD             reduce using rule 33 (narrayindex -> arrayindex .)
    PLUS            reduce using rule 33 (narrayindex -> arrayindex .)
    MINUS           reduce using rule 33 (narrayindex -> arrayindex .)
    L_SHIFT         reduce using rule 33 (narrayindex -> arrayindex .)
    R_SHIFT         reduce using rule 33 (narrayindex -> arrayindex .)
    LE              reduce using rule 33 (narrayindex -> arrayindex .)
    LT              reduce using rule 33 (narrayindex -> arrayindex .)
    GE              reduce using rule 33 (narrayindex -> arrayindex .)
    GT              reduce using rule 33 (narrayindex -> arrayindex .)
    EQ              reduce using rule 33 (narrayindex -> arrayindex .)
    NE              reduce using rule 33 (narrayindex -> arrayindex .)
    BIT_AND         reduce using rule 33 (narrayindex -> arrayindex .)
    BIT_XOR         reduce using rule 33 (narrayindex -> arrayindex .)
    BIT_OR          reduce using rule 33 (narrayindex -> arrayindex .)
    AND             reduce using rule 33 (narrayindex -> arrayindex .)
    OR              reduce using rule 33 (narrayindex -> arrayindex .)
    SEMICOLON       reduce using rule 33 (narrayindex -> arrayindex .)
    ASSIGN          reduce using rule 33 (narrayindex -> arrayindex .)
    PLUS_ASSIGN     reduce using rule 33 (narrayindex -> arrayindex .)
    MINUS_ASSIGN    reduce using rule 33 (narrayindex -> arrayindex .)
    MUL_ASSIGN      reduce using rule 33 (narrayindex -> arrayindex .)
    DIV_ASSIGN      reduce using rule 33 (narrayindex -> arrayindex .)
    AND_ASSIGN      reduce using rule 33 (narrayindex -> arrayindex .)
    OR_ASSIGN       reduce using rule 33 (narrayindex -> arrayindex .)
    XOR_ASSIGN      reduce using rule 33 (narrayindex -> arrayindex .)
    MOD_ASSIGN      reduce using rule 33 (narrayindex -> arrayindex .)
    L_SHIFT_ASSIGN  reduce using rule 33 (narrayindex -> arrayindex .)
    R_SHIFT_ASSIGN  reduce using rule 33 (narrayindex -> arrayindex .)
    R_PAREN         reduce using rule 33 (narrayindex -> arrayindex .)
    COMMA           reduce using rule 33 (narrayindex -> arrayindex .)
    R_SQBRACE       reduce using rule 33 (narrayindex -> arrayindex .)
    R_FLOWBRACE     reduce using rule 33 (narrayindex -> arrayindex .)


state 82

    (31) arrayindex -> L_SQBRACE . index R_SQBRACE
    (47) index -> . expr
    (48) index -> . empty
    (91) expr -> . expr assignment exprOR
    (92) expr -> . exprOR
    (62) empty -> .
    (104) exprOR -> . exprOR OR exprAND
    (105) exprOR -> . exprAND
    (106) exprAND -> . exprAND AND exprBITOR
    (107) exprAND -> . exprBITOR
    (108) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (109) exprBITOR -> . exprBITXOR
    (110) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (111) exprBITXOR -> . exprBITAND
    (112) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (113) exprBITAND -> . exprEQ
    (114) exprEQ -> . exprEQ EQ exprRELOP
    (115) exprEQ -> . exprEQ NE exprRELOP
    (116) exprEQ -> . exprRELOP
    (117) exprRELOP -> . exprRELOP relop exprSHIFT
    (118) exprRELOP -> . exprSHIFT
    (123) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (124) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (125) exprSHIFT -> . exprOP
    (126) exprOP -> . exprOP PLUS term
    (127) exprOP -> . exprOP MINUS term
    (128) exprOP -> . term
    (129) term -> . term MULTIPLY factor
    (130) term -> . term DIVIDE factor
    (131) term -> . term MOD factor
    (132) term -> . factor
    (133) factor -> . NOT factor
    (134) factor -> . PLUS factor
    (135) factor -> . MINUS factor
    (136) factor -> . PLUS_PLUS factor
    (137) factor -> . MINUS_MINUS factor
    (138) factor -> . cast brace
    (139) factor -> . brace
    (140) cast -> . L_PAREN TYPE R_PAREN
    (141) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (142) brace -> . L_PAREN expr R_PAREN
    (143) brace -> . brace PLUS_PLUS
    (144) brace -> . brace MINUS_MINUS
    (145) brace -> . NUM
    (146) brace -> . STRING
    (147) brace -> . MULTIPLY ID
    (148) brace -> . BIT_AND ID
    (149) brace -> . ID
    (150) brace -> . CHAR
    (151) brace -> . function_call
    (152) brace -> . ID narrayindex
    (153) NUM -> . INT_NUM
    (154) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    R_SQBRACE       reduce using rule 62 (empty -> .)
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    index                          shift and go to state 146
    expr                           shift and go to state 147
    empty                          shift and go to state 148
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 83

    (147) brace -> MULTIPLY ID .

    PLUS_PLUS       reduce using rule 147 (brace -> MULTIPLY ID .)
    MINUS_MINUS     reduce using rule 147 (brace -> MULTIPLY ID .)
    MULTIPLY        reduce using rule 147 (brace -> MULTIPLY ID .)
    DIVIDE          reduce using rule 147 (brace -> MULTIPLY ID .)
    MOD             reduce using rule 147 (brace -> MULTIPLY ID .)
    PLUS            reduce using rule 147 (brace -> MULTIPLY ID .)
    MINUS           reduce using rule 147 (brace -> MULTIPLY ID .)
    L_SHIFT         reduce using rule 147 (brace -> MULTIPLY ID .)
    R_SHIFT         reduce using rule 147 (brace -> MULTIPLY ID .)
    LE              reduce using rule 147 (brace -> MULTIPLY ID .)
    LT              reduce using rule 147 (brace -> MULTIPLY ID .)
    GE              reduce using rule 147 (brace -> MULTIPLY ID .)
    GT              reduce using rule 147 (brace -> MULTIPLY ID .)
    EQ              reduce using rule 147 (brace -> MULTIPLY ID .)
    NE              reduce using rule 147 (brace -> MULTIPLY ID .)
    BIT_AND         reduce using rule 147 (brace -> MULTIPLY ID .)
    BIT_XOR         reduce using rule 147 (brace -> MULTIPLY ID .)
    BIT_OR          reduce using rule 147 (brace -> MULTIPLY ID .)
    AND             reduce using rule 147 (brace -> MULTIPLY ID .)
    OR              reduce using rule 147 (brace -> MULTIPLY ID .)
    SEMICOLON       reduce using rule 147 (brace -> MULTIPLY ID .)
    ASSIGN          reduce using rule 147 (brace -> MULTIPLY ID .)
    PLUS_ASSIGN     reduce using rule 147 (brace -> MULTIPLY ID .)
    MINUS_ASSIGN    reduce using rule 147 (brace -> MULTIPLY ID .)
    MUL_ASSIGN      reduce using rule 147 (brace -> MULTIPLY ID .)
    DIV_ASSIGN      reduce using rule 147 (brace -> MULTIPLY ID .)
    AND_ASSIGN      reduce using rule 147 (brace -> MULTIPLY ID .)
    OR_ASSIGN       reduce using rule 147 (brace -> MULTIPLY ID .)
    XOR_ASSIGN      reduce using rule 147 (brace -> MULTIPLY ID .)
    MOD_ASSIGN      reduce using rule 147 (brace -> MULTIPLY ID .)
    L_SHIFT_ASSIGN  reduce using rule 147 (brace -> MULTIPLY ID .)
    R_SHIFT_ASSIGN  reduce using rule 147 (brace -> MULTIPLY ID .)
    R_PAREN         reduce using rule 147 (brace -> MULTIPLY ID .)
    COMMA           reduce using rule 147 (brace -> MULTIPLY ID .)
    R_SQBRACE       reduce using rule 147 (brace -> MULTIPLY ID .)
    R_FLOWBRACE     reduce using rule 147 (brace -> MULTIPLY ID .)


state 84

    (140) cast -> L_PAREN TYPE . R_PAREN
    (141) cast -> L_PAREN TYPE . MULTIPLY R_PAREN

    R_PAREN         shift and go to state 149
    MULTIPLY        shift and go to state 150


state 85

    (142) brace -> L_PAREN expr . R_PAREN
    (91) expr -> expr . assignment exprOR
    (93) assignment -> . ASSIGN
    (94) assignment -> . PLUS_ASSIGN
    (95) assignment -> . MINUS_ASSIGN
    (96) assignment -> . MUL_ASSIGN
    (97) assignment -> . DIV_ASSIGN
    (98) assignment -> . AND_ASSIGN
    (99) assignment -> . OR_ASSIGN
    (100) assignment -> . XOR_ASSIGN
    (101) assignment -> . MOD_ASSIGN
    (102) assignment -> . L_SHIFT_ASSIGN
    (103) assignment -> . R_SHIFT_ASSIGN

    R_PAREN         shift and go to state 151
    ASSIGN          shift and go to state 58
    PLUS_ASSIGN     shift and go to state 59
    MINUS_ASSIGN    shift and go to state 60
    MUL_ASSIGN      shift and go to state 61
    DIV_ASSIGN      shift and go to state 62
    AND_ASSIGN      shift and go to state 63
    OR_ASSIGN       shift and go to state 64
    XOR_ASSIGN      shift and go to state 65
    MOD_ASSIGN      shift and go to state 66
    L_SHIFT_ASSIGN  shift and go to state 67
    R_SHIFT_ASSIGN  shift and go to state 68

    assignment                     shift and go to state 57

state 86

    (106) exprAND -> exprAND AND . exprBITOR
    (108) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (109) exprBITOR -> . exprBITXOR
    (110) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (111) exprBITXOR -> . exprBITAND
    (112) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (113) exprBITAND -> . exprEQ
    (114) exprEQ -> . exprEQ EQ exprRELOP
    (115) exprEQ -> . exprEQ NE exprRELOP
    (116) exprEQ -> . exprRELOP
    (117) exprRELOP -> . exprRELOP relop exprSHIFT
    (118) exprRELOP -> . exprSHIFT
    (123) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (124) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (125) exprSHIFT -> . exprOP
    (126) exprOP -> . exprOP PLUS term
    (127) exprOP -> . exprOP MINUS term
    (128) exprOP -> . term
    (129) term -> . term MULTIPLY factor
    (130) term -> . term DIVIDE factor
    (131) term -> . term MOD factor
    (132) term -> . factor
    (133) factor -> . NOT factor
    (134) factor -> . PLUS factor
    (135) factor -> . MINUS factor
    (136) factor -> . PLUS_PLUS factor
    (137) factor -> . MINUS_MINUS factor
    (138) factor -> . cast brace
    (139) factor -> . brace
    (140) cast -> . L_PAREN TYPE R_PAREN
    (141) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (142) brace -> . L_PAREN expr R_PAREN
    (143) brace -> . brace PLUS_PLUS
    (144) brace -> . brace MINUS_MINUS
    (145) brace -> . NUM
    (146) brace -> . STRING
    (147) brace -> . MULTIPLY ID
    (148) brace -> . BIT_AND ID
    (149) brace -> . ID
    (150) brace -> . CHAR
    (151) brace -> . function_call
    (152) brace -> . ID narrayindex
    (153) NUM -> . INT_NUM
    (154) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    exprBITOR                      shift and go to state 152
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 87

    (108) exprBITOR -> exprBITOR BIT_OR . exprBITXOR
    (110) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (111) exprBITXOR -> . exprBITAND
    (112) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (113) exprBITAND -> . exprEQ
    (114) exprEQ -> . exprEQ EQ exprRELOP
    (115) exprEQ -> . exprEQ NE exprRELOP
    (116) exprEQ -> . exprRELOP
    (117) exprRELOP -> . exprRELOP relop exprSHIFT
    (118) exprRELOP -> . exprSHIFT
    (123) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (124) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (125) exprSHIFT -> . exprOP
    (126) exprOP -> . exprOP PLUS term
    (127) exprOP -> . exprOP MINUS term
    (128) exprOP -> . term
    (129) term -> . term MULTIPLY factor
    (130) term -> . term DIVIDE factor
    (131) term -> . term MOD factor
    (132) term -> . factor
    (133) factor -> . NOT factor
    (134) factor -> . PLUS factor
    (135) factor -> . MINUS factor
    (136) factor -> . PLUS_PLUS factor
    (137) factor -> . MINUS_MINUS factor
    (138) factor -> . cast brace
    (139) factor -> . brace
    (140) cast -> . L_PAREN TYPE R_PAREN
    (141) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (142) brace -> . L_PAREN expr R_PAREN
    (143) brace -> . brace PLUS_PLUS
    (144) brace -> . brace MINUS_MINUS
    (145) brace -> . NUM
    (146) brace -> . STRING
    (147) brace -> . MULTIPLY ID
    (148) brace -> . BIT_AND ID
    (149) brace -> . ID
    (150) brace -> . CHAR
    (151) brace -> . function_call
    (152) brace -> . ID narrayindex
    (153) NUM -> . INT_NUM
    (154) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    exprBITXOR                     shift and go to state 153
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 88

    (110) exprBITXOR -> exprBITXOR BIT_XOR . exprBITAND
    (112) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (113) exprBITAND -> . exprEQ
    (114) exprEQ -> . exprEQ EQ exprRELOP
    (115) exprEQ -> . exprEQ NE exprRELOP
    (116) exprEQ -> . exprRELOP
    (117) exprRELOP -> . exprRELOP relop exprSHIFT
    (118) exprRELOP -> . exprSHIFT
    (123) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (124) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (125) exprSHIFT -> . exprOP
    (126) exprOP -> . exprOP PLUS term
    (127) exprOP -> . exprOP MINUS term
    (128) exprOP -> . term
    (129) term -> . term MULTIPLY factor
    (130) term -> . term DIVIDE factor
    (131) term -> . term MOD factor
    (132) term -> . factor
    (133) factor -> . NOT factor
    (134) factor -> . PLUS factor
    (135) factor -> . MINUS factor
    (136) factor -> . PLUS_PLUS factor
    (137) factor -> . MINUS_MINUS factor
    (138) factor -> . cast brace
    (139) factor -> . brace
    (140) cast -> . L_PAREN TYPE R_PAREN
    (141) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (142) brace -> . L_PAREN expr R_PAREN
    (143) brace -> . brace PLUS_PLUS
    (144) brace -> . brace MINUS_MINUS
    (145) brace -> . NUM
    (146) brace -> . STRING
    (147) brace -> . MULTIPLY ID
    (148) brace -> . BIT_AND ID
    (149) brace -> . ID
    (150) brace -> . CHAR
    (151) brace -> . function_call
    (152) brace -> . ID narrayindex
    (153) NUM -> . INT_NUM
    (154) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    exprBITAND                     shift and go to state 154
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 89

    (112) exprBITAND -> exprBITAND BIT_AND . exprEQ
    (114) exprEQ -> . exprEQ EQ exprRELOP
    (115) exprEQ -> . exprEQ NE exprRELOP
    (116) exprEQ -> . exprRELOP
    (117) exprRELOP -> . exprRELOP relop exprSHIFT
    (118) exprRELOP -> . exprSHIFT
    (123) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (124) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (125) exprSHIFT -> . exprOP
    (126) exprOP -> . exprOP PLUS term
    (127) exprOP -> . exprOP MINUS term
    (128) exprOP -> . term
    (129) term -> . term MULTIPLY factor
    (130) term -> . term DIVIDE factor
    (131) term -> . term MOD factor
    (132) term -> . factor
    (133) factor -> . NOT factor
    (134) factor -> . PLUS factor
    (135) factor -> . MINUS factor
    (136) factor -> . PLUS_PLUS factor
    (137) factor -> . MINUS_MINUS factor
    (138) factor -> . cast brace
    (139) factor -> . brace
    (140) cast -> . L_PAREN TYPE R_PAREN
    (141) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (142) brace -> . L_PAREN expr R_PAREN
    (143) brace -> . brace PLUS_PLUS
    (144) brace -> . brace MINUS_MINUS
    (145) brace -> . NUM
    (146) brace -> . STRING
    (147) brace -> . MULTIPLY ID
    (148) brace -> . BIT_AND ID
    (149) brace -> . ID
    (150) brace -> . CHAR
    (151) brace -> . function_call
    (152) brace -> . ID narrayindex
    (153) NUM -> . INT_NUM
    (154) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    exprEQ                         shift and go to state 155
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 90

    (148) brace -> BIT_AND ID .

    PLUS_PLUS       reduce using rule 148 (brace -> BIT_AND ID .)
    MINUS_MINUS     reduce using rule 148 (brace -> BIT_AND ID .)
    MULTIPLY        reduce using rule 148 (brace -> BIT_AND ID .)
    DIVIDE          reduce using rule 148 (brace -> BIT_AND ID .)
    MOD             reduce using rule 148 (brace -> BIT_AND ID .)
    PLUS            reduce using rule 148 (brace -> BIT_AND ID .)
    MINUS           reduce using rule 148 (brace -> BIT_AND ID .)
    L_SHIFT         reduce using rule 148 (brace -> BIT_AND ID .)
    R_SHIFT         reduce using rule 148 (brace -> BIT_AND ID .)
    LE              reduce using rule 148 (brace -> BIT_AND ID .)
    LT              reduce using rule 148 (brace -> BIT_AND ID .)
    GE              reduce using rule 148 (brace -> BIT_AND ID .)
    GT              reduce using rule 148 (brace -> BIT_AND ID .)
    EQ              reduce using rule 148 (brace -> BIT_AND ID .)
    NE              reduce using rule 148 (brace -> BIT_AND ID .)
    BIT_AND         reduce using rule 148 (brace -> BIT_AND ID .)
    BIT_XOR         reduce using rule 148 (brace -> BIT_AND ID .)
    BIT_OR          reduce using rule 148 (brace -> BIT_AND ID .)
    AND             reduce using rule 148 (brace -> BIT_AND ID .)
    OR              reduce using rule 148 (brace -> BIT_AND ID .)
    SEMICOLON       reduce using rule 148 (brace -> BIT_AND ID .)
    ASSIGN          reduce using rule 148 (brace -> BIT_AND ID .)
    PLUS_ASSIGN     reduce using rule 148 (brace -> BIT_AND ID .)
    MINUS_ASSIGN    reduce using rule 148 (brace -> BIT_AND ID .)
    MUL_ASSIGN      reduce using rule 148 (brace -> BIT_AND ID .)
    DIV_ASSIGN      reduce using rule 148 (brace -> BIT_AND ID .)
    AND_ASSIGN      reduce using rule 148 (brace -> BIT_AND ID .)
    OR_ASSIGN       reduce using rule 148 (brace -> BIT_AND ID .)
    XOR_ASSIGN      reduce using rule 148 (brace -> BIT_AND ID .)
    MOD_ASSIGN      reduce using rule 148 (brace -> BIT_AND ID .)
    L_SHIFT_ASSIGN  reduce using rule 148 (brace -> BIT_AND ID .)
    R_SHIFT_ASSIGN  reduce using rule 148 (brace -> BIT_AND ID .)
    R_PAREN         reduce using rule 148 (brace -> BIT_AND ID .)
    COMMA           reduce using rule 148 (brace -> BIT_AND ID .)
    R_SQBRACE       reduce using rule 148 (brace -> BIT_AND ID .)
    R_FLOWBRACE     reduce using rule 148 (brace -> BIT_AND ID .)


state 91

    (114) exprEQ -> exprEQ EQ . exprRELOP
    (117) exprRELOP -> . exprRELOP relop exprSHIFT
    (118) exprRELOP -> . exprSHIFT
    (123) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (124) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (125) exprSHIFT -> . exprOP
    (126) exprOP -> . exprOP PLUS term
    (127) exprOP -> . exprOP MINUS term
    (128) exprOP -> . term
    (129) term -> . term MULTIPLY factor
    (130) term -> . term DIVIDE factor
    (131) term -> . term MOD factor
    (132) term -> . factor
    (133) factor -> . NOT factor
    (134) factor -> . PLUS factor
    (135) factor -> . MINUS factor
    (136) factor -> . PLUS_PLUS factor
    (137) factor -> . MINUS_MINUS factor
    (138) factor -> . cast brace
    (139) factor -> . brace
    (140) cast -> . L_PAREN TYPE R_PAREN
    (141) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (142) brace -> . L_PAREN expr R_PAREN
    (143) brace -> . brace PLUS_PLUS
    (144) brace -> . brace MINUS_MINUS
    (145) brace -> . NUM
    (146) brace -> . STRING
    (147) brace -> . MULTIPLY ID
    (148) brace -> . BIT_AND ID
    (149) brace -> . ID
    (150) brace -> . CHAR
    (151) brace -> . function_call
    (152) brace -> . ID narrayindex
    (153) NUM -> . INT_NUM
    (154) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    exprRELOP                      shift and go to state 156
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 92

    (115) exprEQ -> exprEQ NE . exprRELOP
    (117) exprRELOP -> . exprRELOP relop exprSHIFT
    (118) exprRELOP -> . exprSHIFT
    (123) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (124) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (125) exprSHIFT -> . exprOP
    (126) exprOP -> . exprOP PLUS term
    (127) exprOP -> . exprOP MINUS term
    (128) exprOP -> . term
    (129) term -> . term MULTIPLY factor
    (130) term -> . term DIVIDE factor
    (131) term -> . term MOD factor
    (132) term -> . factor
    (133) factor -> . NOT factor
    (134) factor -> . PLUS factor
    (135) factor -> . MINUS factor
    (136) factor -> . PLUS_PLUS factor
    (137) factor -> . MINUS_MINUS factor
    (138) factor -> . cast brace
    (139) factor -> . brace
    (140) cast -> . L_PAREN TYPE R_PAREN
    (141) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (142) brace -> . L_PAREN expr R_PAREN
    (143) brace -> . brace PLUS_PLUS
    (144) brace -> . brace MINUS_MINUS
    (145) brace -> . NUM
    (146) brace -> . STRING
    (147) brace -> . MULTIPLY ID
    (148) brace -> . BIT_AND ID
    (149) brace -> . ID
    (150) brace -> . CHAR
    (151) brace -> . function_call
    (152) brace -> . ID narrayindex
    (153) NUM -> . INT_NUM
    (154) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    exprRELOP                      shift and go to state 157
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 93

    (117) exprRELOP -> exprRELOP relop . exprSHIFT
    (123) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (124) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (125) exprSHIFT -> . exprOP
    (126) exprOP -> . exprOP PLUS term
    (127) exprOP -> . exprOP MINUS term
    (128) exprOP -> . term
    (129) term -> . term MULTIPLY factor
    (130) term -> . term DIVIDE factor
    (131) term -> . term MOD factor
    (132) term -> . factor
    (133) factor -> . NOT factor
    (134) factor -> . PLUS factor
    (135) factor -> . MINUS factor
    (136) factor -> . PLUS_PLUS factor
    (137) factor -> . MINUS_MINUS factor
    (138) factor -> . cast brace
    (139) factor -> . brace
    (140) cast -> . L_PAREN TYPE R_PAREN
    (141) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (142) brace -> . L_PAREN expr R_PAREN
    (143) brace -> . brace PLUS_PLUS
    (144) brace -> . brace MINUS_MINUS
    (145) brace -> . NUM
    (146) brace -> . STRING
    (147) brace -> . MULTIPLY ID
    (148) brace -> . BIT_AND ID
    (149) brace -> . ID
    (150) brace -> . CHAR
    (151) brace -> . function_call
    (152) brace -> . ID narrayindex
    (153) NUM -> . INT_NUM
    (154) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    exprSHIFT                      shift and go to state 158
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 94

    (119) relop -> LE .

    NOT             reduce using rule 119 (relop -> LE .)
    PLUS            reduce using rule 119 (relop -> LE .)
    MINUS           reduce using rule 119 (relop -> LE .)
    PLUS_PLUS       reduce using rule 119 (relop -> LE .)
    MINUS_MINUS     reduce using rule 119 (relop -> LE .)
    L_PAREN         reduce using rule 119 (relop -> LE .)
    STRING          reduce using rule 119 (relop -> LE .)
    MULTIPLY        reduce using rule 119 (relop -> LE .)
    BIT_AND         reduce using rule 119 (relop -> LE .)
    ID              reduce using rule 119 (relop -> LE .)
    CHAR            reduce using rule 119 (relop -> LE .)
    INT_NUM         reduce using rule 119 (relop -> LE .)
    FLOAT_NUM       reduce using rule 119 (relop -> LE .)


state 95

    (120) relop -> LT .

    NOT             reduce using rule 120 (relop -> LT .)
    PLUS            reduce using rule 120 (relop -> LT .)
    MINUS           reduce using rule 120 (relop -> LT .)
    PLUS_PLUS       reduce using rule 120 (relop -> LT .)
    MINUS_MINUS     reduce using rule 120 (relop -> LT .)
    L_PAREN         reduce using rule 120 (relop -> LT .)
    STRING          reduce using rule 120 (relop -> LT .)
    MULTIPLY        reduce using rule 120 (relop -> LT .)
    BIT_AND         reduce using rule 120 (relop -> LT .)
    ID              reduce using rule 120 (relop -> LT .)
    CHAR            reduce using rule 120 (relop -> LT .)
    INT_NUM         reduce using rule 120 (relop -> LT .)
    FLOAT_NUM       reduce using rule 120 (relop -> LT .)


state 96

    (121) relop -> GE .

    NOT             reduce using rule 121 (relop -> GE .)
    PLUS            reduce using rule 121 (relop -> GE .)
    MINUS           reduce using rule 121 (relop -> GE .)
    PLUS_PLUS       reduce using rule 121 (relop -> GE .)
    MINUS_MINUS     reduce using rule 121 (relop -> GE .)
    L_PAREN         reduce using rule 121 (relop -> GE .)
    STRING          reduce using rule 121 (relop -> GE .)
    MULTIPLY        reduce using rule 121 (relop -> GE .)
    BIT_AND         reduce using rule 121 (relop -> GE .)
    ID              reduce using rule 121 (relop -> GE .)
    CHAR            reduce using rule 121 (relop -> GE .)
    INT_NUM         reduce using rule 121 (relop -> GE .)
    FLOAT_NUM       reduce using rule 121 (relop -> GE .)


state 97

    (122) relop -> GT .

    NOT             reduce using rule 122 (relop -> GT .)
    PLUS            reduce using rule 122 (relop -> GT .)
    MINUS           reduce using rule 122 (relop -> GT .)
    PLUS_PLUS       reduce using rule 122 (relop -> GT .)
    MINUS_MINUS     reduce using rule 122 (relop -> GT .)
    L_PAREN         reduce using rule 122 (relop -> GT .)
    STRING          reduce using rule 122 (relop -> GT .)
    MULTIPLY        reduce using rule 122 (relop -> GT .)
    BIT_AND         reduce using rule 122 (relop -> GT .)
    ID              reduce using rule 122 (relop -> GT .)
    CHAR            reduce using rule 122 (relop -> GT .)
    INT_NUM         reduce using rule 122 (relop -> GT .)
    FLOAT_NUM       reduce using rule 122 (relop -> GT .)


state 98

    (123) exprSHIFT -> exprSHIFT L_SHIFT . exprOP
    (126) exprOP -> . exprOP PLUS term
    (127) exprOP -> . exprOP MINUS term
    (128) exprOP -> . term
    (129) term -> . term MULTIPLY factor
    (130) term -> . term DIVIDE factor
    (131) term -> . term MOD factor
    (132) term -> . factor
    (133) factor -> . NOT factor
    (134) factor -> . PLUS factor
    (135) factor -> . MINUS factor
    (136) factor -> . PLUS_PLUS factor
    (137) factor -> . MINUS_MINUS factor
    (138) factor -> . cast brace
    (139) factor -> . brace
    (140) cast -> . L_PAREN TYPE R_PAREN
    (141) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (142) brace -> . L_PAREN expr R_PAREN
    (143) brace -> . brace PLUS_PLUS
    (144) brace -> . brace MINUS_MINUS
    (145) brace -> . NUM
    (146) brace -> . STRING
    (147) brace -> . MULTIPLY ID
    (148) brace -> . BIT_AND ID
    (149) brace -> . ID
    (150) brace -> . CHAR
    (151) brace -> . function_call
    (152) brace -> . ID narrayindex
    (153) NUM -> . INT_NUM
    (154) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    exprOP                         shift and go to state 159
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 99

    (124) exprSHIFT -> exprSHIFT R_SHIFT . exprOP
    (126) exprOP -> . exprOP PLUS term
    (127) exprOP -> . exprOP MINUS term
    (128) exprOP -> . term
    (129) term -> . term MULTIPLY factor
    (130) term -> . term DIVIDE factor
    (131) term -> . term MOD factor
    (132) term -> . factor
    (133) factor -> . NOT factor
    (134) factor -> . PLUS factor
    (135) factor -> . MINUS factor
    (136) factor -> . PLUS_PLUS factor
    (137) factor -> . MINUS_MINUS factor
    (138) factor -> . cast brace
    (139) factor -> . brace
    (140) cast -> . L_PAREN TYPE R_PAREN
    (141) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (142) brace -> . L_PAREN expr R_PAREN
    (143) brace -> . brace PLUS_PLUS
    (144) brace -> . brace MINUS_MINUS
    (145) brace -> . NUM
    (146) brace -> . STRING
    (147) brace -> . MULTIPLY ID
    (148) brace -> . BIT_AND ID
    (149) brace -> . ID
    (150) brace -> . CHAR
    (151) brace -> . function_call
    (152) brace -> . ID narrayindex
    (153) NUM -> . INT_NUM
    (154) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    exprOP                         shift and go to state 160
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 100

    (126) exprOP -> exprOP PLUS . term
    (129) term -> . term MULTIPLY factor
    (130) term -> . term DIVIDE factor
    (131) term -> . term MOD factor
    (132) term -> . factor
    (133) factor -> . NOT factor
    (134) factor -> . PLUS factor
    (135) factor -> . MINUS factor
    (136) factor -> . PLUS_PLUS factor
    (137) factor -> . MINUS_MINUS factor
    (138) factor -> . cast brace
    (139) factor -> . brace
    (140) cast -> . L_PAREN TYPE R_PAREN
    (141) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (142) brace -> . L_PAREN expr R_PAREN
    (143) brace -> . brace PLUS_PLUS
    (144) brace -> . brace MINUS_MINUS
    (145) brace -> . NUM
    (146) brace -> . STRING
    (147) brace -> . MULTIPLY ID
    (148) brace -> . BIT_AND ID
    (149) brace -> . ID
    (150) brace -> . CHAR
    (151) brace -> . function_call
    (152) brace -> . ID narrayindex
    (153) NUM -> . INT_NUM
    (154) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    term                           shift and go to state 161
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 101

    (127) exprOP -> exprOP MINUS . term
    (129) term -> . term MULTIPLY factor
    (130) term -> . term DIVIDE factor
    (131) term -> . term MOD factor
    (132) term -> . factor
    (133) factor -> . NOT factor
    (134) factor -> . PLUS factor
    (135) factor -> . MINUS factor
    (136) factor -> . PLUS_PLUS factor
    (137) factor -> . MINUS_MINUS factor
    (138) factor -> . cast brace
    (139) factor -> . brace
    (140) cast -> . L_PAREN TYPE R_PAREN
    (141) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (142) brace -> . L_PAREN expr R_PAREN
    (143) brace -> . brace PLUS_PLUS
    (144) brace -> . brace MINUS_MINUS
    (145) brace -> . NUM
    (146) brace -> . STRING
    (147) brace -> . MULTIPLY ID
    (148) brace -> . BIT_AND ID
    (149) brace -> . ID
    (150) brace -> . CHAR
    (151) brace -> . function_call
    (152) brace -> . ID narrayindex
    (153) NUM -> . INT_NUM
    (154) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    term                           shift and go to state 162
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 102

    (134) factor -> PLUS factor .

    MULTIPLY        reduce using rule 134 (factor -> PLUS factor .)
    DIVIDE          reduce using rule 134 (factor -> PLUS factor .)
    MOD             reduce using rule 134 (factor -> PLUS factor .)
    PLUS            reduce using rule 134 (factor -> PLUS factor .)
    MINUS           reduce using rule 134 (factor -> PLUS factor .)
    L_SHIFT         reduce using rule 134 (factor -> PLUS factor .)
    R_SHIFT         reduce using rule 134 (factor -> PLUS factor .)
    LE              reduce using rule 134 (factor -> PLUS factor .)
    LT              reduce using rule 134 (factor -> PLUS factor .)
    GE              reduce using rule 134 (factor -> PLUS factor .)
    GT              reduce using rule 134 (factor -> PLUS factor .)
    EQ              reduce using rule 134 (factor -> PLUS factor .)
    NE              reduce using rule 134 (factor -> PLUS factor .)
    BIT_AND         reduce using rule 134 (factor -> PLUS factor .)
    BIT_XOR         reduce using rule 134 (factor -> PLUS factor .)
    BIT_OR          reduce using rule 134 (factor -> PLUS factor .)
    AND             reduce using rule 134 (factor -> PLUS factor .)
    OR              reduce using rule 134 (factor -> PLUS factor .)
    SEMICOLON       reduce using rule 134 (factor -> PLUS factor .)
    ASSIGN          reduce using rule 134 (factor -> PLUS factor .)
    PLUS_ASSIGN     reduce using rule 134 (factor -> PLUS factor .)
    MINUS_ASSIGN    reduce using rule 134 (factor -> PLUS factor .)
    MUL_ASSIGN      reduce using rule 134 (factor -> PLUS factor .)
    DIV_ASSIGN      reduce using rule 134 (factor -> PLUS factor .)
    AND_ASSIGN      reduce using rule 134 (factor -> PLUS factor .)
    OR_ASSIGN       reduce using rule 134 (factor -> PLUS factor .)
    XOR_ASSIGN      reduce using rule 134 (factor -> PLUS factor .)
    MOD_ASSIGN      reduce using rule 134 (factor -> PLUS factor .)
    L_SHIFT_ASSIGN  reduce using rule 134 (factor -> PLUS factor .)
    R_SHIFT_ASSIGN  reduce using rule 134 (factor -> PLUS factor .)
    R_PAREN         reduce using rule 134 (factor -> PLUS factor .)
    COMMA           reduce using rule 134 (factor -> PLUS factor .)
    R_SQBRACE       reduce using rule 134 (factor -> PLUS factor .)
    R_FLOWBRACE     reduce using rule 134 (factor -> PLUS factor .)


state 103

    (129) term -> term MULTIPLY . factor
    (133) factor -> . NOT factor
    (134) factor -> . PLUS factor
    (135) factor -> . MINUS factor
    (136) factor -> . PLUS_PLUS factor
    (137) factor -> . MINUS_MINUS factor
    (138) factor -> . cast brace
    (139) factor -> . brace
    (140) cast -> . L_PAREN TYPE R_PAREN
    (141) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (142) brace -> . L_PAREN expr R_PAREN
    (143) brace -> . brace PLUS_PLUS
    (144) brace -> . brace MINUS_MINUS
    (145) brace -> . NUM
    (146) brace -> . STRING
    (147) brace -> . MULTIPLY ID
    (148) brace -> . BIT_AND ID
    (149) brace -> . ID
    (150) brace -> . CHAR
    (151) brace -> . function_call
    (152) brace -> . ID narrayindex
    (153) NUM -> . INT_NUM
    (154) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    factor                         shift and go to state 163
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 104

    (130) term -> term DIVIDE . factor
    (133) factor -> . NOT factor
    (134) factor -> . PLUS factor
    (135) factor -> . MINUS factor
    (136) factor -> . PLUS_PLUS factor
    (137) factor -> . MINUS_MINUS factor
    (138) factor -> . cast brace
    (139) factor -> . brace
    (140) cast -> . L_PAREN TYPE R_PAREN
    (141) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (142) brace -> . L_PAREN expr R_PAREN
    (143) brace -> . brace PLUS_PLUS
    (144) brace -> . brace MINUS_MINUS
    (145) brace -> . NUM
    (146) brace -> . STRING
    (147) brace -> . MULTIPLY ID
    (148) brace -> . BIT_AND ID
    (149) brace -> . ID
    (150) brace -> . CHAR
    (151) brace -> . function_call
    (152) brace -> . ID narrayindex
    (153) NUM -> . INT_NUM
    (154) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    factor                         shift and go to state 164
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 105

    (131) term -> term MOD . factor
    (133) factor -> . NOT factor
    (134) factor -> . PLUS factor
    (135) factor -> . MINUS factor
    (136) factor -> . PLUS_PLUS factor
    (137) factor -> . MINUS_MINUS factor
    (138) factor -> . cast brace
    (139) factor -> . brace
    (140) cast -> . L_PAREN TYPE R_PAREN
    (141) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (142) brace -> . L_PAREN expr R_PAREN
    (143) brace -> . brace PLUS_PLUS
    (144) brace -> . brace MINUS_MINUS
    (145) brace -> . NUM
    (146) brace -> . STRING
    (147) brace -> . MULTIPLY ID
    (148) brace -> . BIT_AND ID
    (149) brace -> . ID
    (150) brace -> . CHAR
    (151) brace -> . function_call
    (152) brace -> . ID narrayindex
    (153) NUM -> . INT_NUM
    (154) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    factor                         shift and go to state 165
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 106

    (135) factor -> MINUS factor .

    MULTIPLY        reduce using rule 135 (factor -> MINUS factor .)
    DIVIDE          reduce using rule 135 (factor -> MINUS factor .)
    MOD             reduce using rule 135 (factor -> MINUS factor .)
    PLUS            reduce using rule 135 (factor -> MINUS factor .)
    MINUS           reduce using rule 135 (factor -> MINUS factor .)
    L_SHIFT         reduce using rule 135 (factor -> MINUS factor .)
    R_SHIFT         reduce using rule 135 (factor -> MINUS factor .)
    LE              reduce using rule 135 (factor -> MINUS factor .)
    LT              reduce using rule 135 (factor -> MINUS factor .)
    GE              reduce using rule 135 (factor -> MINUS factor .)
    GT              reduce using rule 135 (factor -> MINUS factor .)
    EQ              reduce using rule 135 (factor -> MINUS factor .)
    NE              reduce using rule 135 (factor -> MINUS factor .)
    BIT_AND         reduce using rule 135 (factor -> MINUS factor .)
    BIT_XOR         reduce using rule 135 (factor -> MINUS factor .)
    BIT_OR          reduce using rule 135 (factor -> MINUS factor .)
    AND             reduce using rule 135 (factor -> MINUS factor .)
    OR              reduce using rule 135 (factor -> MINUS factor .)
    SEMICOLON       reduce using rule 135 (factor -> MINUS factor .)
    ASSIGN          reduce using rule 135 (factor -> MINUS factor .)
    PLUS_ASSIGN     reduce using rule 135 (factor -> MINUS factor .)
    MINUS_ASSIGN    reduce using rule 135 (factor -> MINUS factor .)
    MUL_ASSIGN      reduce using rule 135 (factor -> MINUS factor .)
    DIV_ASSIGN      reduce using rule 135 (factor -> MINUS factor .)
    AND_ASSIGN      reduce using rule 135 (factor -> MINUS factor .)
    OR_ASSIGN       reduce using rule 135 (factor -> MINUS factor .)
    XOR_ASSIGN      reduce using rule 135 (factor -> MINUS factor .)
    MOD_ASSIGN      reduce using rule 135 (factor -> MINUS factor .)
    L_SHIFT_ASSIGN  reduce using rule 135 (factor -> MINUS factor .)
    R_SHIFT_ASSIGN  reduce using rule 135 (factor -> MINUS factor .)
    R_PAREN         reduce using rule 135 (factor -> MINUS factor .)
    COMMA           reduce using rule 135 (factor -> MINUS factor .)
    R_SQBRACE       reduce using rule 135 (factor -> MINUS factor .)
    R_FLOWBRACE     reduce using rule 135 (factor -> MINUS factor .)


state 107

    (133) factor -> NOT factor .

    MULTIPLY        reduce using rule 133 (factor -> NOT factor .)
    DIVIDE          reduce using rule 133 (factor -> NOT factor .)
    MOD             reduce using rule 133 (factor -> NOT factor .)
    PLUS            reduce using rule 133 (factor -> NOT factor .)
    MINUS           reduce using rule 133 (factor -> NOT factor .)
    L_SHIFT         reduce using rule 133 (factor -> NOT factor .)
    R_SHIFT         reduce using rule 133 (factor -> NOT factor .)
    LE              reduce using rule 133 (factor -> NOT factor .)
    LT              reduce using rule 133 (factor -> NOT factor .)
    GE              reduce using rule 133 (factor -> NOT factor .)
    GT              reduce using rule 133 (factor -> NOT factor .)
    EQ              reduce using rule 133 (factor -> NOT factor .)
    NE              reduce using rule 133 (factor -> NOT factor .)
    BIT_AND         reduce using rule 133 (factor -> NOT factor .)
    BIT_XOR         reduce using rule 133 (factor -> NOT factor .)
    BIT_OR          reduce using rule 133 (factor -> NOT factor .)
    AND             reduce using rule 133 (factor -> NOT factor .)
    OR              reduce using rule 133 (factor -> NOT factor .)
    SEMICOLON       reduce using rule 133 (factor -> NOT factor .)
    ASSIGN          reduce using rule 133 (factor -> NOT factor .)
    PLUS_ASSIGN     reduce using rule 133 (factor -> NOT factor .)
    MINUS_ASSIGN    reduce using rule 133 (factor -> NOT factor .)
    MUL_ASSIGN      reduce using rule 133 (factor -> NOT factor .)
    DIV_ASSIGN      reduce using rule 133 (factor -> NOT factor .)
    AND_ASSIGN      reduce using rule 133 (factor -> NOT factor .)
    OR_ASSIGN       reduce using rule 133 (factor -> NOT factor .)
    XOR_ASSIGN      reduce using rule 133 (factor -> NOT factor .)
    MOD_ASSIGN      reduce using rule 133 (factor -> NOT factor .)
    L_SHIFT_ASSIGN  reduce using rule 133 (factor -> NOT factor .)
    R_SHIFT_ASSIGN  reduce using rule 133 (factor -> NOT factor .)
    R_PAREN         reduce using rule 133 (factor -> NOT factor .)
    COMMA           reduce using rule 133 (factor -> NOT factor .)
    R_SQBRACE       reduce using rule 133 (factor -> NOT factor .)
    R_FLOWBRACE     reduce using rule 133 (factor -> NOT factor .)


state 108

    (136) factor -> PLUS_PLUS factor .

    MULTIPLY        reduce using rule 136 (factor -> PLUS_PLUS factor .)
    DIVIDE          reduce using rule 136 (factor -> PLUS_PLUS factor .)
    MOD             reduce using rule 136 (factor -> PLUS_PLUS factor .)
    PLUS            reduce using rule 136 (factor -> PLUS_PLUS factor .)
    MINUS           reduce using rule 136 (factor -> PLUS_PLUS factor .)
    L_SHIFT         reduce using rule 136 (factor -> PLUS_PLUS factor .)
    R_SHIFT         reduce using rule 136 (factor -> PLUS_PLUS factor .)
    LE              reduce using rule 136 (factor -> PLUS_PLUS factor .)
    LT              reduce using rule 136 (factor -> PLUS_PLUS factor .)
    GE              reduce using rule 136 (factor -> PLUS_PLUS factor .)
    GT              reduce using rule 136 (factor -> PLUS_PLUS factor .)
    EQ              reduce using rule 136 (factor -> PLUS_PLUS factor .)
    NE              reduce using rule 136 (factor -> PLUS_PLUS factor .)
    BIT_AND         reduce using rule 136 (factor -> PLUS_PLUS factor .)
    BIT_XOR         reduce using rule 136 (factor -> PLUS_PLUS factor .)
    BIT_OR          reduce using rule 136 (factor -> PLUS_PLUS factor .)
    AND             reduce using rule 136 (factor -> PLUS_PLUS factor .)
    OR              reduce using rule 136 (factor -> PLUS_PLUS factor .)
    SEMICOLON       reduce using rule 136 (factor -> PLUS_PLUS factor .)
    ASSIGN          reduce using rule 136 (factor -> PLUS_PLUS factor .)
    PLUS_ASSIGN     reduce using rule 136 (factor -> PLUS_PLUS factor .)
    MINUS_ASSIGN    reduce using rule 136 (factor -> PLUS_PLUS factor .)
    MUL_ASSIGN      reduce using rule 136 (factor -> PLUS_PLUS factor .)
    DIV_ASSIGN      reduce using rule 136 (factor -> PLUS_PLUS factor .)
    AND_ASSIGN      reduce using rule 136 (factor -> PLUS_PLUS factor .)
    OR_ASSIGN       reduce using rule 136 (factor -> PLUS_PLUS factor .)
    XOR_ASSIGN      reduce using rule 136 (factor -> PLUS_PLUS factor .)
    MOD_ASSIGN      reduce using rule 136 (factor -> PLUS_PLUS factor .)
    L_SHIFT_ASSIGN  reduce using rule 136 (factor -> PLUS_PLUS factor .)
    R_SHIFT_ASSIGN  reduce using rule 136 (factor -> PLUS_PLUS factor .)
    R_PAREN         reduce using rule 136 (factor -> PLUS_PLUS factor .)
    COMMA           reduce using rule 136 (factor -> PLUS_PLUS factor .)
    R_SQBRACE       reduce using rule 136 (factor -> PLUS_PLUS factor .)
    R_FLOWBRACE     reduce using rule 136 (factor -> PLUS_PLUS factor .)


state 109

    (137) factor -> MINUS_MINUS factor .

    MULTIPLY        reduce using rule 137 (factor -> MINUS_MINUS factor .)
    DIVIDE          reduce using rule 137 (factor -> MINUS_MINUS factor .)
    MOD             reduce using rule 137 (factor -> MINUS_MINUS factor .)
    PLUS            reduce using rule 137 (factor -> MINUS_MINUS factor .)
    MINUS           reduce using rule 137 (factor -> MINUS_MINUS factor .)
    L_SHIFT         reduce using rule 137 (factor -> MINUS_MINUS factor .)
    R_SHIFT         reduce using rule 137 (factor -> MINUS_MINUS factor .)
    LE              reduce using rule 137 (factor -> MINUS_MINUS factor .)
    LT              reduce using rule 137 (factor -> MINUS_MINUS factor .)
    GE              reduce using rule 137 (factor -> MINUS_MINUS factor .)
    GT              reduce using rule 137 (factor -> MINUS_MINUS factor .)
    EQ              reduce using rule 137 (factor -> MINUS_MINUS factor .)
    NE              reduce using rule 137 (factor -> MINUS_MINUS factor .)
    BIT_AND         reduce using rule 137 (factor -> MINUS_MINUS factor .)
    BIT_XOR         reduce using rule 137 (factor -> MINUS_MINUS factor .)
    BIT_OR          reduce using rule 137 (factor -> MINUS_MINUS factor .)
    AND             reduce using rule 137 (factor -> MINUS_MINUS factor .)
    OR              reduce using rule 137 (factor -> MINUS_MINUS factor .)
    SEMICOLON       reduce using rule 137 (factor -> MINUS_MINUS factor .)
    ASSIGN          reduce using rule 137 (factor -> MINUS_MINUS factor .)
    PLUS_ASSIGN     reduce using rule 137 (factor -> MINUS_MINUS factor .)
    MINUS_ASSIGN    reduce using rule 137 (factor -> MINUS_MINUS factor .)
    MUL_ASSIGN      reduce using rule 137 (factor -> MINUS_MINUS factor .)
    DIV_ASSIGN      reduce using rule 137 (factor -> MINUS_MINUS factor .)
    AND_ASSIGN      reduce using rule 137 (factor -> MINUS_MINUS factor .)
    OR_ASSIGN       reduce using rule 137 (factor -> MINUS_MINUS factor .)
    XOR_ASSIGN      reduce using rule 137 (factor -> MINUS_MINUS factor .)
    MOD_ASSIGN      reduce using rule 137 (factor -> MINUS_MINUS factor .)
    L_SHIFT_ASSIGN  reduce using rule 137 (factor -> MINUS_MINUS factor .)
    R_SHIFT_ASSIGN  reduce using rule 137 (factor -> MINUS_MINUS factor .)
    R_PAREN         reduce using rule 137 (factor -> MINUS_MINUS factor .)
    COMMA           reduce using rule 137 (factor -> MINUS_MINUS factor .)
    R_SQBRACE       reduce using rule 137 (factor -> MINUS_MINUS factor .)
    R_FLOWBRACE     reduce using rule 137 (factor -> MINUS_MINUS factor .)


state 110

    (138) factor -> cast brace .
    (143) brace -> brace . PLUS_PLUS
    (144) brace -> brace . MINUS_MINUS

    MULTIPLY        reduce using rule 138 (factor -> cast brace .)
    DIVIDE          reduce using rule 138 (factor -> cast brace .)
    MOD             reduce using rule 138 (factor -> cast brace .)
    PLUS            reduce using rule 138 (factor -> cast brace .)
    MINUS           reduce using rule 138 (factor -> cast brace .)
    L_SHIFT         reduce using rule 138 (factor -> cast brace .)
    R_SHIFT         reduce using rule 138 (factor -> cast brace .)
    LE              reduce using rule 138 (factor -> cast brace .)
    LT              reduce using rule 138 (factor -> cast brace .)
    GE              reduce using rule 138 (factor -> cast brace .)
    GT              reduce using rule 138 (factor -> cast brace .)
    EQ              reduce using rule 138 (factor -> cast brace .)
    NE              reduce using rule 138 (factor -> cast brace .)
    BIT_AND         reduce using rule 138 (factor -> cast brace .)
    BIT_XOR         reduce using rule 138 (factor -> cast brace .)
    BIT_OR          reduce using rule 138 (factor -> cast brace .)
    AND             reduce using rule 138 (factor -> cast brace .)
    OR              reduce using rule 138 (factor -> cast brace .)
    SEMICOLON       reduce using rule 138 (factor -> cast brace .)
    ASSIGN          reduce using rule 138 (factor -> cast brace .)
    PLUS_ASSIGN     reduce using rule 138 (factor -> cast brace .)
    MINUS_ASSIGN    reduce using rule 138 (factor -> cast brace .)
    MUL_ASSIGN      reduce using rule 138 (factor -> cast brace .)
    DIV_ASSIGN      reduce using rule 138 (factor -> cast brace .)
    AND_ASSIGN      reduce using rule 138 (factor -> cast brace .)
    OR_ASSIGN       reduce using rule 138 (factor -> cast brace .)
    XOR_ASSIGN      reduce using rule 138 (factor -> cast brace .)
    MOD_ASSIGN      reduce using rule 138 (factor -> cast brace .)
    L_SHIFT_ASSIGN  reduce using rule 138 (factor -> cast brace .)
    R_SHIFT_ASSIGN  reduce using rule 138 (factor -> cast brace .)
    R_PAREN         reduce using rule 138 (factor -> cast brace .)
    COMMA           reduce using rule 138 (factor -> cast brace .)
    R_SQBRACE       reduce using rule 138 (factor -> cast brace .)
    R_FLOWBRACE     reduce using rule 138 (factor -> cast brace .)
    PLUS_PLUS       shift and go to state 112
    MINUS_MINUS     shift and go to state 113


state 111

    (142) brace -> L_PAREN . expr R_PAREN
    (91) expr -> . expr assignment exprOR
    (92) expr -> . exprOR
    (104) exprOR -> . exprOR OR exprAND
    (105) exprOR -> . exprAND
    (106) exprAND -> . exprAND AND exprBITOR
    (107) exprAND -> . exprBITOR
    (108) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (109) exprBITOR -> . exprBITXOR
    (110) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (111) exprBITXOR -> . exprBITAND
    (112) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (113) exprBITAND -> . exprEQ
    (114) exprEQ -> . exprEQ EQ exprRELOP
    (115) exprEQ -> . exprEQ NE exprRELOP
    (116) exprEQ -> . exprRELOP
    (117) exprRELOP -> . exprRELOP relop exprSHIFT
    (118) exprRELOP -> . exprSHIFT
    (123) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (124) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (125) exprSHIFT -> . exprOP
    (126) exprOP -> . exprOP PLUS term
    (127) exprOP -> . exprOP MINUS term
    (128) exprOP -> . term
    (129) term -> . term MULTIPLY factor
    (130) term -> . term DIVIDE factor
    (131) term -> . term MOD factor
    (132) term -> . factor
    (133) factor -> . NOT factor
    (134) factor -> . PLUS factor
    (135) factor -> . MINUS factor
    (136) factor -> . PLUS_PLUS factor
    (137) factor -> . MINUS_MINUS factor
    (138) factor -> . cast brace
    (139) factor -> . brace
    (140) cast -> . L_PAREN TYPE R_PAREN
    (141) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (142) brace -> . L_PAREN expr R_PAREN
    (143) brace -> . brace PLUS_PLUS
    (144) brace -> . brace MINUS_MINUS
    (145) brace -> . NUM
    (146) brace -> . STRING
    (147) brace -> . MULTIPLY ID
    (148) brace -> . BIT_AND ID
    (149) brace -> . ID
    (150) brace -> . CHAR
    (151) brace -> . function_call
    (152) brace -> . ID narrayindex
    (153) NUM -> . INT_NUM
    (154) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    expr                           shift and go to state 85
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 112

    (143) brace -> brace PLUS_PLUS .

    PLUS_PLUS       reduce using rule 143 (brace -> brace PLUS_PLUS .)
    MINUS_MINUS     reduce using rule 143 (brace -> brace PLUS_PLUS .)
    MULTIPLY        reduce using rule 143 (brace -> brace PLUS_PLUS .)
    DIVIDE          reduce using rule 143 (brace -> brace PLUS_PLUS .)
    MOD             reduce using rule 143 (brace -> brace PLUS_PLUS .)
    PLUS            reduce using rule 143 (brace -> brace PLUS_PLUS .)
    MINUS           reduce using rule 143 (brace -> brace PLUS_PLUS .)
    L_SHIFT         reduce using rule 143 (brace -> brace PLUS_PLUS .)
    R_SHIFT         reduce using rule 143 (brace -> brace PLUS_PLUS .)
    LE              reduce using rule 143 (brace -> brace PLUS_PLUS .)
    LT              reduce using rule 143 (brace -> brace PLUS_PLUS .)
    GE              reduce using rule 143 (brace -> brace PLUS_PLUS .)
    GT              reduce using rule 143 (brace -> brace PLUS_PLUS .)
    EQ              reduce using rule 143 (brace -> brace PLUS_PLUS .)
    NE              reduce using rule 143 (brace -> brace PLUS_PLUS .)
    BIT_AND         reduce using rule 143 (brace -> brace PLUS_PLUS .)
    BIT_XOR         reduce using rule 143 (brace -> brace PLUS_PLUS .)
    BIT_OR          reduce using rule 143 (brace -> brace PLUS_PLUS .)
    AND             reduce using rule 143 (brace -> brace PLUS_PLUS .)
    OR              reduce using rule 143 (brace -> brace PLUS_PLUS .)
    SEMICOLON       reduce using rule 143 (brace -> brace PLUS_PLUS .)
    ASSIGN          reduce using rule 143 (brace -> brace PLUS_PLUS .)
    PLUS_ASSIGN     reduce using rule 143 (brace -> brace PLUS_PLUS .)
    MINUS_ASSIGN    reduce using rule 143 (brace -> brace PLUS_PLUS .)
    MUL_ASSIGN      reduce using rule 143 (brace -> brace PLUS_PLUS .)
    DIV_ASSIGN      reduce using rule 143 (brace -> brace PLUS_PLUS .)
    AND_ASSIGN      reduce using rule 143 (brace -> brace PLUS_PLUS .)
    OR_ASSIGN       reduce using rule 143 (brace -> brace PLUS_PLUS .)
    XOR_ASSIGN      reduce using rule 143 (brace -> brace PLUS_PLUS .)
    MOD_ASSIGN      reduce using rule 143 (brace -> brace PLUS_PLUS .)
    L_SHIFT_ASSIGN  reduce using rule 143 (brace -> brace PLUS_PLUS .)
    R_SHIFT_ASSIGN  reduce using rule 143 (brace -> brace PLUS_PLUS .)
    R_PAREN         reduce using rule 143 (brace -> brace PLUS_PLUS .)
    COMMA           reduce using rule 143 (brace -> brace PLUS_PLUS .)
    R_SQBRACE       reduce using rule 143 (brace -> brace PLUS_PLUS .)
    R_FLOWBRACE     reduce using rule 143 (brace -> brace PLUS_PLUS .)


state 113

    (144) brace -> brace MINUS_MINUS .

    PLUS_PLUS       reduce using rule 144 (brace -> brace MINUS_MINUS .)
    MINUS_MINUS     reduce using rule 144 (brace -> brace MINUS_MINUS .)
    MULTIPLY        reduce using rule 144 (brace -> brace MINUS_MINUS .)
    DIVIDE          reduce using rule 144 (brace -> brace MINUS_MINUS .)
    MOD             reduce using rule 144 (brace -> brace MINUS_MINUS .)
    PLUS            reduce using rule 144 (brace -> brace MINUS_MINUS .)
    MINUS           reduce using rule 144 (brace -> brace MINUS_MINUS .)
    L_SHIFT         reduce using rule 144 (brace -> brace MINUS_MINUS .)
    R_SHIFT         reduce using rule 144 (brace -> brace MINUS_MINUS .)
    LE              reduce using rule 144 (brace -> brace MINUS_MINUS .)
    LT              reduce using rule 144 (brace -> brace MINUS_MINUS .)
    GE              reduce using rule 144 (brace -> brace MINUS_MINUS .)
    GT              reduce using rule 144 (brace -> brace MINUS_MINUS .)
    EQ              reduce using rule 144 (brace -> brace MINUS_MINUS .)
    NE              reduce using rule 144 (brace -> brace MINUS_MINUS .)
    BIT_AND         reduce using rule 144 (brace -> brace MINUS_MINUS .)
    BIT_XOR         reduce using rule 144 (brace -> brace MINUS_MINUS .)
    BIT_OR          reduce using rule 144 (brace -> brace MINUS_MINUS .)
    AND             reduce using rule 144 (brace -> brace MINUS_MINUS .)
    OR              reduce using rule 144 (brace -> brace MINUS_MINUS .)
    SEMICOLON       reduce using rule 144 (brace -> brace MINUS_MINUS .)
    ASSIGN          reduce using rule 144 (brace -> brace MINUS_MINUS .)
    PLUS_ASSIGN     reduce using rule 144 (brace -> brace MINUS_MINUS .)
    MINUS_ASSIGN    reduce using rule 144 (brace -> brace MINUS_MINUS .)
    MUL_ASSIGN      reduce using rule 144 (brace -> brace MINUS_MINUS .)
    DIV_ASSIGN      reduce using rule 144 (brace -> brace MINUS_MINUS .)
    AND_ASSIGN      reduce using rule 144 (brace -> brace MINUS_MINUS .)
    OR_ASSIGN       reduce using rule 144 (brace -> brace MINUS_MINUS .)
    XOR_ASSIGN      reduce using rule 144 (brace -> brace MINUS_MINUS .)
    MOD_ASSIGN      reduce using rule 144 (brace -> brace MINUS_MINUS .)
    L_SHIFT_ASSIGN  reduce using rule 144 (brace -> brace MINUS_MINUS .)
    R_SHIFT_ASSIGN  reduce using rule 144 (brace -> brace MINUS_MINUS .)
    R_PAREN         reduce using rule 144 (brace -> brace MINUS_MINUS .)
    COMMA           reduce using rule 144 (brace -> brace MINUS_MINUS .)
    R_SQBRACE       reduce using rule 144 (brace -> brace MINUS_MINUS .)
    R_FLOWBRACE     reduce using rule 144 (brace -> brace MINUS_MINUS .)


state 114

    (13) closed -> IF . condition closed ELSE closed
    (6) open -> IF . condition statement
    (7) open -> IF . condition closed ELSE open
    (16) condition -> . L_PAREN expr R_PAREN

    L_PAREN         shift and go to state 52

    condition                      shift and go to state 166

state 115

    (6) open -> IF condition statement .

    IF              reduce using rule 6 (open -> IF condition statement .)
    WHILE           reduce using rule 6 (open -> IF condition statement .)
    FOR             reduce using rule 6 (open -> IF condition statement .)
    SEMICOLON       reduce using rule 6 (open -> IF condition statement .)
    RETURN          reduce using rule 6 (open -> IF condition statement .)
    HASH            reduce using rule 6 (open -> IF condition statement .)
    TYPE            reduce using rule 6 (open -> IF condition statement .)
    L_FLOWBRACE     reduce using rule 6 (open -> IF condition statement .)
    NOT             reduce using rule 6 (open -> IF condition statement .)
    PLUS            reduce using rule 6 (open -> IF condition statement .)
    MINUS           reduce using rule 6 (open -> IF condition statement .)
    PLUS_PLUS       reduce using rule 6 (open -> IF condition statement .)
    MINUS_MINUS     reduce using rule 6 (open -> IF condition statement .)
    L_PAREN         reduce using rule 6 (open -> IF condition statement .)
    STRING          reduce using rule 6 (open -> IF condition statement .)
    MULTIPLY        reduce using rule 6 (open -> IF condition statement .)
    BIT_AND         reduce using rule 6 (open -> IF condition statement .)
    ID              reduce using rule 6 (open -> IF condition statement .)
    CHAR            reduce using rule 6 (open -> IF condition statement .)
    INT_NUM         reduce using rule 6 (open -> IF condition statement .)
    FLOAT_NUM       reduce using rule 6 (open -> IF condition statement .)
    $end            reduce using rule 6 (open -> IF condition statement .)
    R_FLOWBRACE     reduce using rule 6 (open -> IF condition statement .)


state 116

    (7) open -> IF condition closed . ELSE open
    (13) closed -> IF condition closed . ELSE closed
    (5) statement -> closed .

    ELSE            shift and go to state 167
    IF              reduce using rule 5 (statement -> closed .)
    WHILE           reduce using rule 5 (statement -> closed .)
    FOR             reduce using rule 5 (statement -> closed .)
    SEMICOLON       reduce using rule 5 (statement -> closed .)
    RETURN          reduce using rule 5 (statement -> closed .)
    HASH            reduce using rule 5 (statement -> closed .)
    TYPE            reduce using rule 5 (statement -> closed .)
    L_FLOWBRACE     reduce using rule 5 (statement -> closed .)
    NOT             reduce using rule 5 (statement -> closed .)
    PLUS            reduce using rule 5 (statement -> closed .)
    MINUS           reduce using rule 5 (statement -> closed .)
    PLUS_PLUS       reduce using rule 5 (statement -> closed .)
    MINUS_MINUS     reduce using rule 5 (statement -> closed .)
    L_PAREN         reduce using rule 5 (statement -> closed .)
    STRING          reduce using rule 5 (statement -> closed .)
    MULTIPLY        reduce using rule 5 (statement -> closed .)
    BIT_AND         reduce using rule 5 (statement -> closed .)
    ID              reduce using rule 5 (statement -> closed .)
    CHAR            reduce using rule 5 (statement -> closed .)
    INT_NUM         reduce using rule 5 (statement -> closed .)
    FLOAT_NUM       reduce using rule 5 (statement -> closed .)
    $end            reduce using rule 5 (statement -> closed .)
    R_FLOWBRACE     reduce using rule 5 (statement -> closed .)


state 117

    (14) closed -> WHILE . condition closed
    (8) open -> WHILE . condition open
    (16) condition -> . L_PAREN expr R_PAREN

    L_PAREN         shift and go to state 52

    condition                      shift and go to state 168

state 118

    (15) closed -> for . for_condition closed
    (9) open -> for . for_condition open
    (17) for_condition -> . L_PAREN simple simple expr R_PAREN
    (18) for_condition -> . L_PAREN simple simple R_PAREN

    L_PAREN         shift and go to state 55

    for_condition                  shift and go to state 169

state 119

    (16) condition -> L_PAREN expr . R_PAREN
    (91) expr -> expr . assignment exprOR
    (93) assignment -> . ASSIGN
    (94) assignment -> . PLUS_ASSIGN
    (95) assignment -> . MINUS_ASSIGN
    (96) assignment -> . MUL_ASSIGN
    (97) assignment -> . DIV_ASSIGN
    (98) assignment -> . AND_ASSIGN
    (99) assignment -> . OR_ASSIGN
    (100) assignment -> . XOR_ASSIGN
    (101) assignment -> . MOD_ASSIGN
    (102) assignment -> . L_SHIFT_ASSIGN
    (103) assignment -> . R_SHIFT_ASSIGN

    R_PAREN         shift and go to state 170
    ASSIGN          shift and go to state 58
    PLUS_ASSIGN     shift and go to state 59
    MINUS_ASSIGN    shift and go to state 60
    MUL_ASSIGN      shift and go to state 61
    DIV_ASSIGN      shift and go to state 62
    AND_ASSIGN      shift and go to state 63
    OR_ASSIGN       shift and go to state 64
    XOR_ASSIGN      shift and go to state 65
    MOD_ASSIGN      shift and go to state 66
    L_SHIFT_ASSIGN  shift and go to state 67
    R_SHIFT_ASSIGN  shift and go to state 68

    assignment                     shift and go to state 57

state 120

    (8) open -> WHILE condition open .

    IF              reduce using rule 8 (open -> WHILE condition open .)
    WHILE           reduce using rule 8 (open -> WHILE condition open .)
    FOR             reduce using rule 8 (open -> WHILE condition open .)
    SEMICOLON       reduce using rule 8 (open -> WHILE condition open .)
    RETURN          reduce using rule 8 (open -> WHILE condition open .)
    HASH            reduce using rule 8 (open -> WHILE condition open .)
    TYPE            reduce using rule 8 (open -> WHILE condition open .)
    L_FLOWBRACE     reduce using rule 8 (open -> WHILE condition open .)
    NOT             reduce using rule 8 (open -> WHILE condition open .)
    PLUS            reduce using rule 8 (open -> WHILE condition open .)
    MINUS           reduce using rule 8 (open -> WHILE condition open .)
    PLUS_PLUS       reduce using rule 8 (open -> WHILE condition open .)
    MINUS_MINUS     reduce using rule 8 (open -> WHILE condition open .)
    L_PAREN         reduce using rule 8 (open -> WHILE condition open .)
    STRING          reduce using rule 8 (open -> WHILE condition open .)
    MULTIPLY        reduce using rule 8 (open -> WHILE condition open .)
    BIT_AND         reduce using rule 8 (open -> WHILE condition open .)
    ID              reduce using rule 8 (open -> WHILE condition open .)
    CHAR            reduce using rule 8 (open -> WHILE condition open .)
    INT_NUM         reduce using rule 8 (open -> WHILE condition open .)
    FLOAT_NUM       reduce using rule 8 (open -> WHILE condition open .)
    $end            reduce using rule 8 (open -> WHILE condition open .)
    R_FLOWBRACE     reduce using rule 8 (open -> WHILE condition open .)


state 121

    (14) closed -> WHILE condition closed .

    IF              reduce using rule 14 (closed -> WHILE condition closed .)
    WHILE           reduce using rule 14 (closed -> WHILE condition closed .)
    FOR             reduce using rule 14 (closed -> WHILE condition closed .)
    SEMICOLON       reduce using rule 14 (closed -> WHILE condition closed .)
    RETURN          reduce using rule 14 (closed -> WHILE condition closed .)
    HASH            reduce using rule 14 (closed -> WHILE condition closed .)
    TYPE            reduce using rule 14 (closed -> WHILE condition closed .)
    L_FLOWBRACE     reduce using rule 14 (closed -> WHILE condition closed .)
    NOT             reduce using rule 14 (closed -> WHILE condition closed .)
    PLUS            reduce using rule 14 (closed -> WHILE condition closed .)
    MINUS           reduce using rule 14 (closed -> WHILE condition closed .)
    PLUS_PLUS       reduce using rule 14 (closed -> WHILE condition closed .)
    MINUS_MINUS     reduce using rule 14 (closed -> WHILE condition closed .)
    L_PAREN         reduce using rule 14 (closed -> WHILE condition closed .)
    STRING          reduce using rule 14 (closed -> WHILE condition closed .)
    MULTIPLY        reduce using rule 14 (closed -> WHILE condition closed .)
    BIT_AND         reduce using rule 14 (closed -> WHILE condition closed .)
    ID              reduce using rule 14 (closed -> WHILE condition closed .)
    CHAR            reduce using rule 14 (closed -> WHILE condition closed .)
    INT_NUM         reduce using rule 14 (closed -> WHILE condition closed .)
    FLOAT_NUM       reduce using rule 14 (closed -> WHILE condition closed .)
    $end            reduce using rule 14 (closed -> WHILE condition closed .)
    R_FLOWBRACE     reduce using rule 14 (closed -> WHILE condition closed .)
    ELSE            reduce using rule 14 (closed -> WHILE condition closed .)


state 122

    (9) open -> for for_condition open .

    IF              reduce using rule 9 (open -> for for_condition open .)
    WHILE           reduce using rule 9 (open -> for for_condition open .)
    FOR             reduce using rule 9 (open -> for for_condition open .)
    SEMICOLON       reduce using rule 9 (open -> for for_condition open .)
    RETURN          reduce using rule 9 (open -> for for_condition open .)
    HASH            reduce using rule 9 (open -> for for_condition open .)
    TYPE            reduce using rule 9 (open -> for for_condition open .)
    L_FLOWBRACE     reduce using rule 9 (open -> for for_condition open .)
    NOT             reduce using rule 9 (open -> for for_condition open .)
    PLUS            reduce using rule 9 (open -> for for_condition open .)
    MINUS           reduce using rule 9 (open -> for for_condition open .)
    PLUS_PLUS       reduce using rule 9 (open -> for for_condition open .)
    MINUS_MINUS     reduce using rule 9 (open -> for for_condition open .)
    L_PAREN         reduce using rule 9 (open -> for for_condition open .)
    STRING          reduce using rule 9 (open -> for for_condition open .)
    MULTIPLY        reduce using rule 9 (open -> for for_condition open .)
    BIT_AND         reduce using rule 9 (open -> for for_condition open .)
    ID              reduce using rule 9 (open -> for for_condition open .)
    CHAR            reduce using rule 9 (open -> for for_condition open .)
    INT_NUM         reduce using rule 9 (open -> for for_condition open .)
    FLOAT_NUM       reduce using rule 9 (open -> for for_condition open .)
    $end            reduce using rule 9 (open -> for for_condition open .)
    R_FLOWBRACE     reduce using rule 9 (open -> for for_condition open .)


state 123

    (15) closed -> for for_condition closed .

    IF              reduce using rule 15 (closed -> for for_condition closed .)
    WHILE           reduce using rule 15 (closed -> for for_condition closed .)
    FOR             reduce using rule 15 (closed -> for for_condition closed .)
    SEMICOLON       reduce using rule 15 (closed -> for for_condition closed .)
    RETURN          reduce using rule 15 (closed -> for for_condition closed .)
    HASH            reduce using rule 15 (closed -> for for_condition closed .)
    TYPE            reduce using rule 15 (closed -> for for_condition closed .)
    L_FLOWBRACE     reduce using rule 15 (closed -> for for_condition closed .)
    NOT             reduce using rule 15 (closed -> for for_condition closed .)
    PLUS            reduce using rule 15 (closed -> for for_condition closed .)
    MINUS           reduce using rule 15 (closed -> for for_condition closed .)
    PLUS_PLUS       reduce using rule 15 (closed -> for for_condition closed .)
    MINUS_MINUS     reduce using rule 15 (closed -> for for_condition closed .)
    L_PAREN         reduce using rule 15 (closed -> for for_condition closed .)
    STRING          reduce using rule 15 (closed -> for for_condition closed .)
    MULTIPLY        reduce using rule 15 (closed -> for for_condition closed .)
    BIT_AND         reduce using rule 15 (closed -> for for_condition closed .)
    ID              reduce using rule 15 (closed -> for for_condition closed .)
    CHAR            reduce using rule 15 (closed -> for for_condition closed .)
    INT_NUM         reduce using rule 15 (closed -> for for_condition closed .)
    FLOAT_NUM       reduce using rule 15 (closed -> for for_condition closed .)
    $end            reduce using rule 15 (closed -> for for_condition closed .)
    R_FLOWBRACE     reduce using rule 15 (closed -> for for_condition closed .)
    ELSE            reduce using rule 15 (closed -> for for_condition closed .)


state 124

    (17) for_condition -> L_PAREN simple . simple expr R_PAREN
    (18) for_condition -> L_PAREN simple . simple R_PAREN
    (53) simple -> . expr SEMICOLON
    (54) simple -> . header
    (55) simple -> . declaration
    (56) simple -> . SEMICOLON
    (57) simple -> . function
    (58) simple -> . RETURN expr SEMICOLON
    (59) simple -> . RETURN SEMICOLON
    (91) expr -> . expr assignment exprOR
    (92) expr -> . exprOR
    (60) header -> . HASH INCLUDE STRING
    (61) header -> . HASH INCLUDE HEADER_FILE
    (34) declaration -> . TYPE ID SEMICOLON
    (35) declaration -> . TYPE MULTIPLY ID SEMICOLON
    (36) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (37) declaration -> . TYPE MULTIPLY ID ASSIGN expr SEMICOLON
    (38) declaration -> . TYPE multi_declaration stop
    (39) declaration -> . TYPE ID narrayindex SEMICOLON
    (40) declaration -> . TYPE ID narrayindex ASSIGN init_list SEMICOLON
    (88) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (104) exprOR -> . exprOR OR exprAND
    (105) exprOR -> . exprAND
    (106) exprAND -> . exprAND AND exprBITOR
    (107) exprAND -> . exprBITOR
    (108) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (109) exprBITOR -> . exprBITXOR
    (110) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (111) exprBITXOR -> . exprBITAND
    (112) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (113) exprBITAND -> . exprEQ
    (114) exprEQ -> . exprEQ EQ exprRELOP
    (115) exprEQ -> . exprEQ NE exprRELOP
    (116) exprEQ -> . exprRELOP
    (117) exprRELOP -> . exprRELOP relop exprSHIFT
    (118) exprRELOP -> . exprSHIFT
    (123) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (124) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (125) exprSHIFT -> . exprOP
    (126) exprOP -> . exprOP PLUS term
    (127) exprOP -> . exprOP MINUS term
    (128) exprOP -> . term
    (129) term -> . term MULTIPLY factor
    (130) term -> . term DIVIDE factor
    (131) term -> . term MOD factor
    (132) term -> . factor
    (133) factor -> . NOT factor
    (134) factor -> . PLUS factor
    (135) factor -> . MINUS factor
    (136) factor -> . PLUS_PLUS factor
    (137) factor -> . MINUS_MINUS factor
    (138) factor -> . cast brace
    (139) factor -> . brace
    (140) cast -> . L_PAREN TYPE R_PAREN
    (141) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (142) brace -> . L_PAREN expr R_PAREN
    (143) brace -> . brace PLUS_PLUS
    (144) brace -> . brace MINUS_MINUS
    (145) brace -> . NUM
    (146) brace -> . STRING
    (147) brace -> . MULTIPLY ID
    (148) brace -> . BIT_AND ID
    (149) brace -> . ID
    (150) brace -> . CHAR
    (151) brace -> . function_call
    (152) brace -> . ID narrayindex
    (153) NUM -> . INT_NUM
    (154) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    SEMICOLON       shift and go to state 13
    RETURN          shift and go to state 17
    HASH            shift and go to state 20
    TYPE            shift and go to state 22
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    simple                         shift and go to state 171
    expr                           shift and go to state 12
    header                         shift and go to state 14
    declaration                    shift and go to state 15
    function                       shift and go to state 16
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 125

    (91) expr -> expr assignment exprOR .
    (104) exprOR -> exprOR . OR exprAND

    SEMICOLON       reduce using rule 91 (expr -> expr assignment exprOR .)
    ASSIGN          reduce using rule 91 (expr -> expr assignment exprOR .)
    PLUS_ASSIGN     reduce using rule 91 (expr -> expr assignment exprOR .)
    MINUS_ASSIGN    reduce using rule 91 (expr -> expr assignment exprOR .)
    MUL_ASSIGN      reduce using rule 91 (expr -> expr assignment exprOR .)
    DIV_ASSIGN      reduce using rule 91 (expr -> expr assignment exprOR .)
    AND_ASSIGN      reduce using rule 91 (expr -> expr assignment exprOR .)
    OR_ASSIGN       reduce using rule 91 (expr -> expr assignment exprOR .)
    XOR_ASSIGN      reduce using rule 91 (expr -> expr assignment exprOR .)
    MOD_ASSIGN      reduce using rule 91 (expr -> expr assignment exprOR .)
    L_SHIFT_ASSIGN  reduce using rule 91 (expr -> expr assignment exprOR .)
    R_SHIFT_ASSIGN  reduce using rule 91 (expr -> expr assignment exprOR .)
    R_PAREN         reduce using rule 91 (expr -> expr assignment exprOR .)
    COMMA           reduce using rule 91 (expr -> expr assignment exprOR .)
    R_SQBRACE       reduce using rule 91 (expr -> expr assignment exprOR .)
    R_FLOWBRACE     reduce using rule 91 (expr -> expr assignment exprOR .)
    OR              shift and go to state 74


state 126

    (58) simple -> RETURN expr SEMICOLON .

    IF              reduce using rule 58 (simple -> RETURN expr SEMICOLON .)
    WHILE           reduce using rule 58 (simple -> RETURN expr SEMICOLON .)
    FOR             reduce using rule 58 (simple -> RETURN expr SEMICOLON .)
    SEMICOLON       reduce using rule 58 (simple -> RETURN expr SEMICOLON .)
    RETURN          reduce using rule 58 (simple -> RETURN expr SEMICOLON .)
    HASH            reduce using rule 58 (simple -> RETURN expr SEMICOLON .)
    TYPE            reduce using rule 58 (simple -> RETURN expr SEMICOLON .)
    L_FLOWBRACE     reduce using rule 58 (simple -> RETURN expr SEMICOLON .)
    NOT             reduce using rule 58 (simple -> RETURN expr SEMICOLON .)
    PLUS            reduce using rule 58 (simple -> RETURN expr SEMICOLON .)
    MINUS           reduce using rule 58 (simple -> RETURN expr SEMICOLON .)
    PLUS_PLUS       reduce using rule 58 (simple -> RETURN expr SEMICOLON .)
    MINUS_MINUS     reduce using rule 58 (simple -> RETURN expr SEMICOLON .)
    L_PAREN         reduce using rule 58 (simple -> RETURN expr SEMICOLON .)
    STRING          reduce using rule 58 (simple -> RETURN expr SEMICOLON .)
    MULTIPLY        reduce using rule 58 (simple -> RETURN expr SEMICOLON .)
    BIT_AND         reduce using rule 58 (simple -> RETURN expr SEMICOLON .)
    ID              reduce using rule 58 (simple -> RETURN expr SEMICOLON .)
    CHAR            reduce using rule 58 (simple -> RETURN expr SEMICOLON .)
    INT_NUM         reduce using rule 58 (simple -> RETURN expr SEMICOLON .)
    FLOAT_NUM       reduce using rule 58 (simple -> RETURN expr SEMICOLON .)
    $end            reduce using rule 58 (simple -> RETURN expr SEMICOLON .)
    R_FLOWBRACE     reduce using rule 58 (simple -> RETURN expr SEMICOLON .)
    ELSE            reduce using rule 58 (simple -> RETURN expr SEMICOLON .)
    R_PAREN         reduce using rule 58 (simple -> RETURN expr SEMICOLON .)


state 127

    (49) block -> left_flower multiple_statements right_flower .

    IF              reduce using rule 49 (block -> left_flower multiple_statements right_flower .)
    WHILE           reduce using rule 49 (block -> left_flower multiple_statements right_flower .)
    FOR             reduce using rule 49 (block -> left_flower multiple_statements right_flower .)
    SEMICOLON       reduce using rule 49 (block -> left_flower multiple_statements right_flower .)
    RETURN          reduce using rule 49 (block -> left_flower multiple_statements right_flower .)
    HASH            reduce using rule 49 (block -> left_flower multiple_statements right_flower .)
    TYPE            reduce using rule 49 (block -> left_flower multiple_statements right_flower .)
    L_FLOWBRACE     reduce using rule 49 (block -> left_flower multiple_statements right_flower .)
    NOT             reduce using rule 49 (block -> left_flower multiple_statements right_flower .)
    PLUS            reduce using rule 49 (block -> left_flower multiple_statements right_flower .)
    MINUS           reduce using rule 49 (block -> left_flower multiple_statements right_flower .)
    PLUS_PLUS       reduce using rule 49 (block -> left_flower multiple_statements right_flower .)
    MINUS_MINUS     reduce using rule 49 (block -> left_flower multiple_statements right_flower .)
    L_PAREN         reduce using rule 49 (block -> left_flower multiple_statements right_flower .)
    STRING          reduce using rule 49 (block -> left_flower multiple_statements right_flower .)
    MULTIPLY        reduce using rule 49 (block -> left_flower multiple_statements right_flower .)
    BIT_AND         reduce using rule 49 (block -> left_flower multiple_statements right_flower .)
    ID              reduce using rule 49 (block -> left_flower multiple_statements right_flower .)
    CHAR            reduce using rule 49 (block -> left_flower multiple_statements right_flower .)
    INT_NUM         reduce using rule 49 (block -> left_flower multiple_statements right_flower .)
    FLOAT_NUM       reduce using rule 49 (block -> left_flower multiple_statements right_flower .)
    $end            reduce using rule 49 (block -> left_flower multiple_statements right_flower .)
    R_FLOWBRACE     reduce using rule 49 (block -> left_flower multiple_statements right_flower .)
    ELSE            reduce using rule 49 (block -> left_flower multiple_statements right_flower .)
    R_PAREN         reduce using rule 49 (block -> left_flower multiple_statements right_flower .)


state 128

    (104) exprOR -> exprOR OR exprAND .
    (106) exprAND -> exprAND . AND exprBITOR

    OR              reduce using rule 104 (exprOR -> exprOR OR exprAND .)
    SEMICOLON       reduce using rule 104 (exprOR -> exprOR OR exprAND .)
    ASSIGN          reduce using rule 104 (exprOR -> exprOR OR exprAND .)
    PLUS_ASSIGN     reduce using rule 104 (exprOR -> exprOR OR exprAND .)
    MINUS_ASSIGN    reduce using rule 104 (exprOR -> exprOR OR exprAND .)
    MUL_ASSIGN      reduce using rule 104 (exprOR -> exprOR OR exprAND .)
    DIV_ASSIGN      reduce using rule 104 (exprOR -> exprOR OR exprAND .)
    AND_ASSIGN      reduce using rule 104 (exprOR -> exprOR OR exprAND .)
    OR_ASSIGN       reduce using rule 104 (exprOR -> exprOR OR exprAND .)
    XOR_ASSIGN      reduce using rule 104 (exprOR -> exprOR OR exprAND .)
    MOD_ASSIGN      reduce using rule 104 (exprOR -> exprOR OR exprAND .)
    L_SHIFT_ASSIGN  reduce using rule 104 (exprOR -> exprOR OR exprAND .)
    R_SHIFT_ASSIGN  reduce using rule 104 (exprOR -> exprOR OR exprAND .)
    R_PAREN         reduce using rule 104 (exprOR -> exprOR OR exprAND .)
    COMMA           reduce using rule 104 (exprOR -> exprOR OR exprAND .)
    R_SQBRACE       reduce using rule 104 (exprOR -> exprOR OR exprAND .)
    R_FLOWBRACE     reduce using rule 104 (exprOR -> exprOR OR exprAND .)
    AND             shift and go to state 86


state 129

    (60) header -> HASH INCLUDE STRING .

    IF              reduce using rule 60 (header -> HASH INCLUDE STRING .)
    WHILE           reduce using rule 60 (header -> HASH INCLUDE STRING .)
    FOR             reduce using rule 60 (header -> HASH INCLUDE STRING .)
    SEMICOLON       reduce using rule 60 (header -> HASH INCLUDE STRING .)
    RETURN          reduce using rule 60 (header -> HASH INCLUDE STRING .)
    HASH            reduce using rule 60 (header -> HASH INCLUDE STRING .)
    TYPE            reduce using rule 60 (header -> HASH INCLUDE STRING .)
    L_FLOWBRACE     reduce using rule 60 (header -> HASH INCLUDE STRING .)
    NOT             reduce using rule 60 (header -> HASH INCLUDE STRING .)
    PLUS            reduce using rule 60 (header -> HASH INCLUDE STRING .)
    MINUS           reduce using rule 60 (header -> HASH INCLUDE STRING .)
    PLUS_PLUS       reduce using rule 60 (header -> HASH INCLUDE STRING .)
    MINUS_MINUS     reduce using rule 60 (header -> HASH INCLUDE STRING .)
    L_PAREN         reduce using rule 60 (header -> HASH INCLUDE STRING .)
    STRING          reduce using rule 60 (header -> HASH INCLUDE STRING .)
    MULTIPLY        reduce using rule 60 (header -> HASH INCLUDE STRING .)
    BIT_AND         reduce using rule 60 (header -> HASH INCLUDE STRING .)
    ID              reduce using rule 60 (header -> HASH INCLUDE STRING .)
    CHAR            reduce using rule 60 (header -> HASH INCLUDE STRING .)
    INT_NUM         reduce using rule 60 (header -> HASH INCLUDE STRING .)
    FLOAT_NUM       reduce using rule 60 (header -> HASH INCLUDE STRING .)
    $end            reduce using rule 60 (header -> HASH INCLUDE STRING .)
    R_FLOWBRACE     reduce using rule 60 (header -> HASH INCLUDE STRING .)
    ELSE            reduce using rule 60 (header -> HASH INCLUDE STRING .)
    R_PAREN         reduce using rule 60 (header -> HASH INCLUDE STRING .)


state 130

    (61) header -> HASH INCLUDE HEADER_FILE .

    IF              reduce using rule 61 (header -> HASH INCLUDE HEADER_FILE .)
    WHILE           reduce using rule 61 (header -> HASH INCLUDE HEADER_FILE .)
    FOR             reduce using rule 61 (header -> HASH INCLUDE HEADER_FILE .)
    SEMICOLON       reduce using rule 61 (header -> HASH INCLUDE HEADER_FILE .)
    RETURN          reduce using rule 61 (header -> HASH INCLUDE HEADER_FILE .)
    HASH            reduce using rule 61 (header -> HASH INCLUDE HEADER_FILE .)
    TYPE            reduce using rule 61 (header -> HASH INCLUDE HEADER_FILE .)
    L_FLOWBRACE     reduce using rule 61 (header -> HASH INCLUDE HEADER_FILE .)
    NOT             reduce using rule 61 (header -> HASH INCLUDE HEADER_FILE .)
    PLUS            reduce using rule 61 (header -> HASH INCLUDE HEADER_FILE .)
    MINUS           reduce using rule 61 (header -> HASH INCLUDE HEADER_FILE .)
    PLUS_PLUS       reduce using rule 61 (header -> HASH INCLUDE HEADER_FILE .)
    MINUS_MINUS     reduce using rule 61 (header -> HASH INCLUDE HEADER_FILE .)
    L_PAREN         reduce using rule 61 (header -> HASH INCLUDE HEADER_FILE .)
    STRING          reduce using rule 61 (header -> HASH INCLUDE HEADER_FILE .)
    MULTIPLY        reduce using rule 61 (header -> HASH INCLUDE HEADER_FILE .)
    BIT_AND         reduce using rule 61 (header -> HASH INCLUDE HEADER_FILE .)
    ID              reduce using rule 61 (header -> HASH INCLUDE HEADER_FILE .)
    CHAR            reduce using rule 61 (header -> HASH INCLUDE HEADER_FILE .)
    INT_NUM         reduce using rule 61 (header -> HASH INCLUDE HEADER_FILE .)
    FLOAT_NUM       reduce using rule 61 (header -> HASH INCLUDE HEADER_FILE .)
    $end            reduce using rule 61 (header -> HASH INCLUDE HEADER_FILE .)
    R_FLOWBRACE     reduce using rule 61 (header -> HASH INCLUDE HEADER_FILE .)
    ELSE            reduce using rule 61 (header -> HASH INCLUDE HEADER_FILE .)
    R_PAREN         reduce using rule 61 (header -> HASH INCLUDE HEADER_FILE .)


state 131

    (34) declaration -> TYPE ID SEMICOLON .

    IF              reduce using rule 34 (declaration -> TYPE ID SEMICOLON .)
    WHILE           reduce using rule 34 (declaration -> TYPE ID SEMICOLON .)
    FOR             reduce using rule 34 (declaration -> TYPE ID SEMICOLON .)
    SEMICOLON       reduce using rule 34 (declaration -> TYPE ID SEMICOLON .)
    RETURN          reduce using rule 34 (declaration -> TYPE ID SEMICOLON .)
    HASH            reduce using rule 34 (declaration -> TYPE ID SEMICOLON .)
    TYPE            reduce using rule 34 (declaration -> TYPE ID SEMICOLON .)
    L_FLOWBRACE     reduce using rule 34 (declaration -> TYPE ID SEMICOLON .)
    NOT             reduce using rule 34 (declaration -> TYPE ID SEMICOLON .)
    PLUS            reduce using rule 34 (declaration -> TYPE ID SEMICOLON .)
    MINUS           reduce using rule 34 (declaration -> TYPE ID SEMICOLON .)
    PLUS_PLUS       reduce using rule 34 (declaration -> TYPE ID SEMICOLON .)
    MINUS_MINUS     reduce using rule 34 (declaration -> TYPE ID SEMICOLON .)
    L_PAREN         reduce using rule 34 (declaration -> TYPE ID SEMICOLON .)
    STRING          reduce using rule 34 (declaration -> TYPE ID SEMICOLON .)
    MULTIPLY        reduce using rule 34 (declaration -> TYPE ID SEMICOLON .)
    BIT_AND         reduce using rule 34 (declaration -> TYPE ID SEMICOLON .)
    ID              reduce using rule 34 (declaration -> TYPE ID SEMICOLON .)
    CHAR            reduce using rule 34 (declaration -> TYPE ID SEMICOLON .)
    INT_NUM         reduce using rule 34 (declaration -> TYPE ID SEMICOLON .)
    FLOAT_NUM       reduce using rule 34 (declaration -> TYPE ID SEMICOLON .)
    $end            reduce using rule 34 (declaration -> TYPE ID SEMICOLON .)
    R_FLOWBRACE     reduce using rule 34 (declaration -> TYPE ID SEMICOLON .)
    ELSE            reduce using rule 34 (declaration -> TYPE ID SEMICOLON .)
    R_PAREN         reduce using rule 34 (declaration -> TYPE ID SEMICOLON .)


state 132

    (36) declaration -> TYPE ID ASSIGN . expr SEMICOLON
    (24) multi_declaration -> ID ASSIGN . expr COMMA
    (91) expr -> . expr assignment exprOR
    (92) expr -> . exprOR
    (104) exprOR -> . exprOR OR exprAND
    (105) exprOR -> . exprAND
    (106) exprAND -> . exprAND AND exprBITOR
    (107) exprAND -> . exprBITOR
    (108) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (109) exprBITOR -> . exprBITXOR
    (110) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (111) exprBITXOR -> . exprBITAND
    (112) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (113) exprBITAND -> . exprEQ
    (114) exprEQ -> . exprEQ EQ exprRELOP
    (115) exprEQ -> . exprEQ NE exprRELOP
    (116) exprEQ -> . exprRELOP
    (117) exprRELOP -> . exprRELOP relop exprSHIFT
    (118) exprRELOP -> . exprSHIFT
    (123) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (124) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (125) exprSHIFT -> . exprOP
    (126) exprOP -> . exprOP PLUS term
    (127) exprOP -> . exprOP MINUS term
    (128) exprOP -> . term
    (129) term -> . term MULTIPLY factor
    (130) term -> . term DIVIDE factor
    (131) term -> . term MOD factor
    (132) term -> . factor
    (133) factor -> . NOT factor
    (134) factor -> . PLUS factor
    (135) factor -> . MINUS factor
    (136) factor -> . PLUS_PLUS factor
    (137) factor -> . MINUS_MINUS factor
    (138) factor -> . cast brace
    (139) factor -> . brace
    (140) cast -> . L_PAREN TYPE R_PAREN
    (141) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (142) brace -> . L_PAREN expr R_PAREN
    (143) brace -> . brace PLUS_PLUS
    (144) brace -> . brace MINUS_MINUS
    (145) brace -> . NUM
    (146) brace -> . STRING
    (147) brace -> . MULTIPLY ID
    (148) brace -> . BIT_AND ID
    (149) brace -> . ID
    (150) brace -> . CHAR
    (151) brace -> . function_call
    (152) brace -> . ID narrayindex
    (153) NUM -> . INT_NUM
    (154) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    expr                           shift and go to state 172
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 133

    (39) declaration -> TYPE ID narrayindex . SEMICOLON
    (40) declaration -> TYPE ID narrayindex . ASSIGN init_list SEMICOLON
    (32) narrayindex -> narrayindex . arrayindex
    (31) arrayindex -> . L_SQBRACE index R_SQBRACE

    SEMICOLON       shift and go to state 173
    ASSIGN          shift and go to state 174
    L_SQBRACE       shift and go to state 82

    arrayindex                     shift and go to state 140

state 134

    (88) function -> TYPE ID L_PAREN . dec_params R_PAREN function_2
    (85) dec_params -> . empty
    (86) dec_params -> . yes_dec_params end_dec_params
    (87) dec_params -> . end_dec_params
    (62) empty -> .
    (70) yes_dec_params -> . yes_dec_params TYPE ID COMMA
    (71) yes_dec_params -> . yes_dec_params TYPE MULTIPLY ID COMMA
    (72) yes_dec_params -> . yes_dec_params TYPE COMMA
    (73) yes_dec_params -> . yes_dec_params TYPE MULTIPLY COMMA
    (74) yes_dec_params -> . yes_dec_params TYPE ID ASSIGN NUM COMMA
    (75) yes_dec_params -> . TYPE ID COMMA
    (76) yes_dec_params -> . TYPE MULTIPLY ID COMMA
    (77) yes_dec_params -> . TYPE COMMA
    (78) yes_dec_params -> . TYPE MULTIPLY COMMA
    (79) yes_dec_params -> . TYPE ID ASSIGN NUM COMMA
    (80) end_dec_params -> . TYPE ID
    (81) end_dec_params -> . TYPE ID ASSIGN NUM
    (82) end_dec_params -> . TYPE
    (83) end_dec_params -> . TYPE MULTIPLY ID
    (84) end_dec_params -> . TYPE MULTIPLY

    R_PAREN         reduce using rule 62 (empty -> .)
    TYPE            shift and go to state 175

    dec_params                     shift and go to state 176
    empty                          shift and go to state 177
    yes_dec_params                 shift and go to state 178
    end_dec_params                 shift and go to state 179

state 135

    (23) multi_declaration -> ID COMMA .

    ID              reduce using rule 23 (multi_declaration -> ID COMMA .)
    MULTIPLY        reduce using rule 23 (multi_declaration -> ID COMMA .)


state 136

    (35) declaration -> TYPE MULTIPLY ID . SEMICOLON
    (37) declaration -> TYPE MULTIPLY ID . ASSIGN expr SEMICOLON
    (25) multi_declaration -> MULTIPLY ID . COMMA
    (26) multi_declaration -> MULTIPLY ID . ASSIGN expr COMMA

    SEMICOLON       shift and go to state 180
    ASSIGN          shift and go to state 181
    COMMA           shift and go to state 182


state 137

    (38) declaration -> TYPE multi_declaration stop .

    IF              reduce using rule 38 (declaration -> TYPE multi_declaration stop .)
    WHILE           reduce using rule 38 (declaration -> TYPE multi_declaration stop .)
    FOR             reduce using rule 38 (declaration -> TYPE multi_declaration stop .)
    SEMICOLON       reduce using rule 38 (declaration -> TYPE multi_declaration stop .)
    RETURN          reduce using rule 38 (declaration -> TYPE multi_declaration stop .)
    HASH            reduce using rule 38 (declaration -> TYPE multi_declaration stop .)
    TYPE            reduce using rule 38 (declaration -> TYPE multi_declaration stop .)
    L_FLOWBRACE     reduce using rule 38 (declaration -> TYPE multi_declaration stop .)
    NOT             reduce using rule 38 (declaration -> TYPE multi_declaration stop .)
    PLUS            reduce using rule 38 (declaration -> TYPE multi_declaration stop .)
    MINUS           reduce using rule 38 (declaration -> TYPE multi_declaration stop .)
    PLUS_PLUS       reduce using rule 38 (declaration -> TYPE multi_declaration stop .)
    MINUS_MINUS     reduce using rule 38 (declaration -> TYPE multi_declaration stop .)
    L_PAREN         reduce using rule 38 (declaration -> TYPE multi_declaration stop .)
    STRING          reduce using rule 38 (declaration -> TYPE multi_declaration stop .)
    MULTIPLY        reduce using rule 38 (declaration -> TYPE multi_declaration stop .)
    BIT_AND         reduce using rule 38 (declaration -> TYPE multi_declaration stop .)
    ID              reduce using rule 38 (declaration -> TYPE multi_declaration stop .)
    CHAR            reduce using rule 38 (declaration -> TYPE multi_declaration stop .)
    INT_NUM         reduce using rule 38 (declaration -> TYPE multi_declaration stop .)
    FLOAT_NUM       reduce using rule 38 (declaration -> TYPE multi_declaration stop .)
    $end            reduce using rule 38 (declaration -> TYPE multi_declaration stop .)
    R_FLOWBRACE     reduce using rule 38 (declaration -> TYPE multi_declaration stop .)
    ELSE            reduce using rule 38 (declaration -> TYPE multi_declaration stop .)
    R_PAREN         reduce using rule 38 (declaration -> TYPE multi_declaration stop .)


state 138

    (19) multi_declaration -> multi_declaration ID . COMMA
    (21) multi_declaration -> multi_declaration ID . ASSIGN expr COMMA
    (27) stop -> ID . SEMICOLON
    (29) stop -> ID . ASSIGN expr SEMICOLON

    COMMA           shift and go to state 183
    ASSIGN          shift and go to state 184
    SEMICOLON       shift and go to state 185


state 139

    (20) multi_declaration -> multi_declaration MULTIPLY . ID COMMA
    (22) multi_declaration -> multi_declaration MULTIPLY . ID ASSIGN expr COMMA
    (28) stop -> MULTIPLY . ID SEMICOLON
    (30) stop -> MULTIPLY . ID ASSIGN expr SEMICOLON

    ID              shift and go to state 186


state 140

    (32) narrayindex -> narrayindex arrayindex .

    L_SQBRACE       reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    PLUS_PLUS       reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    MINUS_MINUS     reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    MULTIPLY        reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    DIVIDE          reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    MOD             reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    PLUS            reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    MINUS           reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    L_SHIFT         reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    R_SHIFT         reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    LE              reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    LT              reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    GE              reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    GT              reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    EQ              reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    NE              reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    BIT_AND         reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    BIT_XOR         reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    BIT_OR          reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    AND             reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    OR              reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    SEMICOLON       reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    ASSIGN          reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    PLUS_ASSIGN     reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    MINUS_ASSIGN    reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    MUL_ASSIGN      reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    DIV_ASSIGN      reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    AND_ASSIGN      reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    OR_ASSIGN       reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    XOR_ASSIGN      reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    MOD_ASSIGN      reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    L_SHIFT_ASSIGN  reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    R_SHIFT_ASSIGN  reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    R_PAREN         reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    COMMA           reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    R_SQBRACE       reduce using rule 32 (narrayindex -> narrayindex arrayindex .)
    R_FLOWBRACE     reduce using rule 32 (narrayindex -> narrayindex arrayindex .)


state 141

    (63) function_call -> ID L_PAREN call_params . R_PAREN

    R_PAREN         shift and go to state 187


state 142

    (64) call_params -> empty .

    R_PAREN         reduce using rule 64 (call_params -> empty .)


state 143

    (65) call_params -> yes_call_params . end_call_params
    (67) yes_call_params -> yes_call_params . expr COMMA
    (69) end_call_params -> . expr
    (91) expr -> . expr assignment exprOR
    (92) expr -> . exprOR
    (104) exprOR -> . exprOR OR exprAND
    (105) exprOR -> . exprAND
    (106) exprAND -> . exprAND AND exprBITOR
    (107) exprAND -> . exprBITOR
    (108) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (109) exprBITOR -> . exprBITXOR
    (110) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (111) exprBITXOR -> . exprBITAND
    (112) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (113) exprBITAND -> . exprEQ
    (114) exprEQ -> . exprEQ EQ exprRELOP
    (115) exprEQ -> . exprEQ NE exprRELOP
    (116) exprEQ -> . exprRELOP
    (117) exprRELOP -> . exprRELOP relop exprSHIFT
    (118) exprRELOP -> . exprSHIFT
    (123) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (124) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (125) exprSHIFT -> . exprOP
    (126) exprOP -> . exprOP PLUS term
    (127) exprOP -> . exprOP MINUS term
    (128) exprOP -> . term
    (129) term -> . term MULTIPLY factor
    (130) term -> . term DIVIDE factor
    (131) term -> . term MOD factor
    (132) term -> . factor
    (133) factor -> . NOT factor
    (134) factor -> . PLUS factor
    (135) factor -> . MINUS factor
    (136) factor -> . PLUS_PLUS factor
    (137) factor -> . MINUS_MINUS factor
    (138) factor -> . cast brace
    (139) factor -> . brace
    (140) cast -> . L_PAREN TYPE R_PAREN
    (141) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (142) brace -> . L_PAREN expr R_PAREN
    (143) brace -> . brace PLUS_PLUS
    (144) brace -> . brace MINUS_MINUS
    (145) brace -> . NUM
    (146) brace -> . STRING
    (147) brace -> . MULTIPLY ID
    (148) brace -> . BIT_AND ID
    (149) brace -> . ID
    (150) brace -> . CHAR
    (151) brace -> . function_call
    (152) brace -> . ID narrayindex
    (153) NUM -> . INT_NUM
    (154) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    end_call_params                shift and go to state 188
    expr                           shift and go to state 189
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 144

    (66) call_params -> end_call_params .

    R_PAREN         reduce using rule 66 (call_params -> end_call_params .)


state 145

    (68) yes_call_params -> expr . COMMA
    (69) end_call_params -> expr .
    (91) expr -> expr . assignment exprOR
    (93) assignment -> . ASSIGN
    (94) assignment -> . PLUS_ASSIGN
    (95) assignment -> . MINUS_ASSIGN
    (96) assignment -> . MUL_ASSIGN
    (97) assignment -> . DIV_ASSIGN
    (98) assignment -> . AND_ASSIGN
    (99) assignment -> . OR_ASSIGN
    (100) assignment -> . XOR_ASSIGN
    (101) assignment -> . MOD_ASSIGN
    (102) assignment -> . L_SHIFT_ASSIGN
    (103) assignment -> . R_SHIFT_ASSIGN

    COMMA           shift and go to state 190
    R_PAREN         reduce using rule 69 (end_call_params -> expr .)
    ASSIGN          shift and go to state 58
    PLUS_ASSIGN     shift and go to state 59
    MINUS_ASSIGN    shift and go to state 60
    MUL_ASSIGN      shift and go to state 61
    DIV_ASSIGN      shift and go to state 62
    AND_ASSIGN      shift and go to state 63
    OR_ASSIGN       shift and go to state 64
    XOR_ASSIGN      shift and go to state 65
    MOD_ASSIGN      shift and go to state 66
    L_SHIFT_ASSIGN  shift and go to state 67
    R_SHIFT_ASSIGN  shift and go to state 68

    assignment                     shift and go to state 57

state 146

    (31) arrayindex -> L_SQBRACE index . R_SQBRACE

    R_SQBRACE       shift and go to state 191


state 147

    (47) index -> expr .
    (91) expr -> expr . assignment exprOR
    (93) assignment -> . ASSIGN
    (94) assignment -> . PLUS_ASSIGN
    (95) assignment -> . MINUS_ASSIGN
    (96) assignment -> . MUL_ASSIGN
    (97) assignment -> . DIV_ASSIGN
    (98) assignment -> . AND_ASSIGN
    (99) assignment -> . OR_ASSIGN
    (100) assignment -> . XOR_ASSIGN
    (101) assignment -> . MOD_ASSIGN
    (102) assignment -> . L_SHIFT_ASSIGN
    (103) assignment -> . R_SHIFT_ASSIGN

    R_SQBRACE       reduce using rule 47 (index -> expr .)
    ASSIGN          shift and go to state 58
    PLUS_ASSIGN     shift and go to state 59
    MINUS_ASSIGN    shift and go to state 60
    MUL_ASSIGN      shift and go to state 61
    DIV_ASSIGN      shift and go to state 62
    AND_ASSIGN      shift and go to state 63
    OR_ASSIGN       shift and go to state 64
    XOR_ASSIGN      shift and go to state 65
    MOD_ASSIGN      shift and go to state 66
    L_SHIFT_ASSIGN  shift and go to state 67
    R_SHIFT_ASSIGN  shift and go to state 68

    assignment                     shift and go to state 57

state 148

    (48) index -> empty .

    R_SQBRACE       reduce using rule 48 (index -> empty .)


state 149

    (140) cast -> L_PAREN TYPE R_PAREN .

    L_PAREN         reduce using rule 140 (cast -> L_PAREN TYPE R_PAREN .)
    STRING          reduce using rule 140 (cast -> L_PAREN TYPE R_PAREN .)
    MULTIPLY        reduce using rule 140 (cast -> L_PAREN TYPE R_PAREN .)
    BIT_AND         reduce using rule 140 (cast -> L_PAREN TYPE R_PAREN .)
    ID              reduce using rule 140 (cast -> L_PAREN TYPE R_PAREN .)
    CHAR            reduce using rule 140 (cast -> L_PAREN TYPE R_PAREN .)
    INT_NUM         reduce using rule 140 (cast -> L_PAREN TYPE R_PAREN .)
    FLOAT_NUM       reduce using rule 140 (cast -> L_PAREN TYPE R_PAREN .)


state 150

    (141) cast -> L_PAREN TYPE MULTIPLY . R_PAREN

    R_PAREN         shift and go to state 192


state 151

    (142) brace -> L_PAREN expr R_PAREN .

    PLUS_PLUS       reduce using rule 142 (brace -> L_PAREN expr R_PAREN .)
    MINUS_MINUS     reduce using rule 142 (brace -> L_PAREN expr R_PAREN .)
    MULTIPLY        reduce using rule 142 (brace -> L_PAREN expr R_PAREN .)
    DIVIDE          reduce using rule 142 (brace -> L_PAREN expr R_PAREN .)
    MOD             reduce using rule 142 (brace -> L_PAREN expr R_PAREN .)
    PLUS            reduce using rule 142 (brace -> L_PAREN expr R_PAREN .)
    MINUS           reduce using rule 142 (brace -> L_PAREN expr R_PAREN .)
    L_SHIFT         reduce using rule 142 (brace -> L_PAREN expr R_PAREN .)
    R_SHIFT         reduce using rule 142 (brace -> L_PAREN expr R_PAREN .)
    LE              reduce using rule 142 (brace -> L_PAREN expr R_PAREN .)
    LT              reduce using rule 142 (brace -> L_PAREN expr R_PAREN .)
    GE              reduce using rule 142 (brace -> L_PAREN expr R_PAREN .)
    GT              reduce using rule 142 (brace -> L_PAREN expr R_PAREN .)
    EQ              reduce using rule 142 (brace -> L_PAREN expr R_PAREN .)
    NE              reduce using rule 142 (brace -> L_PAREN expr R_PAREN .)
    BIT_AND         reduce using rule 142 (brace -> L_PAREN expr R_PAREN .)
    BIT_XOR         reduce using rule 142 (brace -> L_PAREN expr R_PAREN .)
    BIT_OR          reduce using rule 142 (brace -> L_PAREN expr R_PAREN .)
    AND             reduce using rule 142 (brace -> L_PAREN expr R_PAREN .)
    OR              reduce using rule 142 (brace -> L_PAREN expr R_PAREN .)
    SEMICOLON       reduce using rule 142 (brace -> L_PAREN expr R_PAREN .)
    ASSIGN          reduce using rule 142 (brace -> L_PAREN expr R_PAREN .)
    PLUS_ASSIGN     reduce using rule 142 (brace -> L_PAREN expr R_PAREN .)
    MINUS_ASSIGN    reduce using rule 142 (brace -> L_PAREN expr R_PAREN .)
    MUL_ASSIGN      reduce using rule 142 (brace -> L_PAREN expr R_PAREN .)
    DIV_ASSIGN      reduce using rule 142 (brace -> L_PAREN expr R_PAREN .)
    AND_ASSIGN      reduce using rule 142 (brace -> L_PAREN expr R_PAREN .)
    OR_ASSIGN       reduce using rule 142 (brace -> L_PAREN expr R_PAREN .)
    XOR_ASSIGN      reduce using rule 142 (brace -> L_PAREN expr R_PAREN .)
    MOD_ASSIGN      reduce using rule 142 (brace -> L_PAREN expr R_PAREN .)
    L_SHIFT_ASSIGN  reduce using rule 142 (brace -> L_PAREN expr R_PAREN .)
    R_SHIFT_ASSIGN  reduce using rule 142 (brace -> L_PAREN expr R_PAREN .)
    R_PAREN         reduce using rule 142 (brace -> L_PAREN expr R_PAREN .)
    COMMA           reduce using rule 142 (brace -> L_PAREN expr R_PAREN .)
    R_SQBRACE       reduce using rule 142 (brace -> L_PAREN expr R_PAREN .)
    R_FLOWBRACE     reduce using rule 142 (brace -> L_PAREN expr R_PAREN .)


state 152

    (106) exprAND -> exprAND AND exprBITOR .
    (108) exprBITOR -> exprBITOR . BIT_OR exprBITXOR

    AND             reduce using rule 106 (exprAND -> exprAND AND exprBITOR .)
    OR              reduce using rule 106 (exprAND -> exprAND AND exprBITOR .)
    SEMICOLON       reduce using rule 106 (exprAND -> exprAND AND exprBITOR .)
    ASSIGN          reduce using rule 106 (exprAND -> exprAND AND exprBITOR .)
    PLUS_ASSIGN     reduce using rule 106 (exprAND -> exprAND AND exprBITOR .)
    MINUS_ASSIGN    reduce using rule 106 (exprAND -> exprAND AND exprBITOR .)
    MUL_ASSIGN      reduce using rule 106 (exprAND -> exprAND AND exprBITOR .)
    DIV_ASSIGN      reduce using rule 106 (exprAND -> exprAND AND exprBITOR .)
    AND_ASSIGN      reduce using rule 106 (exprAND -> exprAND AND exprBITOR .)
    OR_ASSIGN       reduce using rule 106 (exprAND -> exprAND AND exprBITOR .)
    XOR_ASSIGN      reduce using rule 106 (exprAND -> exprAND AND exprBITOR .)
    MOD_ASSIGN      reduce using rule 106 (exprAND -> exprAND AND exprBITOR .)
    L_SHIFT_ASSIGN  reduce using rule 106 (exprAND -> exprAND AND exprBITOR .)
    R_SHIFT_ASSIGN  reduce using rule 106 (exprAND -> exprAND AND exprBITOR .)
    R_PAREN         reduce using rule 106 (exprAND -> exprAND AND exprBITOR .)
    COMMA           reduce using rule 106 (exprAND -> exprAND AND exprBITOR .)
    R_SQBRACE       reduce using rule 106 (exprAND -> exprAND AND exprBITOR .)
    R_FLOWBRACE     reduce using rule 106 (exprAND -> exprAND AND exprBITOR .)
    BIT_OR          shift and go to state 87


state 153

    (108) exprBITOR -> exprBITOR BIT_OR exprBITXOR .
    (110) exprBITXOR -> exprBITXOR . BIT_XOR exprBITAND

    BIT_OR          reduce using rule 108 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    AND             reduce using rule 108 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    OR              reduce using rule 108 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    SEMICOLON       reduce using rule 108 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    ASSIGN          reduce using rule 108 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    PLUS_ASSIGN     reduce using rule 108 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    MINUS_ASSIGN    reduce using rule 108 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    MUL_ASSIGN      reduce using rule 108 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    DIV_ASSIGN      reduce using rule 108 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    AND_ASSIGN      reduce using rule 108 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    OR_ASSIGN       reduce using rule 108 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    XOR_ASSIGN      reduce using rule 108 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    MOD_ASSIGN      reduce using rule 108 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    L_SHIFT_ASSIGN  reduce using rule 108 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    R_SHIFT_ASSIGN  reduce using rule 108 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    R_PAREN         reduce using rule 108 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    COMMA           reduce using rule 108 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    R_SQBRACE       reduce using rule 108 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    R_FLOWBRACE     reduce using rule 108 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    BIT_XOR         shift and go to state 88


state 154

    (110) exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .
    (112) exprBITAND -> exprBITAND . BIT_AND exprEQ

    BIT_XOR         reduce using rule 110 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    BIT_OR          reduce using rule 110 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    AND             reduce using rule 110 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    OR              reduce using rule 110 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    SEMICOLON       reduce using rule 110 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    ASSIGN          reduce using rule 110 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    PLUS_ASSIGN     reduce using rule 110 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    MINUS_ASSIGN    reduce using rule 110 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    MUL_ASSIGN      reduce using rule 110 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    DIV_ASSIGN      reduce using rule 110 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    AND_ASSIGN      reduce using rule 110 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    OR_ASSIGN       reduce using rule 110 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    XOR_ASSIGN      reduce using rule 110 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    MOD_ASSIGN      reduce using rule 110 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    L_SHIFT_ASSIGN  reduce using rule 110 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    R_SHIFT_ASSIGN  reduce using rule 110 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    R_PAREN         reduce using rule 110 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    COMMA           reduce using rule 110 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    R_SQBRACE       reduce using rule 110 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    R_FLOWBRACE     reduce using rule 110 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    BIT_AND         shift and go to state 89


state 155

    (112) exprBITAND -> exprBITAND BIT_AND exprEQ .
    (114) exprEQ -> exprEQ . EQ exprRELOP
    (115) exprEQ -> exprEQ . NE exprRELOP

    BIT_AND         reduce using rule 112 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    BIT_XOR         reduce using rule 112 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    BIT_OR          reduce using rule 112 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    AND             reduce using rule 112 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    OR              reduce using rule 112 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    SEMICOLON       reduce using rule 112 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    ASSIGN          reduce using rule 112 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    PLUS_ASSIGN     reduce using rule 112 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    MINUS_ASSIGN    reduce using rule 112 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    MUL_ASSIGN      reduce using rule 112 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    DIV_ASSIGN      reduce using rule 112 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    AND_ASSIGN      reduce using rule 112 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    OR_ASSIGN       reduce using rule 112 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    XOR_ASSIGN      reduce using rule 112 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    MOD_ASSIGN      reduce using rule 112 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    L_SHIFT_ASSIGN  reduce using rule 112 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    R_SHIFT_ASSIGN  reduce using rule 112 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    R_PAREN         reduce using rule 112 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    COMMA           reduce using rule 112 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    R_SQBRACE       reduce using rule 112 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    R_FLOWBRACE     reduce using rule 112 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    EQ              shift and go to state 91
    NE              shift and go to state 92


state 156

    (114) exprEQ -> exprEQ EQ exprRELOP .
    (117) exprRELOP -> exprRELOP . relop exprSHIFT
    (119) relop -> . LE
    (120) relop -> . LT
    (121) relop -> . GE
    (122) relop -> . GT

    EQ              reduce using rule 114 (exprEQ -> exprEQ EQ exprRELOP .)
    NE              reduce using rule 114 (exprEQ -> exprEQ EQ exprRELOP .)
    BIT_AND         reduce using rule 114 (exprEQ -> exprEQ EQ exprRELOP .)
    BIT_XOR         reduce using rule 114 (exprEQ -> exprEQ EQ exprRELOP .)
    BIT_OR          reduce using rule 114 (exprEQ -> exprEQ EQ exprRELOP .)
    AND             reduce using rule 114 (exprEQ -> exprEQ EQ exprRELOP .)
    OR              reduce using rule 114 (exprEQ -> exprEQ EQ exprRELOP .)
    SEMICOLON       reduce using rule 114 (exprEQ -> exprEQ EQ exprRELOP .)
    ASSIGN          reduce using rule 114 (exprEQ -> exprEQ EQ exprRELOP .)
    PLUS_ASSIGN     reduce using rule 114 (exprEQ -> exprEQ EQ exprRELOP .)
    MINUS_ASSIGN    reduce using rule 114 (exprEQ -> exprEQ EQ exprRELOP .)
    MUL_ASSIGN      reduce using rule 114 (exprEQ -> exprEQ EQ exprRELOP .)
    DIV_ASSIGN      reduce using rule 114 (exprEQ -> exprEQ EQ exprRELOP .)
    AND_ASSIGN      reduce using rule 114 (exprEQ -> exprEQ EQ exprRELOP .)
    OR_ASSIGN       reduce using rule 114 (exprEQ -> exprEQ EQ exprRELOP .)
    XOR_ASSIGN      reduce using rule 114 (exprEQ -> exprEQ EQ exprRELOP .)
    MOD_ASSIGN      reduce using rule 114 (exprEQ -> exprEQ EQ exprRELOP .)
    L_SHIFT_ASSIGN  reduce using rule 114 (exprEQ -> exprEQ EQ exprRELOP .)
    R_SHIFT_ASSIGN  reduce using rule 114 (exprEQ -> exprEQ EQ exprRELOP .)
    R_PAREN         reduce using rule 114 (exprEQ -> exprEQ EQ exprRELOP .)
    COMMA           reduce using rule 114 (exprEQ -> exprEQ EQ exprRELOP .)
    R_SQBRACE       reduce using rule 114 (exprEQ -> exprEQ EQ exprRELOP .)
    R_FLOWBRACE     reduce using rule 114 (exprEQ -> exprEQ EQ exprRELOP .)
    LE              shift and go to state 94
    LT              shift and go to state 95
    GE              shift and go to state 96
    GT              shift and go to state 97

    relop                          shift and go to state 93

state 157

    (115) exprEQ -> exprEQ NE exprRELOP .
    (117) exprRELOP -> exprRELOP . relop exprSHIFT
    (119) relop -> . LE
    (120) relop -> . LT
    (121) relop -> . GE
    (122) relop -> . GT

    EQ              reduce using rule 115 (exprEQ -> exprEQ NE exprRELOP .)
    NE              reduce using rule 115 (exprEQ -> exprEQ NE exprRELOP .)
    BIT_AND         reduce using rule 115 (exprEQ -> exprEQ NE exprRELOP .)
    BIT_XOR         reduce using rule 115 (exprEQ -> exprEQ NE exprRELOP .)
    BIT_OR          reduce using rule 115 (exprEQ -> exprEQ NE exprRELOP .)
    AND             reduce using rule 115 (exprEQ -> exprEQ NE exprRELOP .)
    OR              reduce using rule 115 (exprEQ -> exprEQ NE exprRELOP .)
    SEMICOLON       reduce using rule 115 (exprEQ -> exprEQ NE exprRELOP .)
    ASSIGN          reduce using rule 115 (exprEQ -> exprEQ NE exprRELOP .)
    PLUS_ASSIGN     reduce using rule 115 (exprEQ -> exprEQ NE exprRELOP .)
    MINUS_ASSIGN    reduce using rule 115 (exprEQ -> exprEQ NE exprRELOP .)
    MUL_ASSIGN      reduce using rule 115 (exprEQ -> exprEQ NE exprRELOP .)
    DIV_ASSIGN      reduce using rule 115 (exprEQ -> exprEQ NE exprRELOP .)
    AND_ASSIGN      reduce using rule 115 (exprEQ -> exprEQ NE exprRELOP .)
    OR_ASSIGN       reduce using rule 115 (exprEQ -> exprEQ NE exprRELOP .)
    XOR_ASSIGN      reduce using rule 115 (exprEQ -> exprEQ NE exprRELOP .)
    MOD_ASSIGN      reduce using rule 115 (exprEQ -> exprEQ NE exprRELOP .)
    L_SHIFT_ASSIGN  reduce using rule 115 (exprEQ -> exprEQ NE exprRELOP .)
    R_SHIFT_ASSIGN  reduce using rule 115 (exprEQ -> exprEQ NE exprRELOP .)
    R_PAREN         reduce using rule 115 (exprEQ -> exprEQ NE exprRELOP .)
    COMMA           reduce using rule 115 (exprEQ -> exprEQ NE exprRELOP .)
    R_SQBRACE       reduce using rule 115 (exprEQ -> exprEQ NE exprRELOP .)
    R_FLOWBRACE     reduce using rule 115 (exprEQ -> exprEQ NE exprRELOP .)
    LE              shift and go to state 94
    LT              shift and go to state 95
    GE              shift and go to state 96
    GT              shift and go to state 97

    relop                          shift and go to state 93

state 158

    (117) exprRELOP -> exprRELOP relop exprSHIFT .
    (123) exprSHIFT -> exprSHIFT . L_SHIFT exprOP
    (124) exprSHIFT -> exprSHIFT . R_SHIFT exprOP

    LE              reduce using rule 117 (exprRELOP -> exprRELOP relop exprSHIFT .)
    LT              reduce using rule 117 (exprRELOP -> exprRELOP relop exprSHIFT .)
    GE              reduce using rule 117 (exprRELOP -> exprRELOP relop exprSHIFT .)
    GT              reduce using rule 117 (exprRELOP -> exprRELOP relop exprSHIFT .)
    EQ              reduce using rule 117 (exprRELOP -> exprRELOP relop exprSHIFT .)
    NE              reduce using rule 117 (exprRELOP -> exprRELOP relop exprSHIFT .)
    BIT_AND         reduce using rule 117 (exprRELOP -> exprRELOP relop exprSHIFT .)
    BIT_XOR         reduce using rule 117 (exprRELOP -> exprRELOP relop exprSHIFT .)
    BIT_OR          reduce using rule 117 (exprRELOP -> exprRELOP relop exprSHIFT .)
    AND             reduce using rule 117 (exprRELOP -> exprRELOP relop exprSHIFT .)
    OR              reduce using rule 117 (exprRELOP -> exprRELOP relop exprSHIFT .)
    SEMICOLON       reduce using rule 117 (exprRELOP -> exprRELOP relop exprSHIFT .)
    ASSIGN          reduce using rule 117 (exprRELOP -> exprRELOP relop exprSHIFT .)
    PLUS_ASSIGN     reduce using rule 117 (exprRELOP -> exprRELOP relop exprSHIFT .)
    MINUS_ASSIGN    reduce using rule 117 (exprRELOP -> exprRELOP relop exprSHIFT .)
    MUL_ASSIGN      reduce using rule 117 (exprRELOP -> exprRELOP relop exprSHIFT .)
    DIV_ASSIGN      reduce using rule 117 (exprRELOP -> exprRELOP relop exprSHIFT .)
    AND_ASSIGN      reduce using rule 117 (exprRELOP -> exprRELOP relop exprSHIFT .)
    OR_ASSIGN       reduce using rule 117 (exprRELOP -> exprRELOP relop exprSHIFT .)
    XOR_ASSIGN      reduce using rule 117 (exprRELOP -> exprRELOP relop exprSHIFT .)
    MOD_ASSIGN      reduce using rule 117 (exprRELOP -> exprRELOP relop exprSHIFT .)
    L_SHIFT_ASSIGN  reduce using rule 117 (exprRELOP -> exprRELOP relop exprSHIFT .)
    R_SHIFT_ASSIGN  reduce using rule 117 (exprRELOP -> exprRELOP relop exprSHIFT .)
    R_PAREN         reduce using rule 117 (exprRELOP -> exprRELOP relop exprSHIFT .)
    COMMA           reduce using rule 117 (exprRELOP -> exprRELOP relop exprSHIFT .)
    R_SQBRACE       reduce using rule 117 (exprRELOP -> exprRELOP relop exprSHIFT .)
    R_FLOWBRACE     reduce using rule 117 (exprRELOP -> exprRELOP relop exprSHIFT .)
    L_SHIFT         shift and go to state 98
    R_SHIFT         shift and go to state 99


state 159

    (123) exprSHIFT -> exprSHIFT L_SHIFT exprOP .
    (126) exprOP -> exprOP . PLUS term
    (127) exprOP -> exprOP . MINUS term

    L_SHIFT         reduce using rule 123 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    R_SHIFT         reduce using rule 123 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    LE              reduce using rule 123 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    LT              reduce using rule 123 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    GE              reduce using rule 123 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    GT              reduce using rule 123 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    EQ              reduce using rule 123 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    NE              reduce using rule 123 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    BIT_AND         reduce using rule 123 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    BIT_XOR         reduce using rule 123 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    BIT_OR          reduce using rule 123 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    AND             reduce using rule 123 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    OR              reduce using rule 123 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    SEMICOLON       reduce using rule 123 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    ASSIGN          reduce using rule 123 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    PLUS_ASSIGN     reduce using rule 123 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    MINUS_ASSIGN    reduce using rule 123 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    MUL_ASSIGN      reduce using rule 123 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    DIV_ASSIGN      reduce using rule 123 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    AND_ASSIGN      reduce using rule 123 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    OR_ASSIGN       reduce using rule 123 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    XOR_ASSIGN      reduce using rule 123 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    MOD_ASSIGN      reduce using rule 123 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    L_SHIFT_ASSIGN  reduce using rule 123 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    R_SHIFT_ASSIGN  reduce using rule 123 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    R_PAREN         reduce using rule 123 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    COMMA           reduce using rule 123 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    R_SQBRACE       reduce using rule 123 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    R_FLOWBRACE     reduce using rule 123 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101


state 160

    (124) exprSHIFT -> exprSHIFT R_SHIFT exprOP .
    (126) exprOP -> exprOP . PLUS term
    (127) exprOP -> exprOP . MINUS term

    L_SHIFT         reduce using rule 124 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    R_SHIFT         reduce using rule 124 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    LE              reduce using rule 124 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    LT              reduce using rule 124 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    GE              reduce using rule 124 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    GT              reduce using rule 124 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    EQ              reduce using rule 124 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    NE              reduce using rule 124 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    BIT_AND         reduce using rule 124 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    BIT_XOR         reduce using rule 124 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    BIT_OR          reduce using rule 124 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    AND             reduce using rule 124 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    OR              reduce using rule 124 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    SEMICOLON       reduce using rule 124 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    ASSIGN          reduce using rule 124 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    PLUS_ASSIGN     reduce using rule 124 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    MINUS_ASSIGN    reduce using rule 124 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    MUL_ASSIGN      reduce using rule 124 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    DIV_ASSIGN      reduce using rule 124 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    AND_ASSIGN      reduce using rule 124 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    OR_ASSIGN       reduce using rule 124 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    XOR_ASSIGN      reduce using rule 124 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    MOD_ASSIGN      reduce using rule 124 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    L_SHIFT_ASSIGN  reduce using rule 124 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    R_SHIFT_ASSIGN  reduce using rule 124 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    R_PAREN         reduce using rule 124 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    COMMA           reduce using rule 124 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    R_SQBRACE       reduce using rule 124 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    R_FLOWBRACE     reduce using rule 124 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101


state 161

    (126) exprOP -> exprOP PLUS term .
    (129) term -> term . MULTIPLY factor
    (130) term -> term . DIVIDE factor
    (131) term -> term . MOD factor

    PLUS            reduce using rule 126 (exprOP -> exprOP PLUS term .)
    MINUS           reduce using rule 126 (exprOP -> exprOP PLUS term .)
    L_SHIFT         reduce using rule 126 (exprOP -> exprOP PLUS term .)
    R_SHIFT         reduce using rule 126 (exprOP -> exprOP PLUS term .)
    LE              reduce using rule 126 (exprOP -> exprOP PLUS term .)
    LT              reduce using rule 126 (exprOP -> exprOP PLUS term .)
    GE              reduce using rule 126 (exprOP -> exprOP PLUS term .)
    GT              reduce using rule 126 (exprOP -> exprOP PLUS term .)
    EQ              reduce using rule 126 (exprOP -> exprOP PLUS term .)
    NE              reduce using rule 126 (exprOP -> exprOP PLUS term .)
    BIT_AND         reduce using rule 126 (exprOP -> exprOP PLUS term .)
    BIT_XOR         reduce using rule 126 (exprOP -> exprOP PLUS term .)
    BIT_OR          reduce using rule 126 (exprOP -> exprOP PLUS term .)
    AND             reduce using rule 126 (exprOP -> exprOP PLUS term .)
    OR              reduce using rule 126 (exprOP -> exprOP PLUS term .)
    SEMICOLON       reduce using rule 126 (exprOP -> exprOP PLUS term .)
    ASSIGN          reduce using rule 126 (exprOP -> exprOP PLUS term .)
    PLUS_ASSIGN     reduce using rule 126 (exprOP -> exprOP PLUS term .)
    MINUS_ASSIGN    reduce using rule 126 (exprOP -> exprOP PLUS term .)
    MUL_ASSIGN      reduce using rule 126 (exprOP -> exprOP PLUS term .)
    DIV_ASSIGN      reduce using rule 126 (exprOP -> exprOP PLUS term .)
    AND_ASSIGN      reduce using rule 126 (exprOP -> exprOP PLUS term .)
    OR_ASSIGN       reduce using rule 126 (exprOP -> exprOP PLUS term .)
    XOR_ASSIGN      reduce using rule 126 (exprOP -> exprOP PLUS term .)
    MOD_ASSIGN      reduce using rule 126 (exprOP -> exprOP PLUS term .)
    L_SHIFT_ASSIGN  reduce using rule 126 (exprOP -> exprOP PLUS term .)
    R_SHIFT_ASSIGN  reduce using rule 126 (exprOP -> exprOP PLUS term .)
    R_PAREN         reduce using rule 126 (exprOP -> exprOP PLUS term .)
    COMMA           reduce using rule 126 (exprOP -> exprOP PLUS term .)
    R_SQBRACE       reduce using rule 126 (exprOP -> exprOP PLUS term .)
    R_FLOWBRACE     reduce using rule 126 (exprOP -> exprOP PLUS term .)
    MULTIPLY        shift and go to state 103
    DIVIDE          shift and go to state 104
    MOD             shift and go to state 105


state 162

    (127) exprOP -> exprOP MINUS term .
    (129) term -> term . MULTIPLY factor
    (130) term -> term . DIVIDE factor
    (131) term -> term . MOD factor

    PLUS            reduce using rule 127 (exprOP -> exprOP MINUS term .)
    MINUS           reduce using rule 127 (exprOP -> exprOP MINUS term .)
    L_SHIFT         reduce using rule 127 (exprOP -> exprOP MINUS term .)
    R_SHIFT         reduce using rule 127 (exprOP -> exprOP MINUS term .)
    LE              reduce using rule 127 (exprOP -> exprOP MINUS term .)
    LT              reduce using rule 127 (exprOP -> exprOP MINUS term .)
    GE              reduce using rule 127 (exprOP -> exprOP MINUS term .)
    GT              reduce using rule 127 (exprOP -> exprOP MINUS term .)
    EQ              reduce using rule 127 (exprOP -> exprOP MINUS term .)
    NE              reduce using rule 127 (exprOP -> exprOP MINUS term .)
    BIT_AND         reduce using rule 127 (exprOP -> exprOP MINUS term .)
    BIT_XOR         reduce using rule 127 (exprOP -> exprOP MINUS term .)
    BIT_OR          reduce using rule 127 (exprOP -> exprOP MINUS term .)
    AND             reduce using rule 127 (exprOP -> exprOP MINUS term .)
    OR              reduce using rule 127 (exprOP -> exprOP MINUS term .)
    SEMICOLON       reduce using rule 127 (exprOP -> exprOP MINUS term .)
    ASSIGN          reduce using rule 127 (exprOP -> exprOP MINUS term .)
    PLUS_ASSIGN     reduce using rule 127 (exprOP -> exprOP MINUS term .)
    MINUS_ASSIGN    reduce using rule 127 (exprOP -> exprOP MINUS term .)
    MUL_ASSIGN      reduce using rule 127 (exprOP -> exprOP MINUS term .)
    DIV_ASSIGN      reduce using rule 127 (exprOP -> exprOP MINUS term .)
    AND_ASSIGN      reduce using rule 127 (exprOP -> exprOP MINUS term .)
    OR_ASSIGN       reduce using rule 127 (exprOP -> exprOP MINUS term .)
    XOR_ASSIGN      reduce using rule 127 (exprOP -> exprOP MINUS term .)
    MOD_ASSIGN      reduce using rule 127 (exprOP -> exprOP MINUS term .)
    L_SHIFT_ASSIGN  reduce using rule 127 (exprOP -> exprOP MINUS term .)
    R_SHIFT_ASSIGN  reduce using rule 127 (exprOP -> exprOP MINUS term .)
    R_PAREN         reduce using rule 127 (exprOP -> exprOP MINUS term .)
    COMMA           reduce using rule 127 (exprOP -> exprOP MINUS term .)
    R_SQBRACE       reduce using rule 127 (exprOP -> exprOP MINUS term .)
    R_FLOWBRACE     reduce using rule 127 (exprOP -> exprOP MINUS term .)
    MULTIPLY        shift and go to state 103
    DIVIDE          shift and go to state 104
    MOD             shift and go to state 105


state 163

    (129) term -> term MULTIPLY factor .

    MULTIPLY        reduce using rule 129 (term -> term MULTIPLY factor .)
    DIVIDE          reduce using rule 129 (term -> term MULTIPLY factor .)
    MOD             reduce using rule 129 (term -> term MULTIPLY factor .)
    PLUS            reduce using rule 129 (term -> term MULTIPLY factor .)
    MINUS           reduce using rule 129 (term -> term MULTIPLY factor .)
    L_SHIFT         reduce using rule 129 (term -> term MULTIPLY factor .)
    R_SHIFT         reduce using rule 129 (term -> term MULTIPLY factor .)
    LE              reduce using rule 129 (term -> term MULTIPLY factor .)
    LT              reduce using rule 129 (term -> term MULTIPLY factor .)
    GE              reduce using rule 129 (term -> term MULTIPLY factor .)
    GT              reduce using rule 129 (term -> term MULTIPLY factor .)
    EQ              reduce using rule 129 (term -> term MULTIPLY factor .)
    NE              reduce using rule 129 (term -> term MULTIPLY factor .)
    BIT_AND         reduce using rule 129 (term -> term MULTIPLY factor .)
    BIT_XOR         reduce using rule 129 (term -> term MULTIPLY factor .)
    BIT_OR          reduce using rule 129 (term -> term MULTIPLY factor .)
    AND             reduce using rule 129 (term -> term MULTIPLY factor .)
    OR              reduce using rule 129 (term -> term MULTIPLY factor .)
    SEMICOLON       reduce using rule 129 (term -> term MULTIPLY factor .)
    ASSIGN          reduce using rule 129 (term -> term MULTIPLY factor .)
    PLUS_ASSIGN     reduce using rule 129 (term -> term MULTIPLY factor .)
    MINUS_ASSIGN    reduce using rule 129 (term -> term MULTIPLY factor .)
    MUL_ASSIGN      reduce using rule 129 (term -> term MULTIPLY factor .)
    DIV_ASSIGN      reduce using rule 129 (term -> term MULTIPLY factor .)
    AND_ASSIGN      reduce using rule 129 (term -> term MULTIPLY factor .)
    OR_ASSIGN       reduce using rule 129 (term -> term MULTIPLY factor .)
    XOR_ASSIGN      reduce using rule 129 (term -> term MULTIPLY factor .)
    MOD_ASSIGN      reduce using rule 129 (term -> term MULTIPLY factor .)
    L_SHIFT_ASSIGN  reduce using rule 129 (term -> term MULTIPLY factor .)
    R_SHIFT_ASSIGN  reduce using rule 129 (term -> term MULTIPLY factor .)
    R_PAREN         reduce using rule 129 (term -> term MULTIPLY factor .)
    COMMA           reduce using rule 129 (term -> term MULTIPLY factor .)
    R_SQBRACE       reduce using rule 129 (term -> term MULTIPLY factor .)
    R_FLOWBRACE     reduce using rule 129 (term -> term MULTIPLY factor .)


state 164

    (130) term -> term DIVIDE factor .

    MULTIPLY        reduce using rule 130 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 130 (term -> term DIVIDE factor .)
    MOD             reduce using rule 130 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 130 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 130 (term -> term DIVIDE factor .)
    L_SHIFT         reduce using rule 130 (term -> term DIVIDE factor .)
    R_SHIFT         reduce using rule 130 (term -> term DIVIDE factor .)
    LE              reduce using rule 130 (term -> term DIVIDE factor .)
    LT              reduce using rule 130 (term -> term DIVIDE factor .)
    GE              reduce using rule 130 (term -> term DIVIDE factor .)
    GT              reduce using rule 130 (term -> term DIVIDE factor .)
    EQ              reduce using rule 130 (term -> term DIVIDE factor .)
    NE              reduce using rule 130 (term -> term DIVIDE factor .)
    BIT_AND         reduce using rule 130 (term -> term DIVIDE factor .)
    BIT_XOR         reduce using rule 130 (term -> term DIVIDE factor .)
    BIT_OR          reduce using rule 130 (term -> term DIVIDE factor .)
    AND             reduce using rule 130 (term -> term DIVIDE factor .)
    OR              reduce using rule 130 (term -> term DIVIDE factor .)
    SEMICOLON       reduce using rule 130 (term -> term DIVIDE factor .)
    ASSIGN          reduce using rule 130 (term -> term DIVIDE factor .)
    PLUS_ASSIGN     reduce using rule 130 (term -> term DIVIDE factor .)
    MINUS_ASSIGN    reduce using rule 130 (term -> term DIVIDE factor .)
    MUL_ASSIGN      reduce using rule 130 (term -> term DIVIDE factor .)
    DIV_ASSIGN      reduce using rule 130 (term -> term DIVIDE factor .)
    AND_ASSIGN      reduce using rule 130 (term -> term DIVIDE factor .)
    OR_ASSIGN       reduce using rule 130 (term -> term DIVIDE factor .)
    XOR_ASSIGN      reduce using rule 130 (term -> term DIVIDE factor .)
    MOD_ASSIGN      reduce using rule 130 (term -> term DIVIDE factor .)
    L_SHIFT_ASSIGN  reduce using rule 130 (term -> term DIVIDE factor .)
    R_SHIFT_ASSIGN  reduce using rule 130 (term -> term DIVIDE factor .)
    R_PAREN         reduce using rule 130 (term -> term DIVIDE factor .)
    COMMA           reduce using rule 130 (term -> term DIVIDE factor .)
    R_SQBRACE       reduce using rule 130 (term -> term DIVIDE factor .)
    R_FLOWBRACE     reduce using rule 130 (term -> term DIVIDE factor .)


state 165

    (131) term -> term MOD factor .

    MULTIPLY        reduce using rule 131 (term -> term MOD factor .)
    DIVIDE          reduce using rule 131 (term -> term MOD factor .)
    MOD             reduce using rule 131 (term -> term MOD factor .)
    PLUS            reduce using rule 131 (term -> term MOD factor .)
    MINUS           reduce using rule 131 (term -> term MOD factor .)
    L_SHIFT         reduce using rule 131 (term -> term MOD factor .)
    R_SHIFT         reduce using rule 131 (term -> term MOD factor .)
    LE              reduce using rule 131 (term -> term MOD factor .)
    LT              reduce using rule 131 (term -> term MOD factor .)
    GE              reduce using rule 131 (term -> term MOD factor .)
    GT              reduce using rule 131 (term -> term MOD factor .)
    EQ              reduce using rule 131 (term -> term MOD factor .)
    NE              reduce using rule 131 (term -> term MOD factor .)
    BIT_AND         reduce using rule 131 (term -> term MOD factor .)
    BIT_XOR         reduce using rule 131 (term -> term MOD factor .)
    BIT_OR          reduce using rule 131 (term -> term MOD factor .)
    AND             reduce using rule 131 (term -> term MOD factor .)
    OR              reduce using rule 131 (term -> term MOD factor .)
    SEMICOLON       reduce using rule 131 (term -> term MOD factor .)
    ASSIGN          reduce using rule 131 (term -> term MOD factor .)
    PLUS_ASSIGN     reduce using rule 131 (term -> term MOD factor .)
    MINUS_ASSIGN    reduce using rule 131 (term -> term MOD factor .)
    MUL_ASSIGN      reduce using rule 131 (term -> term MOD factor .)
    DIV_ASSIGN      reduce using rule 131 (term -> term MOD factor .)
    AND_ASSIGN      reduce using rule 131 (term -> term MOD factor .)
    OR_ASSIGN       reduce using rule 131 (term -> term MOD factor .)
    XOR_ASSIGN      reduce using rule 131 (term -> term MOD factor .)
    MOD_ASSIGN      reduce using rule 131 (term -> term MOD factor .)
    L_SHIFT_ASSIGN  reduce using rule 131 (term -> term MOD factor .)
    R_SHIFT_ASSIGN  reduce using rule 131 (term -> term MOD factor .)
    R_PAREN         reduce using rule 131 (term -> term MOD factor .)
    COMMA           reduce using rule 131 (term -> term MOD factor .)
    R_SQBRACE       reduce using rule 131 (term -> term MOD factor .)
    R_FLOWBRACE     reduce using rule 131 (term -> term MOD factor .)


state 166

    (13) closed -> IF condition . closed ELSE closed
    (6) open -> IF condition . statement
    (7) open -> IF condition . closed ELSE open
    (11) closed -> . simple
    (12) closed -> . block
    (13) closed -> . IF condition closed ELSE closed
    (14) closed -> . WHILE condition closed
    (15) closed -> . for for_condition closed
    (4) statement -> . open
    (5) statement -> . closed
    (53) simple -> . expr SEMICOLON
    (54) simple -> . header
    (55) simple -> . declaration
    (56) simple -> . SEMICOLON
    (57) simple -> . function
    (58) simple -> . RETURN expr SEMICOLON
    (59) simple -> . RETURN SEMICOLON
    (49) block -> . left_flower multiple_statements right_flower
    (50) block -> . left_flower right_flower
    (10) for -> . FOR
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) open -> . for for_condition open
    (91) expr -> . expr assignment exprOR
    (92) expr -> . exprOR
    (60) header -> . HASH INCLUDE STRING
    (61) header -> . HASH INCLUDE HEADER_FILE
    (34) declaration -> . TYPE ID SEMICOLON
    (35) declaration -> . TYPE MULTIPLY ID SEMICOLON
    (36) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (37) declaration -> . TYPE MULTIPLY ID ASSIGN expr SEMICOLON
    (38) declaration -> . TYPE multi_declaration stop
    (39) declaration -> . TYPE ID narrayindex SEMICOLON
    (40) declaration -> . TYPE ID narrayindex ASSIGN init_list SEMICOLON
    (88) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (51) left_flower -> . L_FLOWBRACE
    (104) exprOR -> . exprOR OR exprAND
    (105) exprOR -> . exprAND
    (106) exprAND -> . exprAND AND exprBITOR
    (107) exprAND -> . exprBITOR
    (108) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (109) exprBITOR -> . exprBITXOR
    (110) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (111) exprBITXOR -> . exprBITAND
    (112) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (113) exprBITAND -> . exprEQ
    (114) exprEQ -> . exprEQ EQ exprRELOP
    (115) exprEQ -> . exprEQ NE exprRELOP
    (116) exprEQ -> . exprRELOP
    (117) exprRELOP -> . exprRELOP relop exprSHIFT
    (118) exprRELOP -> . exprSHIFT
    (123) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (124) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (125) exprSHIFT -> . exprOP
    (126) exprOP -> . exprOP PLUS term
    (127) exprOP -> . exprOP MINUS term
    (128) exprOP -> . term
    (129) term -> . term MULTIPLY factor
    (130) term -> . term DIVIDE factor
    (131) term -> . term MOD factor
    (132) term -> . factor
    (133) factor -> . NOT factor
    (134) factor -> . PLUS factor
    (135) factor -> . MINUS factor
    (136) factor -> . PLUS_PLUS factor
    (137) factor -> . MINUS_MINUS factor
    (138) factor -> . cast brace
    (139) factor -> . brace
    (140) cast -> . L_PAREN TYPE R_PAREN
    (141) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (142) brace -> . L_PAREN expr R_PAREN
    (143) brace -> . brace PLUS_PLUS
    (144) brace -> . brace MINUS_MINUS
    (145) brace -> . NUM
    (146) brace -> . STRING
    (147) brace -> . MULTIPLY ID
    (148) brace -> . BIT_AND ID
    (149) brace -> . ID
    (150) brace -> . CHAR
    (151) brace -> . function_call
    (152) brace -> . ID narrayindex
    (153) NUM -> . INT_NUM
    (154) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    IF              shift and go to state 114
    WHILE           shift and go to state 117
    SEMICOLON       shift and go to state 13
    RETURN          shift and go to state 17
    FOR             shift and go to state 11
    HASH            shift and go to state 20
    TYPE            shift and go to state 22
    L_FLOWBRACE     shift and go to state 26
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    closed                         shift and go to state 193
    statement                      shift and go to state 115
    open                           shift and go to state 4
    simple                         shift and go to state 9
    block                          shift and go to state 10
    for                            shift and go to state 118
    expr                           shift and go to state 12
    header                         shift and go to state 14
    declaration                    shift and go to state 15
    function                       shift and go to state 16
    left_flower                    shift and go to state 18
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 167

    (7) open -> IF condition closed ELSE . open
    (13) closed -> IF condition closed ELSE . closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) open -> . for for_condition open
    (11) closed -> . simple
    (12) closed -> . block
    (13) closed -> . IF condition closed ELSE closed
    (14) closed -> . WHILE condition closed
    (15) closed -> . for for_condition closed
    (10) for -> . FOR
    (53) simple -> . expr SEMICOLON
    (54) simple -> . header
    (55) simple -> . declaration
    (56) simple -> . SEMICOLON
    (57) simple -> . function
    (58) simple -> . RETURN expr SEMICOLON
    (59) simple -> . RETURN SEMICOLON
    (49) block -> . left_flower multiple_statements right_flower
    (50) block -> . left_flower right_flower
    (91) expr -> . expr assignment exprOR
    (92) expr -> . exprOR
    (60) header -> . HASH INCLUDE STRING
    (61) header -> . HASH INCLUDE HEADER_FILE
    (34) declaration -> . TYPE ID SEMICOLON
    (35) declaration -> . TYPE MULTIPLY ID SEMICOLON
    (36) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (37) declaration -> . TYPE MULTIPLY ID ASSIGN expr SEMICOLON
    (38) declaration -> . TYPE multi_declaration stop
    (39) declaration -> . TYPE ID narrayindex SEMICOLON
    (40) declaration -> . TYPE ID narrayindex ASSIGN init_list SEMICOLON
    (88) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (51) left_flower -> . L_FLOWBRACE
    (104) exprOR -> . exprOR OR exprAND
    (105) exprOR -> . exprAND
    (106) exprAND -> . exprAND AND exprBITOR
    (107) exprAND -> . exprBITOR
    (108) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (109) exprBITOR -> . exprBITXOR
    (110) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (111) exprBITXOR -> . exprBITAND
    (112) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (113) exprBITAND -> . exprEQ
    (114) exprEQ -> . exprEQ EQ exprRELOP
    (115) exprEQ -> . exprEQ NE exprRELOP
    (116) exprEQ -> . exprRELOP
    (117) exprRELOP -> . exprRELOP relop exprSHIFT
    (118) exprRELOP -> . exprSHIFT
    (123) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (124) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (125) exprSHIFT -> . exprOP
    (126) exprOP -> . exprOP PLUS term
    (127) exprOP -> . exprOP MINUS term
    (128) exprOP -> . term
    (129) term -> . term MULTIPLY factor
    (130) term -> . term DIVIDE factor
    (131) term -> . term MOD factor
    (132) term -> . factor
    (133) factor -> . NOT factor
    (134) factor -> . PLUS factor
    (135) factor -> . MINUS factor
    (136) factor -> . PLUS_PLUS factor
    (137) factor -> . MINUS_MINUS factor
    (138) factor -> . cast brace
    (139) factor -> . brace
    (140) cast -> . L_PAREN TYPE R_PAREN
    (141) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (142) brace -> . L_PAREN expr R_PAREN
    (143) brace -> . brace PLUS_PLUS
    (144) brace -> . brace MINUS_MINUS
    (145) brace -> . NUM
    (146) brace -> . STRING
    (147) brace -> . MULTIPLY ID
    (148) brace -> . BIT_AND ID
    (149) brace -> . ID
    (150) brace -> . CHAR
    (151) brace -> . function_call
    (152) brace -> . ID narrayindex
    (153) NUM -> . INT_NUM
    (154) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    IF              shift and go to state 6
    WHILE           shift and go to state 7
    FOR             shift and go to state 11
    SEMICOLON       shift and go to state 13
    RETURN          shift and go to state 17
    HASH            shift and go to state 20
    TYPE            shift and go to state 22
    L_FLOWBRACE     shift and go to state 26
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    closed                         shift and go to state 194
    open                           shift and go to state 195
    for                            shift and go to state 8
    simple                         shift and go to state 9
    block                          shift and go to state 10
    expr                           shift and go to state 12
    header                         shift and go to state 14
    declaration                    shift and go to state 15
    function                       shift and go to state 16
    left_flower                    shift and go to state 18
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 168

    (14) closed -> WHILE condition . closed
    (8) open -> WHILE condition . open
    (11) closed -> . simple
    (12) closed -> . block
    (13) closed -> . IF condition closed ELSE closed
    (14) closed -> . WHILE condition closed
    (15) closed -> . for for_condition closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) open -> . for for_condition open
    (53) simple -> . expr SEMICOLON
    (54) simple -> . header
    (55) simple -> . declaration
    (56) simple -> . SEMICOLON
    (57) simple -> . function
    (58) simple -> . RETURN expr SEMICOLON
    (59) simple -> . RETURN SEMICOLON
    (49) block -> . left_flower multiple_statements right_flower
    (50) block -> . left_flower right_flower
    (10) for -> . FOR
    (91) expr -> . expr assignment exprOR
    (92) expr -> . exprOR
    (60) header -> . HASH INCLUDE STRING
    (61) header -> . HASH INCLUDE HEADER_FILE
    (34) declaration -> . TYPE ID SEMICOLON
    (35) declaration -> . TYPE MULTIPLY ID SEMICOLON
    (36) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (37) declaration -> . TYPE MULTIPLY ID ASSIGN expr SEMICOLON
    (38) declaration -> . TYPE multi_declaration stop
    (39) declaration -> . TYPE ID narrayindex SEMICOLON
    (40) declaration -> . TYPE ID narrayindex ASSIGN init_list SEMICOLON
    (88) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (51) left_flower -> . L_FLOWBRACE
    (104) exprOR -> . exprOR OR exprAND
    (105) exprOR -> . exprAND
    (106) exprAND -> . exprAND AND exprBITOR
    (107) exprAND -> . exprBITOR
    (108) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (109) exprBITOR -> . exprBITXOR
    (110) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (111) exprBITXOR -> . exprBITAND
    (112) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (113) exprBITAND -> . exprEQ
    (114) exprEQ -> . exprEQ EQ exprRELOP
    (115) exprEQ -> . exprEQ NE exprRELOP
    (116) exprEQ -> . exprRELOP
    (117) exprRELOP -> . exprRELOP relop exprSHIFT
    (118) exprRELOP -> . exprSHIFT
    (123) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (124) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (125) exprSHIFT -> . exprOP
    (126) exprOP -> . exprOP PLUS term
    (127) exprOP -> . exprOP MINUS term
    (128) exprOP -> . term
    (129) term -> . term MULTIPLY factor
    (130) term -> . term DIVIDE factor
    (131) term -> . term MOD factor
    (132) term -> . factor
    (133) factor -> . NOT factor
    (134) factor -> . PLUS factor
    (135) factor -> . MINUS factor
    (136) factor -> . PLUS_PLUS factor
    (137) factor -> . MINUS_MINUS factor
    (138) factor -> . cast brace
    (139) factor -> . brace
    (140) cast -> . L_PAREN TYPE R_PAREN
    (141) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (142) brace -> . L_PAREN expr R_PAREN
    (143) brace -> . brace PLUS_PLUS
    (144) brace -> . brace MINUS_MINUS
    (145) brace -> . NUM
    (146) brace -> . STRING
    (147) brace -> . MULTIPLY ID
    (148) brace -> . BIT_AND ID
    (149) brace -> . ID
    (150) brace -> . CHAR
    (151) brace -> . function_call
    (152) brace -> . ID narrayindex
    (153) NUM -> . INT_NUM
    (154) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    IF              shift and go to state 114
    WHILE           shift and go to state 117
    SEMICOLON       shift and go to state 13
    RETURN          shift and go to state 17
    FOR             shift and go to state 11
    HASH            shift and go to state 20
    TYPE            shift and go to state 22
    L_FLOWBRACE     shift and go to state 26
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    closed                         shift and go to state 121
    open                           shift and go to state 120
    simple                         shift and go to state 9
    block                          shift and go to state 10
    for                            shift and go to state 118
    expr                           shift and go to state 12
    header                         shift and go to state 14
    declaration                    shift and go to state 15
    function                       shift and go to state 16
    left_flower                    shift and go to state 18
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 169

    (15) closed -> for for_condition . closed
    (9) open -> for for_condition . open
    (11) closed -> . simple
    (12) closed -> . block
    (13) closed -> . IF condition closed ELSE closed
    (14) closed -> . WHILE condition closed
    (15) closed -> . for for_condition closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) open -> . for for_condition open
    (53) simple -> . expr SEMICOLON
    (54) simple -> . header
    (55) simple -> . declaration
    (56) simple -> . SEMICOLON
    (57) simple -> . function
    (58) simple -> . RETURN expr SEMICOLON
    (59) simple -> . RETURN SEMICOLON
    (49) block -> . left_flower multiple_statements right_flower
    (50) block -> . left_flower right_flower
    (10) for -> . FOR
    (91) expr -> . expr assignment exprOR
    (92) expr -> . exprOR
    (60) header -> . HASH INCLUDE STRING
    (61) header -> . HASH INCLUDE HEADER_FILE
    (34) declaration -> . TYPE ID SEMICOLON
    (35) declaration -> . TYPE MULTIPLY ID SEMICOLON
    (36) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (37) declaration -> . TYPE MULTIPLY ID ASSIGN expr SEMICOLON
    (38) declaration -> . TYPE multi_declaration stop
    (39) declaration -> . TYPE ID narrayindex SEMICOLON
    (40) declaration -> . TYPE ID narrayindex ASSIGN init_list SEMICOLON
    (88) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (51) left_flower -> . L_FLOWBRACE
    (104) exprOR -> . exprOR OR exprAND
    (105) exprOR -> . exprAND
    (106) exprAND -> . exprAND AND exprBITOR
    (107) exprAND -> . exprBITOR
    (108) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (109) exprBITOR -> . exprBITXOR
    (110) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (111) exprBITXOR -> . exprBITAND
    (112) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (113) exprBITAND -> . exprEQ
    (114) exprEQ -> . exprEQ EQ exprRELOP
    (115) exprEQ -> . exprEQ NE exprRELOP
    (116) exprEQ -> . exprRELOP
    (117) exprRELOP -> . exprRELOP relop exprSHIFT
    (118) exprRELOP -> . exprSHIFT
    (123) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (124) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (125) exprSHIFT -> . exprOP
    (126) exprOP -> . exprOP PLUS term
    (127) exprOP -> . exprOP MINUS term
    (128) exprOP -> . term
    (129) term -> . term MULTIPLY factor
    (130) term -> . term DIVIDE factor
    (131) term -> . term MOD factor
    (132) term -> . factor
    (133) factor -> . NOT factor
    (134) factor -> . PLUS factor
    (135) factor -> . MINUS factor
    (136) factor -> . PLUS_PLUS factor
    (137) factor -> . MINUS_MINUS factor
    (138) factor -> . cast brace
    (139) factor -> . brace
    (140) cast -> . L_PAREN TYPE R_PAREN
    (141) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (142) brace -> . L_PAREN expr R_PAREN
    (143) brace -> . brace PLUS_PLUS
    (144) brace -> . brace MINUS_MINUS
    (145) brace -> . NUM
    (146) brace -> . STRING
    (147) brace -> . MULTIPLY ID
    (148) brace -> . BIT_AND ID
    (149) brace -> . ID
    (150) brace -> . CHAR
    (151) brace -> . function_call
    (152) brace -> . ID narrayindex
    (153) NUM -> . INT_NUM
    (154) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    IF              shift and go to state 114
    WHILE           shift and go to state 117
    SEMICOLON       shift and go to state 13
    RETURN          shift and go to state 17
    FOR             shift and go to state 11
    HASH            shift and go to state 20
    TYPE            shift and go to state 22
    L_FLOWBRACE     shift and go to state 26
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    for                            shift and go to state 118
    closed                         shift and go to state 123
    open                           shift and go to state 122
    simple                         shift and go to state 9
    block                          shift and go to state 10
    expr                           shift and go to state 12
    header                         shift and go to state 14
    declaration                    shift and go to state 15
    function                       shift and go to state 16
    left_flower                    shift and go to state 18
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 170

    (16) condition -> L_PAREN expr R_PAREN .

    IF              reduce using rule 16 (condition -> L_PAREN expr R_PAREN .)
    WHILE           reduce using rule 16 (condition -> L_PAREN expr R_PAREN .)
    SEMICOLON       reduce using rule 16 (condition -> L_PAREN expr R_PAREN .)
    RETURN          reduce using rule 16 (condition -> L_PAREN expr R_PAREN .)
    FOR             reduce using rule 16 (condition -> L_PAREN expr R_PAREN .)
    HASH            reduce using rule 16 (condition -> L_PAREN expr R_PAREN .)
    TYPE            reduce using rule 16 (condition -> L_PAREN expr R_PAREN .)
    L_FLOWBRACE     reduce using rule 16 (condition -> L_PAREN expr R_PAREN .)
    NOT             reduce using rule 16 (condition -> L_PAREN expr R_PAREN .)
    PLUS            reduce using rule 16 (condition -> L_PAREN expr R_PAREN .)
    MINUS           reduce using rule 16 (condition -> L_PAREN expr R_PAREN .)
    PLUS_PLUS       reduce using rule 16 (condition -> L_PAREN expr R_PAREN .)
    MINUS_MINUS     reduce using rule 16 (condition -> L_PAREN expr R_PAREN .)
    L_PAREN         reduce using rule 16 (condition -> L_PAREN expr R_PAREN .)
    STRING          reduce using rule 16 (condition -> L_PAREN expr R_PAREN .)
    MULTIPLY        reduce using rule 16 (condition -> L_PAREN expr R_PAREN .)
    BIT_AND         reduce using rule 16 (condition -> L_PAREN expr R_PAREN .)
    ID              reduce using rule 16 (condition -> L_PAREN expr R_PAREN .)
    CHAR            reduce using rule 16 (condition -> L_PAREN expr R_PAREN .)
    INT_NUM         reduce using rule 16 (condition -> L_PAREN expr R_PAREN .)
    FLOAT_NUM       reduce using rule 16 (condition -> L_PAREN expr R_PAREN .)


state 171

    (17) for_condition -> L_PAREN simple simple . expr R_PAREN
    (18) for_condition -> L_PAREN simple simple . R_PAREN
    (91) expr -> . expr assignment exprOR
    (92) expr -> . exprOR
    (104) exprOR -> . exprOR OR exprAND
    (105) exprOR -> . exprAND
    (106) exprAND -> . exprAND AND exprBITOR
    (107) exprAND -> . exprBITOR
    (108) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (109) exprBITOR -> . exprBITXOR
    (110) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (111) exprBITXOR -> . exprBITAND
    (112) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (113) exprBITAND -> . exprEQ
    (114) exprEQ -> . exprEQ EQ exprRELOP
    (115) exprEQ -> . exprEQ NE exprRELOP
    (116) exprEQ -> . exprRELOP
    (117) exprRELOP -> . exprRELOP relop exprSHIFT
    (118) exprRELOP -> . exprSHIFT
    (123) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (124) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (125) exprSHIFT -> . exprOP
    (126) exprOP -> . exprOP PLUS term
    (127) exprOP -> . exprOP MINUS term
    (128) exprOP -> . term
    (129) term -> . term MULTIPLY factor
    (130) term -> . term DIVIDE factor
    (131) term -> . term MOD factor
    (132) term -> . factor
    (133) factor -> . NOT factor
    (134) factor -> . PLUS factor
    (135) factor -> . MINUS factor
    (136) factor -> . PLUS_PLUS factor
    (137) factor -> . MINUS_MINUS factor
    (138) factor -> . cast brace
    (139) factor -> . brace
    (140) cast -> . L_PAREN TYPE R_PAREN
    (141) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (142) brace -> . L_PAREN expr R_PAREN
    (143) brace -> . brace PLUS_PLUS
    (144) brace -> . brace MINUS_MINUS
    (145) brace -> . NUM
    (146) brace -> . STRING
    (147) brace -> . MULTIPLY ID
    (148) brace -> . BIT_AND ID
    (149) brace -> . ID
    (150) brace -> . CHAR
    (151) brace -> . function_call
    (152) brace -> . ID narrayindex
    (153) NUM -> . INT_NUM
    (154) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    R_PAREN         shift and go to state 197
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    expr                           shift and go to state 196
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 172

    (36) declaration -> TYPE ID ASSIGN expr . SEMICOLON
    (24) multi_declaration -> ID ASSIGN expr . COMMA
    (91) expr -> expr . assignment exprOR
    (93) assignment -> . ASSIGN
    (94) assignment -> . PLUS_ASSIGN
    (95) assignment -> . MINUS_ASSIGN
    (96) assignment -> . MUL_ASSIGN
    (97) assignment -> . DIV_ASSIGN
    (98) assignment -> . AND_ASSIGN
    (99) assignment -> . OR_ASSIGN
    (100) assignment -> . XOR_ASSIGN
    (101) assignment -> . MOD_ASSIGN
    (102) assignment -> . L_SHIFT_ASSIGN
    (103) assignment -> . R_SHIFT_ASSIGN

    SEMICOLON       shift and go to state 198
    COMMA           shift and go to state 199
    ASSIGN          shift and go to state 58
    PLUS_ASSIGN     shift and go to state 59
    MINUS_ASSIGN    shift and go to state 60
    MUL_ASSIGN      shift and go to state 61
    DIV_ASSIGN      shift and go to state 62
    AND_ASSIGN      shift and go to state 63
    OR_ASSIGN       shift and go to state 64
    XOR_ASSIGN      shift and go to state 65
    MOD_ASSIGN      shift and go to state 66
    L_SHIFT_ASSIGN  shift and go to state 67
    R_SHIFT_ASSIGN  shift and go to state 68

    assignment                     shift and go to state 57

state 173

    (39) declaration -> TYPE ID narrayindex SEMICOLON .

    IF              reduce using rule 39 (declaration -> TYPE ID narrayindex SEMICOLON .)
    WHILE           reduce using rule 39 (declaration -> TYPE ID narrayindex SEMICOLON .)
    FOR             reduce using rule 39 (declaration -> TYPE ID narrayindex SEMICOLON .)
    SEMICOLON       reduce using rule 39 (declaration -> TYPE ID narrayindex SEMICOLON .)
    RETURN          reduce using rule 39 (declaration -> TYPE ID narrayindex SEMICOLON .)
    HASH            reduce using rule 39 (declaration -> TYPE ID narrayindex SEMICOLON .)
    TYPE            reduce using rule 39 (declaration -> TYPE ID narrayindex SEMICOLON .)
    L_FLOWBRACE     reduce using rule 39 (declaration -> TYPE ID narrayindex SEMICOLON .)
    NOT             reduce using rule 39 (declaration -> TYPE ID narrayindex SEMICOLON .)
    PLUS            reduce using rule 39 (declaration -> TYPE ID narrayindex SEMICOLON .)
    MINUS           reduce using rule 39 (declaration -> TYPE ID narrayindex SEMICOLON .)
    PLUS_PLUS       reduce using rule 39 (declaration -> TYPE ID narrayindex SEMICOLON .)
    MINUS_MINUS     reduce using rule 39 (declaration -> TYPE ID narrayindex SEMICOLON .)
    L_PAREN         reduce using rule 39 (declaration -> TYPE ID narrayindex SEMICOLON .)
    STRING          reduce using rule 39 (declaration -> TYPE ID narrayindex SEMICOLON .)
    MULTIPLY        reduce using rule 39 (declaration -> TYPE ID narrayindex SEMICOLON .)
    BIT_AND         reduce using rule 39 (declaration -> TYPE ID narrayindex SEMICOLON .)
    ID              reduce using rule 39 (declaration -> TYPE ID narrayindex SEMICOLON .)
    CHAR            reduce using rule 39 (declaration -> TYPE ID narrayindex SEMICOLON .)
    INT_NUM         reduce using rule 39 (declaration -> TYPE ID narrayindex SEMICOLON .)
    FLOAT_NUM       reduce using rule 39 (declaration -> TYPE ID narrayindex SEMICOLON .)
    $end            reduce using rule 39 (declaration -> TYPE ID narrayindex SEMICOLON .)
    R_FLOWBRACE     reduce using rule 39 (declaration -> TYPE ID narrayindex SEMICOLON .)
    ELSE            reduce using rule 39 (declaration -> TYPE ID narrayindex SEMICOLON .)
    R_PAREN         reduce using rule 39 (declaration -> TYPE ID narrayindex SEMICOLON .)


state 174

    (40) declaration -> TYPE ID narrayindex ASSIGN . init_list SEMICOLON
    (43) init_list -> . L_FLOWBRACE init_list R_FLOWBRACE COMMA init_list
    (44) init_list -> . L_FLOWBRACE init R_FLOWBRACE COMMA init_list
    (45) init_list -> . L_FLOWBRACE init R_FLOWBRACE
    (46) init_list -> . L_FLOWBRACE init_list R_FLOWBRACE

    L_FLOWBRACE     shift and go to state 201

    init_list                      shift and go to state 200

state 175

    (75) yes_dec_params -> TYPE . ID COMMA
    (76) yes_dec_params -> TYPE . MULTIPLY ID COMMA
    (77) yes_dec_params -> TYPE . COMMA
    (78) yes_dec_params -> TYPE . MULTIPLY COMMA
    (79) yes_dec_params -> TYPE . ID ASSIGN NUM COMMA
    (80) end_dec_params -> TYPE . ID
    (81) end_dec_params -> TYPE . ID ASSIGN NUM
    (82) end_dec_params -> TYPE .
    (83) end_dec_params -> TYPE . MULTIPLY ID
    (84) end_dec_params -> TYPE . MULTIPLY

    ID              shift and go to state 202
    MULTIPLY        shift and go to state 204
    COMMA           shift and go to state 203
    R_PAREN         reduce using rule 82 (end_dec_params -> TYPE .)


state 176

    (88) function -> TYPE ID L_PAREN dec_params . R_PAREN function_2

    R_PAREN         shift and go to state 205


state 177

    (85) dec_params -> empty .

    R_PAREN         reduce using rule 85 (dec_params -> empty .)


state 178

    (86) dec_params -> yes_dec_params . end_dec_params
    (70) yes_dec_params -> yes_dec_params . TYPE ID COMMA
    (71) yes_dec_params -> yes_dec_params . TYPE MULTIPLY ID COMMA
    (72) yes_dec_params -> yes_dec_params . TYPE COMMA
    (73) yes_dec_params -> yes_dec_params . TYPE MULTIPLY COMMA
    (74) yes_dec_params -> yes_dec_params . TYPE ID ASSIGN NUM COMMA
    (80) end_dec_params -> . TYPE ID
    (81) end_dec_params -> . TYPE ID ASSIGN NUM
    (82) end_dec_params -> . TYPE
    (83) end_dec_params -> . TYPE MULTIPLY ID
    (84) end_dec_params -> . TYPE MULTIPLY

    TYPE            shift and go to state 207

    end_dec_params                 shift and go to state 206

state 179

    (87) dec_params -> end_dec_params .

    R_PAREN         reduce using rule 87 (dec_params -> end_dec_params .)


state 180

    (35) declaration -> TYPE MULTIPLY ID SEMICOLON .

    IF              reduce using rule 35 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    WHILE           reduce using rule 35 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    FOR             reduce using rule 35 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    SEMICOLON       reduce using rule 35 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    RETURN          reduce using rule 35 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    HASH            reduce using rule 35 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    TYPE            reduce using rule 35 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    L_FLOWBRACE     reduce using rule 35 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    NOT             reduce using rule 35 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    PLUS            reduce using rule 35 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    MINUS           reduce using rule 35 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    PLUS_PLUS       reduce using rule 35 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    MINUS_MINUS     reduce using rule 35 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    L_PAREN         reduce using rule 35 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    STRING          reduce using rule 35 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    MULTIPLY        reduce using rule 35 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    BIT_AND         reduce using rule 35 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    ID              reduce using rule 35 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    CHAR            reduce using rule 35 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    INT_NUM         reduce using rule 35 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    FLOAT_NUM       reduce using rule 35 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    $end            reduce using rule 35 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    R_FLOWBRACE     reduce using rule 35 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    ELSE            reduce using rule 35 (declaration -> TYPE MULTIPLY ID SEMICOLON .)
    R_PAREN         reduce using rule 35 (declaration -> TYPE MULTIPLY ID SEMICOLON .)


state 181

    (37) declaration -> TYPE MULTIPLY ID ASSIGN . expr SEMICOLON
    (26) multi_declaration -> MULTIPLY ID ASSIGN . expr COMMA
    (91) expr -> . expr assignment exprOR
    (92) expr -> . exprOR
    (104) exprOR -> . exprOR OR exprAND
    (105) exprOR -> . exprAND
    (106) exprAND -> . exprAND AND exprBITOR
    (107) exprAND -> . exprBITOR
    (108) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (109) exprBITOR -> . exprBITXOR
    (110) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (111) exprBITXOR -> . exprBITAND
    (112) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (113) exprBITAND -> . exprEQ
    (114) exprEQ -> . exprEQ EQ exprRELOP
    (115) exprEQ -> . exprEQ NE exprRELOP
    (116) exprEQ -> . exprRELOP
    (117) exprRELOP -> . exprRELOP relop exprSHIFT
    (118) exprRELOP -> . exprSHIFT
    (123) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (124) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (125) exprSHIFT -> . exprOP
    (126) exprOP -> . exprOP PLUS term
    (127) exprOP -> . exprOP MINUS term
    (128) exprOP -> . term
    (129) term -> . term MULTIPLY factor
    (130) term -> . term DIVIDE factor
    (131) term -> . term MOD factor
    (132) term -> . factor
    (133) factor -> . NOT factor
    (134) factor -> . PLUS factor
    (135) factor -> . MINUS factor
    (136) factor -> . PLUS_PLUS factor
    (137) factor -> . MINUS_MINUS factor
    (138) factor -> . cast brace
    (139) factor -> . brace
    (140) cast -> . L_PAREN TYPE R_PAREN
    (141) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (142) brace -> . L_PAREN expr R_PAREN
    (143) brace -> . brace PLUS_PLUS
    (144) brace -> . brace MINUS_MINUS
    (145) brace -> . NUM
    (146) brace -> . STRING
    (147) brace -> . MULTIPLY ID
    (148) brace -> . BIT_AND ID
    (149) brace -> . ID
    (150) brace -> . CHAR
    (151) brace -> . function_call
    (152) brace -> . ID narrayindex
    (153) NUM -> . INT_NUM
    (154) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    expr                           shift and go to state 208
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 182

    (25) multi_declaration -> MULTIPLY ID COMMA .

    ID              reduce using rule 25 (multi_declaration -> MULTIPLY ID COMMA .)
    MULTIPLY        reduce using rule 25 (multi_declaration -> MULTIPLY ID COMMA .)


state 183

    (19) multi_declaration -> multi_declaration ID COMMA .

    ID              reduce using rule 19 (multi_declaration -> multi_declaration ID COMMA .)
    MULTIPLY        reduce using rule 19 (multi_declaration -> multi_declaration ID COMMA .)


state 184

    (21) multi_declaration -> multi_declaration ID ASSIGN . expr COMMA
    (29) stop -> ID ASSIGN . expr SEMICOLON
    (91) expr -> . expr assignment exprOR
    (92) expr -> . exprOR
    (104) exprOR -> . exprOR OR exprAND
    (105) exprOR -> . exprAND
    (106) exprAND -> . exprAND AND exprBITOR
    (107) exprAND -> . exprBITOR
    (108) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (109) exprBITOR -> . exprBITXOR
    (110) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (111) exprBITXOR -> . exprBITAND
    (112) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (113) exprBITAND -> . exprEQ
    (114) exprEQ -> . exprEQ EQ exprRELOP
    (115) exprEQ -> . exprEQ NE exprRELOP
    (116) exprEQ -> . exprRELOP
    (117) exprRELOP -> . exprRELOP relop exprSHIFT
    (118) exprRELOP -> . exprSHIFT
    (123) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (124) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (125) exprSHIFT -> . exprOP
    (126) exprOP -> . exprOP PLUS term
    (127) exprOP -> . exprOP MINUS term
    (128) exprOP -> . term
    (129) term -> . term MULTIPLY factor
    (130) term -> . term DIVIDE factor
    (131) term -> . term MOD factor
    (132) term -> . factor
    (133) factor -> . NOT factor
    (134) factor -> . PLUS factor
    (135) factor -> . MINUS factor
    (136) factor -> . PLUS_PLUS factor
    (137) factor -> . MINUS_MINUS factor
    (138) factor -> . cast brace
    (139) factor -> . brace
    (140) cast -> . L_PAREN TYPE R_PAREN
    (141) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (142) brace -> . L_PAREN expr R_PAREN
    (143) brace -> . brace PLUS_PLUS
    (144) brace -> . brace MINUS_MINUS
    (145) brace -> . NUM
    (146) brace -> . STRING
    (147) brace -> . MULTIPLY ID
    (148) brace -> . BIT_AND ID
    (149) brace -> . ID
    (150) brace -> . CHAR
    (151) brace -> . function_call
    (152) brace -> . ID narrayindex
    (153) NUM -> . INT_NUM
    (154) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    expr                           shift and go to state 209
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 185

    (27) stop -> ID SEMICOLON .

    IF              reduce using rule 27 (stop -> ID SEMICOLON .)
    WHILE           reduce using rule 27 (stop -> ID SEMICOLON .)
    FOR             reduce using rule 27 (stop -> ID SEMICOLON .)
    SEMICOLON       reduce using rule 27 (stop -> ID SEMICOLON .)
    RETURN          reduce using rule 27 (stop -> ID SEMICOLON .)
    HASH            reduce using rule 27 (stop -> ID SEMICOLON .)
    TYPE            reduce using rule 27 (stop -> ID SEMICOLON .)
    L_FLOWBRACE     reduce using rule 27 (stop -> ID SEMICOLON .)
    NOT             reduce using rule 27 (stop -> ID SEMICOLON .)
    PLUS            reduce using rule 27 (stop -> ID SEMICOLON .)
    MINUS           reduce using rule 27 (stop -> ID SEMICOLON .)
    PLUS_PLUS       reduce using rule 27 (stop -> ID SEMICOLON .)
    MINUS_MINUS     reduce using rule 27 (stop -> ID SEMICOLON .)
    L_PAREN         reduce using rule 27 (stop -> ID SEMICOLON .)
    STRING          reduce using rule 27 (stop -> ID SEMICOLON .)
    MULTIPLY        reduce using rule 27 (stop -> ID SEMICOLON .)
    BIT_AND         reduce using rule 27 (stop -> ID SEMICOLON .)
    ID              reduce using rule 27 (stop -> ID SEMICOLON .)
    CHAR            reduce using rule 27 (stop -> ID SEMICOLON .)
    INT_NUM         reduce using rule 27 (stop -> ID SEMICOLON .)
    FLOAT_NUM       reduce using rule 27 (stop -> ID SEMICOLON .)
    $end            reduce using rule 27 (stop -> ID SEMICOLON .)
    R_FLOWBRACE     reduce using rule 27 (stop -> ID SEMICOLON .)
    ELSE            reduce using rule 27 (stop -> ID SEMICOLON .)
    R_PAREN         reduce using rule 27 (stop -> ID SEMICOLON .)


state 186

    (20) multi_declaration -> multi_declaration MULTIPLY ID . COMMA
    (22) multi_declaration -> multi_declaration MULTIPLY ID . ASSIGN expr COMMA
    (28) stop -> MULTIPLY ID . SEMICOLON
    (30) stop -> MULTIPLY ID . ASSIGN expr SEMICOLON

    COMMA           shift and go to state 210
    ASSIGN          shift and go to state 211
    SEMICOLON       shift and go to state 212


state 187

    (63) function_call -> ID L_PAREN call_params R_PAREN .

    PLUS_PLUS       reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    MINUS_MINUS     reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    MULTIPLY        reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    DIVIDE          reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    MOD             reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    PLUS            reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    MINUS           reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    L_SHIFT         reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    R_SHIFT         reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    LE              reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    LT              reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    GE              reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    GT              reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    EQ              reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    NE              reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    BIT_AND         reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    BIT_XOR         reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    BIT_OR          reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    AND             reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    OR              reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    SEMICOLON       reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    ASSIGN          reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    PLUS_ASSIGN     reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    MINUS_ASSIGN    reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    MUL_ASSIGN      reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    DIV_ASSIGN      reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    AND_ASSIGN      reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    OR_ASSIGN       reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    XOR_ASSIGN      reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    MOD_ASSIGN      reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    L_SHIFT_ASSIGN  reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    R_SHIFT_ASSIGN  reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    R_PAREN         reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    COMMA           reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    R_SQBRACE       reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)
    R_FLOWBRACE     reduce using rule 63 (function_call -> ID L_PAREN call_params R_PAREN .)


state 188

    (65) call_params -> yes_call_params end_call_params .

    R_PAREN         reduce using rule 65 (call_params -> yes_call_params end_call_params .)


state 189

    (67) yes_call_params -> yes_call_params expr . COMMA
    (69) end_call_params -> expr .
    (91) expr -> expr . assignment exprOR
    (93) assignment -> . ASSIGN
    (94) assignment -> . PLUS_ASSIGN
    (95) assignment -> . MINUS_ASSIGN
    (96) assignment -> . MUL_ASSIGN
    (97) assignment -> . DIV_ASSIGN
    (98) assignment -> . AND_ASSIGN
    (99) assignment -> . OR_ASSIGN
    (100) assignment -> . XOR_ASSIGN
    (101) assignment -> . MOD_ASSIGN
    (102) assignment -> . L_SHIFT_ASSIGN
    (103) assignment -> . R_SHIFT_ASSIGN

    COMMA           shift and go to state 213
    R_PAREN         reduce using rule 69 (end_call_params -> expr .)
    ASSIGN          shift and go to state 58
    PLUS_ASSIGN     shift and go to state 59
    MINUS_ASSIGN    shift and go to state 60
    MUL_ASSIGN      shift and go to state 61
    DIV_ASSIGN      shift and go to state 62
    AND_ASSIGN      shift and go to state 63
    OR_ASSIGN       shift and go to state 64
    XOR_ASSIGN      shift and go to state 65
    MOD_ASSIGN      shift and go to state 66
    L_SHIFT_ASSIGN  shift and go to state 67
    R_SHIFT_ASSIGN  shift and go to state 68

    assignment                     shift and go to state 57

state 190

    (68) yes_call_params -> expr COMMA .

    NOT             reduce using rule 68 (yes_call_params -> expr COMMA .)
    PLUS            reduce using rule 68 (yes_call_params -> expr COMMA .)
    MINUS           reduce using rule 68 (yes_call_params -> expr COMMA .)
    PLUS_PLUS       reduce using rule 68 (yes_call_params -> expr COMMA .)
    MINUS_MINUS     reduce using rule 68 (yes_call_params -> expr COMMA .)
    L_PAREN         reduce using rule 68 (yes_call_params -> expr COMMA .)
    STRING          reduce using rule 68 (yes_call_params -> expr COMMA .)
    MULTIPLY        reduce using rule 68 (yes_call_params -> expr COMMA .)
    BIT_AND         reduce using rule 68 (yes_call_params -> expr COMMA .)
    ID              reduce using rule 68 (yes_call_params -> expr COMMA .)
    CHAR            reduce using rule 68 (yes_call_params -> expr COMMA .)
    INT_NUM         reduce using rule 68 (yes_call_params -> expr COMMA .)
    FLOAT_NUM       reduce using rule 68 (yes_call_params -> expr COMMA .)


state 191

    (31) arrayindex -> L_SQBRACE index R_SQBRACE .

    L_SQBRACE       reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    PLUS_PLUS       reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    MINUS_MINUS     reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    MULTIPLY        reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    DIVIDE          reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    MOD             reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    PLUS            reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    MINUS           reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    L_SHIFT         reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    R_SHIFT         reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    LE              reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    LT              reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    GE              reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    GT              reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    EQ              reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    NE              reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    BIT_AND         reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    BIT_XOR         reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    BIT_OR          reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    AND             reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    OR              reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    SEMICOLON       reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    ASSIGN          reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    PLUS_ASSIGN     reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    MINUS_ASSIGN    reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    MUL_ASSIGN      reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    DIV_ASSIGN      reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    AND_ASSIGN      reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    OR_ASSIGN       reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    XOR_ASSIGN      reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    MOD_ASSIGN      reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    L_SHIFT_ASSIGN  reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    R_SHIFT_ASSIGN  reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    R_PAREN         reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    COMMA           reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    R_SQBRACE       reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)
    R_FLOWBRACE     reduce using rule 31 (arrayindex -> L_SQBRACE index R_SQBRACE .)


state 192

    (141) cast -> L_PAREN TYPE MULTIPLY R_PAREN .

    L_PAREN         reduce using rule 141 (cast -> L_PAREN TYPE MULTIPLY R_PAREN .)
    STRING          reduce using rule 141 (cast -> L_PAREN TYPE MULTIPLY R_PAREN .)
    MULTIPLY        reduce using rule 141 (cast -> L_PAREN TYPE MULTIPLY R_PAREN .)
    BIT_AND         reduce using rule 141 (cast -> L_PAREN TYPE MULTIPLY R_PAREN .)
    ID              reduce using rule 141 (cast -> L_PAREN TYPE MULTIPLY R_PAREN .)
    CHAR            reduce using rule 141 (cast -> L_PAREN TYPE MULTIPLY R_PAREN .)
    INT_NUM         reduce using rule 141 (cast -> L_PAREN TYPE MULTIPLY R_PAREN .)
    FLOAT_NUM       reduce using rule 141 (cast -> L_PAREN TYPE MULTIPLY R_PAREN .)


state 193

    (13) closed -> IF condition closed . ELSE closed
    (7) open -> IF condition closed . ELSE open
    (5) statement -> closed .

    ELSE            shift and go to state 214
    IF              reduce using rule 5 (statement -> closed .)
    WHILE           reduce using rule 5 (statement -> closed .)
    FOR             reduce using rule 5 (statement -> closed .)
    SEMICOLON       reduce using rule 5 (statement -> closed .)
    RETURN          reduce using rule 5 (statement -> closed .)
    HASH            reduce using rule 5 (statement -> closed .)
    TYPE            reduce using rule 5 (statement -> closed .)
    L_FLOWBRACE     reduce using rule 5 (statement -> closed .)
    NOT             reduce using rule 5 (statement -> closed .)
    PLUS            reduce using rule 5 (statement -> closed .)
    MINUS           reduce using rule 5 (statement -> closed .)
    PLUS_PLUS       reduce using rule 5 (statement -> closed .)
    MINUS_MINUS     reduce using rule 5 (statement -> closed .)
    L_PAREN         reduce using rule 5 (statement -> closed .)
    STRING          reduce using rule 5 (statement -> closed .)
    MULTIPLY        reduce using rule 5 (statement -> closed .)
    BIT_AND         reduce using rule 5 (statement -> closed .)
    ID              reduce using rule 5 (statement -> closed .)
    CHAR            reduce using rule 5 (statement -> closed .)
    INT_NUM         reduce using rule 5 (statement -> closed .)
    FLOAT_NUM       reduce using rule 5 (statement -> closed .)
    $end            reduce using rule 5 (statement -> closed .)
    R_FLOWBRACE     reduce using rule 5 (statement -> closed .)


state 194

    (13) closed -> IF condition closed ELSE closed .

    IF              reduce using rule 13 (closed -> IF condition closed ELSE closed .)
    WHILE           reduce using rule 13 (closed -> IF condition closed ELSE closed .)
    FOR             reduce using rule 13 (closed -> IF condition closed ELSE closed .)
    SEMICOLON       reduce using rule 13 (closed -> IF condition closed ELSE closed .)
    RETURN          reduce using rule 13 (closed -> IF condition closed ELSE closed .)
    HASH            reduce using rule 13 (closed -> IF condition closed ELSE closed .)
    TYPE            reduce using rule 13 (closed -> IF condition closed ELSE closed .)
    L_FLOWBRACE     reduce using rule 13 (closed -> IF condition closed ELSE closed .)
    NOT             reduce using rule 13 (closed -> IF condition closed ELSE closed .)
    PLUS            reduce using rule 13 (closed -> IF condition closed ELSE closed .)
    MINUS           reduce using rule 13 (closed -> IF condition closed ELSE closed .)
    PLUS_PLUS       reduce using rule 13 (closed -> IF condition closed ELSE closed .)
    MINUS_MINUS     reduce using rule 13 (closed -> IF condition closed ELSE closed .)
    L_PAREN         reduce using rule 13 (closed -> IF condition closed ELSE closed .)
    STRING          reduce using rule 13 (closed -> IF condition closed ELSE closed .)
    MULTIPLY        reduce using rule 13 (closed -> IF condition closed ELSE closed .)
    BIT_AND         reduce using rule 13 (closed -> IF condition closed ELSE closed .)
    ID              reduce using rule 13 (closed -> IF condition closed ELSE closed .)
    CHAR            reduce using rule 13 (closed -> IF condition closed ELSE closed .)
    INT_NUM         reduce using rule 13 (closed -> IF condition closed ELSE closed .)
    FLOAT_NUM       reduce using rule 13 (closed -> IF condition closed ELSE closed .)
    $end            reduce using rule 13 (closed -> IF condition closed ELSE closed .)
    R_FLOWBRACE     reduce using rule 13 (closed -> IF condition closed ELSE closed .)
    ELSE            reduce using rule 13 (closed -> IF condition closed ELSE closed .)


state 195

    (7) open -> IF condition closed ELSE open .

    IF              reduce using rule 7 (open -> IF condition closed ELSE open .)
    WHILE           reduce using rule 7 (open -> IF condition closed ELSE open .)
    FOR             reduce using rule 7 (open -> IF condition closed ELSE open .)
    SEMICOLON       reduce using rule 7 (open -> IF condition closed ELSE open .)
    RETURN          reduce using rule 7 (open -> IF condition closed ELSE open .)
    HASH            reduce using rule 7 (open -> IF condition closed ELSE open .)
    TYPE            reduce using rule 7 (open -> IF condition closed ELSE open .)
    L_FLOWBRACE     reduce using rule 7 (open -> IF condition closed ELSE open .)
    NOT             reduce using rule 7 (open -> IF condition closed ELSE open .)
    PLUS            reduce using rule 7 (open -> IF condition closed ELSE open .)
    MINUS           reduce using rule 7 (open -> IF condition closed ELSE open .)
    PLUS_PLUS       reduce using rule 7 (open -> IF condition closed ELSE open .)
    MINUS_MINUS     reduce using rule 7 (open -> IF condition closed ELSE open .)
    L_PAREN         reduce using rule 7 (open -> IF condition closed ELSE open .)
    STRING          reduce using rule 7 (open -> IF condition closed ELSE open .)
    MULTIPLY        reduce using rule 7 (open -> IF condition closed ELSE open .)
    BIT_AND         reduce using rule 7 (open -> IF condition closed ELSE open .)
    ID              reduce using rule 7 (open -> IF condition closed ELSE open .)
    CHAR            reduce using rule 7 (open -> IF condition closed ELSE open .)
    INT_NUM         reduce using rule 7 (open -> IF condition closed ELSE open .)
    FLOAT_NUM       reduce using rule 7 (open -> IF condition closed ELSE open .)
    $end            reduce using rule 7 (open -> IF condition closed ELSE open .)
    R_FLOWBRACE     reduce using rule 7 (open -> IF condition closed ELSE open .)


state 196

    (17) for_condition -> L_PAREN simple simple expr . R_PAREN
    (91) expr -> expr . assignment exprOR
    (93) assignment -> . ASSIGN
    (94) assignment -> . PLUS_ASSIGN
    (95) assignment -> . MINUS_ASSIGN
    (96) assignment -> . MUL_ASSIGN
    (97) assignment -> . DIV_ASSIGN
    (98) assignment -> . AND_ASSIGN
    (99) assignment -> . OR_ASSIGN
    (100) assignment -> . XOR_ASSIGN
    (101) assignment -> . MOD_ASSIGN
    (102) assignment -> . L_SHIFT_ASSIGN
    (103) assignment -> . R_SHIFT_ASSIGN

    R_PAREN         shift and go to state 215
    ASSIGN          shift and go to state 58
    PLUS_ASSIGN     shift and go to state 59
    MINUS_ASSIGN    shift and go to state 60
    MUL_ASSIGN      shift and go to state 61
    DIV_ASSIGN      shift and go to state 62
    AND_ASSIGN      shift and go to state 63
    OR_ASSIGN       shift and go to state 64
    XOR_ASSIGN      shift and go to state 65
    MOD_ASSIGN      shift and go to state 66
    L_SHIFT_ASSIGN  shift and go to state 67
    R_SHIFT_ASSIGN  shift and go to state 68

    assignment                     shift and go to state 57

state 197

    (18) for_condition -> L_PAREN simple simple R_PAREN .

    IF              reduce using rule 18 (for_condition -> L_PAREN simple simple R_PAREN .)
    WHILE           reduce using rule 18 (for_condition -> L_PAREN simple simple R_PAREN .)
    FOR             reduce using rule 18 (for_condition -> L_PAREN simple simple R_PAREN .)
    SEMICOLON       reduce using rule 18 (for_condition -> L_PAREN simple simple R_PAREN .)
    RETURN          reduce using rule 18 (for_condition -> L_PAREN simple simple R_PAREN .)
    HASH            reduce using rule 18 (for_condition -> L_PAREN simple simple R_PAREN .)
    TYPE            reduce using rule 18 (for_condition -> L_PAREN simple simple R_PAREN .)
    L_FLOWBRACE     reduce using rule 18 (for_condition -> L_PAREN simple simple R_PAREN .)
    NOT             reduce using rule 18 (for_condition -> L_PAREN simple simple R_PAREN .)
    PLUS            reduce using rule 18 (for_condition -> L_PAREN simple simple R_PAREN .)
    MINUS           reduce using rule 18 (for_condition -> L_PAREN simple simple R_PAREN .)
    PLUS_PLUS       reduce using rule 18 (for_condition -> L_PAREN simple simple R_PAREN .)
    MINUS_MINUS     reduce using rule 18 (for_condition -> L_PAREN simple simple R_PAREN .)
    L_PAREN         reduce using rule 18 (for_condition -> L_PAREN simple simple R_PAREN .)
    STRING          reduce using rule 18 (for_condition -> L_PAREN simple simple R_PAREN .)
    MULTIPLY        reduce using rule 18 (for_condition -> L_PAREN simple simple R_PAREN .)
    BIT_AND         reduce using rule 18 (for_condition -> L_PAREN simple simple R_PAREN .)
    ID              reduce using rule 18 (for_condition -> L_PAREN simple simple R_PAREN .)
    CHAR            reduce using rule 18 (for_condition -> L_PAREN simple simple R_PAREN .)
    INT_NUM         reduce using rule 18 (for_condition -> L_PAREN simple simple R_PAREN .)
    FLOAT_NUM       reduce using rule 18 (for_condition -> L_PAREN simple simple R_PAREN .)


state 198

    (36) declaration -> TYPE ID ASSIGN expr SEMICOLON .

    IF              reduce using rule 36 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    WHILE           reduce using rule 36 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    FOR             reduce using rule 36 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    SEMICOLON       reduce using rule 36 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    RETURN          reduce using rule 36 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    HASH            reduce using rule 36 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    TYPE            reduce using rule 36 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    L_FLOWBRACE     reduce using rule 36 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    NOT             reduce using rule 36 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    PLUS            reduce using rule 36 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    MINUS           reduce using rule 36 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    PLUS_PLUS       reduce using rule 36 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    MINUS_MINUS     reduce using rule 36 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    L_PAREN         reduce using rule 36 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    STRING          reduce using rule 36 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    MULTIPLY        reduce using rule 36 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    BIT_AND         reduce using rule 36 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    ID              reduce using rule 36 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    CHAR            reduce using rule 36 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    INT_NUM         reduce using rule 36 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    FLOAT_NUM       reduce using rule 36 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    $end            reduce using rule 36 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    R_FLOWBRACE     reduce using rule 36 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    ELSE            reduce using rule 36 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    R_PAREN         reduce using rule 36 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)


state 199

    (24) multi_declaration -> ID ASSIGN expr COMMA .

    ID              reduce using rule 24 (multi_declaration -> ID ASSIGN expr COMMA .)
    MULTIPLY        reduce using rule 24 (multi_declaration -> ID ASSIGN expr COMMA .)


state 200

    (40) declaration -> TYPE ID narrayindex ASSIGN init_list . SEMICOLON

    SEMICOLON       shift and go to state 216


state 201

    (43) init_list -> L_FLOWBRACE . init_list R_FLOWBRACE COMMA init_list
    (44) init_list -> L_FLOWBRACE . init R_FLOWBRACE COMMA init_list
    (45) init_list -> L_FLOWBRACE . init R_FLOWBRACE
    (46) init_list -> L_FLOWBRACE . init_list R_FLOWBRACE
    (43) init_list -> . L_FLOWBRACE init_list R_FLOWBRACE COMMA init_list
    (44) init_list -> . L_FLOWBRACE init R_FLOWBRACE COMMA init_list
    (45) init_list -> . L_FLOWBRACE init R_FLOWBRACE
    (46) init_list -> . L_FLOWBRACE init_list R_FLOWBRACE
    (41) init -> . expr COMMA init
    (42) init -> . expr
    (91) expr -> . expr assignment exprOR
    (92) expr -> . exprOR
    (104) exprOR -> . exprOR OR exprAND
    (105) exprOR -> . exprAND
    (106) exprAND -> . exprAND AND exprBITOR
    (107) exprAND -> . exprBITOR
    (108) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (109) exprBITOR -> . exprBITXOR
    (110) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (111) exprBITXOR -> . exprBITAND
    (112) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (113) exprBITAND -> . exprEQ
    (114) exprEQ -> . exprEQ EQ exprRELOP
    (115) exprEQ -> . exprEQ NE exprRELOP
    (116) exprEQ -> . exprRELOP
    (117) exprRELOP -> . exprRELOP relop exprSHIFT
    (118) exprRELOP -> . exprSHIFT
    (123) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (124) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (125) exprSHIFT -> . exprOP
    (126) exprOP -> . exprOP PLUS term
    (127) exprOP -> . exprOP MINUS term
    (128) exprOP -> . term
    (129) term -> . term MULTIPLY factor
    (130) term -> . term DIVIDE factor
    (131) term -> . term MOD factor
    (132) term -> . factor
    (133) factor -> . NOT factor
    (134) factor -> . PLUS factor
    (135) factor -> . MINUS factor
    (136) factor -> . PLUS_PLUS factor
    (137) factor -> . MINUS_MINUS factor
    (138) factor -> . cast brace
    (139) factor -> . brace
    (140) cast -> . L_PAREN TYPE R_PAREN
    (141) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (142) brace -> . L_PAREN expr R_PAREN
    (143) brace -> . brace PLUS_PLUS
    (144) brace -> . brace MINUS_MINUS
    (145) brace -> . NUM
    (146) brace -> . STRING
    (147) brace -> . MULTIPLY ID
    (148) brace -> . BIT_AND ID
    (149) brace -> . ID
    (150) brace -> . CHAR
    (151) brace -> . function_call
    (152) brace -> . ID narrayindex
    (153) NUM -> . INT_NUM
    (154) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    L_FLOWBRACE     shift and go to state 201
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    init_list                      shift and go to state 217
    init                           shift and go to state 218
    expr                           shift and go to state 219
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 202

    (75) yes_dec_params -> TYPE ID . COMMA
    (79) yes_dec_params -> TYPE ID . ASSIGN NUM COMMA
    (80) end_dec_params -> TYPE ID .
    (81) end_dec_params -> TYPE ID . ASSIGN NUM

    COMMA           shift and go to state 220
    ASSIGN          shift and go to state 221
    R_PAREN         reduce using rule 80 (end_dec_params -> TYPE ID .)


state 203

    (77) yes_dec_params -> TYPE COMMA .

    TYPE            reduce using rule 77 (yes_dec_params -> TYPE COMMA .)


state 204

    (76) yes_dec_params -> TYPE MULTIPLY . ID COMMA
    (78) yes_dec_params -> TYPE MULTIPLY . COMMA
    (83) end_dec_params -> TYPE MULTIPLY . ID
    (84) end_dec_params -> TYPE MULTIPLY .

    ID              shift and go to state 222
    COMMA           shift and go to state 223
    R_PAREN         reduce using rule 84 (end_dec_params -> TYPE MULTIPLY .)


state 205

    (88) function -> TYPE ID L_PAREN dec_params R_PAREN . function_2
    (89) function_2 -> . SEMICOLON
    (90) function_2 -> . block
    (49) block -> . left_flower multiple_statements right_flower
    (50) block -> . left_flower right_flower
    (51) left_flower -> . L_FLOWBRACE

    SEMICOLON       shift and go to state 225
    L_FLOWBRACE     shift and go to state 26

    function_2                     shift and go to state 224
    block                          shift and go to state 226
    left_flower                    shift and go to state 18

state 206

    (86) dec_params -> yes_dec_params end_dec_params .

    R_PAREN         reduce using rule 86 (dec_params -> yes_dec_params end_dec_params .)


state 207

    (70) yes_dec_params -> yes_dec_params TYPE . ID COMMA
    (71) yes_dec_params -> yes_dec_params TYPE . MULTIPLY ID COMMA
    (72) yes_dec_params -> yes_dec_params TYPE . COMMA
    (73) yes_dec_params -> yes_dec_params TYPE . MULTIPLY COMMA
    (74) yes_dec_params -> yes_dec_params TYPE . ID ASSIGN NUM COMMA
    (80) end_dec_params -> TYPE . ID
    (81) end_dec_params -> TYPE . ID ASSIGN NUM
    (82) end_dec_params -> TYPE .
    (83) end_dec_params -> TYPE . MULTIPLY ID
    (84) end_dec_params -> TYPE . MULTIPLY

    ID              shift and go to state 227
    MULTIPLY        shift and go to state 229
    COMMA           shift and go to state 228
    R_PAREN         reduce using rule 82 (end_dec_params -> TYPE .)


state 208

    (37) declaration -> TYPE MULTIPLY ID ASSIGN expr . SEMICOLON
    (26) multi_declaration -> MULTIPLY ID ASSIGN expr . COMMA
    (91) expr -> expr . assignment exprOR
    (93) assignment -> . ASSIGN
    (94) assignment -> . PLUS_ASSIGN
    (95) assignment -> . MINUS_ASSIGN
    (96) assignment -> . MUL_ASSIGN
    (97) assignment -> . DIV_ASSIGN
    (98) assignment -> . AND_ASSIGN
    (99) assignment -> . OR_ASSIGN
    (100) assignment -> . XOR_ASSIGN
    (101) assignment -> . MOD_ASSIGN
    (102) assignment -> . L_SHIFT_ASSIGN
    (103) assignment -> . R_SHIFT_ASSIGN

    SEMICOLON       shift and go to state 230
    COMMA           shift and go to state 231
    ASSIGN          shift and go to state 58
    PLUS_ASSIGN     shift and go to state 59
    MINUS_ASSIGN    shift and go to state 60
    MUL_ASSIGN      shift and go to state 61
    DIV_ASSIGN      shift and go to state 62
    AND_ASSIGN      shift and go to state 63
    OR_ASSIGN       shift and go to state 64
    XOR_ASSIGN      shift and go to state 65
    MOD_ASSIGN      shift and go to state 66
    L_SHIFT_ASSIGN  shift and go to state 67
    R_SHIFT_ASSIGN  shift and go to state 68

    assignment                     shift and go to state 57

state 209

    (21) multi_declaration -> multi_declaration ID ASSIGN expr . COMMA
    (29) stop -> ID ASSIGN expr . SEMICOLON
    (91) expr -> expr . assignment exprOR
    (93) assignment -> . ASSIGN
    (94) assignment -> . PLUS_ASSIGN
    (95) assignment -> . MINUS_ASSIGN
    (96) assignment -> . MUL_ASSIGN
    (97) assignment -> . DIV_ASSIGN
    (98) assignment -> . AND_ASSIGN
    (99) assignment -> . OR_ASSIGN
    (100) assignment -> . XOR_ASSIGN
    (101) assignment -> . MOD_ASSIGN
    (102) assignment -> . L_SHIFT_ASSIGN
    (103) assignment -> . R_SHIFT_ASSIGN

    COMMA           shift and go to state 232
    SEMICOLON       shift and go to state 233
    ASSIGN          shift and go to state 58
    PLUS_ASSIGN     shift and go to state 59
    MINUS_ASSIGN    shift and go to state 60
    MUL_ASSIGN      shift and go to state 61
    DIV_ASSIGN      shift and go to state 62
    AND_ASSIGN      shift and go to state 63
    OR_ASSIGN       shift and go to state 64
    XOR_ASSIGN      shift and go to state 65
    MOD_ASSIGN      shift and go to state 66
    L_SHIFT_ASSIGN  shift and go to state 67
    R_SHIFT_ASSIGN  shift and go to state 68

    assignment                     shift and go to state 57

state 210

    (20) multi_declaration -> multi_declaration MULTIPLY ID COMMA .

    ID              reduce using rule 20 (multi_declaration -> multi_declaration MULTIPLY ID COMMA .)
    MULTIPLY        reduce using rule 20 (multi_declaration -> multi_declaration MULTIPLY ID COMMA .)


state 211

    (22) multi_declaration -> multi_declaration MULTIPLY ID ASSIGN . expr COMMA
    (30) stop -> MULTIPLY ID ASSIGN . expr SEMICOLON
    (91) expr -> . expr assignment exprOR
    (92) expr -> . exprOR
    (104) exprOR -> . exprOR OR exprAND
    (105) exprOR -> . exprAND
    (106) exprAND -> . exprAND AND exprBITOR
    (107) exprAND -> . exprBITOR
    (108) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (109) exprBITOR -> . exprBITXOR
    (110) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (111) exprBITXOR -> . exprBITAND
    (112) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (113) exprBITAND -> . exprEQ
    (114) exprEQ -> . exprEQ EQ exprRELOP
    (115) exprEQ -> . exprEQ NE exprRELOP
    (116) exprEQ -> . exprRELOP
    (117) exprRELOP -> . exprRELOP relop exprSHIFT
    (118) exprRELOP -> . exprSHIFT
    (123) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (124) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (125) exprSHIFT -> . exprOP
    (126) exprOP -> . exprOP PLUS term
    (127) exprOP -> . exprOP MINUS term
    (128) exprOP -> . term
    (129) term -> . term MULTIPLY factor
    (130) term -> . term DIVIDE factor
    (131) term -> . term MOD factor
    (132) term -> . factor
    (133) factor -> . NOT factor
    (134) factor -> . PLUS factor
    (135) factor -> . MINUS factor
    (136) factor -> . PLUS_PLUS factor
    (137) factor -> . MINUS_MINUS factor
    (138) factor -> . cast brace
    (139) factor -> . brace
    (140) cast -> . L_PAREN TYPE R_PAREN
    (141) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (142) brace -> . L_PAREN expr R_PAREN
    (143) brace -> . brace PLUS_PLUS
    (144) brace -> . brace MINUS_MINUS
    (145) brace -> . NUM
    (146) brace -> . STRING
    (147) brace -> . MULTIPLY ID
    (148) brace -> . BIT_AND ID
    (149) brace -> . ID
    (150) brace -> . CHAR
    (151) brace -> . function_call
    (152) brace -> . ID narrayindex
    (153) NUM -> . INT_NUM
    (154) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    expr                           shift and go to state 234
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 212

    (28) stop -> MULTIPLY ID SEMICOLON .

    IF              reduce using rule 28 (stop -> MULTIPLY ID SEMICOLON .)
    WHILE           reduce using rule 28 (stop -> MULTIPLY ID SEMICOLON .)
    FOR             reduce using rule 28 (stop -> MULTIPLY ID SEMICOLON .)
    SEMICOLON       reduce using rule 28 (stop -> MULTIPLY ID SEMICOLON .)
    RETURN          reduce using rule 28 (stop -> MULTIPLY ID SEMICOLON .)
    HASH            reduce using rule 28 (stop -> MULTIPLY ID SEMICOLON .)
    TYPE            reduce using rule 28 (stop -> MULTIPLY ID SEMICOLON .)
    L_FLOWBRACE     reduce using rule 28 (stop -> MULTIPLY ID SEMICOLON .)
    NOT             reduce using rule 28 (stop -> MULTIPLY ID SEMICOLON .)
    PLUS            reduce using rule 28 (stop -> MULTIPLY ID SEMICOLON .)
    MINUS           reduce using rule 28 (stop -> MULTIPLY ID SEMICOLON .)
    PLUS_PLUS       reduce using rule 28 (stop -> MULTIPLY ID SEMICOLON .)
    MINUS_MINUS     reduce using rule 28 (stop -> MULTIPLY ID SEMICOLON .)
    L_PAREN         reduce using rule 28 (stop -> MULTIPLY ID SEMICOLON .)
    STRING          reduce using rule 28 (stop -> MULTIPLY ID SEMICOLON .)
    MULTIPLY        reduce using rule 28 (stop -> MULTIPLY ID SEMICOLON .)
    BIT_AND         reduce using rule 28 (stop -> MULTIPLY ID SEMICOLON .)
    ID              reduce using rule 28 (stop -> MULTIPLY ID SEMICOLON .)
    CHAR            reduce using rule 28 (stop -> MULTIPLY ID SEMICOLON .)
    INT_NUM         reduce using rule 28 (stop -> MULTIPLY ID SEMICOLON .)
    FLOAT_NUM       reduce using rule 28 (stop -> MULTIPLY ID SEMICOLON .)
    $end            reduce using rule 28 (stop -> MULTIPLY ID SEMICOLON .)
    R_FLOWBRACE     reduce using rule 28 (stop -> MULTIPLY ID SEMICOLON .)
    ELSE            reduce using rule 28 (stop -> MULTIPLY ID SEMICOLON .)
    R_PAREN         reduce using rule 28 (stop -> MULTIPLY ID SEMICOLON .)


state 213

    (67) yes_call_params -> yes_call_params expr COMMA .

    NOT             reduce using rule 67 (yes_call_params -> yes_call_params expr COMMA .)
    PLUS            reduce using rule 67 (yes_call_params -> yes_call_params expr COMMA .)
    MINUS           reduce using rule 67 (yes_call_params -> yes_call_params expr COMMA .)
    PLUS_PLUS       reduce using rule 67 (yes_call_params -> yes_call_params expr COMMA .)
    MINUS_MINUS     reduce using rule 67 (yes_call_params -> yes_call_params expr COMMA .)
    L_PAREN         reduce using rule 67 (yes_call_params -> yes_call_params expr COMMA .)
    STRING          reduce using rule 67 (yes_call_params -> yes_call_params expr COMMA .)
    MULTIPLY        reduce using rule 67 (yes_call_params -> yes_call_params expr COMMA .)
    BIT_AND         reduce using rule 67 (yes_call_params -> yes_call_params expr COMMA .)
    ID              reduce using rule 67 (yes_call_params -> yes_call_params expr COMMA .)
    CHAR            reduce using rule 67 (yes_call_params -> yes_call_params expr COMMA .)
    INT_NUM         reduce using rule 67 (yes_call_params -> yes_call_params expr COMMA .)
    FLOAT_NUM       reduce using rule 67 (yes_call_params -> yes_call_params expr COMMA .)


state 214

    (13) closed -> IF condition closed ELSE . closed
    (7) open -> IF condition closed ELSE . open
    (11) closed -> . simple
    (12) closed -> . block
    (13) closed -> . IF condition closed ELSE closed
    (14) closed -> . WHILE condition closed
    (15) closed -> . for for_condition closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) open -> . for for_condition open
    (53) simple -> . expr SEMICOLON
    (54) simple -> . header
    (55) simple -> . declaration
    (56) simple -> . SEMICOLON
    (57) simple -> . function
    (58) simple -> . RETURN expr SEMICOLON
    (59) simple -> . RETURN SEMICOLON
    (49) block -> . left_flower multiple_statements right_flower
    (50) block -> . left_flower right_flower
    (10) for -> . FOR
    (91) expr -> . expr assignment exprOR
    (92) expr -> . exprOR
    (60) header -> . HASH INCLUDE STRING
    (61) header -> . HASH INCLUDE HEADER_FILE
    (34) declaration -> . TYPE ID SEMICOLON
    (35) declaration -> . TYPE MULTIPLY ID SEMICOLON
    (36) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (37) declaration -> . TYPE MULTIPLY ID ASSIGN expr SEMICOLON
    (38) declaration -> . TYPE multi_declaration stop
    (39) declaration -> . TYPE ID narrayindex SEMICOLON
    (40) declaration -> . TYPE ID narrayindex ASSIGN init_list SEMICOLON
    (88) function -> . TYPE ID L_PAREN dec_params R_PAREN function_2
    (51) left_flower -> . L_FLOWBRACE
    (104) exprOR -> . exprOR OR exprAND
    (105) exprOR -> . exprAND
    (106) exprAND -> . exprAND AND exprBITOR
    (107) exprAND -> . exprBITOR
    (108) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (109) exprBITOR -> . exprBITXOR
    (110) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (111) exprBITXOR -> . exprBITAND
    (112) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (113) exprBITAND -> . exprEQ
    (114) exprEQ -> . exprEQ EQ exprRELOP
    (115) exprEQ -> . exprEQ NE exprRELOP
    (116) exprEQ -> . exprRELOP
    (117) exprRELOP -> . exprRELOP relop exprSHIFT
    (118) exprRELOP -> . exprSHIFT
    (123) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (124) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (125) exprSHIFT -> . exprOP
    (126) exprOP -> . exprOP PLUS term
    (127) exprOP -> . exprOP MINUS term
    (128) exprOP -> . term
    (129) term -> . term MULTIPLY factor
    (130) term -> . term DIVIDE factor
    (131) term -> . term MOD factor
    (132) term -> . factor
    (133) factor -> . NOT factor
    (134) factor -> . PLUS factor
    (135) factor -> . MINUS factor
    (136) factor -> . PLUS_PLUS factor
    (137) factor -> . MINUS_MINUS factor
    (138) factor -> . cast brace
    (139) factor -> . brace
    (140) cast -> . L_PAREN TYPE R_PAREN
    (141) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (142) brace -> . L_PAREN expr R_PAREN
    (143) brace -> . brace PLUS_PLUS
    (144) brace -> . brace MINUS_MINUS
    (145) brace -> . NUM
    (146) brace -> . STRING
    (147) brace -> . MULTIPLY ID
    (148) brace -> . BIT_AND ID
    (149) brace -> . ID
    (150) brace -> . CHAR
    (151) brace -> . function_call
    (152) brace -> . ID narrayindex
    (153) NUM -> . INT_NUM
    (154) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    IF              shift and go to state 114
    WHILE           shift and go to state 117
    SEMICOLON       shift and go to state 13
    RETURN          shift and go to state 17
    FOR             shift and go to state 11
    HASH            shift and go to state 20
    TYPE            shift and go to state 22
    L_FLOWBRACE     shift and go to state 26
    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    closed                         shift and go to state 194
    open                           shift and go to state 195
    simple                         shift and go to state 9
    block                          shift and go to state 10
    for                            shift and go to state 118
    expr                           shift and go to state 12
    header                         shift and go to state 14
    declaration                    shift and go to state 15
    function                       shift and go to state 16
    left_flower                    shift and go to state 18
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 215

    (17) for_condition -> L_PAREN simple simple expr R_PAREN .

    IF              reduce using rule 17 (for_condition -> L_PAREN simple simple expr R_PAREN .)
    WHILE           reduce using rule 17 (for_condition -> L_PAREN simple simple expr R_PAREN .)
    FOR             reduce using rule 17 (for_condition -> L_PAREN simple simple expr R_PAREN .)
    SEMICOLON       reduce using rule 17 (for_condition -> L_PAREN simple simple expr R_PAREN .)
    RETURN          reduce using rule 17 (for_condition -> L_PAREN simple simple expr R_PAREN .)
    HASH            reduce using rule 17 (for_condition -> L_PAREN simple simple expr R_PAREN .)
    TYPE            reduce using rule 17 (for_condition -> L_PAREN simple simple expr R_PAREN .)
    L_FLOWBRACE     reduce using rule 17 (for_condition -> L_PAREN simple simple expr R_PAREN .)
    NOT             reduce using rule 17 (for_condition -> L_PAREN simple simple expr R_PAREN .)
    PLUS            reduce using rule 17 (for_condition -> L_PAREN simple simple expr R_PAREN .)
    MINUS           reduce using rule 17 (for_condition -> L_PAREN simple simple expr R_PAREN .)
    PLUS_PLUS       reduce using rule 17 (for_condition -> L_PAREN simple simple expr R_PAREN .)
    MINUS_MINUS     reduce using rule 17 (for_condition -> L_PAREN simple simple expr R_PAREN .)
    L_PAREN         reduce using rule 17 (for_condition -> L_PAREN simple simple expr R_PAREN .)
    STRING          reduce using rule 17 (for_condition -> L_PAREN simple simple expr R_PAREN .)
    MULTIPLY        reduce using rule 17 (for_condition -> L_PAREN simple simple expr R_PAREN .)
    BIT_AND         reduce using rule 17 (for_condition -> L_PAREN simple simple expr R_PAREN .)
    ID              reduce using rule 17 (for_condition -> L_PAREN simple simple expr R_PAREN .)
    CHAR            reduce using rule 17 (for_condition -> L_PAREN simple simple expr R_PAREN .)
    INT_NUM         reduce using rule 17 (for_condition -> L_PAREN simple simple expr R_PAREN .)
    FLOAT_NUM       reduce using rule 17 (for_condition -> L_PAREN simple simple expr R_PAREN .)


state 216

    (40) declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .

    IF              reduce using rule 40 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    WHILE           reduce using rule 40 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    FOR             reduce using rule 40 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    SEMICOLON       reduce using rule 40 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    RETURN          reduce using rule 40 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    HASH            reduce using rule 40 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    TYPE            reduce using rule 40 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    L_FLOWBRACE     reduce using rule 40 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    NOT             reduce using rule 40 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    PLUS            reduce using rule 40 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    MINUS           reduce using rule 40 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    PLUS_PLUS       reduce using rule 40 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    MINUS_MINUS     reduce using rule 40 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    L_PAREN         reduce using rule 40 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    STRING          reduce using rule 40 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    MULTIPLY        reduce using rule 40 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    BIT_AND         reduce using rule 40 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    ID              reduce using rule 40 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    CHAR            reduce using rule 40 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    INT_NUM         reduce using rule 40 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    FLOAT_NUM       reduce using rule 40 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    $end            reduce using rule 40 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    R_FLOWBRACE     reduce using rule 40 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    ELSE            reduce using rule 40 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)
    R_PAREN         reduce using rule 40 (declaration -> TYPE ID narrayindex ASSIGN init_list SEMICOLON .)


state 217

    (43) init_list -> L_FLOWBRACE init_list . R_FLOWBRACE COMMA init_list
    (46) init_list -> L_FLOWBRACE init_list . R_FLOWBRACE

    R_FLOWBRACE     shift and go to state 235


state 218

    (44) init_list -> L_FLOWBRACE init . R_FLOWBRACE COMMA init_list
    (45) init_list -> L_FLOWBRACE init . R_FLOWBRACE

    R_FLOWBRACE     shift and go to state 236


state 219

    (41) init -> expr . COMMA init
    (42) init -> expr .
    (91) expr -> expr . assignment exprOR
    (93) assignment -> . ASSIGN
    (94) assignment -> . PLUS_ASSIGN
    (95) assignment -> . MINUS_ASSIGN
    (96) assignment -> . MUL_ASSIGN
    (97) assignment -> . DIV_ASSIGN
    (98) assignment -> . AND_ASSIGN
    (99) assignment -> . OR_ASSIGN
    (100) assignment -> . XOR_ASSIGN
    (101) assignment -> . MOD_ASSIGN
    (102) assignment -> . L_SHIFT_ASSIGN
    (103) assignment -> . R_SHIFT_ASSIGN

    COMMA           shift and go to state 237
    R_FLOWBRACE     reduce using rule 42 (init -> expr .)
    ASSIGN          shift and go to state 58
    PLUS_ASSIGN     shift and go to state 59
    MINUS_ASSIGN    shift and go to state 60
    MUL_ASSIGN      shift and go to state 61
    DIV_ASSIGN      shift and go to state 62
    AND_ASSIGN      shift and go to state 63
    OR_ASSIGN       shift and go to state 64
    XOR_ASSIGN      shift and go to state 65
    MOD_ASSIGN      shift and go to state 66
    L_SHIFT_ASSIGN  shift and go to state 67
    R_SHIFT_ASSIGN  shift and go to state 68

    assignment                     shift and go to state 57

state 220

    (75) yes_dec_params -> TYPE ID COMMA .

    TYPE            reduce using rule 75 (yes_dec_params -> TYPE ID COMMA .)


state 221

    (79) yes_dec_params -> TYPE ID ASSIGN . NUM COMMA
    (81) end_dec_params -> TYPE ID ASSIGN . NUM
    (153) NUM -> . INT_NUM
    (154) NUM -> . FLOAT_NUM

    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    NUM                            shift and go to state 238

state 222

    (76) yes_dec_params -> TYPE MULTIPLY ID . COMMA
    (83) end_dec_params -> TYPE MULTIPLY ID .

    COMMA           shift and go to state 239
    R_PAREN         reduce using rule 83 (end_dec_params -> TYPE MULTIPLY ID .)


state 223

    (78) yes_dec_params -> TYPE MULTIPLY COMMA .

    TYPE            reduce using rule 78 (yes_dec_params -> TYPE MULTIPLY COMMA .)


state 224

    (88) function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .

    IF              reduce using rule 88 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    WHILE           reduce using rule 88 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    FOR             reduce using rule 88 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    SEMICOLON       reduce using rule 88 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    RETURN          reduce using rule 88 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    HASH            reduce using rule 88 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    TYPE            reduce using rule 88 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    L_FLOWBRACE     reduce using rule 88 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    NOT             reduce using rule 88 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    PLUS            reduce using rule 88 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    MINUS           reduce using rule 88 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    PLUS_PLUS       reduce using rule 88 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    MINUS_MINUS     reduce using rule 88 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    L_PAREN         reduce using rule 88 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    STRING          reduce using rule 88 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    MULTIPLY        reduce using rule 88 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    BIT_AND         reduce using rule 88 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    ID              reduce using rule 88 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    CHAR            reduce using rule 88 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    INT_NUM         reduce using rule 88 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    FLOAT_NUM       reduce using rule 88 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    $end            reduce using rule 88 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    R_FLOWBRACE     reduce using rule 88 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    ELSE            reduce using rule 88 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)
    R_PAREN         reduce using rule 88 (function -> TYPE ID L_PAREN dec_params R_PAREN function_2 .)


state 225

    (89) function_2 -> SEMICOLON .

    IF              reduce using rule 89 (function_2 -> SEMICOLON .)
    WHILE           reduce using rule 89 (function_2 -> SEMICOLON .)
    FOR             reduce using rule 89 (function_2 -> SEMICOLON .)
    SEMICOLON       reduce using rule 89 (function_2 -> SEMICOLON .)
    RETURN          reduce using rule 89 (function_2 -> SEMICOLON .)
    HASH            reduce using rule 89 (function_2 -> SEMICOLON .)
    TYPE            reduce using rule 89 (function_2 -> SEMICOLON .)
    L_FLOWBRACE     reduce using rule 89 (function_2 -> SEMICOLON .)
    NOT             reduce using rule 89 (function_2 -> SEMICOLON .)
    PLUS            reduce using rule 89 (function_2 -> SEMICOLON .)
    MINUS           reduce using rule 89 (function_2 -> SEMICOLON .)
    PLUS_PLUS       reduce using rule 89 (function_2 -> SEMICOLON .)
    MINUS_MINUS     reduce using rule 89 (function_2 -> SEMICOLON .)
    L_PAREN         reduce using rule 89 (function_2 -> SEMICOLON .)
    STRING          reduce using rule 89 (function_2 -> SEMICOLON .)
    MULTIPLY        reduce using rule 89 (function_2 -> SEMICOLON .)
    BIT_AND         reduce using rule 89 (function_2 -> SEMICOLON .)
    ID              reduce using rule 89 (function_2 -> SEMICOLON .)
    CHAR            reduce using rule 89 (function_2 -> SEMICOLON .)
    INT_NUM         reduce using rule 89 (function_2 -> SEMICOLON .)
    FLOAT_NUM       reduce using rule 89 (function_2 -> SEMICOLON .)
    $end            reduce using rule 89 (function_2 -> SEMICOLON .)
    R_FLOWBRACE     reduce using rule 89 (function_2 -> SEMICOLON .)
    ELSE            reduce using rule 89 (function_2 -> SEMICOLON .)
    R_PAREN         reduce using rule 89 (function_2 -> SEMICOLON .)


state 226

    (90) function_2 -> block .

    IF              reduce using rule 90 (function_2 -> block .)
    WHILE           reduce using rule 90 (function_2 -> block .)
    FOR             reduce using rule 90 (function_2 -> block .)
    SEMICOLON       reduce using rule 90 (function_2 -> block .)
    RETURN          reduce using rule 90 (function_2 -> block .)
    HASH            reduce using rule 90 (function_2 -> block .)
    TYPE            reduce using rule 90 (function_2 -> block .)
    L_FLOWBRACE     reduce using rule 90 (function_2 -> block .)
    NOT             reduce using rule 90 (function_2 -> block .)
    PLUS            reduce using rule 90 (function_2 -> block .)
    MINUS           reduce using rule 90 (function_2 -> block .)
    PLUS_PLUS       reduce using rule 90 (function_2 -> block .)
    MINUS_MINUS     reduce using rule 90 (function_2 -> block .)
    L_PAREN         reduce using rule 90 (function_2 -> block .)
    STRING          reduce using rule 90 (function_2 -> block .)
    MULTIPLY        reduce using rule 90 (function_2 -> block .)
    BIT_AND         reduce using rule 90 (function_2 -> block .)
    ID              reduce using rule 90 (function_2 -> block .)
    CHAR            reduce using rule 90 (function_2 -> block .)
    INT_NUM         reduce using rule 90 (function_2 -> block .)
    FLOAT_NUM       reduce using rule 90 (function_2 -> block .)
    $end            reduce using rule 90 (function_2 -> block .)
    R_FLOWBRACE     reduce using rule 90 (function_2 -> block .)
    ELSE            reduce using rule 90 (function_2 -> block .)
    R_PAREN         reduce using rule 90 (function_2 -> block .)


state 227

    (70) yes_dec_params -> yes_dec_params TYPE ID . COMMA
    (74) yes_dec_params -> yes_dec_params TYPE ID . ASSIGN NUM COMMA
    (80) end_dec_params -> TYPE ID .
    (81) end_dec_params -> TYPE ID . ASSIGN NUM

    COMMA           shift and go to state 240
    ASSIGN          shift and go to state 241
    R_PAREN         reduce using rule 80 (end_dec_params -> TYPE ID .)


state 228

    (72) yes_dec_params -> yes_dec_params TYPE COMMA .

    TYPE            reduce using rule 72 (yes_dec_params -> yes_dec_params TYPE COMMA .)


state 229

    (71) yes_dec_params -> yes_dec_params TYPE MULTIPLY . ID COMMA
    (73) yes_dec_params -> yes_dec_params TYPE MULTIPLY . COMMA
    (83) end_dec_params -> TYPE MULTIPLY . ID
    (84) end_dec_params -> TYPE MULTIPLY .

    ID              shift and go to state 242
    COMMA           shift and go to state 243
    R_PAREN         reduce using rule 84 (end_dec_params -> TYPE MULTIPLY .)


state 230

    (37) declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .

    IF              reduce using rule 37 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    WHILE           reduce using rule 37 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    FOR             reduce using rule 37 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    SEMICOLON       reduce using rule 37 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    RETURN          reduce using rule 37 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    HASH            reduce using rule 37 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    TYPE            reduce using rule 37 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    L_FLOWBRACE     reduce using rule 37 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    NOT             reduce using rule 37 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    PLUS            reduce using rule 37 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    MINUS           reduce using rule 37 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    PLUS_PLUS       reduce using rule 37 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    MINUS_MINUS     reduce using rule 37 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    L_PAREN         reduce using rule 37 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    STRING          reduce using rule 37 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    MULTIPLY        reduce using rule 37 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    BIT_AND         reduce using rule 37 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    ID              reduce using rule 37 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    CHAR            reduce using rule 37 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    INT_NUM         reduce using rule 37 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    FLOAT_NUM       reduce using rule 37 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    $end            reduce using rule 37 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    R_FLOWBRACE     reduce using rule 37 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    ELSE            reduce using rule 37 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)
    R_PAREN         reduce using rule 37 (declaration -> TYPE MULTIPLY ID ASSIGN expr SEMICOLON .)


state 231

    (26) multi_declaration -> MULTIPLY ID ASSIGN expr COMMA .

    ID              reduce using rule 26 (multi_declaration -> MULTIPLY ID ASSIGN expr COMMA .)
    MULTIPLY        reduce using rule 26 (multi_declaration -> MULTIPLY ID ASSIGN expr COMMA .)


state 232

    (21) multi_declaration -> multi_declaration ID ASSIGN expr COMMA .

    ID              reduce using rule 21 (multi_declaration -> multi_declaration ID ASSIGN expr COMMA .)
    MULTIPLY        reduce using rule 21 (multi_declaration -> multi_declaration ID ASSIGN expr COMMA .)


state 233

    (29) stop -> ID ASSIGN expr SEMICOLON .

    IF              reduce using rule 29 (stop -> ID ASSIGN expr SEMICOLON .)
    WHILE           reduce using rule 29 (stop -> ID ASSIGN expr SEMICOLON .)
    FOR             reduce using rule 29 (stop -> ID ASSIGN expr SEMICOLON .)
    SEMICOLON       reduce using rule 29 (stop -> ID ASSIGN expr SEMICOLON .)
    RETURN          reduce using rule 29 (stop -> ID ASSIGN expr SEMICOLON .)
    HASH            reduce using rule 29 (stop -> ID ASSIGN expr SEMICOLON .)
    TYPE            reduce using rule 29 (stop -> ID ASSIGN expr SEMICOLON .)
    L_FLOWBRACE     reduce using rule 29 (stop -> ID ASSIGN expr SEMICOLON .)
    NOT             reduce using rule 29 (stop -> ID ASSIGN expr SEMICOLON .)
    PLUS            reduce using rule 29 (stop -> ID ASSIGN expr SEMICOLON .)
    MINUS           reduce using rule 29 (stop -> ID ASSIGN expr SEMICOLON .)
    PLUS_PLUS       reduce using rule 29 (stop -> ID ASSIGN expr SEMICOLON .)
    MINUS_MINUS     reduce using rule 29 (stop -> ID ASSIGN expr SEMICOLON .)
    L_PAREN         reduce using rule 29 (stop -> ID ASSIGN expr SEMICOLON .)
    STRING          reduce using rule 29 (stop -> ID ASSIGN expr SEMICOLON .)
    MULTIPLY        reduce using rule 29 (stop -> ID ASSIGN expr SEMICOLON .)
    BIT_AND         reduce using rule 29 (stop -> ID ASSIGN expr SEMICOLON .)
    ID              reduce using rule 29 (stop -> ID ASSIGN expr SEMICOLON .)
    CHAR            reduce using rule 29 (stop -> ID ASSIGN expr SEMICOLON .)
    INT_NUM         reduce using rule 29 (stop -> ID ASSIGN expr SEMICOLON .)
    FLOAT_NUM       reduce using rule 29 (stop -> ID ASSIGN expr SEMICOLON .)
    $end            reduce using rule 29 (stop -> ID ASSIGN expr SEMICOLON .)
    R_FLOWBRACE     reduce using rule 29 (stop -> ID ASSIGN expr SEMICOLON .)
    ELSE            reduce using rule 29 (stop -> ID ASSIGN expr SEMICOLON .)
    R_PAREN         reduce using rule 29 (stop -> ID ASSIGN expr SEMICOLON .)


state 234

    (22) multi_declaration -> multi_declaration MULTIPLY ID ASSIGN expr . COMMA
    (30) stop -> MULTIPLY ID ASSIGN expr . SEMICOLON
    (91) expr -> expr . assignment exprOR
    (93) assignment -> . ASSIGN
    (94) assignment -> . PLUS_ASSIGN
    (95) assignment -> . MINUS_ASSIGN
    (96) assignment -> . MUL_ASSIGN
    (97) assignment -> . DIV_ASSIGN
    (98) assignment -> . AND_ASSIGN
    (99) assignment -> . OR_ASSIGN
    (100) assignment -> . XOR_ASSIGN
    (101) assignment -> . MOD_ASSIGN
    (102) assignment -> . L_SHIFT_ASSIGN
    (103) assignment -> . R_SHIFT_ASSIGN

    COMMA           shift and go to state 244
    SEMICOLON       shift and go to state 245
    ASSIGN          shift and go to state 58
    PLUS_ASSIGN     shift and go to state 59
    MINUS_ASSIGN    shift and go to state 60
    MUL_ASSIGN      shift and go to state 61
    DIV_ASSIGN      shift and go to state 62
    AND_ASSIGN      shift and go to state 63
    OR_ASSIGN       shift and go to state 64
    XOR_ASSIGN      shift and go to state 65
    MOD_ASSIGN      shift and go to state 66
    L_SHIFT_ASSIGN  shift and go to state 67
    R_SHIFT_ASSIGN  shift and go to state 68

    assignment                     shift and go to state 57

state 235

    (43) init_list -> L_FLOWBRACE init_list R_FLOWBRACE . COMMA init_list
    (46) init_list -> L_FLOWBRACE init_list R_FLOWBRACE .

    COMMA           shift and go to state 246
    SEMICOLON       reduce using rule 46 (init_list -> L_FLOWBRACE init_list R_FLOWBRACE .)
    R_FLOWBRACE     reduce using rule 46 (init_list -> L_FLOWBRACE init_list R_FLOWBRACE .)


state 236

    (44) init_list -> L_FLOWBRACE init R_FLOWBRACE . COMMA init_list
    (45) init_list -> L_FLOWBRACE init R_FLOWBRACE .

    COMMA           shift and go to state 247
    SEMICOLON       reduce using rule 45 (init_list -> L_FLOWBRACE init R_FLOWBRACE .)
    R_FLOWBRACE     reduce using rule 45 (init_list -> L_FLOWBRACE init R_FLOWBRACE .)


state 237

    (41) init -> expr COMMA . init
    (41) init -> . expr COMMA init
    (42) init -> . expr
    (91) expr -> . expr assignment exprOR
    (92) expr -> . exprOR
    (104) exprOR -> . exprOR OR exprAND
    (105) exprOR -> . exprAND
    (106) exprAND -> . exprAND AND exprBITOR
    (107) exprAND -> . exprBITOR
    (108) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (109) exprBITOR -> . exprBITXOR
    (110) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (111) exprBITXOR -> . exprBITAND
    (112) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (113) exprBITAND -> . exprEQ
    (114) exprEQ -> . exprEQ EQ exprRELOP
    (115) exprEQ -> . exprEQ NE exprRELOP
    (116) exprEQ -> . exprRELOP
    (117) exprRELOP -> . exprRELOP relop exprSHIFT
    (118) exprRELOP -> . exprSHIFT
    (123) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (124) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (125) exprSHIFT -> . exprOP
    (126) exprOP -> . exprOP PLUS term
    (127) exprOP -> . exprOP MINUS term
    (128) exprOP -> . term
    (129) term -> . term MULTIPLY factor
    (130) term -> . term DIVIDE factor
    (131) term -> . term MOD factor
    (132) term -> . factor
    (133) factor -> . NOT factor
    (134) factor -> . PLUS factor
    (135) factor -> . MINUS factor
    (136) factor -> . PLUS_PLUS factor
    (137) factor -> . MINUS_MINUS factor
    (138) factor -> . cast brace
    (139) factor -> . brace
    (140) cast -> . L_PAREN TYPE R_PAREN
    (141) cast -> . L_PAREN TYPE MULTIPLY R_PAREN
    (142) brace -> . L_PAREN expr R_PAREN
    (143) brace -> . brace PLUS_PLUS
    (144) brace -> . brace MINUS_MINUS
    (145) brace -> . NUM
    (146) brace -> . STRING
    (147) brace -> . MULTIPLY ID
    (148) brace -> . BIT_AND ID
    (149) brace -> . ID
    (150) brace -> . CHAR
    (151) brace -> . function_call
    (152) brace -> . ID narrayindex
    (153) NUM -> . INT_NUM
    (154) NUM -> . FLOAT_NUM
    (63) function_call -> . ID L_PAREN call_params R_PAREN

    NOT             shift and go to state 40
    PLUS            shift and go to state 36
    MINUS           shift and go to state 38
    PLUS_PLUS       shift and go to state 41
    MINUS_MINUS     shift and go to state 42
    L_PAREN         shift and go to state 25
    STRING          shift and go to state 21
    MULTIPLY        shift and go to state 24
    BIT_AND         shift and go to state 31
    ID              shift and go to state 23
    CHAR            shift and go to state 46
    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    expr                           shift and go to state 219
    init                           shift and go to state 248
    exprOR                         shift and go to state 19
    exprAND                        shift and go to state 27
    exprBITOR                      shift and go to state 28
    exprBITXOR                     shift and go to state 29
    exprBITAND                     shift and go to state 30
    exprEQ                         shift and go to state 32
    exprRELOP                      shift and go to state 33
    exprSHIFT                      shift and go to state 34
    exprOP                         shift and go to state 35
    term                           shift and go to state 37
    factor                         shift and go to state 39
    cast                           shift and go to state 43
    brace                          shift and go to state 44
    NUM                            shift and go to state 45
    function_call                  shift and go to state 47

state 238

    (79) yes_dec_params -> TYPE ID ASSIGN NUM . COMMA
    (81) end_dec_params -> TYPE ID ASSIGN NUM .

    COMMA           shift and go to state 249
    R_PAREN         reduce using rule 81 (end_dec_params -> TYPE ID ASSIGN NUM .)


state 239

    (76) yes_dec_params -> TYPE MULTIPLY ID COMMA .

    TYPE            reduce using rule 76 (yes_dec_params -> TYPE MULTIPLY ID COMMA .)


state 240

    (70) yes_dec_params -> yes_dec_params TYPE ID COMMA .

    TYPE            reduce using rule 70 (yes_dec_params -> yes_dec_params TYPE ID COMMA .)


state 241

    (74) yes_dec_params -> yes_dec_params TYPE ID ASSIGN . NUM COMMA
    (81) end_dec_params -> TYPE ID ASSIGN . NUM
    (153) NUM -> . INT_NUM
    (154) NUM -> . FLOAT_NUM

    INT_NUM         shift and go to state 48
    FLOAT_NUM       shift and go to state 49

    NUM                            shift and go to state 250

state 242

    (71) yes_dec_params -> yes_dec_params TYPE MULTIPLY ID . COMMA
    (83) end_dec_params -> TYPE MULTIPLY ID .

    COMMA           shift and go to state 251
    R_PAREN         reduce using rule 83 (end_dec_params -> TYPE MULTIPLY ID .)


state 243

    (73) yes_dec_params -> yes_dec_params TYPE MULTIPLY COMMA .

    TYPE            reduce using rule 73 (yes_dec_params -> yes_dec_params TYPE MULTIPLY COMMA .)


state 244

    (22) multi_declaration -> multi_declaration MULTIPLY ID ASSIGN expr COMMA .

    ID              reduce using rule 22 (multi_declaration -> multi_declaration MULTIPLY ID ASSIGN expr COMMA .)
    MULTIPLY        reduce using rule 22 (multi_declaration -> multi_declaration MULTIPLY ID ASSIGN expr COMMA .)


state 245

    (30) stop -> MULTIPLY ID ASSIGN expr SEMICOLON .

    IF              reduce using rule 30 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    WHILE           reduce using rule 30 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    FOR             reduce using rule 30 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    SEMICOLON       reduce using rule 30 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    RETURN          reduce using rule 30 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    HASH            reduce using rule 30 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    TYPE            reduce using rule 30 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    L_FLOWBRACE     reduce using rule 30 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    NOT             reduce using rule 30 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    PLUS            reduce using rule 30 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    MINUS           reduce using rule 30 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    PLUS_PLUS       reduce using rule 30 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    MINUS_MINUS     reduce using rule 30 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    L_PAREN         reduce using rule 30 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    STRING          reduce using rule 30 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    MULTIPLY        reduce using rule 30 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    BIT_AND         reduce using rule 30 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    ID              reduce using rule 30 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    CHAR            reduce using rule 30 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    INT_NUM         reduce using rule 30 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    FLOAT_NUM       reduce using rule 30 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    $end            reduce using rule 30 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    R_FLOWBRACE     reduce using rule 30 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    ELSE            reduce using rule 30 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)
    R_PAREN         reduce using rule 30 (stop -> MULTIPLY ID ASSIGN expr SEMICOLON .)


state 246

    (43) init_list -> L_FLOWBRACE init_list R_FLOWBRACE COMMA . init_list
    (43) init_list -> . L_FLOWBRACE init_list R_FLOWBRACE COMMA init_list
    (44) init_list -> . L_FLOWBRACE init R_FLOWBRACE COMMA init_list
    (45) init_list -> . L_FLOWBRACE init R_FLOWBRACE
    (46) init_list -> . L_FLOWBRACE init_list R_FLOWBRACE

    L_FLOWBRACE     shift and go to state 201

    init_list                      shift and go to state 252

state 247

    (44) init_list -> L_FLOWBRACE init R_FLOWBRACE COMMA . init_list
    (43) init_list -> . L_FLOWBRACE init_list R_FLOWBRACE COMMA init_list
    (44) init_list -> . L_FLOWBRACE init R_FLOWBRACE COMMA init_list
    (45) init_list -> . L_FLOWBRACE init R_FLOWBRACE
    (46) init_list -> . L_FLOWBRACE init_list R_FLOWBRACE

    L_FLOWBRACE     shift and go to state 201

    init_list                      shift and go to state 253

state 248

    (41) init -> expr COMMA init .

    R_FLOWBRACE     reduce using rule 41 (init -> expr COMMA init .)


state 249

    (79) yes_dec_params -> TYPE ID ASSIGN NUM COMMA .

    TYPE            reduce using rule 79 (yes_dec_params -> TYPE ID ASSIGN NUM COMMA .)


state 250

    (74) yes_dec_params -> yes_dec_params TYPE ID ASSIGN NUM . COMMA
    (81) end_dec_params -> TYPE ID ASSIGN NUM .

    COMMA           shift and go to state 254
    R_PAREN         reduce using rule 81 (end_dec_params -> TYPE ID ASSIGN NUM .)


state 251

    (71) yes_dec_params -> yes_dec_params TYPE MULTIPLY ID COMMA .

    TYPE            reduce using rule 71 (yes_dec_params -> yes_dec_params TYPE MULTIPLY ID COMMA .)


state 252

    (43) init_list -> L_FLOWBRACE init_list R_FLOWBRACE COMMA init_list .

    SEMICOLON       reduce using rule 43 (init_list -> L_FLOWBRACE init_list R_FLOWBRACE COMMA init_list .)
    R_FLOWBRACE     reduce using rule 43 (init_list -> L_FLOWBRACE init_list R_FLOWBRACE COMMA init_list .)


state 253

    (44) init_list -> L_FLOWBRACE init R_FLOWBRACE COMMA init_list .

    SEMICOLON       reduce using rule 44 (init_list -> L_FLOWBRACE init R_FLOWBRACE COMMA init_list .)
    R_FLOWBRACE     reduce using rule 44 (init_list -> L_FLOWBRACE init R_FLOWBRACE COMMA init_list .)


state 254

    (74) yes_dec_params -> yes_dec_params TYPE ID ASSIGN NUM COMMA .

    TYPE            reduce using rule 74 (yes_dec_params -> yes_dec_params TYPE ID ASSIGN NUM COMMA .)

