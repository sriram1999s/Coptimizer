Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> start
Rule 1     start -> multiple_statements
Rule 2     multiple_statements -> multiple_statements statement
Rule 3     multiple_statements -> statement
Rule 4     statement -> open
Rule 5     statement -> closed
Rule 6     open -> IF condition statement
Rule 7     open -> IF condition closed ELSE open
Rule 8     open -> WHILE condition open
Rule 9     open -> FOR for_condition open
Rule 10    closed -> simple
Rule 11    closed -> block
Rule 12    closed -> IF condition closed ELSE closed
Rule 13    closed -> WHILE condition closed
Rule 14    closed -> FOR for_condition closed
Rule 15    condition -> L_PAREN expr R_PAREN
Rule 16    for_condition -> L_PAREN declaration expr SEMICOLON expr R_PAREN
Rule 17    declaration -> TYPE ID SEMICOLON
Rule 18    declaration -> TYPE ID ASSIGN expr SEMICOLON
Rule 19    block -> L_FLOWBRACE multiple_statements R_FLOWBRACE
Rule 20    simple -> expr SEMICOLON
Rule 21    simple -> declaration
Rule 22    simple -> SEMICOLON
Rule 23    expr -> expr assignment exprOR
Rule 24    expr -> exprOR
Rule 25    assignment -> ASSIGN
Rule 26    assignment -> PLUS_ASSIGN
Rule 27    assignment -> MINUS_ASSIGN
Rule 28    assignment -> MUL_ASSIGN
Rule 29    assignment -> DIV_ASSIGN
Rule 30    assignment -> AND_ASSIGN
Rule 31    assignment -> OR_ASSIGN
Rule 32    assignment -> XOR_ASSIGN
Rule 33    assignment -> MOD_ASSIGN
Rule 34    assignment -> L_SHIFT_ASSIGN
Rule 35    assignment -> R_SHIFT_ASSIGN
Rule 36    exprOR -> exprOR OR exprAND
Rule 37    exprOR -> exprAND
Rule 38    exprAND -> exprAND AND exprBITOR
Rule 39    exprAND -> exprBITOR
Rule 40    exprBITOR -> exprBITOR BIT_OR exprBITXOR
Rule 41    exprBITOR -> exprBITXOR
Rule 42    exprBITXOR -> exprBITXOR BIT_XOR exprBITAND
Rule 43    exprBITXOR -> exprBITAND
Rule 44    exprBITAND -> exprBITAND BIT_AND exprEQ
Rule 45    exprBITAND -> exprEQ
Rule 46    exprEQ -> exprEQ EQ exprRELOP
Rule 47    exprEQ -> exprEQ NE exprRELOP
Rule 48    exprEQ -> exprRELOP
Rule 49    exprRELOP -> exprRELOP relop exprSHIFT
Rule 50    exprRELOP -> exprSHIFT
Rule 51    relop -> LE
Rule 52    relop -> LT
Rule 53    relop -> GE
Rule 54    relop -> GT
Rule 55    exprSHIFT -> exprSHIFT L_SHIFT exprOP
Rule 56    exprSHIFT -> exprSHIFT R_SHIFT exprOP
Rule 57    exprSHIFT -> exprOP
Rule 58    exprOP -> exprOP PLUS term
Rule 59    exprOP -> exprOP MINUS term
Rule 60    exprOP -> term
Rule 61    term -> term MULTIPLY factor
Rule 62    term -> term DIVIDE factor
Rule 63    term -> term MOD factor
Rule 64    term -> factor
Rule 65    factor -> NOT factor
Rule 66    factor -> PLUS factor
Rule 67    factor -> MINUS factor
Rule 68    factor -> PLUS_PLUS factor
Rule 69    factor -> MINUS_MINUS factor
Rule 70    factor -> brace
Rule 71    brace -> L_PAREN expr R_PAREN
Rule 72    brace -> brace PLUS_PLUS
Rule 73    brace -> brace MINUS_MINUS
Rule 74    brace -> INT_NUM
Rule 75    brace -> FLOAT_NUM
Rule 76    brace -> ID

Terminals, with rules where they appear

AND                  : 38
AND_ASSIGN           : 30
ASSIGN               : 18 25
BIT_AND              : 44
BIT_OR               : 40
BIT_XOR              : 42
DIVIDE               : 62
DIV_ASSIGN           : 29
ELSE                 : 7 12
EQ                   : 46
FLOAT_NUM            : 75
FOR                  : 9 14
GE                   : 53
GT                   : 54
ID                   : 17 18 76
IF                   : 6 7 12
INT_NUM              : 74
LE                   : 51
LT                   : 52
L_FLOWBRACE          : 19
L_PAREN              : 15 16 71
L_SHIFT              : 55
L_SHIFT_ASSIGN       : 34
MINUS                : 59 67
MINUS_ASSIGN         : 27
MINUS_MINUS          : 69 73
MOD                  : 63
MOD_ASSIGN           : 33
MULTIPLY             : 61
MUL_ASSIGN           : 28
NE                   : 47
NOT                  : 65
OR                   : 36
OR_ASSIGN            : 31
PLUS                 : 58 66
PLUS_ASSIGN          : 26
PLUS_PLUS            : 68 72
R_FLOWBRACE          : 19
R_PAREN              : 15 16 71
R_SHIFT              : 56
R_SHIFT_ASSIGN       : 35
SEMICOLON            : 16 17 18 20 22
TYPE                 : 17 18
WHILE                : 8 13
XOR_ASSIGN           : 32
error                : 

Nonterminals, with rules where they appear

assignment           : 23
block                : 11
brace                : 70 72 73
closed               : 5 7 12 12 13 14
condition            : 6 7 8 12 13
declaration          : 16 21
expr                 : 15 16 16 18 20 23 71
exprAND              : 36 37 38
exprBITAND           : 42 43 44
exprBITOR            : 38 39 40
exprBITXOR           : 40 41 42
exprEQ               : 44 45 46 47
exprOP               : 55 56 57 58 59
exprOR               : 23 24 36
exprRELOP            : 46 47 48 49
exprSHIFT            : 49 50 55 56
factor               : 61 62 63 64 65 66 67 68 69
for_condition        : 9 14
multiple_statements  : 1 2 19
open                 : 4 7 8 9
relop                : 49
simple               : 10
start                : 0
statement            : 2 3 6
term                 : 58 59 60 61 62 63

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . multiple_statements
    (2) multiple_statements -> . multiple_statements statement
    (3) multiple_statements -> . statement
    (4) statement -> . open
    (5) statement -> . closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) open -> . FOR for_condition open
    (10) closed -> . simple
    (11) closed -> . block
    (12) closed -> . IF condition closed ELSE closed
    (13) closed -> . WHILE condition closed
    (14) closed -> . FOR for_condition closed
    (20) simple -> . expr SEMICOLON
    (21) simple -> . declaration
    (22) simple -> . SEMICOLON
    (19) block -> . L_FLOWBRACE multiple_statements R_FLOWBRACE
    (23) expr -> . expr assignment exprOR
    (24) expr -> . exprOR
    (17) declaration -> . TYPE ID SEMICOLON
    (18) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (36) exprOR -> . exprOR OR exprAND
    (37) exprOR -> . exprAND
    (38) exprAND -> . exprAND AND exprBITOR
    (39) exprAND -> . exprBITOR
    (40) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (41) exprBITOR -> . exprBITXOR
    (42) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (43) exprBITXOR -> . exprBITAND
    (44) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (45) exprBITAND -> . exprEQ
    (46) exprEQ -> . exprEQ EQ exprRELOP
    (47) exprEQ -> . exprEQ NE exprRELOP
    (48) exprEQ -> . exprRELOP
    (49) exprRELOP -> . exprRELOP relop exprSHIFT
    (50) exprRELOP -> . exprSHIFT
    (55) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (56) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (57) exprSHIFT -> . exprOP
    (58) exprOP -> . exprOP PLUS term
    (59) exprOP -> . exprOP MINUS term
    (60) exprOP -> . term
    (61) term -> . term MULTIPLY factor
    (62) term -> . term DIVIDE factor
    (63) term -> . term MOD factor
    (64) term -> . factor
    (65) factor -> . NOT factor
    (66) factor -> . PLUS factor
    (67) factor -> . MINUS factor
    (68) factor -> . PLUS_PLUS factor
    (69) factor -> . MINUS_MINUS factor
    (70) factor -> . brace
    (71) brace -> . L_PAREN expr R_PAREN
    (72) brace -> . brace PLUS_PLUS
    (73) brace -> . brace MINUS_MINUS
    (74) brace -> . INT_NUM
    (75) brace -> . FLOAT_NUM
    (76) brace -> . ID

    IF              shift and go to state 6
    WHILE           shift and go to state 7
    FOR             shift and go to state 8
    SEMICOLON       shift and go to state 12
    L_FLOWBRACE     shift and go to state 14
    TYPE            shift and go to state 16
    NOT             shift and go to state 30
    PLUS            shift and go to state 26
    MINUS           shift and go to state 28
    PLUS_PLUS       shift and go to state 31
    MINUS_MINUS     shift and go to state 32
    L_PAREN         shift and go to state 34
    INT_NUM         shift and go to state 35
    FLOAT_NUM       shift and go to state 36
    ID              shift and go to state 17

    start                          shift and go to state 1
    multiple_statements            shift and go to state 2
    statement                      shift and go to state 3
    open                           shift and go to state 4
    closed                         shift and go to state 5
    simple                         shift and go to state 9
    block                          shift and go to state 10
    expr                           shift and go to state 11
    declaration                    shift and go to state 13
    exprOR                         shift and go to state 15
    exprAND                        shift and go to state 18
    exprBITOR                      shift and go to state 19
    exprBITXOR                     shift and go to state 20
    exprBITAND                     shift and go to state 21
    exprEQ                         shift and go to state 22
    exprRELOP                      shift and go to state 23
    exprSHIFT                      shift and go to state 24
    exprOP                         shift and go to state 25
    term                           shift and go to state 27
    factor                         shift and go to state 29
    brace                          shift and go to state 33

state 1

    (0) S' -> start .



state 2

    (1) start -> multiple_statements .
    (2) multiple_statements -> multiple_statements . statement
    (4) statement -> . open
    (5) statement -> . closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) open -> . FOR for_condition open
    (10) closed -> . simple
    (11) closed -> . block
    (12) closed -> . IF condition closed ELSE closed
    (13) closed -> . WHILE condition closed
    (14) closed -> . FOR for_condition closed
    (20) simple -> . expr SEMICOLON
    (21) simple -> . declaration
    (22) simple -> . SEMICOLON
    (19) block -> . L_FLOWBRACE multiple_statements R_FLOWBRACE
    (23) expr -> . expr assignment exprOR
    (24) expr -> . exprOR
    (17) declaration -> . TYPE ID SEMICOLON
    (18) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (36) exprOR -> . exprOR OR exprAND
    (37) exprOR -> . exprAND
    (38) exprAND -> . exprAND AND exprBITOR
    (39) exprAND -> . exprBITOR
    (40) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (41) exprBITOR -> . exprBITXOR
    (42) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (43) exprBITXOR -> . exprBITAND
    (44) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (45) exprBITAND -> . exprEQ
    (46) exprEQ -> . exprEQ EQ exprRELOP
    (47) exprEQ -> . exprEQ NE exprRELOP
    (48) exprEQ -> . exprRELOP
    (49) exprRELOP -> . exprRELOP relop exprSHIFT
    (50) exprRELOP -> . exprSHIFT
    (55) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (56) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (57) exprSHIFT -> . exprOP
    (58) exprOP -> . exprOP PLUS term
    (59) exprOP -> . exprOP MINUS term
    (60) exprOP -> . term
    (61) term -> . term MULTIPLY factor
    (62) term -> . term DIVIDE factor
    (63) term -> . term MOD factor
    (64) term -> . factor
    (65) factor -> . NOT factor
    (66) factor -> . PLUS factor
    (67) factor -> . MINUS factor
    (68) factor -> . PLUS_PLUS factor
    (69) factor -> . MINUS_MINUS factor
    (70) factor -> . brace
    (71) brace -> . L_PAREN expr R_PAREN
    (72) brace -> . brace PLUS_PLUS
    (73) brace -> . brace MINUS_MINUS
    (74) brace -> . INT_NUM
    (75) brace -> . FLOAT_NUM
    (76) brace -> . ID

    $end            reduce using rule 1 (start -> multiple_statements .)
    IF              shift and go to state 6
    WHILE           shift and go to state 7
    FOR             shift and go to state 8
    SEMICOLON       shift and go to state 12
    L_FLOWBRACE     shift and go to state 14
    TYPE            shift and go to state 16
    NOT             shift and go to state 30
    PLUS            shift and go to state 26
    MINUS           shift and go to state 28
    PLUS_PLUS       shift and go to state 31
    MINUS_MINUS     shift and go to state 32
    L_PAREN         shift and go to state 34
    INT_NUM         shift and go to state 35
    FLOAT_NUM       shift and go to state 36
    ID              shift and go to state 17

    statement                      shift and go to state 37
    open                           shift and go to state 4
    closed                         shift and go to state 5
    simple                         shift and go to state 9
    block                          shift and go to state 10
    expr                           shift and go to state 11
    declaration                    shift and go to state 13
    exprOR                         shift and go to state 15
    exprAND                        shift and go to state 18
    exprBITOR                      shift and go to state 19
    exprBITXOR                     shift and go to state 20
    exprBITAND                     shift and go to state 21
    exprEQ                         shift and go to state 22
    exprRELOP                      shift and go to state 23
    exprSHIFT                      shift and go to state 24
    exprOP                         shift and go to state 25
    term                           shift and go to state 27
    factor                         shift and go to state 29
    brace                          shift and go to state 33

state 3

    (3) multiple_statements -> statement .

    IF              reduce using rule 3 (multiple_statements -> statement .)
    WHILE           reduce using rule 3 (multiple_statements -> statement .)
    FOR             reduce using rule 3 (multiple_statements -> statement .)
    SEMICOLON       reduce using rule 3 (multiple_statements -> statement .)
    L_FLOWBRACE     reduce using rule 3 (multiple_statements -> statement .)
    TYPE            reduce using rule 3 (multiple_statements -> statement .)
    NOT             reduce using rule 3 (multiple_statements -> statement .)
    PLUS            reduce using rule 3 (multiple_statements -> statement .)
    MINUS           reduce using rule 3 (multiple_statements -> statement .)
    PLUS_PLUS       reduce using rule 3 (multiple_statements -> statement .)
    MINUS_MINUS     reduce using rule 3 (multiple_statements -> statement .)
    L_PAREN         reduce using rule 3 (multiple_statements -> statement .)
    INT_NUM         reduce using rule 3 (multiple_statements -> statement .)
    FLOAT_NUM       reduce using rule 3 (multiple_statements -> statement .)
    ID              reduce using rule 3 (multiple_statements -> statement .)
    $end            reduce using rule 3 (multiple_statements -> statement .)
    R_FLOWBRACE     reduce using rule 3 (multiple_statements -> statement .)


state 4

    (4) statement -> open .

    IF              reduce using rule 4 (statement -> open .)
    WHILE           reduce using rule 4 (statement -> open .)
    FOR             reduce using rule 4 (statement -> open .)
    SEMICOLON       reduce using rule 4 (statement -> open .)
    L_FLOWBRACE     reduce using rule 4 (statement -> open .)
    TYPE            reduce using rule 4 (statement -> open .)
    NOT             reduce using rule 4 (statement -> open .)
    PLUS            reduce using rule 4 (statement -> open .)
    MINUS           reduce using rule 4 (statement -> open .)
    PLUS_PLUS       reduce using rule 4 (statement -> open .)
    MINUS_MINUS     reduce using rule 4 (statement -> open .)
    L_PAREN         reduce using rule 4 (statement -> open .)
    INT_NUM         reduce using rule 4 (statement -> open .)
    FLOAT_NUM       reduce using rule 4 (statement -> open .)
    ID              reduce using rule 4 (statement -> open .)
    $end            reduce using rule 4 (statement -> open .)
    R_FLOWBRACE     reduce using rule 4 (statement -> open .)


state 5

    (5) statement -> closed .

    IF              reduce using rule 5 (statement -> closed .)
    WHILE           reduce using rule 5 (statement -> closed .)
    FOR             reduce using rule 5 (statement -> closed .)
    SEMICOLON       reduce using rule 5 (statement -> closed .)
    L_FLOWBRACE     reduce using rule 5 (statement -> closed .)
    TYPE            reduce using rule 5 (statement -> closed .)
    NOT             reduce using rule 5 (statement -> closed .)
    PLUS            reduce using rule 5 (statement -> closed .)
    MINUS           reduce using rule 5 (statement -> closed .)
    PLUS_PLUS       reduce using rule 5 (statement -> closed .)
    MINUS_MINUS     reduce using rule 5 (statement -> closed .)
    L_PAREN         reduce using rule 5 (statement -> closed .)
    INT_NUM         reduce using rule 5 (statement -> closed .)
    FLOAT_NUM       reduce using rule 5 (statement -> closed .)
    ID              reduce using rule 5 (statement -> closed .)
    $end            reduce using rule 5 (statement -> closed .)
    R_FLOWBRACE     reduce using rule 5 (statement -> closed .)


state 6

    (6) open -> IF . condition statement
    (7) open -> IF . condition closed ELSE open
    (12) closed -> IF . condition closed ELSE closed
    (15) condition -> . L_PAREN expr R_PAREN

    L_PAREN         shift and go to state 39

    condition                      shift and go to state 38

state 7

    (8) open -> WHILE . condition open
    (13) closed -> WHILE . condition closed
    (15) condition -> . L_PAREN expr R_PAREN

    L_PAREN         shift and go to state 39

    condition                      shift and go to state 40

state 8

    (9) open -> FOR . for_condition open
    (14) closed -> FOR . for_condition closed
    (16) for_condition -> . L_PAREN declaration expr SEMICOLON expr R_PAREN

    L_PAREN         shift and go to state 42

    for_condition                  shift and go to state 41

state 9

    (10) closed -> simple .

    IF              reduce using rule 10 (closed -> simple .)
    WHILE           reduce using rule 10 (closed -> simple .)
    FOR             reduce using rule 10 (closed -> simple .)
    SEMICOLON       reduce using rule 10 (closed -> simple .)
    L_FLOWBRACE     reduce using rule 10 (closed -> simple .)
    TYPE            reduce using rule 10 (closed -> simple .)
    NOT             reduce using rule 10 (closed -> simple .)
    PLUS            reduce using rule 10 (closed -> simple .)
    MINUS           reduce using rule 10 (closed -> simple .)
    PLUS_PLUS       reduce using rule 10 (closed -> simple .)
    MINUS_MINUS     reduce using rule 10 (closed -> simple .)
    L_PAREN         reduce using rule 10 (closed -> simple .)
    INT_NUM         reduce using rule 10 (closed -> simple .)
    FLOAT_NUM       reduce using rule 10 (closed -> simple .)
    ID              reduce using rule 10 (closed -> simple .)
    $end            reduce using rule 10 (closed -> simple .)
    R_FLOWBRACE     reduce using rule 10 (closed -> simple .)
    ELSE            reduce using rule 10 (closed -> simple .)


state 10

    (11) closed -> block .

    IF              reduce using rule 11 (closed -> block .)
    WHILE           reduce using rule 11 (closed -> block .)
    FOR             reduce using rule 11 (closed -> block .)
    SEMICOLON       reduce using rule 11 (closed -> block .)
    L_FLOWBRACE     reduce using rule 11 (closed -> block .)
    TYPE            reduce using rule 11 (closed -> block .)
    NOT             reduce using rule 11 (closed -> block .)
    PLUS            reduce using rule 11 (closed -> block .)
    MINUS           reduce using rule 11 (closed -> block .)
    PLUS_PLUS       reduce using rule 11 (closed -> block .)
    MINUS_MINUS     reduce using rule 11 (closed -> block .)
    L_PAREN         reduce using rule 11 (closed -> block .)
    INT_NUM         reduce using rule 11 (closed -> block .)
    FLOAT_NUM       reduce using rule 11 (closed -> block .)
    ID              reduce using rule 11 (closed -> block .)
    $end            reduce using rule 11 (closed -> block .)
    R_FLOWBRACE     reduce using rule 11 (closed -> block .)
    ELSE            reduce using rule 11 (closed -> block .)


state 11

    (20) simple -> expr . SEMICOLON
    (23) expr -> expr . assignment exprOR
    (25) assignment -> . ASSIGN
    (26) assignment -> . PLUS_ASSIGN
    (27) assignment -> . MINUS_ASSIGN
    (28) assignment -> . MUL_ASSIGN
    (29) assignment -> . DIV_ASSIGN
    (30) assignment -> . AND_ASSIGN
    (31) assignment -> . OR_ASSIGN
    (32) assignment -> . XOR_ASSIGN
    (33) assignment -> . MOD_ASSIGN
    (34) assignment -> . L_SHIFT_ASSIGN
    (35) assignment -> . R_SHIFT_ASSIGN

    SEMICOLON       shift and go to state 43
    ASSIGN          shift and go to state 45
    PLUS_ASSIGN     shift and go to state 46
    MINUS_ASSIGN    shift and go to state 47
    MUL_ASSIGN      shift and go to state 48
    DIV_ASSIGN      shift and go to state 49
    AND_ASSIGN      shift and go to state 50
    OR_ASSIGN       shift and go to state 51
    XOR_ASSIGN      shift and go to state 52
    MOD_ASSIGN      shift and go to state 53
    L_SHIFT_ASSIGN  shift and go to state 54
    R_SHIFT_ASSIGN  shift and go to state 55

    assignment                     shift and go to state 44

state 12

    (22) simple -> SEMICOLON .

    IF              reduce using rule 22 (simple -> SEMICOLON .)
    WHILE           reduce using rule 22 (simple -> SEMICOLON .)
    FOR             reduce using rule 22 (simple -> SEMICOLON .)
    SEMICOLON       reduce using rule 22 (simple -> SEMICOLON .)
    L_FLOWBRACE     reduce using rule 22 (simple -> SEMICOLON .)
    TYPE            reduce using rule 22 (simple -> SEMICOLON .)
    NOT             reduce using rule 22 (simple -> SEMICOLON .)
    PLUS            reduce using rule 22 (simple -> SEMICOLON .)
    MINUS           reduce using rule 22 (simple -> SEMICOLON .)
    PLUS_PLUS       reduce using rule 22 (simple -> SEMICOLON .)
    MINUS_MINUS     reduce using rule 22 (simple -> SEMICOLON .)
    L_PAREN         reduce using rule 22 (simple -> SEMICOLON .)
    INT_NUM         reduce using rule 22 (simple -> SEMICOLON .)
    FLOAT_NUM       reduce using rule 22 (simple -> SEMICOLON .)
    ID              reduce using rule 22 (simple -> SEMICOLON .)
    $end            reduce using rule 22 (simple -> SEMICOLON .)
    R_FLOWBRACE     reduce using rule 22 (simple -> SEMICOLON .)
    ELSE            reduce using rule 22 (simple -> SEMICOLON .)


state 13

    (21) simple -> declaration .

    IF              reduce using rule 21 (simple -> declaration .)
    WHILE           reduce using rule 21 (simple -> declaration .)
    FOR             reduce using rule 21 (simple -> declaration .)
    SEMICOLON       reduce using rule 21 (simple -> declaration .)
    L_FLOWBRACE     reduce using rule 21 (simple -> declaration .)
    TYPE            reduce using rule 21 (simple -> declaration .)
    NOT             reduce using rule 21 (simple -> declaration .)
    PLUS            reduce using rule 21 (simple -> declaration .)
    MINUS           reduce using rule 21 (simple -> declaration .)
    PLUS_PLUS       reduce using rule 21 (simple -> declaration .)
    MINUS_MINUS     reduce using rule 21 (simple -> declaration .)
    L_PAREN         reduce using rule 21 (simple -> declaration .)
    INT_NUM         reduce using rule 21 (simple -> declaration .)
    FLOAT_NUM       reduce using rule 21 (simple -> declaration .)
    ID              reduce using rule 21 (simple -> declaration .)
    $end            reduce using rule 21 (simple -> declaration .)
    R_FLOWBRACE     reduce using rule 21 (simple -> declaration .)
    ELSE            reduce using rule 21 (simple -> declaration .)


state 14

    (19) block -> L_FLOWBRACE . multiple_statements R_FLOWBRACE
    (2) multiple_statements -> . multiple_statements statement
    (3) multiple_statements -> . statement
    (4) statement -> . open
    (5) statement -> . closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) open -> . FOR for_condition open
    (10) closed -> . simple
    (11) closed -> . block
    (12) closed -> . IF condition closed ELSE closed
    (13) closed -> . WHILE condition closed
    (14) closed -> . FOR for_condition closed
    (20) simple -> . expr SEMICOLON
    (21) simple -> . declaration
    (22) simple -> . SEMICOLON
    (19) block -> . L_FLOWBRACE multiple_statements R_FLOWBRACE
    (23) expr -> . expr assignment exprOR
    (24) expr -> . exprOR
    (17) declaration -> . TYPE ID SEMICOLON
    (18) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (36) exprOR -> . exprOR OR exprAND
    (37) exprOR -> . exprAND
    (38) exprAND -> . exprAND AND exprBITOR
    (39) exprAND -> . exprBITOR
    (40) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (41) exprBITOR -> . exprBITXOR
    (42) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (43) exprBITXOR -> . exprBITAND
    (44) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (45) exprBITAND -> . exprEQ
    (46) exprEQ -> . exprEQ EQ exprRELOP
    (47) exprEQ -> . exprEQ NE exprRELOP
    (48) exprEQ -> . exprRELOP
    (49) exprRELOP -> . exprRELOP relop exprSHIFT
    (50) exprRELOP -> . exprSHIFT
    (55) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (56) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (57) exprSHIFT -> . exprOP
    (58) exprOP -> . exprOP PLUS term
    (59) exprOP -> . exprOP MINUS term
    (60) exprOP -> . term
    (61) term -> . term MULTIPLY factor
    (62) term -> . term DIVIDE factor
    (63) term -> . term MOD factor
    (64) term -> . factor
    (65) factor -> . NOT factor
    (66) factor -> . PLUS factor
    (67) factor -> . MINUS factor
    (68) factor -> . PLUS_PLUS factor
    (69) factor -> . MINUS_MINUS factor
    (70) factor -> . brace
    (71) brace -> . L_PAREN expr R_PAREN
    (72) brace -> . brace PLUS_PLUS
    (73) brace -> . brace MINUS_MINUS
    (74) brace -> . INT_NUM
    (75) brace -> . FLOAT_NUM
    (76) brace -> . ID

    IF              shift and go to state 6
    WHILE           shift and go to state 7
    FOR             shift and go to state 8
    SEMICOLON       shift and go to state 12
    L_FLOWBRACE     shift and go to state 14
    TYPE            shift and go to state 16
    NOT             shift and go to state 30
    PLUS            shift and go to state 26
    MINUS           shift and go to state 28
    PLUS_PLUS       shift and go to state 31
    MINUS_MINUS     shift and go to state 32
    L_PAREN         shift and go to state 34
    INT_NUM         shift and go to state 35
    FLOAT_NUM       shift and go to state 36
    ID              shift and go to state 17

    multiple_statements            shift and go to state 56
    statement                      shift and go to state 3
    open                           shift and go to state 4
    closed                         shift and go to state 5
    simple                         shift and go to state 9
    block                          shift and go to state 10
    expr                           shift and go to state 11
    declaration                    shift and go to state 13
    exprOR                         shift and go to state 15
    exprAND                        shift and go to state 18
    exprBITOR                      shift and go to state 19
    exprBITXOR                     shift and go to state 20
    exprBITAND                     shift and go to state 21
    exprEQ                         shift and go to state 22
    exprRELOP                      shift and go to state 23
    exprSHIFT                      shift and go to state 24
    exprOP                         shift and go to state 25
    term                           shift and go to state 27
    factor                         shift and go to state 29
    brace                          shift and go to state 33

state 15

    (24) expr -> exprOR .
    (36) exprOR -> exprOR . OR exprAND

    SEMICOLON       reduce using rule 24 (expr -> exprOR .)
    ASSIGN          reduce using rule 24 (expr -> exprOR .)
    PLUS_ASSIGN     reduce using rule 24 (expr -> exprOR .)
    MINUS_ASSIGN    reduce using rule 24 (expr -> exprOR .)
    MUL_ASSIGN      reduce using rule 24 (expr -> exprOR .)
    DIV_ASSIGN      reduce using rule 24 (expr -> exprOR .)
    AND_ASSIGN      reduce using rule 24 (expr -> exprOR .)
    OR_ASSIGN       reduce using rule 24 (expr -> exprOR .)
    XOR_ASSIGN      reduce using rule 24 (expr -> exprOR .)
    MOD_ASSIGN      reduce using rule 24 (expr -> exprOR .)
    L_SHIFT_ASSIGN  reduce using rule 24 (expr -> exprOR .)
    R_SHIFT_ASSIGN  reduce using rule 24 (expr -> exprOR .)
    R_PAREN         reduce using rule 24 (expr -> exprOR .)
    OR              shift and go to state 57


state 16

    (17) declaration -> TYPE . ID SEMICOLON
    (18) declaration -> TYPE . ID ASSIGN expr SEMICOLON

    ID              shift and go to state 58


state 17

    (76) brace -> ID .

    PLUS_PLUS       reduce using rule 76 (brace -> ID .)
    MINUS_MINUS     reduce using rule 76 (brace -> ID .)
    MULTIPLY        reduce using rule 76 (brace -> ID .)
    DIVIDE          reduce using rule 76 (brace -> ID .)
    MOD             reduce using rule 76 (brace -> ID .)
    PLUS            reduce using rule 76 (brace -> ID .)
    MINUS           reduce using rule 76 (brace -> ID .)
    L_SHIFT         reduce using rule 76 (brace -> ID .)
    R_SHIFT         reduce using rule 76 (brace -> ID .)
    LE              reduce using rule 76 (brace -> ID .)
    LT              reduce using rule 76 (brace -> ID .)
    GE              reduce using rule 76 (brace -> ID .)
    GT              reduce using rule 76 (brace -> ID .)
    EQ              reduce using rule 76 (brace -> ID .)
    NE              reduce using rule 76 (brace -> ID .)
    BIT_AND         reduce using rule 76 (brace -> ID .)
    BIT_XOR         reduce using rule 76 (brace -> ID .)
    BIT_OR          reduce using rule 76 (brace -> ID .)
    AND             reduce using rule 76 (brace -> ID .)
    OR              reduce using rule 76 (brace -> ID .)
    SEMICOLON       reduce using rule 76 (brace -> ID .)
    ASSIGN          reduce using rule 76 (brace -> ID .)
    PLUS_ASSIGN     reduce using rule 76 (brace -> ID .)
    MINUS_ASSIGN    reduce using rule 76 (brace -> ID .)
    MUL_ASSIGN      reduce using rule 76 (brace -> ID .)
    DIV_ASSIGN      reduce using rule 76 (brace -> ID .)
    AND_ASSIGN      reduce using rule 76 (brace -> ID .)
    OR_ASSIGN       reduce using rule 76 (brace -> ID .)
    XOR_ASSIGN      reduce using rule 76 (brace -> ID .)
    MOD_ASSIGN      reduce using rule 76 (brace -> ID .)
    L_SHIFT_ASSIGN  reduce using rule 76 (brace -> ID .)
    R_SHIFT_ASSIGN  reduce using rule 76 (brace -> ID .)
    R_PAREN         reduce using rule 76 (brace -> ID .)


state 18

    (37) exprOR -> exprAND .
    (38) exprAND -> exprAND . AND exprBITOR

    OR              reduce using rule 37 (exprOR -> exprAND .)
    SEMICOLON       reduce using rule 37 (exprOR -> exprAND .)
    ASSIGN          reduce using rule 37 (exprOR -> exprAND .)
    PLUS_ASSIGN     reduce using rule 37 (exprOR -> exprAND .)
    MINUS_ASSIGN    reduce using rule 37 (exprOR -> exprAND .)
    MUL_ASSIGN      reduce using rule 37 (exprOR -> exprAND .)
    DIV_ASSIGN      reduce using rule 37 (exprOR -> exprAND .)
    AND_ASSIGN      reduce using rule 37 (exprOR -> exprAND .)
    OR_ASSIGN       reduce using rule 37 (exprOR -> exprAND .)
    XOR_ASSIGN      reduce using rule 37 (exprOR -> exprAND .)
    MOD_ASSIGN      reduce using rule 37 (exprOR -> exprAND .)
    L_SHIFT_ASSIGN  reduce using rule 37 (exprOR -> exprAND .)
    R_SHIFT_ASSIGN  reduce using rule 37 (exprOR -> exprAND .)
    R_PAREN         reduce using rule 37 (exprOR -> exprAND .)
    AND             shift and go to state 59


state 19

    (39) exprAND -> exprBITOR .
    (40) exprBITOR -> exprBITOR . BIT_OR exprBITXOR

    AND             reduce using rule 39 (exprAND -> exprBITOR .)
    OR              reduce using rule 39 (exprAND -> exprBITOR .)
    SEMICOLON       reduce using rule 39 (exprAND -> exprBITOR .)
    ASSIGN          reduce using rule 39 (exprAND -> exprBITOR .)
    PLUS_ASSIGN     reduce using rule 39 (exprAND -> exprBITOR .)
    MINUS_ASSIGN    reduce using rule 39 (exprAND -> exprBITOR .)
    MUL_ASSIGN      reduce using rule 39 (exprAND -> exprBITOR .)
    DIV_ASSIGN      reduce using rule 39 (exprAND -> exprBITOR .)
    AND_ASSIGN      reduce using rule 39 (exprAND -> exprBITOR .)
    OR_ASSIGN       reduce using rule 39 (exprAND -> exprBITOR .)
    XOR_ASSIGN      reduce using rule 39 (exprAND -> exprBITOR .)
    MOD_ASSIGN      reduce using rule 39 (exprAND -> exprBITOR .)
    L_SHIFT_ASSIGN  reduce using rule 39 (exprAND -> exprBITOR .)
    R_SHIFT_ASSIGN  reduce using rule 39 (exprAND -> exprBITOR .)
    R_PAREN         reduce using rule 39 (exprAND -> exprBITOR .)
    BIT_OR          shift and go to state 60


state 20

    (41) exprBITOR -> exprBITXOR .
    (42) exprBITXOR -> exprBITXOR . BIT_XOR exprBITAND

    BIT_OR          reduce using rule 41 (exprBITOR -> exprBITXOR .)
    AND             reduce using rule 41 (exprBITOR -> exprBITXOR .)
    OR              reduce using rule 41 (exprBITOR -> exprBITXOR .)
    SEMICOLON       reduce using rule 41 (exprBITOR -> exprBITXOR .)
    ASSIGN          reduce using rule 41 (exprBITOR -> exprBITXOR .)
    PLUS_ASSIGN     reduce using rule 41 (exprBITOR -> exprBITXOR .)
    MINUS_ASSIGN    reduce using rule 41 (exprBITOR -> exprBITXOR .)
    MUL_ASSIGN      reduce using rule 41 (exprBITOR -> exprBITXOR .)
    DIV_ASSIGN      reduce using rule 41 (exprBITOR -> exprBITXOR .)
    AND_ASSIGN      reduce using rule 41 (exprBITOR -> exprBITXOR .)
    OR_ASSIGN       reduce using rule 41 (exprBITOR -> exprBITXOR .)
    XOR_ASSIGN      reduce using rule 41 (exprBITOR -> exprBITXOR .)
    MOD_ASSIGN      reduce using rule 41 (exprBITOR -> exprBITXOR .)
    L_SHIFT_ASSIGN  reduce using rule 41 (exprBITOR -> exprBITXOR .)
    R_SHIFT_ASSIGN  reduce using rule 41 (exprBITOR -> exprBITXOR .)
    R_PAREN         reduce using rule 41 (exprBITOR -> exprBITXOR .)
    BIT_XOR         shift and go to state 61


state 21

    (43) exprBITXOR -> exprBITAND .
    (44) exprBITAND -> exprBITAND . BIT_AND exprEQ

    BIT_XOR         reduce using rule 43 (exprBITXOR -> exprBITAND .)
    BIT_OR          reduce using rule 43 (exprBITXOR -> exprBITAND .)
    AND             reduce using rule 43 (exprBITXOR -> exprBITAND .)
    OR              reduce using rule 43 (exprBITXOR -> exprBITAND .)
    SEMICOLON       reduce using rule 43 (exprBITXOR -> exprBITAND .)
    ASSIGN          reduce using rule 43 (exprBITXOR -> exprBITAND .)
    PLUS_ASSIGN     reduce using rule 43 (exprBITXOR -> exprBITAND .)
    MINUS_ASSIGN    reduce using rule 43 (exprBITXOR -> exprBITAND .)
    MUL_ASSIGN      reduce using rule 43 (exprBITXOR -> exprBITAND .)
    DIV_ASSIGN      reduce using rule 43 (exprBITXOR -> exprBITAND .)
    AND_ASSIGN      reduce using rule 43 (exprBITXOR -> exprBITAND .)
    OR_ASSIGN       reduce using rule 43 (exprBITXOR -> exprBITAND .)
    XOR_ASSIGN      reduce using rule 43 (exprBITXOR -> exprBITAND .)
    MOD_ASSIGN      reduce using rule 43 (exprBITXOR -> exprBITAND .)
    L_SHIFT_ASSIGN  reduce using rule 43 (exprBITXOR -> exprBITAND .)
    R_SHIFT_ASSIGN  reduce using rule 43 (exprBITXOR -> exprBITAND .)
    R_PAREN         reduce using rule 43 (exprBITXOR -> exprBITAND .)
    BIT_AND         shift and go to state 62


state 22

    (45) exprBITAND -> exprEQ .
    (46) exprEQ -> exprEQ . EQ exprRELOP
    (47) exprEQ -> exprEQ . NE exprRELOP

    BIT_AND         reduce using rule 45 (exprBITAND -> exprEQ .)
    BIT_XOR         reduce using rule 45 (exprBITAND -> exprEQ .)
    BIT_OR          reduce using rule 45 (exprBITAND -> exprEQ .)
    AND             reduce using rule 45 (exprBITAND -> exprEQ .)
    OR              reduce using rule 45 (exprBITAND -> exprEQ .)
    SEMICOLON       reduce using rule 45 (exprBITAND -> exprEQ .)
    ASSIGN          reduce using rule 45 (exprBITAND -> exprEQ .)
    PLUS_ASSIGN     reduce using rule 45 (exprBITAND -> exprEQ .)
    MINUS_ASSIGN    reduce using rule 45 (exprBITAND -> exprEQ .)
    MUL_ASSIGN      reduce using rule 45 (exprBITAND -> exprEQ .)
    DIV_ASSIGN      reduce using rule 45 (exprBITAND -> exprEQ .)
    AND_ASSIGN      reduce using rule 45 (exprBITAND -> exprEQ .)
    OR_ASSIGN       reduce using rule 45 (exprBITAND -> exprEQ .)
    XOR_ASSIGN      reduce using rule 45 (exprBITAND -> exprEQ .)
    MOD_ASSIGN      reduce using rule 45 (exprBITAND -> exprEQ .)
    L_SHIFT_ASSIGN  reduce using rule 45 (exprBITAND -> exprEQ .)
    R_SHIFT_ASSIGN  reduce using rule 45 (exprBITAND -> exprEQ .)
    R_PAREN         reduce using rule 45 (exprBITAND -> exprEQ .)
    EQ              shift and go to state 63
    NE              shift and go to state 64


state 23

    (48) exprEQ -> exprRELOP .
    (49) exprRELOP -> exprRELOP . relop exprSHIFT
    (51) relop -> . LE
    (52) relop -> . LT
    (53) relop -> . GE
    (54) relop -> . GT

    EQ              reduce using rule 48 (exprEQ -> exprRELOP .)
    NE              reduce using rule 48 (exprEQ -> exprRELOP .)
    BIT_AND         reduce using rule 48 (exprEQ -> exprRELOP .)
    BIT_XOR         reduce using rule 48 (exprEQ -> exprRELOP .)
    BIT_OR          reduce using rule 48 (exprEQ -> exprRELOP .)
    AND             reduce using rule 48 (exprEQ -> exprRELOP .)
    OR              reduce using rule 48 (exprEQ -> exprRELOP .)
    SEMICOLON       reduce using rule 48 (exprEQ -> exprRELOP .)
    ASSIGN          reduce using rule 48 (exprEQ -> exprRELOP .)
    PLUS_ASSIGN     reduce using rule 48 (exprEQ -> exprRELOP .)
    MINUS_ASSIGN    reduce using rule 48 (exprEQ -> exprRELOP .)
    MUL_ASSIGN      reduce using rule 48 (exprEQ -> exprRELOP .)
    DIV_ASSIGN      reduce using rule 48 (exprEQ -> exprRELOP .)
    AND_ASSIGN      reduce using rule 48 (exprEQ -> exprRELOP .)
    OR_ASSIGN       reduce using rule 48 (exprEQ -> exprRELOP .)
    XOR_ASSIGN      reduce using rule 48 (exprEQ -> exprRELOP .)
    MOD_ASSIGN      reduce using rule 48 (exprEQ -> exprRELOP .)
    L_SHIFT_ASSIGN  reduce using rule 48 (exprEQ -> exprRELOP .)
    R_SHIFT_ASSIGN  reduce using rule 48 (exprEQ -> exprRELOP .)
    R_PAREN         reduce using rule 48 (exprEQ -> exprRELOP .)
    LE              shift and go to state 66
    LT              shift and go to state 67
    GE              shift and go to state 68
    GT              shift and go to state 69

    relop                          shift and go to state 65

state 24

    (50) exprRELOP -> exprSHIFT .
    (55) exprSHIFT -> exprSHIFT . L_SHIFT exprOP
    (56) exprSHIFT -> exprSHIFT . R_SHIFT exprOP

    LE              reduce using rule 50 (exprRELOP -> exprSHIFT .)
    LT              reduce using rule 50 (exprRELOP -> exprSHIFT .)
    GE              reduce using rule 50 (exprRELOP -> exprSHIFT .)
    GT              reduce using rule 50 (exprRELOP -> exprSHIFT .)
    EQ              reduce using rule 50 (exprRELOP -> exprSHIFT .)
    NE              reduce using rule 50 (exprRELOP -> exprSHIFT .)
    BIT_AND         reduce using rule 50 (exprRELOP -> exprSHIFT .)
    BIT_XOR         reduce using rule 50 (exprRELOP -> exprSHIFT .)
    BIT_OR          reduce using rule 50 (exprRELOP -> exprSHIFT .)
    AND             reduce using rule 50 (exprRELOP -> exprSHIFT .)
    OR              reduce using rule 50 (exprRELOP -> exprSHIFT .)
    SEMICOLON       reduce using rule 50 (exprRELOP -> exprSHIFT .)
    ASSIGN          reduce using rule 50 (exprRELOP -> exprSHIFT .)
    PLUS_ASSIGN     reduce using rule 50 (exprRELOP -> exprSHIFT .)
    MINUS_ASSIGN    reduce using rule 50 (exprRELOP -> exprSHIFT .)
    MUL_ASSIGN      reduce using rule 50 (exprRELOP -> exprSHIFT .)
    DIV_ASSIGN      reduce using rule 50 (exprRELOP -> exprSHIFT .)
    AND_ASSIGN      reduce using rule 50 (exprRELOP -> exprSHIFT .)
    OR_ASSIGN       reduce using rule 50 (exprRELOP -> exprSHIFT .)
    XOR_ASSIGN      reduce using rule 50 (exprRELOP -> exprSHIFT .)
    MOD_ASSIGN      reduce using rule 50 (exprRELOP -> exprSHIFT .)
    L_SHIFT_ASSIGN  reduce using rule 50 (exprRELOP -> exprSHIFT .)
    R_SHIFT_ASSIGN  reduce using rule 50 (exprRELOP -> exprSHIFT .)
    R_PAREN         reduce using rule 50 (exprRELOP -> exprSHIFT .)
    L_SHIFT         shift and go to state 70
    R_SHIFT         shift and go to state 71


state 25

    (57) exprSHIFT -> exprOP .
    (58) exprOP -> exprOP . PLUS term
    (59) exprOP -> exprOP . MINUS term

    L_SHIFT         reduce using rule 57 (exprSHIFT -> exprOP .)
    R_SHIFT         reduce using rule 57 (exprSHIFT -> exprOP .)
    LE              reduce using rule 57 (exprSHIFT -> exprOP .)
    LT              reduce using rule 57 (exprSHIFT -> exprOP .)
    GE              reduce using rule 57 (exprSHIFT -> exprOP .)
    GT              reduce using rule 57 (exprSHIFT -> exprOP .)
    EQ              reduce using rule 57 (exprSHIFT -> exprOP .)
    NE              reduce using rule 57 (exprSHIFT -> exprOP .)
    BIT_AND         reduce using rule 57 (exprSHIFT -> exprOP .)
    BIT_XOR         reduce using rule 57 (exprSHIFT -> exprOP .)
    BIT_OR          reduce using rule 57 (exprSHIFT -> exprOP .)
    AND             reduce using rule 57 (exprSHIFT -> exprOP .)
    OR              reduce using rule 57 (exprSHIFT -> exprOP .)
    SEMICOLON       reduce using rule 57 (exprSHIFT -> exprOP .)
    ASSIGN          reduce using rule 57 (exprSHIFT -> exprOP .)
    PLUS_ASSIGN     reduce using rule 57 (exprSHIFT -> exprOP .)
    MINUS_ASSIGN    reduce using rule 57 (exprSHIFT -> exprOP .)
    MUL_ASSIGN      reduce using rule 57 (exprSHIFT -> exprOP .)
    DIV_ASSIGN      reduce using rule 57 (exprSHIFT -> exprOP .)
    AND_ASSIGN      reduce using rule 57 (exprSHIFT -> exprOP .)
    OR_ASSIGN       reduce using rule 57 (exprSHIFT -> exprOP .)
    XOR_ASSIGN      reduce using rule 57 (exprSHIFT -> exprOP .)
    MOD_ASSIGN      reduce using rule 57 (exprSHIFT -> exprOP .)
    L_SHIFT_ASSIGN  reduce using rule 57 (exprSHIFT -> exprOP .)
    R_SHIFT_ASSIGN  reduce using rule 57 (exprSHIFT -> exprOP .)
    R_PAREN         reduce using rule 57 (exprSHIFT -> exprOP .)
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73


state 26

    (66) factor -> PLUS . factor
    (65) factor -> . NOT factor
    (66) factor -> . PLUS factor
    (67) factor -> . MINUS factor
    (68) factor -> . PLUS_PLUS factor
    (69) factor -> . MINUS_MINUS factor
    (70) factor -> . brace
    (71) brace -> . L_PAREN expr R_PAREN
    (72) brace -> . brace PLUS_PLUS
    (73) brace -> . brace MINUS_MINUS
    (74) brace -> . INT_NUM
    (75) brace -> . FLOAT_NUM
    (76) brace -> . ID

    NOT             shift and go to state 30
    PLUS            shift and go to state 26
    MINUS           shift and go to state 28
    PLUS_PLUS       shift and go to state 31
    MINUS_MINUS     shift and go to state 32
    L_PAREN         shift and go to state 34
    INT_NUM         shift and go to state 35
    FLOAT_NUM       shift and go to state 36
    ID              shift and go to state 17

    factor                         shift and go to state 74
    brace                          shift and go to state 33

state 27

    (60) exprOP -> term .
    (61) term -> term . MULTIPLY factor
    (62) term -> term . DIVIDE factor
    (63) term -> term . MOD factor

    PLUS            reduce using rule 60 (exprOP -> term .)
    MINUS           reduce using rule 60 (exprOP -> term .)
    L_SHIFT         reduce using rule 60 (exprOP -> term .)
    R_SHIFT         reduce using rule 60 (exprOP -> term .)
    LE              reduce using rule 60 (exprOP -> term .)
    LT              reduce using rule 60 (exprOP -> term .)
    GE              reduce using rule 60 (exprOP -> term .)
    GT              reduce using rule 60 (exprOP -> term .)
    EQ              reduce using rule 60 (exprOP -> term .)
    NE              reduce using rule 60 (exprOP -> term .)
    BIT_AND         reduce using rule 60 (exprOP -> term .)
    BIT_XOR         reduce using rule 60 (exprOP -> term .)
    BIT_OR          reduce using rule 60 (exprOP -> term .)
    AND             reduce using rule 60 (exprOP -> term .)
    OR              reduce using rule 60 (exprOP -> term .)
    SEMICOLON       reduce using rule 60 (exprOP -> term .)
    ASSIGN          reduce using rule 60 (exprOP -> term .)
    PLUS_ASSIGN     reduce using rule 60 (exprOP -> term .)
    MINUS_ASSIGN    reduce using rule 60 (exprOP -> term .)
    MUL_ASSIGN      reduce using rule 60 (exprOP -> term .)
    DIV_ASSIGN      reduce using rule 60 (exprOP -> term .)
    AND_ASSIGN      reduce using rule 60 (exprOP -> term .)
    OR_ASSIGN       reduce using rule 60 (exprOP -> term .)
    XOR_ASSIGN      reduce using rule 60 (exprOP -> term .)
    MOD_ASSIGN      reduce using rule 60 (exprOP -> term .)
    L_SHIFT_ASSIGN  reduce using rule 60 (exprOP -> term .)
    R_SHIFT_ASSIGN  reduce using rule 60 (exprOP -> term .)
    R_PAREN         reduce using rule 60 (exprOP -> term .)
    MULTIPLY        shift and go to state 75
    DIVIDE          shift and go to state 76
    MOD             shift and go to state 77


state 28

    (67) factor -> MINUS . factor
    (65) factor -> . NOT factor
    (66) factor -> . PLUS factor
    (67) factor -> . MINUS factor
    (68) factor -> . PLUS_PLUS factor
    (69) factor -> . MINUS_MINUS factor
    (70) factor -> . brace
    (71) brace -> . L_PAREN expr R_PAREN
    (72) brace -> . brace PLUS_PLUS
    (73) brace -> . brace MINUS_MINUS
    (74) brace -> . INT_NUM
    (75) brace -> . FLOAT_NUM
    (76) brace -> . ID

    NOT             shift and go to state 30
    PLUS            shift and go to state 26
    MINUS           shift and go to state 28
    PLUS_PLUS       shift and go to state 31
    MINUS_MINUS     shift and go to state 32
    L_PAREN         shift and go to state 34
    INT_NUM         shift and go to state 35
    FLOAT_NUM       shift and go to state 36
    ID              shift and go to state 17

    factor                         shift and go to state 78
    brace                          shift and go to state 33

state 29

    (64) term -> factor .

    MULTIPLY        reduce using rule 64 (term -> factor .)
    DIVIDE          reduce using rule 64 (term -> factor .)
    MOD             reduce using rule 64 (term -> factor .)
    PLUS            reduce using rule 64 (term -> factor .)
    MINUS           reduce using rule 64 (term -> factor .)
    L_SHIFT         reduce using rule 64 (term -> factor .)
    R_SHIFT         reduce using rule 64 (term -> factor .)
    LE              reduce using rule 64 (term -> factor .)
    LT              reduce using rule 64 (term -> factor .)
    GE              reduce using rule 64 (term -> factor .)
    GT              reduce using rule 64 (term -> factor .)
    EQ              reduce using rule 64 (term -> factor .)
    NE              reduce using rule 64 (term -> factor .)
    BIT_AND         reduce using rule 64 (term -> factor .)
    BIT_XOR         reduce using rule 64 (term -> factor .)
    BIT_OR          reduce using rule 64 (term -> factor .)
    AND             reduce using rule 64 (term -> factor .)
    OR              reduce using rule 64 (term -> factor .)
    SEMICOLON       reduce using rule 64 (term -> factor .)
    ASSIGN          reduce using rule 64 (term -> factor .)
    PLUS_ASSIGN     reduce using rule 64 (term -> factor .)
    MINUS_ASSIGN    reduce using rule 64 (term -> factor .)
    MUL_ASSIGN      reduce using rule 64 (term -> factor .)
    DIV_ASSIGN      reduce using rule 64 (term -> factor .)
    AND_ASSIGN      reduce using rule 64 (term -> factor .)
    OR_ASSIGN       reduce using rule 64 (term -> factor .)
    XOR_ASSIGN      reduce using rule 64 (term -> factor .)
    MOD_ASSIGN      reduce using rule 64 (term -> factor .)
    L_SHIFT_ASSIGN  reduce using rule 64 (term -> factor .)
    R_SHIFT_ASSIGN  reduce using rule 64 (term -> factor .)
    R_PAREN         reduce using rule 64 (term -> factor .)


state 30

    (65) factor -> NOT . factor
    (65) factor -> . NOT factor
    (66) factor -> . PLUS factor
    (67) factor -> . MINUS factor
    (68) factor -> . PLUS_PLUS factor
    (69) factor -> . MINUS_MINUS factor
    (70) factor -> . brace
    (71) brace -> . L_PAREN expr R_PAREN
    (72) brace -> . brace PLUS_PLUS
    (73) brace -> . brace MINUS_MINUS
    (74) brace -> . INT_NUM
    (75) brace -> . FLOAT_NUM
    (76) brace -> . ID

    NOT             shift and go to state 30
    PLUS            shift and go to state 26
    MINUS           shift and go to state 28
    PLUS_PLUS       shift and go to state 31
    MINUS_MINUS     shift and go to state 32
    L_PAREN         shift and go to state 34
    INT_NUM         shift and go to state 35
    FLOAT_NUM       shift and go to state 36
    ID              shift and go to state 17

    factor                         shift and go to state 79
    brace                          shift and go to state 33

state 31

    (68) factor -> PLUS_PLUS . factor
    (65) factor -> . NOT factor
    (66) factor -> . PLUS factor
    (67) factor -> . MINUS factor
    (68) factor -> . PLUS_PLUS factor
    (69) factor -> . MINUS_MINUS factor
    (70) factor -> . brace
    (71) brace -> . L_PAREN expr R_PAREN
    (72) brace -> . brace PLUS_PLUS
    (73) brace -> . brace MINUS_MINUS
    (74) brace -> . INT_NUM
    (75) brace -> . FLOAT_NUM
    (76) brace -> . ID

    NOT             shift and go to state 30
    PLUS            shift and go to state 26
    MINUS           shift and go to state 28
    PLUS_PLUS       shift and go to state 31
    MINUS_MINUS     shift and go to state 32
    L_PAREN         shift and go to state 34
    INT_NUM         shift and go to state 35
    FLOAT_NUM       shift and go to state 36
    ID              shift and go to state 17

    factor                         shift and go to state 80
    brace                          shift and go to state 33

state 32

    (69) factor -> MINUS_MINUS . factor
    (65) factor -> . NOT factor
    (66) factor -> . PLUS factor
    (67) factor -> . MINUS factor
    (68) factor -> . PLUS_PLUS factor
    (69) factor -> . MINUS_MINUS factor
    (70) factor -> . brace
    (71) brace -> . L_PAREN expr R_PAREN
    (72) brace -> . brace PLUS_PLUS
    (73) brace -> . brace MINUS_MINUS
    (74) brace -> . INT_NUM
    (75) brace -> . FLOAT_NUM
    (76) brace -> . ID

    NOT             shift and go to state 30
    PLUS            shift and go to state 26
    MINUS           shift and go to state 28
    PLUS_PLUS       shift and go to state 31
    MINUS_MINUS     shift and go to state 32
    L_PAREN         shift and go to state 34
    INT_NUM         shift and go to state 35
    FLOAT_NUM       shift and go to state 36
    ID              shift and go to state 17

    factor                         shift and go to state 81
    brace                          shift and go to state 33

state 33

    (70) factor -> brace .
    (72) brace -> brace . PLUS_PLUS
    (73) brace -> brace . MINUS_MINUS

    MULTIPLY        reduce using rule 70 (factor -> brace .)
    DIVIDE          reduce using rule 70 (factor -> brace .)
    MOD             reduce using rule 70 (factor -> brace .)
    PLUS            reduce using rule 70 (factor -> brace .)
    MINUS           reduce using rule 70 (factor -> brace .)
    L_SHIFT         reduce using rule 70 (factor -> brace .)
    R_SHIFT         reduce using rule 70 (factor -> brace .)
    LE              reduce using rule 70 (factor -> brace .)
    LT              reduce using rule 70 (factor -> brace .)
    GE              reduce using rule 70 (factor -> brace .)
    GT              reduce using rule 70 (factor -> brace .)
    EQ              reduce using rule 70 (factor -> brace .)
    NE              reduce using rule 70 (factor -> brace .)
    BIT_AND         reduce using rule 70 (factor -> brace .)
    BIT_XOR         reduce using rule 70 (factor -> brace .)
    BIT_OR          reduce using rule 70 (factor -> brace .)
    AND             reduce using rule 70 (factor -> brace .)
    OR              reduce using rule 70 (factor -> brace .)
    SEMICOLON       reduce using rule 70 (factor -> brace .)
    ASSIGN          reduce using rule 70 (factor -> brace .)
    PLUS_ASSIGN     reduce using rule 70 (factor -> brace .)
    MINUS_ASSIGN    reduce using rule 70 (factor -> brace .)
    MUL_ASSIGN      reduce using rule 70 (factor -> brace .)
    DIV_ASSIGN      reduce using rule 70 (factor -> brace .)
    AND_ASSIGN      reduce using rule 70 (factor -> brace .)
    OR_ASSIGN       reduce using rule 70 (factor -> brace .)
    XOR_ASSIGN      reduce using rule 70 (factor -> brace .)
    MOD_ASSIGN      reduce using rule 70 (factor -> brace .)
    L_SHIFT_ASSIGN  reduce using rule 70 (factor -> brace .)
    R_SHIFT_ASSIGN  reduce using rule 70 (factor -> brace .)
    R_PAREN         reduce using rule 70 (factor -> brace .)
    PLUS_PLUS       shift and go to state 82
    MINUS_MINUS     shift and go to state 83


state 34

    (71) brace -> L_PAREN . expr R_PAREN
    (23) expr -> . expr assignment exprOR
    (24) expr -> . exprOR
    (36) exprOR -> . exprOR OR exprAND
    (37) exprOR -> . exprAND
    (38) exprAND -> . exprAND AND exprBITOR
    (39) exprAND -> . exprBITOR
    (40) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (41) exprBITOR -> . exprBITXOR
    (42) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (43) exprBITXOR -> . exprBITAND
    (44) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (45) exprBITAND -> . exprEQ
    (46) exprEQ -> . exprEQ EQ exprRELOP
    (47) exprEQ -> . exprEQ NE exprRELOP
    (48) exprEQ -> . exprRELOP
    (49) exprRELOP -> . exprRELOP relop exprSHIFT
    (50) exprRELOP -> . exprSHIFT
    (55) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (56) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (57) exprSHIFT -> . exprOP
    (58) exprOP -> . exprOP PLUS term
    (59) exprOP -> . exprOP MINUS term
    (60) exprOP -> . term
    (61) term -> . term MULTIPLY factor
    (62) term -> . term DIVIDE factor
    (63) term -> . term MOD factor
    (64) term -> . factor
    (65) factor -> . NOT factor
    (66) factor -> . PLUS factor
    (67) factor -> . MINUS factor
    (68) factor -> . PLUS_PLUS factor
    (69) factor -> . MINUS_MINUS factor
    (70) factor -> . brace
    (71) brace -> . L_PAREN expr R_PAREN
    (72) brace -> . brace PLUS_PLUS
    (73) brace -> . brace MINUS_MINUS
    (74) brace -> . INT_NUM
    (75) brace -> . FLOAT_NUM
    (76) brace -> . ID

    NOT             shift and go to state 30
    PLUS            shift and go to state 26
    MINUS           shift and go to state 28
    PLUS_PLUS       shift and go to state 31
    MINUS_MINUS     shift and go to state 32
    L_PAREN         shift and go to state 34
    INT_NUM         shift and go to state 35
    FLOAT_NUM       shift and go to state 36
    ID              shift and go to state 17

    expr                           shift and go to state 84
    exprOR                         shift and go to state 15
    exprAND                        shift and go to state 18
    exprBITOR                      shift and go to state 19
    exprBITXOR                     shift and go to state 20
    exprBITAND                     shift and go to state 21
    exprEQ                         shift and go to state 22
    exprRELOP                      shift and go to state 23
    exprSHIFT                      shift and go to state 24
    exprOP                         shift and go to state 25
    term                           shift and go to state 27
    factor                         shift and go to state 29
    brace                          shift and go to state 33

state 35

    (74) brace -> INT_NUM .

    PLUS_PLUS       reduce using rule 74 (brace -> INT_NUM .)
    MINUS_MINUS     reduce using rule 74 (brace -> INT_NUM .)
    MULTIPLY        reduce using rule 74 (brace -> INT_NUM .)
    DIVIDE          reduce using rule 74 (brace -> INT_NUM .)
    MOD             reduce using rule 74 (brace -> INT_NUM .)
    PLUS            reduce using rule 74 (brace -> INT_NUM .)
    MINUS           reduce using rule 74 (brace -> INT_NUM .)
    L_SHIFT         reduce using rule 74 (brace -> INT_NUM .)
    R_SHIFT         reduce using rule 74 (brace -> INT_NUM .)
    LE              reduce using rule 74 (brace -> INT_NUM .)
    LT              reduce using rule 74 (brace -> INT_NUM .)
    GE              reduce using rule 74 (brace -> INT_NUM .)
    GT              reduce using rule 74 (brace -> INT_NUM .)
    EQ              reduce using rule 74 (brace -> INT_NUM .)
    NE              reduce using rule 74 (brace -> INT_NUM .)
    BIT_AND         reduce using rule 74 (brace -> INT_NUM .)
    BIT_XOR         reduce using rule 74 (brace -> INT_NUM .)
    BIT_OR          reduce using rule 74 (brace -> INT_NUM .)
    AND             reduce using rule 74 (brace -> INT_NUM .)
    OR              reduce using rule 74 (brace -> INT_NUM .)
    SEMICOLON       reduce using rule 74 (brace -> INT_NUM .)
    ASSIGN          reduce using rule 74 (brace -> INT_NUM .)
    PLUS_ASSIGN     reduce using rule 74 (brace -> INT_NUM .)
    MINUS_ASSIGN    reduce using rule 74 (brace -> INT_NUM .)
    MUL_ASSIGN      reduce using rule 74 (brace -> INT_NUM .)
    DIV_ASSIGN      reduce using rule 74 (brace -> INT_NUM .)
    AND_ASSIGN      reduce using rule 74 (brace -> INT_NUM .)
    OR_ASSIGN       reduce using rule 74 (brace -> INT_NUM .)
    XOR_ASSIGN      reduce using rule 74 (brace -> INT_NUM .)
    MOD_ASSIGN      reduce using rule 74 (brace -> INT_NUM .)
    L_SHIFT_ASSIGN  reduce using rule 74 (brace -> INT_NUM .)
    R_SHIFT_ASSIGN  reduce using rule 74 (brace -> INT_NUM .)
    R_PAREN         reduce using rule 74 (brace -> INT_NUM .)


state 36

    (75) brace -> FLOAT_NUM .

    PLUS_PLUS       reduce using rule 75 (brace -> FLOAT_NUM .)
    MINUS_MINUS     reduce using rule 75 (brace -> FLOAT_NUM .)
    MULTIPLY        reduce using rule 75 (brace -> FLOAT_NUM .)
    DIVIDE          reduce using rule 75 (brace -> FLOAT_NUM .)
    MOD             reduce using rule 75 (brace -> FLOAT_NUM .)
    PLUS            reduce using rule 75 (brace -> FLOAT_NUM .)
    MINUS           reduce using rule 75 (brace -> FLOAT_NUM .)
    L_SHIFT         reduce using rule 75 (brace -> FLOAT_NUM .)
    R_SHIFT         reduce using rule 75 (brace -> FLOAT_NUM .)
    LE              reduce using rule 75 (brace -> FLOAT_NUM .)
    LT              reduce using rule 75 (brace -> FLOAT_NUM .)
    GE              reduce using rule 75 (brace -> FLOAT_NUM .)
    GT              reduce using rule 75 (brace -> FLOAT_NUM .)
    EQ              reduce using rule 75 (brace -> FLOAT_NUM .)
    NE              reduce using rule 75 (brace -> FLOAT_NUM .)
    BIT_AND         reduce using rule 75 (brace -> FLOAT_NUM .)
    BIT_XOR         reduce using rule 75 (brace -> FLOAT_NUM .)
    BIT_OR          reduce using rule 75 (brace -> FLOAT_NUM .)
    AND             reduce using rule 75 (brace -> FLOAT_NUM .)
    OR              reduce using rule 75 (brace -> FLOAT_NUM .)
    SEMICOLON       reduce using rule 75 (brace -> FLOAT_NUM .)
    ASSIGN          reduce using rule 75 (brace -> FLOAT_NUM .)
    PLUS_ASSIGN     reduce using rule 75 (brace -> FLOAT_NUM .)
    MINUS_ASSIGN    reduce using rule 75 (brace -> FLOAT_NUM .)
    MUL_ASSIGN      reduce using rule 75 (brace -> FLOAT_NUM .)
    DIV_ASSIGN      reduce using rule 75 (brace -> FLOAT_NUM .)
    AND_ASSIGN      reduce using rule 75 (brace -> FLOAT_NUM .)
    OR_ASSIGN       reduce using rule 75 (brace -> FLOAT_NUM .)
    XOR_ASSIGN      reduce using rule 75 (brace -> FLOAT_NUM .)
    MOD_ASSIGN      reduce using rule 75 (brace -> FLOAT_NUM .)
    L_SHIFT_ASSIGN  reduce using rule 75 (brace -> FLOAT_NUM .)
    R_SHIFT_ASSIGN  reduce using rule 75 (brace -> FLOAT_NUM .)
    R_PAREN         reduce using rule 75 (brace -> FLOAT_NUM .)


state 37

    (2) multiple_statements -> multiple_statements statement .

    IF              reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    WHILE           reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    FOR             reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    SEMICOLON       reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    L_FLOWBRACE     reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    TYPE            reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    NOT             reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    PLUS            reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    MINUS           reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    PLUS_PLUS       reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    MINUS_MINUS     reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    L_PAREN         reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    INT_NUM         reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    FLOAT_NUM       reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    ID              reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    $end            reduce using rule 2 (multiple_statements -> multiple_statements statement .)
    R_FLOWBRACE     reduce using rule 2 (multiple_statements -> multiple_statements statement .)


state 38

    (6) open -> IF condition . statement
    (7) open -> IF condition . closed ELSE open
    (12) closed -> IF condition . closed ELSE closed
    (4) statement -> . open
    (5) statement -> . closed
    (10) closed -> . simple
    (11) closed -> . block
    (12) closed -> . IF condition closed ELSE closed
    (13) closed -> . WHILE condition closed
    (14) closed -> . FOR for_condition closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) open -> . FOR for_condition open
    (20) simple -> . expr SEMICOLON
    (21) simple -> . declaration
    (22) simple -> . SEMICOLON
    (19) block -> . L_FLOWBRACE multiple_statements R_FLOWBRACE
    (23) expr -> . expr assignment exprOR
    (24) expr -> . exprOR
    (17) declaration -> . TYPE ID SEMICOLON
    (18) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (36) exprOR -> . exprOR OR exprAND
    (37) exprOR -> . exprAND
    (38) exprAND -> . exprAND AND exprBITOR
    (39) exprAND -> . exprBITOR
    (40) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (41) exprBITOR -> . exprBITXOR
    (42) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (43) exprBITXOR -> . exprBITAND
    (44) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (45) exprBITAND -> . exprEQ
    (46) exprEQ -> . exprEQ EQ exprRELOP
    (47) exprEQ -> . exprEQ NE exprRELOP
    (48) exprEQ -> . exprRELOP
    (49) exprRELOP -> . exprRELOP relop exprSHIFT
    (50) exprRELOP -> . exprSHIFT
    (55) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (56) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (57) exprSHIFT -> . exprOP
    (58) exprOP -> . exprOP PLUS term
    (59) exprOP -> . exprOP MINUS term
    (60) exprOP -> . term
    (61) term -> . term MULTIPLY factor
    (62) term -> . term DIVIDE factor
    (63) term -> . term MOD factor
    (64) term -> . factor
    (65) factor -> . NOT factor
    (66) factor -> . PLUS factor
    (67) factor -> . MINUS factor
    (68) factor -> . PLUS_PLUS factor
    (69) factor -> . MINUS_MINUS factor
    (70) factor -> . brace
    (71) brace -> . L_PAREN expr R_PAREN
    (72) brace -> . brace PLUS_PLUS
    (73) brace -> . brace MINUS_MINUS
    (74) brace -> . INT_NUM
    (75) brace -> . FLOAT_NUM
    (76) brace -> . ID

    IF              shift and go to state 85
    WHILE           shift and go to state 88
    FOR             shift and go to state 89
    SEMICOLON       shift and go to state 12
    L_FLOWBRACE     shift and go to state 14
    TYPE            shift and go to state 16
    NOT             shift and go to state 30
    PLUS            shift and go to state 26
    MINUS           shift and go to state 28
    PLUS_PLUS       shift and go to state 31
    MINUS_MINUS     shift and go to state 32
    L_PAREN         shift and go to state 34
    INT_NUM         shift and go to state 35
    FLOAT_NUM       shift and go to state 36
    ID              shift and go to state 17

    statement                      shift and go to state 86
    closed                         shift and go to state 87
    open                           shift and go to state 4
    simple                         shift and go to state 9
    block                          shift and go to state 10
    expr                           shift and go to state 11
    declaration                    shift and go to state 13
    exprOR                         shift and go to state 15
    exprAND                        shift and go to state 18
    exprBITOR                      shift and go to state 19
    exprBITXOR                     shift and go to state 20
    exprBITAND                     shift and go to state 21
    exprEQ                         shift and go to state 22
    exprRELOP                      shift and go to state 23
    exprSHIFT                      shift and go to state 24
    exprOP                         shift and go to state 25
    term                           shift and go to state 27
    factor                         shift and go to state 29
    brace                          shift and go to state 33

state 39

    (15) condition -> L_PAREN . expr R_PAREN
    (23) expr -> . expr assignment exprOR
    (24) expr -> . exprOR
    (36) exprOR -> . exprOR OR exprAND
    (37) exprOR -> . exprAND
    (38) exprAND -> . exprAND AND exprBITOR
    (39) exprAND -> . exprBITOR
    (40) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (41) exprBITOR -> . exprBITXOR
    (42) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (43) exprBITXOR -> . exprBITAND
    (44) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (45) exprBITAND -> . exprEQ
    (46) exprEQ -> . exprEQ EQ exprRELOP
    (47) exprEQ -> . exprEQ NE exprRELOP
    (48) exprEQ -> . exprRELOP
    (49) exprRELOP -> . exprRELOP relop exprSHIFT
    (50) exprRELOP -> . exprSHIFT
    (55) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (56) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (57) exprSHIFT -> . exprOP
    (58) exprOP -> . exprOP PLUS term
    (59) exprOP -> . exprOP MINUS term
    (60) exprOP -> . term
    (61) term -> . term MULTIPLY factor
    (62) term -> . term DIVIDE factor
    (63) term -> . term MOD factor
    (64) term -> . factor
    (65) factor -> . NOT factor
    (66) factor -> . PLUS factor
    (67) factor -> . MINUS factor
    (68) factor -> . PLUS_PLUS factor
    (69) factor -> . MINUS_MINUS factor
    (70) factor -> . brace
    (71) brace -> . L_PAREN expr R_PAREN
    (72) brace -> . brace PLUS_PLUS
    (73) brace -> . brace MINUS_MINUS
    (74) brace -> . INT_NUM
    (75) brace -> . FLOAT_NUM
    (76) brace -> . ID

    NOT             shift and go to state 30
    PLUS            shift and go to state 26
    MINUS           shift and go to state 28
    PLUS_PLUS       shift and go to state 31
    MINUS_MINUS     shift and go to state 32
    L_PAREN         shift and go to state 34
    INT_NUM         shift and go to state 35
    FLOAT_NUM       shift and go to state 36
    ID              shift and go to state 17

    expr                           shift and go to state 90
    exprOR                         shift and go to state 15
    exprAND                        shift and go to state 18
    exprBITOR                      shift and go to state 19
    exprBITXOR                     shift and go to state 20
    exprBITAND                     shift and go to state 21
    exprEQ                         shift and go to state 22
    exprRELOP                      shift and go to state 23
    exprSHIFT                      shift and go to state 24
    exprOP                         shift and go to state 25
    term                           shift and go to state 27
    factor                         shift and go to state 29
    brace                          shift and go to state 33

state 40

    (8) open -> WHILE condition . open
    (13) closed -> WHILE condition . closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) open -> . FOR for_condition open
    (10) closed -> . simple
    (11) closed -> . block
    (12) closed -> . IF condition closed ELSE closed
    (13) closed -> . WHILE condition closed
    (14) closed -> . FOR for_condition closed
    (20) simple -> . expr SEMICOLON
    (21) simple -> . declaration
    (22) simple -> . SEMICOLON
    (19) block -> . L_FLOWBRACE multiple_statements R_FLOWBRACE
    (23) expr -> . expr assignment exprOR
    (24) expr -> . exprOR
    (17) declaration -> . TYPE ID SEMICOLON
    (18) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (36) exprOR -> . exprOR OR exprAND
    (37) exprOR -> . exprAND
    (38) exprAND -> . exprAND AND exprBITOR
    (39) exprAND -> . exprBITOR
    (40) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (41) exprBITOR -> . exprBITXOR
    (42) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (43) exprBITXOR -> . exprBITAND
    (44) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (45) exprBITAND -> . exprEQ
    (46) exprEQ -> . exprEQ EQ exprRELOP
    (47) exprEQ -> . exprEQ NE exprRELOP
    (48) exprEQ -> . exprRELOP
    (49) exprRELOP -> . exprRELOP relop exprSHIFT
    (50) exprRELOP -> . exprSHIFT
    (55) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (56) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (57) exprSHIFT -> . exprOP
    (58) exprOP -> . exprOP PLUS term
    (59) exprOP -> . exprOP MINUS term
    (60) exprOP -> . term
    (61) term -> . term MULTIPLY factor
    (62) term -> . term DIVIDE factor
    (63) term -> . term MOD factor
    (64) term -> . factor
    (65) factor -> . NOT factor
    (66) factor -> . PLUS factor
    (67) factor -> . MINUS factor
    (68) factor -> . PLUS_PLUS factor
    (69) factor -> . MINUS_MINUS factor
    (70) factor -> . brace
    (71) brace -> . L_PAREN expr R_PAREN
    (72) brace -> . brace PLUS_PLUS
    (73) brace -> . brace MINUS_MINUS
    (74) brace -> . INT_NUM
    (75) brace -> . FLOAT_NUM
    (76) brace -> . ID

    IF              shift and go to state 6
    WHILE           shift and go to state 7
    FOR             shift and go to state 8
    SEMICOLON       shift and go to state 12
    L_FLOWBRACE     shift and go to state 14
    TYPE            shift and go to state 16
    NOT             shift and go to state 30
    PLUS            shift and go to state 26
    MINUS           shift and go to state 28
    PLUS_PLUS       shift and go to state 31
    MINUS_MINUS     shift and go to state 32
    L_PAREN         shift and go to state 34
    INT_NUM         shift and go to state 35
    FLOAT_NUM       shift and go to state 36
    ID              shift and go to state 17

    open                           shift and go to state 91
    closed                         shift and go to state 92
    simple                         shift and go to state 9
    block                          shift and go to state 10
    expr                           shift and go to state 11
    declaration                    shift and go to state 13
    exprOR                         shift and go to state 15
    exprAND                        shift and go to state 18
    exprBITOR                      shift and go to state 19
    exprBITXOR                     shift and go to state 20
    exprBITAND                     shift and go to state 21
    exprEQ                         shift and go to state 22
    exprRELOP                      shift and go to state 23
    exprSHIFT                      shift and go to state 24
    exprOP                         shift and go to state 25
    term                           shift and go to state 27
    factor                         shift and go to state 29
    brace                          shift and go to state 33

state 41

    (9) open -> FOR for_condition . open
    (14) closed -> FOR for_condition . closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) open -> . FOR for_condition open
    (10) closed -> . simple
    (11) closed -> . block
    (12) closed -> . IF condition closed ELSE closed
    (13) closed -> . WHILE condition closed
    (14) closed -> . FOR for_condition closed
    (20) simple -> . expr SEMICOLON
    (21) simple -> . declaration
    (22) simple -> . SEMICOLON
    (19) block -> . L_FLOWBRACE multiple_statements R_FLOWBRACE
    (23) expr -> . expr assignment exprOR
    (24) expr -> . exprOR
    (17) declaration -> . TYPE ID SEMICOLON
    (18) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (36) exprOR -> . exprOR OR exprAND
    (37) exprOR -> . exprAND
    (38) exprAND -> . exprAND AND exprBITOR
    (39) exprAND -> . exprBITOR
    (40) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (41) exprBITOR -> . exprBITXOR
    (42) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (43) exprBITXOR -> . exprBITAND
    (44) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (45) exprBITAND -> . exprEQ
    (46) exprEQ -> . exprEQ EQ exprRELOP
    (47) exprEQ -> . exprEQ NE exprRELOP
    (48) exprEQ -> . exprRELOP
    (49) exprRELOP -> . exprRELOP relop exprSHIFT
    (50) exprRELOP -> . exprSHIFT
    (55) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (56) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (57) exprSHIFT -> . exprOP
    (58) exprOP -> . exprOP PLUS term
    (59) exprOP -> . exprOP MINUS term
    (60) exprOP -> . term
    (61) term -> . term MULTIPLY factor
    (62) term -> . term DIVIDE factor
    (63) term -> . term MOD factor
    (64) term -> . factor
    (65) factor -> . NOT factor
    (66) factor -> . PLUS factor
    (67) factor -> . MINUS factor
    (68) factor -> . PLUS_PLUS factor
    (69) factor -> . MINUS_MINUS factor
    (70) factor -> . brace
    (71) brace -> . L_PAREN expr R_PAREN
    (72) brace -> . brace PLUS_PLUS
    (73) brace -> . brace MINUS_MINUS
    (74) brace -> . INT_NUM
    (75) brace -> . FLOAT_NUM
    (76) brace -> . ID

    IF              shift and go to state 6
    WHILE           shift and go to state 7
    FOR             shift and go to state 8
    SEMICOLON       shift and go to state 12
    L_FLOWBRACE     shift and go to state 14
    TYPE            shift and go to state 16
    NOT             shift and go to state 30
    PLUS            shift and go to state 26
    MINUS           shift and go to state 28
    PLUS_PLUS       shift and go to state 31
    MINUS_MINUS     shift and go to state 32
    L_PAREN         shift and go to state 34
    INT_NUM         shift and go to state 35
    FLOAT_NUM       shift and go to state 36
    ID              shift and go to state 17

    open                           shift and go to state 93
    closed                         shift and go to state 94
    simple                         shift and go to state 9
    block                          shift and go to state 10
    expr                           shift and go to state 11
    declaration                    shift and go to state 13
    exprOR                         shift and go to state 15
    exprAND                        shift and go to state 18
    exprBITOR                      shift and go to state 19
    exprBITXOR                     shift and go to state 20
    exprBITAND                     shift and go to state 21
    exprEQ                         shift and go to state 22
    exprRELOP                      shift and go to state 23
    exprSHIFT                      shift and go to state 24
    exprOP                         shift and go to state 25
    term                           shift and go to state 27
    factor                         shift and go to state 29
    brace                          shift and go to state 33

state 42

    (16) for_condition -> L_PAREN . declaration expr SEMICOLON expr R_PAREN
    (17) declaration -> . TYPE ID SEMICOLON
    (18) declaration -> . TYPE ID ASSIGN expr SEMICOLON

    TYPE            shift and go to state 16

    declaration                    shift and go to state 95

state 43

    (20) simple -> expr SEMICOLON .

    IF              reduce using rule 20 (simple -> expr SEMICOLON .)
    WHILE           reduce using rule 20 (simple -> expr SEMICOLON .)
    FOR             reduce using rule 20 (simple -> expr SEMICOLON .)
    SEMICOLON       reduce using rule 20 (simple -> expr SEMICOLON .)
    L_FLOWBRACE     reduce using rule 20 (simple -> expr SEMICOLON .)
    TYPE            reduce using rule 20 (simple -> expr SEMICOLON .)
    NOT             reduce using rule 20 (simple -> expr SEMICOLON .)
    PLUS            reduce using rule 20 (simple -> expr SEMICOLON .)
    MINUS           reduce using rule 20 (simple -> expr SEMICOLON .)
    PLUS_PLUS       reduce using rule 20 (simple -> expr SEMICOLON .)
    MINUS_MINUS     reduce using rule 20 (simple -> expr SEMICOLON .)
    L_PAREN         reduce using rule 20 (simple -> expr SEMICOLON .)
    INT_NUM         reduce using rule 20 (simple -> expr SEMICOLON .)
    FLOAT_NUM       reduce using rule 20 (simple -> expr SEMICOLON .)
    ID              reduce using rule 20 (simple -> expr SEMICOLON .)
    $end            reduce using rule 20 (simple -> expr SEMICOLON .)
    R_FLOWBRACE     reduce using rule 20 (simple -> expr SEMICOLON .)
    ELSE            reduce using rule 20 (simple -> expr SEMICOLON .)


state 44

    (23) expr -> expr assignment . exprOR
    (36) exprOR -> . exprOR OR exprAND
    (37) exprOR -> . exprAND
    (38) exprAND -> . exprAND AND exprBITOR
    (39) exprAND -> . exprBITOR
    (40) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (41) exprBITOR -> . exprBITXOR
    (42) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (43) exprBITXOR -> . exprBITAND
    (44) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (45) exprBITAND -> . exprEQ
    (46) exprEQ -> . exprEQ EQ exprRELOP
    (47) exprEQ -> . exprEQ NE exprRELOP
    (48) exprEQ -> . exprRELOP
    (49) exprRELOP -> . exprRELOP relop exprSHIFT
    (50) exprRELOP -> . exprSHIFT
    (55) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (56) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (57) exprSHIFT -> . exprOP
    (58) exprOP -> . exprOP PLUS term
    (59) exprOP -> . exprOP MINUS term
    (60) exprOP -> . term
    (61) term -> . term MULTIPLY factor
    (62) term -> . term DIVIDE factor
    (63) term -> . term MOD factor
    (64) term -> . factor
    (65) factor -> . NOT factor
    (66) factor -> . PLUS factor
    (67) factor -> . MINUS factor
    (68) factor -> . PLUS_PLUS factor
    (69) factor -> . MINUS_MINUS factor
    (70) factor -> . brace
    (71) brace -> . L_PAREN expr R_PAREN
    (72) brace -> . brace PLUS_PLUS
    (73) brace -> . brace MINUS_MINUS
    (74) brace -> . INT_NUM
    (75) brace -> . FLOAT_NUM
    (76) brace -> . ID

    NOT             shift and go to state 30
    PLUS            shift and go to state 26
    MINUS           shift and go to state 28
    PLUS_PLUS       shift and go to state 31
    MINUS_MINUS     shift and go to state 32
    L_PAREN         shift and go to state 34
    INT_NUM         shift and go to state 35
    FLOAT_NUM       shift and go to state 36
    ID              shift and go to state 17

    exprOR                         shift and go to state 96
    exprAND                        shift and go to state 18
    exprBITOR                      shift and go to state 19
    exprBITXOR                     shift and go to state 20
    exprBITAND                     shift and go to state 21
    exprEQ                         shift and go to state 22
    exprRELOP                      shift and go to state 23
    exprSHIFT                      shift and go to state 24
    exprOP                         shift and go to state 25
    term                           shift and go to state 27
    factor                         shift and go to state 29
    brace                          shift and go to state 33

state 45

    (25) assignment -> ASSIGN .

    NOT             reduce using rule 25 (assignment -> ASSIGN .)
    PLUS            reduce using rule 25 (assignment -> ASSIGN .)
    MINUS           reduce using rule 25 (assignment -> ASSIGN .)
    PLUS_PLUS       reduce using rule 25 (assignment -> ASSIGN .)
    MINUS_MINUS     reduce using rule 25 (assignment -> ASSIGN .)
    L_PAREN         reduce using rule 25 (assignment -> ASSIGN .)
    INT_NUM         reduce using rule 25 (assignment -> ASSIGN .)
    FLOAT_NUM       reduce using rule 25 (assignment -> ASSIGN .)
    ID              reduce using rule 25 (assignment -> ASSIGN .)


state 46

    (26) assignment -> PLUS_ASSIGN .

    NOT             reduce using rule 26 (assignment -> PLUS_ASSIGN .)
    PLUS            reduce using rule 26 (assignment -> PLUS_ASSIGN .)
    MINUS           reduce using rule 26 (assignment -> PLUS_ASSIGN .)
    PLUS_PLUS       reduce using rule 26 (assignment -> PLUS_ASSIGN .)
    MINUS_MINUS     reduce using rule 26 (assignment -> PLUS_ASSIGN .)
    L_PAREN         reduce using rule 26 (assignment -> PLUS_ASSIGN .)
    INT_NUM         reduce using rule 26 (assignment -> PLUS_ASSIGN .)
    FLOAT_NUM       reduce using rule 26 (assignment -> PLUS_ASSIGN .)
    ID              reduce using rule 26 (assignment -> PLUS_ASSIGN .)


state 47

    (27) assignment -> MINUS_ASSIGN .

    NOT             reduce using rule 27 (assignment -> MINUS_ASSIGN .)
    PLUS            reduce using rule 27 (assignment -> MINUS_ASSIGN .)
    MINUS           reduce using rule 27 (assignment -> MINUS_ASSIGN .)
    PLUS_PLUS       reduce using rule 27 (assignment -> MINUS_ASSIGN .)
    MINUS_MINUS     reduce using rule 27 (assignment -> MINUS_ASSIGN .)
    L_PAREN         reduce using rule 27 (assignment -> MINUS_ASSIGN .)
    INT_NUM         reduce using rule 27 (assignment -> MINUS_ASSIGN .)
    FLOAT_NUM       reduce using rule 27 (assignment -> MINUS_ASSIGN .)
    ID              reduce using rule 27 (assignment -> MINUS_ASSIGN .)


state 48

    (28) assignment -> MUL_ASSIGN .

    NOT             reduce using rule 28 (assignment -> MUL_ASSIGN .)
    PLUS            reduce using rule 28 (assignment -> MUL_ASSIGN .)
    MINUS           reduce using rule 28 (assignment -> MUL_ASSIGN .)
    PLUS_PLUS       reduce using rule 28 (assignment -> MUL_ASSIGN .)
    MINUS_MINUS     reduce using rule 28 (assignment -> MUL_ASSIGN .)
    L_PAREN         reduce using rule 28 (assignment -> MUL_ASSIGN .)
    INT_NUM         reduce using rule 28 (assignment -> MUL_ASSIGN .)
    FLOAT_NUM       reduce using rule 28 (assignment -> MUL_ASSIGN .)
    ID              reduce using rule 28 (assignment -> MUL_ASSIGN .)


state 49

    (29) assignment -> DIV_ASSIGN .

    NOT             reduce using rule 29 (assignment -> DIV_ASSIGN .)
    PLUS            reduce using rule 29 (assignment -> DIV_ASSIGN .)
    MINUS           reduce using rule 29 (assignment -> DIV_ASSIGN .)
    PLUS_PLUS       reduce using rule 29 (assignment -> DIV_ASSIGN .)
    MINUS_MINUS     reduce using rule 29 (assignment -> DIV_ASSIGN .)
    L_PAREN         reduce using rule 29 (assignment -> DIV_ASSIGN .)
    INT_NUM         reduce using rule 29 (assignment -> DIV_ASSIGN .)
    FLOAT_NUM       reduce using rule 29 (assignment -> DIV_ASSIGN .)
    ID              reduce using rule 29 (assignment -> DIV_ASSIGN .)


state 50

    (30) assignment -> AND_ASSIGN .

    NOT             reduce using rule 30 (assignment -> AND_ASSIGN .)
    PLUS            reduce using rule 30 (assignment -> AND_ASSIGN .)
    MINUS           reduce using rule 30 (assignment -> AND_ASSIGN .)
    PLUS_PLUS       reduce using rule 30 (assignment -> AND_ASSIGN .)
    MINUS_MINUS     reduce using rule 30 (assignment -> AND_ASSIGN .)
    L_PAREN         reduce using rule 30 (assignment -> AND_ASSIGN .)
    INT_NUM         reduce using rule 30 (assignment -> AND_ASSIGN .)
    FLOAT_NUM       reduce using rule 30 (assignment -> AND_ASSIGN .)
    ID              reduce using rule 30 (assignment -> AND_ASSIGN .)


state 51

    (31) assignment -> OR_ASSIGN .

    NOT             reduce using rule 31 (assignment -> OR_ASSIGN .)
    PLUS            reduce using rule 31 (assignment -> OR_ASSIGN .)
    MINUS           reduce using rule 31 (assignment -> OR_ASSIGN .)
    PLUS_PLUS       reduce using rule 31 (assignment -> OR_ASSIGN .)
    MINUS_MINUS     reduce using rule 31 (assignment -> OR_ASSIGN .)
    L_PAREN         reduce using rule 31 (assignment -> OR_ASSIGN .)
    INT_NUM         reduce using rule 31 (assignment -> OR_ASSIGN .)
    FLOAT_NUM       reduce using rule 31 (assignment -> OR_ASSIGN .)
    ID              reduce using rule 31 (assignment -> OR_ASSIGN .)


state 52

    (32) assignment -> XOR_ASSIGN .

    NOT             reduce using rule 32 (assignment -> XOR_ASSIGN .)
    PLUS            reduce using rule 32 (assignment -> XOR_ASSIGN .)
    MINUS           reduce using rule 32 (assignment -> XOR_ASSIGN .)
    PLUS_PLUS       reduce using rule 32 (assignment -> XOR_ASSIGN .)
    MINUS_MINUS     reduce using rule 32 (assignment -> XOR_ASSIGN .)
    L_PAREN         reduce using rule 32 (assignment -> XOR_ASSIGN .)
    INT_NUM         reduce using rule 32 (assignment -> XOR_ASSIGN .)
    FLOAT_NUM       reduce using rule 32 (assignment -> XOR_ASSIGN .)
    ID              reduce using rule 32 (assignment -> XOR_ASSIGN .)


state 53

    (33) assignment -> MOD_ASSIGN .

    NOT             reduce using rule 33 (assignment -> MOD_ASSIGN .)
    PLUS            reduce using rule 33 (assignment -> MOD_ASSIGN .)
    MINUS           reduce using rule 33 (assignment -> MOD_ASSIGN .)
    PLUS_PLUS       reduce using rule 33 (assignment -> MOD_ASSIGN .)
    MINUS_MINUS     reduce using rule 33 (assignment -> MOD_ASSIGN .)
    L_PAREN         reduce using rule 33 (assignment -> MOD_ASSIGN .)
    INT_NUM         reduce using rule 33 (assignment -> MOD_ASSIGN .)
    FLOAT_NUM       reduce using rule 33 (assignment -> MOD_ASSIGN .)
    ID              reduce using rule 33 (assignment -> MOD_ASSIGN .)


state 54

    (34) assignment -> L_SHIFT_ASSIGN .

    NOT             reduce using rule 34 (assignment -> L_SHIFT_ASSIGN .)
    PLUS            reduce using rule 34 (assignment -> L_SHIFT_ASSIGN .)
    MINUS           reduce using rule 34 (assignment -> L_SHIFT_ASSIGN .)
    PLUS_PLUS       reduce using rule 34 (assignment -> L_SHIFT_ASSIGN .)
    MINUS_MINUS     reduce using rule 34 (assignment -> L_SHIFT_ASSIGN .)
    L_PAREN         reduce using rule 34 (assignment -> L_SHIFT_ASSIGN .)
    INT_NUM         reduce using rule 34 (assignment -> L_SHIFT_ASSIGN .)
    FLOAT_NUM       reduce using rule 34 (assignment -> L_SHIFT_ASSIGN .)
    ID              reduce using rule 34 (assignment -> L_SHIFT_ASSIGN .)


state 55

    (35) assignment -> R_SHIFT_ASSIGN .

    NOT             reduce using rule 35 (assignment -> R_SHIFT_ASSIGN .)
    PLUS            reduce using rule 35 (assignment -> R_SHIFT_ASSIGN .)
    MINUS           reduce using rule 35 (assignment -> R_SHIFT_ASSIGN .)
    PLUS_PLUS       reduce using rule 35 (assignment -> R_SHIFT_ASSIGN .)
    MINUS_MINUS     reduce using rule 35 (assignment -> R_SHIFT_ASSIGN .)
    L_PAREN         reduce using rule 35 (assignment -> R_SHIFT_ASSIGN .)
    INT_NUM         reduce using rule 35 (assignment -> R_SHIFT_ASSIGN .)
    FLOAT_NUM       reduce using rule 35 (assignment -> R_SHIFT_ASSIGN .)
    ID              reduce using rule 35 (assignment -> R_SHIFT_ASSIGN .)


state 56

    (19) block -> L_FLOWBRACE multiple_statements . R_FLOWBRACE
    (2) multiple_statements -> multiple_statements . statement
    (4) statement -> . open
    (5) statement -> . closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) open -> . FOR for_condition open
    (10) closed -> . simple
    (11) closed -> . block
    (12) closed -> . IF condition closed ELSE closed
    (13) closed -> . WHILE condition closed
    (14) closed -> . FOR for_condition closed
    (20) simple -> . expr SEMICOLON
    (21) simple -> . declaration
    (22) simple -> . SEMICOLON
    (19) block -> . L_FLOWBRACE multiple_statements R_FLOWBRACE
    (23) expr -> . expr assignment exprOR
    (24) expr -> . exprOR
    (17) declaration -> . TYPE ID SEMICOLON
    (18) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (36) exprOR -> . exprOR OR exprAND
    (37) exprOR -> . exprAND
    (38) exprAND -> . exprAND AND exprBITOR
    (39) exprAND -> . exprBITOR
    (40) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (41) exprBITOR -> . exprBITXOR
    (42) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (43) exprBITXOR -> . exprBITAND
    (44) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (45) exprBITAND -> . exprEQ
    (46) exprEQ -> . exprEQ EQ exprRELOP
    (47) exprEQ -> . exprEQ NE exprRELOP
    (48) exprEQ -> . exprRELOP
    (49) exprRELOP -> . exprRELOP relop exprSHIFT
    (50) exprRELOP -> . exprSHIFT
    (55) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (56) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (57) exprSHIFT -> . exprOP
    (58) exprOP -> . exprOP PLUS term
    (59) exprOP -> . exprOP MINUS term
    (60) exprOP -> . term
    (61) term -> . term MULTIPLY factor
    (62) term -> . term DIVIDE factor
    (63) term -> . term MOD factor
    (64) term -> . factor
    (65) factor -> . NOT factor
    (66) factor -> . PLUS factor
    (67) factor -> . MINUS factor
    (68) factor -> . PLUS_PLUS factor
    (69) factor -> . MINUS_MINUS factor
    (70) factor -> . brace
    (71) brace -> . L_PAREN expr R_PAREN
    (72) brace -> . brace PLUS_PLUS
    (73) brace -> . brace MINUS_MINUS
    (74) brace -> . INT_NUM
    (75) brace -> . FLOAT_NUM
    (76) brace -> . ID

    R_FLOWBRACE     shift and go to state 97
    IF              shift and go to state 6
    WHILE           shift and go to state 7
    FOR             shift and go to state 8
    SEMICOLON       shift and go to state 12
    L_FLOWBRACE     shift and go to state 14
    TYPE            shift and go to state 16
    NOT             shift and go to state 30
    PLUS            shift and go to state 26
    MINUS           shift and go to state 28
    PLUS_PLUS       shift and go to state 31
    MINUS_MINUS     shift and go to state 32
    L_PAREN         shift and go to state 34
    INT_NUM         shift and go to state 35
    FLOAT_NUM       shift and go to state 36
    ID              shift and go to state 17

    statement                      shift and go to state 37
    open                           shift and go to state 4
    closed                         shift and go to state 5
    simple                         shift and go to state 9
    block                          shift and go to state 10
    expr                           shift and go to state 11
    declaration                    shift and go to state 13
    exprOR                         shift and go to state 15
    exprAND                        shift and go to state 18
    exprBITOR                      shift and go to state 19
    exprBITXOR                     shift and go to state 20
    exprBITAND                     shift and go to state 21
    exprEQ                         shift and go to state 22
    exprRELOP                      shift and go to state 23
    exprSHIFT                      shift and go to state 24
    exprOP                         shift and go to state 25
    term                           shift and go to state 27
    factor                         shift and go to state 29
    brace                          shift and go to state 33

state 57

    (36) exprOR -> exprOR OR . exprAND
    (38) exprAND -> . exprAND AND exprBITOR
    (39) exprAND -> . exprBITOR
    (40) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (41) exprBITOR -> . exprBITXOR
    (42) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (43) exprBITXOR -> . exprBITAND
    (44) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (45) exprBITAND -> . exprEQ
    (46) exprEQ -> . exprEQ EQ exprRELOP
    (47) exprEQ -> . exprEQ NE exprRELOP
    (48) exprEQ -> . exprRELOP
    (49) exprRELOP -> . exprRELOP relop exprSHIFT
    (50) exprRELOP -> . exprSHIFT
    (55) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (56) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (57) exprSHIFT -> . exprOP
    (58) exprOP -> . exprOP PLUS term
    (59) exprOP -> . exprOP MINUS term
    (60) exprOP -> . term
    (61) term -> . term MULTIPLY factor
    (62) term -> . term DIVIDE factor
    (63) term -> . term MOD factor
    (64) term -> . factor
    (65) factor -> . NOT factor
    (66) factor -> . PLUS factor
    (67) factor -> . MINUS factor
    (68) factor -> . PLUS_PLUS factor
    (69) factor -> . MINUS_MINUS factor
    (70) factor -> . brace
    (71) brace -> . L_PAREN expr R_PAREN
    (72) brace -> . brace PLUS_PLUS
    (73) brace -> . brace MINUS_MINUS
    (74) brace -> . INT_NUM
    (75) brace -> . FLOAT_NUM
    (76) brace -> . ID

    NOT             shift and go to state 30
    PLUS            shift and go to state 26
    MINUS           shift and go to state 28
    PLUS_PLUS       shift and go to state 31
    MINUS_MINUS     shift and go to state 32
    L_PAREN         shift and go to state 34
    INT_NUM         shift and go to state 35
    FLOAT_NUM       shift and go to state 36
    ID              shift and go to state 17

    exprAND                        shift and go to state 98
    exprBITOR                      shift and go to state 19
    exprBITXOR                     shift and go to state 20
    exprBITAND                     shift and go to state 21
    exprEQ                         shift and go to state 22
    exprRELOP                      shift and go to state 23
    exprSHIFT                      shift and go to state 24
    exprOP                         shift and go to state 25
    term                           shift and go to state 27
    factor                         shift and go to state 29
    brace                          shift and go to state 33

state 58

    (17) declaration -> TYPE ID . SEMICOLON
    (18) declaration -> TYPE ID . ASSIGN expr SEMICOLON

    SEMICOLON       shift and go to state 99
    ASSIGN          shift and go to state 100


state 59

    (38) exprAND -> exprAND AND . exprBITOR
    (40) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (41) exprBITOR -> . exprBITXOR
    (42) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (43) exprBITXOR -> . exprBITAND
    (44) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (45) exprBITAND -> . exprEQ
    (46) exprEQ -> . exprEQ EQ exprRELOP
    (47) exprEQ -> . exprEQ NE exprRELOP
    (48) exprEQ -> . exprRELOP
    (49) exprRELOP -> . exprRELOP relop exprSHIFT
    (50) exprRELOP -> . exprSHIFT
    (55) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (56) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (57) exprSHIFT -> . exprOP
    (58) exprOP -> . exprOP PLUS term
    (59) exprOP -> . exprOP MINUS term
    (60) exprOP -> . term
    (61) term -> . term MULTIPLY factor
    (62) term -> . term DIVIDE factor
    (63) term -> . term MOD factor
    (64) term -> . factor
    (65) factor -> . NOT factor
    (66) factor -> . PLUS factor
    (67) factor -> . MINUS factor
    (68) factor -> . PLUS_PLUS factor
    (69) factor -> . MINUS_MINUS factor
    (70) factor -> . brace
    (71) brace -> . L_PAREN expr R_PAREN
    (72) brace -> . brace PLUS_PLUS
    (73) brace -> . brace MINUS_MINUS
    (74) brace -> . INT_NUM
    (75) brace -> . FLOAT_NUM
    (76) brace -> . ID

    NOT             shift and go to state 30
    PLUS            shift and go to state 26
    MINUS           shift and go to state 28
    PLUS_PLUS       shift and go to state 31
    MINUS_MINUS     shift and go to state 32
    L_PAREN         shift and go to state 34
    INT_NUM         shift and go to state 35
    FLOAT_NUM       shift and go to state 36
    ID              shift and go to state 17

    exprBITOR                      shift and go to state 101
    exprBITXOR                     shift and go to state 20
    exprBITAND                     shift and go to state 21
    exprEQ                         shift and go to state 22
    exprRELOP                      shift and go to state 23
    exprSHIFT                      shift and go to state 24
    exprOP                         shift and go to state 25
    term                           shift and go to state 27
    factor                         shift and go to state 29
    brace                          shift and go to state 33

state 60

    (40) exprBITOR -> exprBITOR BIT_OR . exprBITXOR
    (42) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (43) exprBITXOR -> . exprBITAND
    (44) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (45) exprBITAND -> . exprEQ
    (46) exprEQ -> . exprEQ EQ exprRELOP
    (47) exprEQ -> . exprEQ NE exprRELOP
    (48) exprEQ -> . exprRELOP
    (49) exprRELOP -> . exprRELOP relop exprSHIFT
    (50) exprRELOP -> . exprSHIFT
    (55) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (56) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (57) exprSHIFT -> . exprOP
    (58) exprOP -> . exprOP PLUS term
    (59) exprOP -> . exprOP MINUS term
    (60) exprOP -> . term
    (61) term -> . term MULTIPLY factor
    (62) term -> . term DIVIDE factor
    (63) term -> . term MOD factor
    (64) term -> . factor
    (65) factor -> . NOT factor
    (66) factor -> . PLUS factor
    (67) factor -> . MINUS factor
    (68) factor -> . PLUS_PLUS factor
    (69) factor -> . MINUS_MINUS factor
    (70) factor -> . brace
    (71) brace -> . L_PAREN expr R_PAREN
    (72) brace -> . brace PLUS_PLUS
    (73) brace -> . brace MINUS_MINUS
    (74) brace -> . INT_NUM
    (75) brace -> . FLOAT_NUM
    (76) brace -> . ID

    NOT             shift and go to state 30
    PLUS            shift and go to state 26
    MINUS           shift and go to state 28
    PLUS_PLUS       shift and go to state 31
    MINUS_MINUS     shift and go to state 32
    L_PAREN         shift and go to state 34
    INT_NUM         shift and go to state 35
    FLOAT_NUM       shift and go to state 36
    ID              shift and go to state 17

    exprBITXOR                     shift and go to state 102
    exprBITAND                     shift and go to state 21
    exprEQ                         shift and go to state 22
    exprRELOP                      shift and go to state 23
    exprSHIFT                      shift and go to state 24
    exprOP                         shift and go to state 25
    term                           shift and go to state 27
    factor                         shift and go to state 29
    brace                          shift and go to state 33

state 61

    (42) exprBITXOR -> exprBITXOR BIT_XOR . exprBITAND
    (44) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (45) exprBITAND -> . exprEQ
    (46) exprEQ -> . exprEQ EQ exprRELOP
    (47) exprEQ -> . exprEQ NE exprRELOP
    (48) exprEQ -> . exprRELOP
    (49) exprRELOP -> . exprRELOP relop exprSHIFT
    (50) exprRELOP -> . exprSHIFT
    (55) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (56) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (57) exprSHIFT -> . exprOP
    (58) exprOP -> . exprOP PLUS term
    (59) exprOP -> . exprOP MINUS term
    (60) exprOP -> . term
    (61) term -> . term MULTIPLY factor
    (62) term -> . term DIVIDE factor
    (63) term -> . term MOD factor
    (64) term -> . factor
    (65) factor -> . NOT factor
    (66) factor -> . PLUS factor
    (67) factor -> . MINUS factor
    (68) factor -> . PLUS_PLUS factor
    (69) factor -> . MINUS_MINUS factor
    (70) factor -> . brace
    (71) brace -> . L_PAREN expr R_PAREN
    (72) brace -> . brace PLUS_PLUS
    (73) brace -> . brace MINUS_MINUS
    (74) brace -> . INT_NUM
    (75) brace -> . FLOAT_NUM
    (76) brace -> . ID

    NOT             shift and go to state 30
    PLUS            shift and go to state 26
    MINUS           shift and go to state 28
    PLUS_PLUS       shift and go to state 31
    MINUS_MINUS     shift and go to state 32
    L_PAREN         shift and go to state 34
    INT_NUM         shift and go to state 35
    FLOAT_NUM       shift and go to state 36
    ID              shift and go to state 17

    exprBITAND                     shift and go to state 103
    exprEQ                         shift and go to state 22
    exprRELOP                      shift and go to state 23
    exprSHIFT                      shift and go to state 24
    exprOP                         shift and go to state 25
    term                           shift and go to state 27
    factor                         shift and go to state 29
    brace                          shift and go to state 33

state 62

    (44) exprBITAND -> exprBITAND BIT_AND . exprEQ
    (46) exprEQ -> . exprEQ EQ exprRELOP
    (47) exprEQ -> . exprEQ NE exprRELOP
    (48) exprEQ -> . exprRELOP
    (49) exprRELOP -> . exprRELOP relop exprSHIFT
    (50) exprRELOP -> . exprSHIFT
    (55) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (56) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (57) exprSHIFT -> . exprOP
    (58) exprOP -> . exprOP PLUS term
    (59) exprOP -> . exprOP MINUS term
    (60) exprOP -> . term
    (61) term -> . term MULTIPLY factor
    (62) term -> . term DIVIDE factor
    (63) term -> . term MOD factor
    (64) term -> . factor
    (65) factor -> . NOT factor
    (66) factor -> . PLUS factor
    (67) factor -> . MINUS factor
    (68) factor -> . PLUS_PLUS factor
    (69) factor -> . MINUS_MINUS factor
    (70) factor -> . brace
    (71) brace -> . L_PAREN expr R_PAREN
    (72) brace -> . brace PLUS_PLUS
    (73) brace -> . brace MINUS_MINUS
    (74) brace -> . INT_NUM
    (75) brace -> . FLOAT_NUM
    (76) brace -> . ID

    NOT             shift and go to state 30
    PLUS            shift and go to state 26
    MINUS           shift and go to state 28
    PLUS_PLUS       shift and go to state 31
    MINUS_MINUS     shift and go to state 32
    L_PAREN         shift and go to state 34
    INT_NUM         shift and go to state 35
    FLOAT_NUM       shift and go to state 36
    ID              shift and go to state 17

    exprEQ                         shift and go to state 104
    exprRELOP                      shift and go to state 23
    exprSHIFT                      shift and go to state 24
    exprOP                         shift and go to state 25
    term                           shift and go to state 27
    factor                         shift and go to state 29
    brace                          shift and go to state 33

state 63

    (46) exprEQ -> exprEQ EQ . exprRELOP
    (49) exprRELOP -> . exprRELOP relop exprSHIFT
    (50) exprRELOP -> . exprSHIFT
    (55) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (56) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (57) exprSHIFT -> . exprOP
    (58) exprOP -> . exprOP PLUS term
    (59) exprOP -> . exprOP MINUS term
    (60) exprOP -> . term
    (61) term -> . term MULTIPLY factor
    (62) term -> . term DIVIDE factor
    (63) term -> . term MOD factor
    (64) term -> . factor
    (65) factor -> . NOT factor
    (66) factor -> . PLUS factor
    (67) factor -> . MINUS factor
    (68) factor -> . PLUS_PLUS factor
    (69) factor -> . MINUS_MINUS factor
    (70) factor -> . brace
    (71) brace -> . L_PAREN expr R_PAREN
    (72) brace -> . brace PLUS_PLUS
    (73) brace -> . brace MINUS_MINUS
    (74) brace -> . INT_NUM
    (75) brace -> . FLOAT_NUM
    (76) brace -> . ID

    NOT             shift and go to state 30
    PLUS            shift and go to state 26
    MINUS           shift and go to state 28
    PLUS_PLUS       shift and go to state 31
    MINUS_MINUS     shift and go to state 32
    L_PAREN         shift and go to state 34
    INT_NUM         shift and go to state 35
    FLOAT_NUM       shift and go to state 36
    ID              shift and go to state 17

    exprRELOP                      shift and go to state 105
    exprSHIFT                      shift and go to state 24
    exprOP                         shift and go to state 25
    term                           shift and go to state 27
    factor                         shift and go to state 29
    brace                          shift and go to state 33

state 64

    (47) exprEQ -> exprEQ NE . exprRELOP
    (49) exprRELOP -> . exprRELOP relop exprSHIFT
    (50) exprRELOP -> . exprSHIFT
    (55) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (56) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (57) exprSHIFT -> . exprOP
    (58) exprOP -> . exprOP PLUS term
    (59) exprOP -> . exprOP MINUS term
    (60) exprOP -> . term
    (61) term -> . term MULTIPLY factor
    (62) term -> . term DIVIDE factor
    (63) term -> . term MOD factor
    (64) term -> . factor
    (65) factor -> . NOT factor
    (66) factor -> . PLUS factor
    (67) factor -> . MINUS factor
    (68) factor -> . PLUS_PLUS factor
    (69) factor -> . MINUS_MINUS factor
    (70) factor -> . brace
    (71) brace -> . L_PAREN expr R_PAREN
    (72) brace -> . brace PLUS_PLUS
    (73) brace -> . brace MINUS_MINUS
    (74) brace -> . INT_NUM
    (75) brace -> . FLOAT_NUM
    (76) brace -> . ID

    NOT             shift and go to state 30
    PLUS            shift and go to state 26
    MINUS           shift and go to state 28
    PLUS_PLUS       shift and go to state 31
    MINUS_MINUS     shift and go to state 32
    L_PAREN         shift and go to state 34
    INT_NUM         shift and go to state 35
    FLOAT_NUM       shift and go to state 36
    ID              shift and go to state 17

    exprRELOP                      shift and go to state 106
    exprSHIFT                      shift and go to state 24
    exprOP                         shift and go to state 25
    term                           shift and go to state 27
    factor                         shift and go to state 29
    brace                          shift and go to state 33

state 65

    (49) exprRELOP -> exprRELOP relop . exprSHIFT
    (55) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (56) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (57) exprSHIFT -> . exprOP
    (58) exprOP -> . exprOP PLUS term
    (59) exprOP -> . exprOP MINUS term
    (60) exprOP -> . term
    (61) term -> . term MULTIPLY factor
    (62) term -> . term DIVIDE factor
    (63) term -> . term MOD factor
    (64) term -> . factor
    (65) factor -> . NOT factor
    (66) factor -> . PLUS factor
    (67) factor -> . MINUS factor
    (68) factor -> . PLUS_PLUS factor
    (69) factor -> . MINUS_MINUS factor
    (70) factor -> . brace
    (71) brace -> . L_PAREN expr R_PAREN
    (72) brace -> . brace PLUS_PLUS
    (73) brace -> . brace MINUS_MINUS
    (74) brace -> . INT_NUM
    (75) brace -> . FLOAT_NUM
    (76) brace -> . ID

    NOT             shift and go to state 30
    PLUS            shift and go to state 26
    MINUS           shift and go to state 28
    PLUS_PLUS       shift and go to state 31
    MINUS_MINUS     shift and go to state 32
    L_PAREN         shift and go to state 34
    INT_NUM         shift and go to state 35
    FLOAT_NUM       shift and go to state 36
    ID              shift and go to state 17

    exprSHIFT                      shift and go to state 107
    exprOP                         shift and go to state 25
    term                           shift and go to state 27
    factor                         shift and go to state 29
    brace                          shift and go to state 33

state 66

    (51) relop -> LE .

    NOT             reduce using rule 51 (relop -> LE .)
    PLUS            reduce using rule 51 (relop -> LE .)
    MINUS           reduce using rule 51 (relop -> LE .)
    PLUS_PLUS       reduce using rule 51 (relop -> LE .)
    MINUS_MINUS     reduce using rule 51 (relop -> LE .)
    L_PAREN         reduce using rule 51 (relop -> LE .)
    INT_NUM         reduce using rule 51 (relop -> LE .)
    FLOAT_NUM       reduce using rule 51 (relop -> LE .)
    ID              reduce using rule 51 (relop -> LE .)


state 67

    (52) relop -> LT .

    NOT             reduce using rule 52 (relop -> LT .)
    PLUS            reduce using rule 52 (relop -> LT .)
    MINUS           reduce using rule 52 (relop -> LT .)
    PLUS_PLUS       reduce using rule 52 (relop -> LT .)
    MINUS_MINUS     reduce using rule 52 (relop -> LT .)
    L_PAREN         reduce using rule 52 (relop -> LT .)
    INT_NUM         reduce using rule 52 (relop -> LT .)
    FLOAT_NUM       reduce using rule 52 (relop -> LT .)
    ID              reduce using rule 52 (relop -> LT .)


state 68

    (53) relop -> GE .

    NOT             reduce using rule 53 (relop -> GE .)
    PLUS            reduce using rule 53 (relop -> GE .)
    MINUS           reduce using rule 53 (relop -> GE .)
    PLUS_PLUS       reduce using rule 53 (relop -> GE .)
    MINUS_MINUS     reduce using rule 53 (relop -> GE .)
    L_PAREN         reduce using rule 53 (relop -> GE .)
    INT_NUM         reduce using rule 53 (relop -> GE .)
    FLOAT_NUM       reduce using rule 53 (relop -> GE .)
    ID              reduce using rule 53 (relop -> GE .)


state 69

    (54) relop -> GT .

    NOT             reduce using rule 54 (relop -> GT .)
    PLUS            reduce using rule 54 (relop -> GT .)
    MINUS           reduce using rule 54 (relop -> GT .)
    PLUS_PLUS       reduce using rule 54 (relop -> GT .)
    MINUS_MINUS     reduce using rule 54 (relop -> GT .)
    L_PAREN         reduce using rule 54 (relop -> GT .)
    INT_NUM         reduce using rule 54 (relop -> GT .)
    FLOAT_NUM       reduce using rule 54 (relop -> GT .)
    ID              reduce using rule 54 (relop -> GT .)


state 70

    (55) exprSHIFT -> exprSHIFT L_SHIFT . exprOP
    (58) exprOP -> . exprOP PLUS term
    (59) exprOP -> . exprOP MINUS term
    (60) exprOP -> . term
    (61) term -> . term MULTIPLY factor
    (62) term -> . term DIVIDE factor
    (63) term -> . term MOD factor
    (64) term -> . factor
    (65) factor -> . NOT factor
    (66) factor -> . PLUS factor
    (67) factor -> . MINUS factor
    (68) factor -> . PLUS_PLUS factor
    (69) factor -> . MINUS_MINUS factor
    (70) factor -> . brace
    (71) brace -> . L_PAREN expr R_PAREN
    (72) brace -> . brace PLUS_PLUS
    (73) brace -> . brace MINUS_MINUS
    (74) brace -> . INT_NUM
    (75) brace -> . FLOAT_NUM
    (76) brace -> . ID

    NOT             shift and go to state 30
    PLUS            shift and go to state 26
    MINUS           shift and go to state 28
    PLUS_PLUS       shift and go to state 31
    MINUS_MINUS     shift and go to state 32
    L_PAREN         shift and go to state 34
    INT_NUM         shift and go to state 35
    FLOAT_NUM       shift and go to state 36
    ID              shift and go to state 17

    exprOP                         shift and go to state 108
    term                           shift and go to state 27
    factor                         shift and go to state 29
    brace                          shift and go to state 33

state 71

    (56) exprSHIFT -> exprSHIFT R_SHIFT . exprOP
    (58) exprOP -> . exprOP PLUS term
    (59) exprOP -> . exprOP MINUS term
    (60) exprOP -> . term
    (61) term -> . term MULTIPLY factor
    (62) term -> . term DIVIDE factor
    (63) term -> . term MOD factor
    (64) term -> . factor
    (65) factor -> . NOT factor
    (66) factor -> . PLUS factor
    (67) factor -> . MINUS factor
    (68) factor -> . PLUS_PLUS factor
    (69) factor -> . MINUS_MINUS factor
    (70) factor -> . brace
    (71) brace -> . L_PAREN expr R_PAREN
    (72) brace -> . brace PLUS_PLUS
    (73) brace -> . brace MINUS_MINUS
    (74) brace -> . INT_NUM
    (75) brace -> . FLOAT_NUM
    (76) brace -> . ID

    NOT             shift and go to state 30
    PLUS            shift and go to state 26
    MINUS           shift and go to state 28
    PLUS_PLUS       shift and go to state 31
    MINUS_MINUS     shift and go to state 32
    L_PAREN         shift and go to state 34
    INT_NUM         shift and go to state 35
    FLOAT_NUM       shift and go to state 36
    ID              shift and go to state 17

    exprOP                         shift and go to state 109
    term                           shift and go to state 27
    factor                         shift and go to state 29
    brace                          shift and go to state 33

state 72

    (58) exprOP -> exprOP PLUS . term
    (61) term -> . term MULTIPLY factor
    (62) term -> . term DIVIDE factor
    (63) term -> . term MOD factor
    (64) term -> . factor
    (65) factor -> . NOT factor
    (66) factor -> . PLUS factor
    (67) factor -> . MINUS factor
    (68) factor -> . PLUS_PLUS factor
    (69) factor -> . MINUS_MINUS factor
    (70) factor -> . brace
    (71) brace -> . L_PAREN expr R_PAREN
    (72) brace -> . brace PLUS_PLUS
    (73) brace -> . brace MINUS_MINUS
    (74) brace -> . INT_NUM
    (75) brace -> . FLOAT_NUM
    (76) brace -> . ID

    NOT             shift and go to state 30
    PLUS            shift and go to state 26
    MINUS           shift and go to state 28
    PLUS_PLUS       shift and go to state 31
    MINUS_MINUS     shift and go to state 32
    L_PAREN         shift and go to state 34
    INT_NUM         shift and go to state 35
    FLOAT_NUM       shift and go to state 36
    ID              shift and go to state 17

    term                           shift and go to state 110
    factor                         shift and go to state 29
    brace                          shift and go to state 33

state 73

    (59) exprOP -> exprOP MINUS . term
    (61) term -> . term MULTIPLY factor
    (62) term -> . term DIVIDE factor
    (63) term -> . term MOD factor
    (64) term -> . factor
    (65) factor -> . NOT factor
    (66) factor -> . PLUS factor
    (67) factor -> . MINUS factor
    (68) factor -> . PLUS_PLUS factor
    (69) factor -> . MINUS_MINUS factor
    (70) factor -> . brace
    (71) brace -> . L_PAREN expr R_PAREN
    (72) brace -> . brace PLUS_PLUS
    (73) brace -> . brace MINUS_MINUS
    (74) brace -> . INT_NUM
    (75) brace -> . FLOAT_NUM
    (76) brace -> . ID

    NOT             shift and go to state 30
    PLUS            shift and go to state 26
    MINUS           shift and go to state 28
    PLUS_PLUS       shift and go to state 31
    MINUS_MINUS     shift and go to state 32
    L_PAREN         shift and go to state 34
    INT_NUM         shift and go to state 35
    FLOAT_NUM       shift and go to state 36
    ID              shift and go to state 17

    term                           shift and go to state 111
    factor                         shift and go to state 29
    brace                          shift and go to state 33

state 74

    (66) factor -> PLUS factor .

    MULTIPLY        reduce using rule 66 (factor -> PLUS factor .)
    DIVIDE          reduce using rule 66 (factor -> PLUS factor .)
    MOD             reduce using rule 66 (factor -> PLUS factor .)
    PLUS            reduce using rule 66 (factor -> PLUS factor .)
    MINUS           reduce using rule 66 (factor -> PLUS factor .)
    L_SHIFT         reduce using rule 66 (factor -> PLUS factor .)
    R_SHIFT         reduce using rule 66 (factor -> PLUS factor .)
    LE              reduce using rule 66 (factor -> PLUS factor .)
    LT              reduce using rule 66 (factor -> PLUS factor .)
    GE              reduce using rule 66 (factor -> PLUS factor .)
    GT              reduce using rule 66 (factor -> PLUS factor .)
    EQ              reduce using rule 66 (factor -> PLUS factor .)
    NE              reduce using rule 66 (factor -> PLUS factor .)
    BIT_AND         reduce using rule 66 (factor -> PLUS factor .)
    BIT_XOR         reduce using rule 66 (factor -> PLUS factor .)
    BIT_OR          reduce using rule 66 (factor -> PLUS factor .)
    AND             reduce using rule 66 (factor -> PLUS factor .)
    OR              reduce using rule 66 (factor -> PLUS factor .)
    SEMICOLON       reduce using rule 66 (factor -> PLUS factor .)
    ASSIGN          reduce using rule 66 (factor -> PLUS factor .)
    PLUS_ASSIGN     reduce using rule 66 (factor -> PLUS factor .)
    MINUS_ASSIGN    reduce using rule 66 (factor -> PLUS factor .)
    MUL_ASSIGN      reduce using rule 66 (factor -> PLUS factor .)
    DIV_ASSIGN      reduce using rule 66 (factor -> PLUS factor .)
    AND_ASSIGN      reduce using rule 66 (factor -> PLUS factor .)
    OR_ASSIGN       reduce using rule 66 (factor -> PLUS factor .)
    XOR_ASSIGN      reduce using rule 66 (factor -> PLUS factor .)
    MOD_ASSIGN      reduce using rule 66 (factor -> PLUS factor .)
    L_SHIFT_ASSIGN  reduce using rule 66 (factor -> PLUS factor .)
    R_SHIFT_ASSIGN  reduce using rule 66 (factor -> PLUS factor .)
    R_PAREN         reduce using rule 66 (factor -> PLUS factor .)


state 75

    (61) term -> term MULTIPLY . factor
    (65) factor -> . NOT factor
    (66) factor -> . PLUS factor
    (67) factor -> . MINUS factor
    (68) factor -> . PLUS_PLUS factor
    (69) factor -> . MINUS_MINUS factor
    (70) factor -> . brace
    (71) brace -> . L_PAREN expr R_PAREN
    (72) brace -> . brace PLUS_PLUS
    (73) brace -> . brace MINUS_MINUS
    (74) brace -> . INT_NUM
    (75) brace -> . FLOAT_NUM
    (76) brace -> . ID

    NOT             shift and go to state 30
    PLUS            shift and go to state 26
    MINUS           shift and go to state 28
    PLUS_PLUS       shift and go to state 31
    MINUS_MINUS     shift and go to state 32
    L_PAREN         shift and go to state 34
    INT_NUM         shift and go to state 35
    FLOAT_NUM       shift and go to state 36
    ID              shift and go to state 17

    factor                         shift and go to state 112
    brace                          shift and go to state 33

state 76

    (62) term -> term DIVIDE . factor
    (65) factor -> . NOT factor
    (66) factor -> . PLUS factor
    (67) factor -> . MINUS factor
    (68) factor -> . PLUS_PLUS factor
    (69) factor -> . MINUS_MINUS factor
    (70) factor -> . brace
    (71) brace -> . L_PAREN expr R_PAREN
    (72) brace -> . brace PLUS_PLUS
    (73) brace -> . brace MINUS_MINUS
    (74) brace -> . INT_NUM
    (75) brace -> . FLOAT_NUM
    (76) brace -> . ID

    NOT             shift and go to state 30
    PLUS            shift and go to state 26
    MINUS           shift and go to state 28
    PLUS_PLUS       shift and go to state 31
    MINUS_MINUS     shift and go to state 32
    L_PAREN         shift and go to state 34
    INT_NUM         shift and go to state 35
    FLOAT_NUM       shift and go to state 36
    ID              shift and go to state 17

    factor                         shift and go to state 113
    brace                          shift and go to state 33

state 77

    (63) term -> term MOD . factor
    (65) factor -> . NOT factor
    (66) factor -> . PLUS factor
    (67) factor -> . MINUS factor
    (68) factor -> . PLUS_PLUS factor
    (69) factor -> . MINUS_MINUS factor
    (70) factor -> . brace
    (71) brace -> . L_PAREN expr R_PAREN
    (72) brace -> . brace PLUS_PLUS
    (73) brace -> . brace MINUS_MINUS
    (74) brace -> . INT_NUM
    (75) brace -> . FLOAT_NUM
    (76) brace -> . ID

    NOT             shift and go to state 30
    PLUS            shift and go to state 26
    MINUS           shift and go to state 28
    PLUS_PLUS       shift and go to state 31
    MINUS_MINUS     shift and go to state 32
    L_PAREN         shift and go to state 34
    INT_NUM         shift and go to state 35
    FLOAT_NUM       shift and go to state 36
    ID              shift and go to state 17

    factor                         shift and go to state 114
    brace                          shift and go to state 33

state 78

    (67) factor -> MINUS factor .

    MULTIPLY        reduce using rule 67 (factor -> MINUS factor .)
    DIVIDE          reduce using rule 67 (factor -> MINUS factor .)
    MOD             reduce using rule 67 (factor -> MINUS factor .)
    PLUS            reduce using rule 67 (factor -> MINUS factor .)
    MINUS           reduce using rule 67 (factor -> MINUS factor .)
    L_SHIFT         reduce using rule 67 (factor -> MINUS factor .)
    R_SHIFT         reduce using rule 67 (factor -> MINUS factor .)
    LE              reduce using rule 67 (factor -> MINUS factor .)
    LT              reduce using rule 67 (factor -> MINUS factor .)
    GE              reduce using rule 67 (factor -> MINUS factor .)
    GT              reduce using rule 67 (factor -> MINUS factor .)
    EQ              reduce using rule 67 (factor -> MINUS factor .)
    NE              reduce using rule 67 (factor -> MINUS factor .)
    BIT_AND         reduce using rule 67 (factor -> MINUS factor .)
    BIT_XOR         reduce using rule 67 (factor -> MINUS factor .)
    BIT_OR          reduce using rule 67 (factor -> MINUS factor .)
    AND             reduce using rule 67 (factor -> MINUS factor .)
    OR              reduce using rule 67 (factor -> MINUS factor .)
    SEMICOLON       reduce using rule 67 (factor -> MINUS factor .)
    ASSIGN          reduce using rule 67 (factor -> MINUS factor .)
    PLUS_ASSIGN     reduce using rule 67 (factor -> MINUS factor .)
    MINUS_ASSIGN    reduce using rule 67 (factor -> MINUS factor .)
    MUL_ASSIGN      reduce using rule 67 (factor -> MINUS factor .)
    DIV_ASSIGN      reduce using rule 67 (factor -> MINUS factor .)
    AND_ASSIGN      reduce using rule 67 (factor -> MINUS factor .)
    OR_ASSIGN       reduce using rule 67 (factor -> MINUS factor .)
    XOR_ASSIGN      reduce using rule 67 (factor -> MINUS factor .)
    MOD_ASSIGN      reduce using rule 67 (factor -> MINUS factor .)
    L_SHIFT_ASSIGN  reduce using rule 67 (factor -> MINUS factor .)
    R_SHIFT_ASSIGN  reduce using rule 67 (factor -> MINUS factor .)
    R_PAREN         reduce using rule 67 (factor -> MINUS factor .)


state 79

    (65) factor -> NOT factor .

    MULTIPLY        reduce using rule 65 (factor -> NOT factor .)
    DIVIDE          reduce using rule 65 (factor -> NOT factor .)
    MOD             reduce using rule 65 (factor -> NOT factor .)
    PLUS            reduce using rule 65 (factor -> NOT factor .)
    MINUS           reduce using rule 65 (factor -> NOT factor .)
    L_SHIFT         reduce using rule 65 (factor -> NOT factor .)
    R_SHIFT         reduce using rule 65 (factor -> NOT factor .)
    LE              reduce using rule 65 (factor -> NOT factor .)
    LT              reduce using rule 65 (factor -> NOT factor .)
    GE              reduce using rule 65 (factor -> NOT factor .)
    GT              reduce using rule 65 (factor -> NOT factor .)
    EQ              reduce using rule 65 (factor -> NOT factor .)
    NE              reduce using rule 65 (factor -> NOT factor .)
    BIT_AND         reduce using rule 65 (factor -> NOT factor .)
    BIT_XOR         reduce using rule 65 (factor -> NOT factor .)
    BIT_OR          reduce using rule 65 (factor -> NOT factor .)
    AND             reduce using rule 65 (factor -> NOT factor .)
    OR              reduce using rule 65 (factor -> NOT factor .)
    SEMICOLON       reduce using rule 65 (factor -> NOT factor .)
    ASSIGN          reduce using rule 65 (factor -> NOT factor .)
    PLUS_ASSIGN     reduce using rule 65 (factor -> NOT factor .)
    MINUS_ASSIGN    reduce using rule 65 (factor -> NOT factor .)
    MUL_ASSIGN      reduce using rule 65 (factor -> NOT factor .)
    DIV_ASSIGN      reduce using rule 65 (factor -> NOT factor .)
    AND_ASSIGN      reduce using rule 65 (factor -> NOT factor .)
    OR_ASSIGN       reduce using rule 65 (factor -> NOT factor .)
    XOR_ASSIGN      reduce using rule 65 (factor -> NOT factor .)
    MOD_ASSIGN      reduce using rule 65 (factor -> NOT factor .)
    L_SHIFT_ASSIGN  reduce using rule 65 (factor -> NOT factor .)
    R_SHIFT_ASSIGN  reduce using rule 65 (factor -> NOT factor .)
    R_PAREN         reduce using rule 65 (factor -> NOT factor .)


state 80

    (68) factor -> PLUS_PLUS factor .

    MULTIPLY        reduce using rule 68 (factor -> PLUS_PLUS factor .)
    DIVIDE          reduce using rule 68 (factor -> PLUS_PLUS factor .)
    MOD             reduce using rule 68 (factor -> PLUS_PLUS factor .)
    PLUS            reduce using rule 68 (factor -> PLUS_PLUS factor .)
    MINUS           reduce using rule 68 (factor -> PLUS_PLUS factor .)
    L_SHIFT         reduce using rule 68 (factor -> PLUS_PLUS factor .)
    R_SHIFT         reduce using rule 68 (factor -> PLUS_PLUS factor .)
    LE              reduce using rule 68 (factor -> PLUS_PLUS factor .)
    LT              reduce using rule 68 (factor -> PLUS_PLUS factor .)
    GE              reduce using rule 68 (factor -> PLUS_PLUS factor .)
    GT              reduce using rule 68 (factor -> PLUS_PLUS factor .)
    EQ              reduce using rule 68 (factor -> PLUS_PLUS factor .)
    NE              reduce using rule 68 (factor -> PLUS_PLUS factor .)
    BIT_AND         reduce using rule 68 (factor -> PLUS_PLUS factor .)
    BIT_XOR         reduce using rule 68 (factor -> PLUS_PLUS factor .)
    BIT_OR          reduce using rule 68 (factor -> PLUS_PLUS factor .)
    AND             reduce using rule 68 (factor -> PLUS_PLUS factor .)
    OR              reduce using rule 68 (factor -> PLUS_PLUS factor .)
    SEMICOLON       reduce using rule 68 (factor -> PLUS_PLUS factor .)
    ASSIGN          reduce using rule 68 (factor -> PLUS_PLUS factor .)
    PLUS_ASSIGN     reduce using rule 68 (factor -> PLUS_PLUS factor .)
    MINUS_ASSIGN    reduce using rule 68 (factor -> PLUS_PLUS factor .)
    MUL_ASSIGN      reduce using rule 68 (factor -> PLUS_PLUS factor .)
    DIV_ASSIGN      reduce using rule 68 (factor -> PLUS_PLUS factor .)
    AND_ASSIGN      reduce using rule 68 (factor -> PLUS_PLUS factor .)
    OR_ASSIGN       reduce using rule 68 (factor -> PLUS_PLUS factor .)
    XOR_ASSIGN      reduce using rule 68 (factor -> PLUS_PLUS factor .)
    MOD_ASSIGN      reduce using rule 68 (factor -> PLUS_PLUS factor .)
    L_SHIFT_ASSIGN  reduce using rule 68 (factor -> PLUS_PLUS factor .)
    R_SHIFT_ASSIGN  reduce using rule 68 (factor -> PLUS_PLUS factor .)
    R_PAREN         reduce using rule 68 (factor -> PLUS_PLUS factor .)


state 81

    (69) factor -> MINUS_MINUS factor .

    MULTIPLY        reduce using rule 69 (factor -> MINUS_MINUS factor .)
    DIVIDE          reduce using rule 69 (factor -> MINUS_MINUS factor .)
    MOD             reduce using rule 69 (factor -> MINUS_MINUS factor .)
    PLUS            reduce using rule 69 (factor -> MINUS_MINUS factor .)
    MINUS           reduce using rule 69 (factor -> MINUS_MINUS factor .)
    L_SHIFT         reduce using rule 69 (factor -> MINUS_MINUS factor .)
    R_SHIFT         reduce using rule 69 (factor -> MINUS_MINUS factor .)
    LE              reduce using rule 69 (factor -> MINUS_MINUS factor .)
    LT              reduce using rule 69 (factor -> MINUS_MINUS factor .)
    GE              reduce using rule 69 (factor -> MINUS_MINUS factor .)
    GT              reduce using rule 69 (factor -> MINUS_MINUS factor .)
    EQ              reduce using rule 69 (factor -> MINUS_MINUS factor .)
    NE              reduce using rule 69 (factor -> MINUS_MINUS factor .)
    BIT_AND         reduce using rule 69 (factor -> MINUS_MINUS factor .)
    BIT_XOR         reduce using rule 69 (factor -> MINUS_MINUS factor .)
    BIT_OR          reduce using rule 69 (factor -> MINUS_MINUS factor .)
    AND             reduce using rule 69 (factor -> MINUS_MINUS factor .)
    OR              reduce using rule 69 (factor -> MINUS_MINUS factor .)
    SEMICOLON       reduce using rule 69 (factor -> MINUS_MINUS factor .)
    ASSIGN          reduce using rule 69 (factor -> MINUS_MINUS factor .)
    PLUS_ASSIGN     reduce using rule 69 (factor -> MINUS_MINUS factor .)
    MINUS_ASSIGN    reduce using rule 69 (factor -> MINUS_MINUS factor .)
    MUL_ASSIGN      reduce using rule 69 (factor -> MINUS_MINUS factor .)
    DIV_ASSIGN      reduce using rule 69 (factor -> MINUS_MINUS factor .)
    AND_ASSIGN      reduce using rule 69 (factor -> MINUS_MINUS factor .)
    OR_ASSIGN       reduce using rule 69 (factor -> MINUS_MINUS factor .)
    XOR_ASSIGN      reduce using rule 69 (factor -> MINUS_MINUS factor .)
    MOD_ASSIGN      reduce using rule 69 (factor -> MINUS_MINUS factor .)
    L_SHIFT_ASSIGN  reduce using rule 69 (factor -> MINUS_MINUS factor .)
    R_SHIFT_ASSIGN  reduce using rule 69 (factor -> MINUS_MINUS factor .)
    R_PAREN         reduce using rule 69 (factor -> MINUS_MINUS factor .)


state 82

    (72) brace -> brace PLUS_PLUS .

    PLUS_PLUS       reduce using rule 72 (brace -> brace PLUS_PLUS .)
    MINUS_MINUS     reduce using rule 72 (brace -> brace PLUS_PLUS .)
    MULTIPLY        reduce using rule 72 (brace -> brace PLUS_PLUS .)
    DIVIDE          reduce using rule 72 (brace -> brace PLUS_PLUS .)
    MOD             reduce using rule 72 (brace -> brace PLUS_PLUS .)
    PLUS            reduce using rule 72 (brace -> brace PLUS_PLUS .)
    MINUS           reduce using rule 72 (brace -> brace PLUS_PLUS .)
    L_SHIFT         reduce using rule 72 (brace -> brace PLUS_PLUS .)
    R_SHIFT         reduce using rule 72 (brace -> brace PLUS_PLUS .)
    LE              reduce using rule 72 (brace -> brace PLUS_PLUS .)
    LT              reduce using rule 72 (brace -> brace PLUS_PLUS .)
    GE              reduce using rule 72 (brace -> brace PLUS_PLUS .)
    GT              reduce using rule 72 (brace -> brace PLUS_PLUS .)
    EQ              reduce using rule 72 (brace -> brace PLUS_PLUS .)
    NE              reduce using rule 72 (brace -> brace PLUS_PLUS .)
    BIT_AND         reduce using rule 72 (brace -> brace PLUS_PLUS .)
    BIT_XOR         reduce using rule 72 (brace -> brace PLUS_PLUS .)
    BIT_OR          reduce using rule 72 (brace -> brace PLUS_PLUS .)
    AND             reduce using rule 72 (brace -> brace PLUS_PLUS .)
    OR              reduce using rule 72 (brace -> brace PLUS_PLUS .)
    SEMICOLON       reduce using rule 72 (brace -> brace PLUS_PLUS .)
    ASSIGN          reduce using rule 72 (brace -> brace PLUS_PLUS .)
    PLUS_ASSIGN     reduce using rule 72 (brace -> brace PLUS_PLUS .)
    MINUS_ASSIGN    reduce using rule 72 (brace -> brace PLUS_PLUS .)
    MUL_ASSIGN      reduce using rule 72 (brace -> brace PLUS_PLUS .)
    DIV_ASSIGN      reduce using rule 72 (brace -> brace PLUS_PLUS .)
    AND_ASSIGN      reduce using rule 72 (brace -> brace PLUS_PLUS .)
    OR_ASSIGN       reduce using rule 72 (brace -> brace PLUS_PLUS .)
    XOR_ASSIGN      reduce using rule 72 (brace -> brace PLUS_PLUS .)
    MOD_ASSIGN      reduce using rule 72 (brace -> brace PLUS_PLUS .)
    L_SHIFT_ASSIGN  reduce using rule 72 (brace -> brace PLUS_PLUS .)
    R_SHIFT_ASSIGN  reduce using rule 72 (brace -> brace PLUS_PLUS .)
    R_PAREN         reduce using rule 72 (brace -> brace PLUS_PLUS .)


state 83

    (73) brace -> brace MINUS_MINUS .

    PLUS_PLUS       reduce using rule 73 (brace -> brace MINUS_MINUS .)
    MINUS_MINUS     reduce using rule 73 (brace -> brace MINUS_MINUS .)
    MULTIPLY        reduce using rule 73 (brace -> brace MINUS_MINUS .)
    DIVIDE          reduce using rule 73 (brace -> brace MINUS_MINUS .)
    MOD             reduce using rule 73 (brace -> brace MINUS_MINUS .)
    PLUS            reduce using rule 73 (brace -> brace MINUS_MINUS .)
    MINUS           reduce using rule 73 (brace -> brace MINUS_MINUS .)
    L_SHIFT         reduce using rule 73 (brace -> brace MINUS_MINUS .)
    R_SHIFT         reduce using rule 73 (brace -> brace MINUS_MINUS .)
    LE              reduce using rule 73 (brace -> brace MINUS_MINUS .)
    LT              reduce using rule 73 (brace -> brace MINUS_MINUS .)
    GE              reduce using rule 73 (brace -> brace MINUS_MINUS .)
    GT              reduce using rule 73 (brace -> brace MINUS_MINUS .)
    EQ              reduce using rule 73 (brace -> brace MINUS_MINUS .)
    NE              reduce using rule 73 (brace -> brace MINUS_MINUS .)
    BIT_AND         reduce using rule 73 (brace -> brace MINUS_MINUS .)
    BIT_XOR         reduce using rule 73 (brace -> brace MINUS_MINUS .)
    BIT_OR          reduce using rule 73 (brace -> brace MINUS_MINUS .)
    AND             reduce using rule 73 (brace -> brace MINUS_MINUS .)
    OR              reduce using rule 73 (brace -> brace MINUS_MINUS .)
    SEMICOLON       reduce using rule 73 (brace -> brace MINUS_MINUS .)
    ASSIGN          reduce using rule 73 (brace -> brace MINUS_MINUS .)
    PLUS_ASSIGN     reduce using rule 73 (brace -> brace MINUS_MINUS .)
    MINUS_ASSIGN    reduce using rule 73 (brace -> brace MINUS_MINUS .)
    MUL_ASSIGN      reduce using rule 73 (brace -> brace MINUS_MINUS .)
    DIV_ASSIGN      reduce using rule 73 (brace -> brace MINUS_MINUS .)
    AND_ASSIGN      reduce using rule 73 (brace -> brace MINUS_MINUS .)
    OR_ASSIGN       reduce using rule 73 (brace -> brace MINUS_MINUS .)
    XOR_ASSIGN      reduce using rule 73 (brace -> brace MINUS_MINUS .)
    MOD_ASSIGN      reduce using rule 73 (brace -> brace MINUS_MINUS .)
    L_SHIFT_ASSIGN  reduce using rule 73 (brace -> brace MINUS_MINUS .)
    R_SHIFT_ASSIGN  reduce using rule 73 (brace -> brace MINUS_MINUS .)
    R_PAREN         reduce using rule 73 (brace -> brace MINUS_MINUS .)


state 84

    (71) brace -> L_PAREN expr . R_PAREN
    (23) expr -> expr . assignment exprOR
    (25) assignment -> . ASSIGN
    (26) assignment -> . PLUS_ASSIGN
    (27) assignment -> . MINUS_ASSIGN
    (28) assignment -> . MUL_ASSIGN
    (29) assignment -> . DIV_ASSIGN
    (30) assignment -> . AND_ASSIGN
    (31) assignment -> . OR_ASSIGN
    (32) assignment -> . XOR_ASSIGN
    (33) assignment -> . MOD_ASSIGN
    (34) assignment -> . L_SHIFT_ASSIGN
    (35) assignment -> . R_SHIFT_ASSIGN

    R_PAREN         shift and go to state 115
    ASSIGN          shift and go to state 45
    PLUS_ASSIGN     shift and go to state 46
    MINUS_ASSIGN    shift and go to state 47
    MUL_ASSIGN      shift and go to state 48
    DIV_ASSIGN      shift and go to state 49
    AND_ASSIGN      shift and go to state 50
    OR_ASSIGN       shift and go to state 51
    XOR_ASSIGN      shift and go to state 52
    MOD_ASSIGN      shift and go to state 53
    L_SHIFT_ASSIGN  shift and go to state 54
    R_SHIFT_ASSIGN  shift and go to state 55

    assignment                     shift and go to state 44

state 85

    (12) closed -> IF . condition closed ELSE closed
    (6) open -> IF . condition statement
    (7) open -> IF . condition closed ELSE open
    (15) condition -> . L_PAREN expr R_PAREN

    L_PAREN         shift and go to state 39

    condition                      shift and go to state 116

state 86

    (6) open -> IF condition statement .

    IF              reduce using rule 6 (open -> IF condition statement .)
    WHILE           reduce using rule 6 (open -> IF condition statement .)
    FOR             reduce using rule 6 (open -> IF condition statement .)
    SEMICOLON       reduce using rule 6 (open -> IF condition statement .)
    L_FLOWBRACE     reduce using rule 6 (open -> IF condition statement .)
    TYPE            reduce using rule 6 (open -> IF condition statement .)
    NOT             reduce using rule 6 (open -> IF condition statement .)
    PLUS            reduce using rule 6 (open -> IF condition statement .)
    MINUS           reduce using rule 6 (open -> IF condition statement .)
    PLUS_PLUS       reduce using rule 6 (open -> IF condition statement .)
    MINUS_MINUS     reduce using rule 6 (open -> IF condition statement .)
    L_PAREN         reduce using rule 6 (open -> IF condition statement .)
    INT_NUM         reduce using rule 6 (open -> IF condition statement .)
    FLOAT_NUM       reduce using rule 6 (open -> IF condition statement .)
    ID              reduce using rule 6 (open -> IF condition statement .)
    $end            reduce using rule 6 (open -> IF condition statement .)
    R_FLOWBRACE     reduce using rule 6 (open -> IF condition statement .)


state 87

    (7) open -> IF condition closed . ELSE open
    (12) closed -> IF condition closed . ELSE closed
    (5) statement -> closed .

    ELSE            shift and go to state 117
    IF              reduce using rule 5 (statement -> closed .)
    WHILE           reduce using rule 5 (statement -> closed .)
    FOR             reduce using rule 5 (statement -> closed .)
    SEMICOLON       reduce using rule 5 (statement -> closed .)
    L_FLOWBRACE     reduce using rule 5 (statement -> closed .)
    TYPE            reduce using rule 5 (statement -> closed .)
    NOT             reduce using rule 5 (statement -> closed .)
    PLUS            reduce using rule 5 (statement -> closed .)
    MINUS           reduce using rule 5 (statement -> closed .)
    PLUS_PLUS       reduce using rule 5 (statement -> closed .)
    MINUS_MINUS     reduce using rule 5 (statement -> closed .)
    L_PAREN         reduce using rule 5 (statement -> closed .)
    INT_NUM         reduce using rule 5 (statement -> closed .)
    FLOAT_NUM       reduce using rule 5 (statement -> closed .)
    ID              reduce using rule 5 (statement -> closed .)
    $end            reduce using rule 5 (statement -> closed .)
    R_FLOWBRACE     reduce using rule 5 (statement -> closed .)


state 88

    (13) closed -> WHILE . condition closed
    (8) open -> WHILE . condition open
    (15) condition -> . L_PAREN expr R_PAREN

    L_PAREN         shift and go to state 39

    condition                      shift and go to state 118

state 89

    (14) closed -> FOR . for_condition closed
    (9) open -> FOR . for_condition open
    (16) for_condition -> . L_PAREN declaration expr SEMICOLON expr R_PAREN

    L_PAREN         shift and go to state 42

    for_condition                  shift and go to state 119

state 90

    (15) condition -> L_PAREN expr . R_PAREN
    (23) expr -> expr . assignment exprOR
    (25) assignment -> . ASSIGN
    (26) assignment -> . PLUS_ASSIGN
    (27) assignment -> . MINUS_ASSIGN
    (28) assignment -> . MUL_ASSIGN
    (29) assignment -> . DIV_ASSIGN
    (30) assignment -> . AND_ASSIGN
    (31) assignment -> . OR_ASSIGN
    (32) assignment -> . XOR_ASSIGN
    (33) assignment -> . MOD_ASSIGN
    (34) assignment -> . L_SHIFT_ASSIGN
    (35) assignment -> . R_SHIFT_ASSIGN

    R_PAREN         shift and go to state 120
    ASSIGN          shift and go to state 45
    PLUS_ASSIGN     shift and go to state 46
    MINUS_ASSIGN    shift and go to state 47
    MUL_ASSIGN      shift and go to state 48
    DIV_ASSIGN      shift and go to state 49
    AND_ASSIGN      shift and go to state 50
    OR_ASSIGN       shift and go to state 51
    XOR_ASSIGN      shift and go to state 52
    MOD_ASSIGN      shift and go to state 53
    L_SHIFT_ASSIGN  shift and go to state 54
    R_SHIFT_ASSIGN  shift and go to state 55

    assignment                     shift and go to state 44

state 91

    (8) open -> WHILE condition open .

    IF              reduce using rule 8 (open -> WHILE condition open .)
    WHILE           reduce using rule 8 (open -> WHILE condition open .)
    FOR             reduce using rule 8 (open -> WHILE condition open .)
    SEMICOLON       reduce using rule 8 (open -> WHILE condition open .)
    L_FLOWBRACE     reduce using rule 8 (open -> WHILE condition open .)
    TYPE            reduce using rule 8 (open -> WHILE condition open .)
    NOT             reduce using rule 8 (open -> WHILE condition open .)
    PLUS            reduce using rule 8 (open -> WHILE condition open .)
    MINUS           reduce using rule 8 (open -> WHILE condition open .)
    PLUS_PLUS       reduce using rule 8 (open -> WHILE condition open .)
    MINUS_MINUS     reduce using rule 8 (open -> WHILE condition open .)
    L_PAREN         reduce using rule 8 (open -> WHILE condition open .)
    INT_NUM         reduce using rule 8 (open -> WHILE condition open .)
    FLOAT_NUM       reduce using rule 8 (open -> WHILE condition open .)
    ID              reduce using rule 8 (open -> WHILE condition open .)
    $end            reduce using rule 8 (open -> WHILE condition open .)
    R_FLOWBRACE     reduce using rule 8 (open -> WHILE condition open .)


state 92

    (13) closed -> WHILE condition closed .

    IF              reduce using rule 13 (closed -> WHILE condition closed .)
    WHILE           reduce using rule 13 (closed -> WHILE condition closed .)
    FOR             reduce using rule 13 (closed -> WHILE condition closed .)
    SEMICOLON       reduce using rule 13 (closed -> WHILE condition closed .)
    L_FLOWBRACE     reduce using rule 13 (closed -> WHILE condition closed .)
    TYPE            reduce using rule 13 (closed -> WHILE condition closed .)
    NOT             reduce using rule 13 (closed -> WHILE condition closed .)
    PLUS            reduce using rule 13 (closed -> WHILE condition closed .)
    MINUS           reduce using rule 13 (closed -> WHILE condition closed .)
    PLUS_PLUS       reduce using rule 13 (closed -> WHILE condition closed .)
    MINUS_MINUS     reduce using rule 13 (closed -> WHILE condition closed .)
    L_PAREN         reduce using rule 13 (closed -> WHILE condition closed .)
    INT_NUM         reduce using rule 13 (closed -> WHILE condition closed .)
    FLOAT_NUM       reduce using rule 13 (closed -> WHILE condition closed .)
    ID              reduce using rule 13 (closed -> WHILE condition closed .)
    $end            reduce using rule 13 (closed -> WHILE condition closed .)
    R_FLOWBRACE     reduce using rule 13 (closed -> WHILE condition closed .)
    ELSE            reduce using rule 13 (closed -> WHILE condition closed .)


state 93

    (9) open -> FOR for_condition open .

    IF              reduce using rule 9 (open -> FOR for_condition open .)
    WHILE           reduce using rule 9 (open -> FOR for_condition open .)
    FOR             reduce using rule 9 (open -> FOR for_condition open .)
    SEMICOLON       reduce using rule 9 (open -> FOR for_condition open .)
    L_FLOWBRACE     reduce using rule 9 (open -> FOR for_condition open .)
    TYPE            reduce using rule 9 (open -> FOR for_condition open .)
    NOT             reduce using rule 9 (open -> FOR for_condition open .)
    PLUS            reduce using rule 9 (open -> FOR for_condition open .)
    MINUS           reduce using rule 9 (open -> FOR for_condition open .)
    PLUS_PLUS       reduce using rule 9 (open -> FOR for_condition open .)
    MINUS_MINUS     reduce using rule 9 (open -> FOR for_condition open .)
    L_PAREN         reduce using rule 9 (open -> FOR for_condition open .)
    INT_NUM         reduce using rule 9 (open -> FOR for_condition open .)
    FLOAT_NUM       reduce using rule 9 (open -> FOR for_condition open .)
    ID              reduce using rule 9 (open -> FOR for_condition open .)
    $end            reduce using rule 9 (open -> FOR for_condition open .)
    R_FLOWBRACE     reduce using rule 9 (open -> FOR for_condition open .)


state 94

    (14) closed -> FOR for_condition closed .

    IF              reduce using rule 14 (closed -> FOR for_condition closed .)
    WHILE           reduce using rule 14 (closed -> FOR for_condition closed .)
    FOR             reduce using rule 14 (closed -> FOR for_condition closed .)
    SEMICOLON       reduce using rule 14 (closed -> FOR for_condition closed .)
    L_FLOWBRACE     reduce using rule 14 (closed -> FOR for_condition closed .)
    TYPE            reduce using rule 14 (closed -> FOR for_condition closed .)
    NOT             reduce using rule 14 (closed -> FOR for_condition closed .)
    PLUS            reduce using rule 14 (closed -> FOR for_condition closed .)
    MINUS           reduce using rule 14 (closed -> FOR for_condition closed .)
    PLUS_PLUS       reduce using rule 14 (closed -> FOR for_condition closed .)
    MINUS_MINUS     reduce using rule 14 (closed -> FOR for_condition closed .)
    L_PAREN         reduce using rule 14 (closed -> FOR for_condition closed .)
    INT_NUM         reduce using rule 14 (closed -> FOR for_condition closed .)
    FLOAT_NUM       reduce using rule 14 (closed -> FOR for_condition closed .)
    ID              reduce using rule 14 (closed -> FOR for_condition closed .)
    $end            reduce using rule 14 (closed -> FOR for_condition closed .)
    R_FLOWBRACE     reduce using rule 14 (closed -> FOR for_condition closed .)
    ELSE            reduce using rule 14 (closed -> FOR for_condition closed .)


state 95

    (16) for_condition -> L_PAREN declaration . expr SEMICOLON expr R_PAREN
    (23) expr -> . expr assignment exprOR
    (24) expr -> . exprOR
    (36) exprOR -> . exprOR OR exprAND
    (37) exprOR -> . exprAND
    (38) exprAND -> . exprAND AND exprBITOR
    (39) exprAND -> . exprBITOR
    (40) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (41) exprBITOR -> . exprBITXOR
    (42) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (43) exprBITXOR -> . exprBITAND
    (44) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (45) exprBITAND -> . exprEQ
    (46) exprEQ -> . exprEQ EQ exprRELOP
    (47) exprEQ -> . exprEQ NE exprRELOP
    (48) exprEQ -> . exprRELOP
    (49) exprRELOP -> . exprRELOP relop exprSHIFT
    (50) exprRELOP -> . exprSHIFT
    (55) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (56) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (57) exprSHIFT -> . exprOP
    (58) exprOP -> . exprOP PLUS term
    (59) exprOP -> . exprOP MINUS term
    (60) exprOP -> . term
    (61) term -> . term MULTIPLY factor
    (62) term -> . term DIVIDE factor
    (63) term -> . term MOD factor
    (64) term -> . factor
    (65) factor -> . NOT factor
    (66) factor -> . PLUS factor
    (67) factor -> . MINUS factor
    (68) factor -> . PLUS_PLUS factor
    (69) factor -> . MINUS_MINUS factor
    (70) factor -> . brace
    (71) brace -> . L_PAREN expr R_PAREN
    (72) brace -> . brace PLUS_PLUS
    (73) brace -> . brace MINUS_MINUS
    (74) brace -> . INT_NUM
    (75) brace -> . FLOAT_NUM
    (76) brace -> . ID

    NOT             shift and go to state 30
    PLUS            shift and go to state 26
    MINUS           shift and go to state 28
    PLUS_PLUS       shift and go to state 31
    MINUS_MINUS     shift and go to state 32
    L_PAREN         shift and go to state 34
    INT_NUM         shift and go to state 35
    FLOAT_NUM       shift and go to state 36
    ID              shift and go to state 17

    expr                           shift and go to state 121
    exprOR                         shift and go to state 15
    exprAND                        shift and go to state 18
    exprBITOR                      shift and go to state 19
    exprBITXOR                     shift and go to state 20
    exprBITAND                     shift and go to state 21
    exprEQ                         shift and go to state 22
    exprRELOP                      shift and go to state 23
    exprSHIFT                      shift and go to state 24
    exprOP                         shift and go to state 25
    term                           shift and go to state 27
    factor                         shift and go to state 29
    brace                          shift and go to state 33

state 96

    (23) expr -> expr assignment exprOR .
    (36) exprOR -> exprOR . OR exprAND

    SEMICOLON       reduce using rule 23 (expr -> expr assignment exprOR .)
    ASSIGN          reduce using rule 23 (expr -> expr assignment exprOR .)
    PLUS_ASSIGN     reduce using rule 23 (expr -> expr assignment exprOR .)
    MINUS_ASSIGN    reduce using rule 23 (expr -> expr assignment exprOR .)
    MUL_ASSIGN      reduce using rule 23 (expr -> expr assignment exprOR .)
    DIV_ASSIGN      reduce using rule 23 (expr -> expr assignment exprOR .)
    AND_ASSIGN      reduce using rule 23 (expr -> expr assignment exprOR .)
    OR_ASSIGN       reduce using rule 23 (expr -> expr assignment exprOR .)
    XOR_ASSIGN      reduce using rule 23 (expr -> expr assignment exprOR .)
    MOD_ASSIGN      reduce using rule 23 (expr -> expr assignment exprOR .)
    L_SHIFT_ASSIGN  reduce using rule 23 (expr -> expr assignment exprOR .)
    R_SHIFT_ASSIGN  reduce using rule 23 (expr -> expr assignment exprOR .)
    R_PAREN         reduce using rule 23 (expr -> expr assignment exprOR .)
    OR              shift and go to state 57


state 97

    (19) block -> L_FLOWBRACE multiple_statements R_FLOWBRACE .

    IF              reduce using rule 19 (block -> L_FLOWBRACE multiple_statements R_FLOWBRACE .)
    WHILE           reduce using rule 19 (block -> L_FLOWBRACE multiple_statements R_FLOWBRACE .)
    FOR             reduce using rule 19 (block -> L_FLOWBRACE multiple_statements R_FLOWBRACE .)
    SEMICOLON       reduce using rule 19 (block -> L_FLOWBRACE multiple_statements R_FLOWBRACE .)
    L_FLOWBRACE     reduce using rule 19 (block -> L_FLOWBRACE multiple_statements R_FLOWBRACE .)
    TYPE            reduce using rule 19 (block -> L_FLOWBRACE multiple_statements R_FLOWBRACE .)
    NOT             reduce using rule 19 (block -> L_FLOWBRACE multiple_statements R_FLOWBRACE .)
    PLUS            reduce using rule 19 (block -> L_FLOWBRACE multiple_statements R_FLOWBRACE .)
    MINUS           reduce using rule 19 (block -> L_FLOWBRACE multiple_statements R_FLOWBRACE .)
    PLUS_PLUS       reduce using rule 19 (block -> L_FLOWBRACE multiple_statements R_FLOWBRACE .)
    MINUS_MINUS     reduce using rule 19 (block -> L_FLOWBRACE multiple_statements R_FLOWBRACE .)
    L_PAREN         reduce using rule 19 (block -> L_FLOWBRACE multiple_statements R_FLOWBRACE .)
    INT_NUM         reduce using rule 19 (block -> L_FLOWBRACE multiple_statements R_FLOWBRACE .)
    FLOAT_NUM       reduce using rule 19 (block -> L_FLOWBRACE multiple_statements R_FLOWBRACE .)
    ID              reduce using rule 19 (block -> L_FLOWBRACE multiple_statements R_FLOWBRACE .)
    $end            reduce using rule 19 (block -> L_FLOWBRACE multiple_statements R_FLOWBRACE .)
    R_FLOWBRACE     reduce using rule 19 (block -> L_FLOWBRACE multiple_statements R_FLOWBRACE .)
    ELSE            reduce using rule 19 (block -> L_FLOWBRACE multiple_statements R_FLOWBRACE .)


state 98

    (36) exprOR -> exprOR OR exprAND .
    (38) exprAND -> exprAND . AND exprBITOR

    OR              reduce using rule 36 (exprOR -> exprOR OR exprAND .)
    SEMICOLON       reduce using rule 36 (exprOR -> exprOR OR exprAND .)
    ASSIGN          reduce using rule 36 (exprOR -> exprOR OR exprAND .)
    PLUS_ASSIGN     reduce using rule 36 (exprOR -> exprOR OR exprAND .)
    MINUS_ASSIGN    reduce using rule 36 (exprOR -> exprOR OR exprAND .)
    MUL_ASSIGN      reduce using rule 36 (exprOR -> exprOR OR exprAND .)
    DIV_ASSIGN      reduce using rule 36 (exprOR -> exprOR OR exprAND .)
    AND_ASSIGN      reduce using rule 36 (exprOR -> exprOR OR exprAND .)
    OR_ASSIGN       reduce using rule 36 (exprOR -> exprOR OR exprAND .)
    XOR_ASSIGN      reduce using rule 36 (exprOR -> exprOR OR exprAND .)
    MOD_ASSIGN      reduce using rule 36 (exprOR -> exprOR OR exprAND .)
    L_SHIFT_ASSIGN  reduce using rule 36 (exprOR -> exprOR OR exprAND .)
    R_SHIFT_ASSIGN  reduce using rule 36 (exprOR -> exprOR OR exprAND .)
    R_PAREN         reduce using rule 36 (exprOR -> exprOR OR exprAND .)
    AND             shift and go to state 59


state 99

    (17) declaration -> TYPE ID SEMICOLON .

    IF              reduce using rule 17 (declaration -> TYPE ID SEMICOLON .)
    WHILE           reduce using rule 17 (declaration -> TYPE ID SEMICOLON .)
    FOR             reduce using rule 17 (declaration -> TYPE ID SEMICOLON .)
    SEMICOLON       reduce using rule 17 (declaration -> TYPE ID SEMICOLON .)
    L_FLOWBRACE     reduce using rule 17 (declaration -> TYPE ID SEMICOLON .)
    TYPE            reduce using rule 17 (declaration -> TYPE ID SEMICOLON .)
    NOT             reduce using rule 17 (declaration -> TYPE ID SEMICOLON .)
    PLUS            reduce using rule 17 (declaration -> TYPE ID SEMICOLON .)
    MINUS           reduce using rule 17 (declaration -> TYPE ID SEMICOLON .)
    PLUS_PLUS       reduce using rule 17 (declaration -> TYPE ID SEMICOLON .)
    MINUS_MINUS     reduce using rule 17 (declaration -> TYPE ID SEMICOLON .)
    L_PAREN         reduce using rule 17 (declaration -> TYPE ID SEMICOLON .)
    INT_NUM         reduce using rule 17 (declaration -> TYPE ID SEMICOLON .)
    FLOAT_NUM       reduce using rule 17 (declaration -> TYPE ID SEMICOLON .)
    ID              reduce using rule 17 (declaration -> TYPE ID SEMICOLON .)
    $end            reduce using rule 17 (declaration -> TYPE ID SEMICOLON .)
    R_FLOWBRACE     reduce using rule 17 (declaration -> TYPE ID SEMICOLON .)
    ELSE            reduce using rule 17 (declaration -> TYPE ID SEMICOLON .)


state 100

    (18) declaration -> TYPE ID ASSIGN . expr SEMICOLON
    (23) expr -> . expr assignment exprOR
    (24) expr -> . exprOR
    (36) exprOR -> . exprOR OR exprAND
    (37) exprOR -> . exprAND
    (38) exprAND -> . exprAND AND exprBITOR
    (39) exprAND -> . exprBITOR
    (40) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (41) exprBITOR -> . exprBITXOR
    (42) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (43) exprBITXOR -> . exprBITAND
    (44) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (45) exprBITAND -> . exprEQ
    (46) exprEQ -> . exprEQ EQ exprRELOP
    (47) exprEQ -> . exprEQ NE exprRELOP
    (48) exprEQ -> . exprRELOP
    (49) exprRELOP -> . exprRELOP relop exprSHIFT
    (50) exprRELOP -> . exprSHIFT
    (55) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (56) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (57) exprSHIFT -> . exprOP
    (58) exprOP -> . exprOP PLUS term
    (59) exprOP -> . exprOP MINUS term
    (60) exprOP -> . term
    (61) term -> . term MULTIPLY factor
    (62) term -> . term DIVIDE factor
    (63) term -> . term MOD factor
    (64) term -> . factor
    (65) factor -> . NOT factor
    (66) factor -> . PLUS factor
    (67) factor -> . MINUS factor
    (68) factor -> . PLUS_PLUS factor
    (69) factor -> . MINUS_MINUS factor
    (70) factor -> . brace
    (71) brace -> . L_PAREN expr R_PAREN
    (72) brace -> . brace PLUS_PLUS
    (73) brace -> . brace MINUS_MINUS
    (74) brace -> . INT_NUM
    (75) brace -> . FLOAT_NUM
    (76) brace -> . ID

    NOT             shift and go to state 30
    PLUS            shift and go to state 26
    MINUS           shift and go to state 28
    PLUS_PLUS       shift and go to state 31
    MINUS_MINUS     shift and go to state 32
    L_PAREN         shift and go to state 34
    INT_NUM         shift and go to state 35
    FLOAT_NUM       shift and go to state 36
    ID              shift and go to state 17

    expr                           shift and go to state 122
    exprOR                         shift and go to state 15
    exprAND                        shift and go to state 18
    exprBITOR                      shift and go to state 19
    exprBITXOR                     shift and go to state 20
    exprBITAND                     shift and go to state 21
    exprEQ                         shift and go to state 22
    exprRELOP                      shift and go to state 23
    exprSHIFT                      shift and go to state 24
    exprOP                         shift and go to state 25
    term                           shift and go to state 27
    factor                         shift and go to state 29
    brace                          shift and go to state 33

state 101

    (38) exprAND -> exprAND AND exprBITOR .
    (40) exprBITOR -> exprBITOR . BIT_OR exprBITXOR

    AND             reduce using rule 38 (exprAND -> exprAND AND exprBITOR .)
    OR              reduce using rule 38 (exprAND -> exprAND AND exprBITOR .)
    SEMICOLON       reduce using rule 38 (exprAND -> exprAND AND exprBITOR .)
    ASSIGN          reduce using rule 38 (exprAND -> exprAND AND exprBITOR .)
    PLUS_ASSIGN     reduce using rule 38 (exprAND -> exprAND AND exprBITOR .)
    MINUS_ASSIGN    reduce using rule 38 (exprAND -> exprAND AND exprBITOR .)
    MUL_ASSIGN      reduce using rule 38 (exprAND -> exprAND AND exprBITOR .)
    DIV_ASSIGN      reduce using rule 38 (exprAND -> exprAND AND exprBITOR .)
    AND_ASSIGN      reduce using rule 38 (exprAND -> exprAND AND exprBITOR .)
    OR_ASSIGN       reduce using rule 38 (exprAND -> exprAND AND exprBITOR .)
    XOR_ASSIGN      reduce using rule 38 (exprAND -> exprAND AND exprBITOR .)
    MOD_ASSIGN      reduce using rule 38 (exprAND -> exprAND AND exprBITOR .)
    L_SHIFT_ASSIGN  reduce using rule 38 (exprAND -> exprAND AND exprBITOR .)
    R_SHIFT_ASSIGN  reduce using rule 38 (exprAND -> exprAND AND exprBITOR .)
    R_PAREN         reduce using rule 38 (exprAND -> exprAND AND exprBITOR .)
    BIT_OR          shift and go to state 60


state 102

    (40) exprBITOR -> exprBITOR BIT_OR exprBITXOR .
    (42) exprBITXOR -> exprBITXOR . BIT_XOR exprBITAND

    BIT_OR          reduce using rule 40 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    AND             reduce using rule 40 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    OR              reduce using rule 40 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    SEMICOLON       reduce using rule 40 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    ASSIGN          reduce using rule 40 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    PLUS_ASSIGN     reduce using rule 40 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    MINUS_ASSIGN    reduce using rule 40 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    MUL_ASSIGN      reduce using rule 40 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    DIV_ASSIGN      reduce using rule 40 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    AND_ASSIGN      reduce using rule 40 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    OR_ASSIGN       reduce using rule 40 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    XOR_ASSIGN      reduce using rule 40 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    MOD_ASSIGN      reduce using rule 40 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    L_SHIFT_ASSIGN  reduce using rule 40 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    R_SHIFT_ASSIGN  reduce using rule 40 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    R_PAREN         reduce using rule 40 (exprBITOR -> exprBITOR BIT_OR exprBITXOR .)
    BIT_XOR         shift and go to state 61


state 103

    (42) exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .
    (44) exprBITAND -> exprBITAND . BIT_AND exprEQ

    BIT_XOR         reduce using rule 42 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    BIT_OR          reduce using rule 42 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    AND             reduce using rule 42 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    OR              reduce using rule 42 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    SEMICOLON       reduce using rule 42 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    ASSIGN          reduce using rule 42 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    PLUS_ASSIGN     reduce using rule 42 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    MINUS_ASSIGN    reduce using rule 42 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    MUL_ASSIGN      reduce using rule 42 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    DIV_ASSIGN      reduce using rule 42 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    AND_ASSIGN      reduce using rule 42 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    OR_ASSIGN       reduce using rule 42 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    XOR_ASSIGN      reduce using rule 42 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    MOD_ASSIGN      reduce using rule 42 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    L_SHIFT_ASSIGN  reduce using rule 42 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    R_SHIFT_ASSIGN  reduce using rule 42 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    R_PAREN         reduce using rule 42 (exprBITXOR -> exprBITXOR BIT_XOR exprBITAND .)
    BIT_AND         shift and go to state 62


state 104

    (44) exprBITAND -> exprBITAND BIT_AND exprEQ .
    (46) exprEQ -> exprEQ . EQ exprRELOP
    (47) exprEQ -> exprEQ . NE exprRELOP

    BIT_AND         reduce using rule 44 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    BIT_XOR         reduce using rule 44 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    BIT_OR          reduce using rule 44 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    AND             reduce using rule 44 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    OR              reduce using rule 44 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    SEMICOLON       reduce using rule 44 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    ASSIGN          reduce using rule 44 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    PLUS_ASSIGN     reduce using rule 44 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    MINUS_ASSIGN    reduce using rule 44 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    MUL_ASSIGN      reduce using rule 44 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    DIV_ASSIGN      reduce using rule 44 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    AND_ASSIGN      reduce using rule 44 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    OR_ASSIGN       reduce using rule 44 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    XOR_ASSIGN      reduce using rule 44 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    MOD_ASSIGN      reduce using rule 44 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    L_SHIFT_ASSIGN  reduce using rule 44 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    R_SHIFT_ASSIGN  reduce using rule 44 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    R_PAREN         reduce using rule 44 (exprBITAND -> exprBITAND BIT_AND exprEQ .)
    EQ              shift and go to state 63
    NE              shift and go to state 64


state 105

    (46) exprEQ -> exprEQ EQ exprRELOP .
    (49) exprRELOP -> exprRELOP . relop exprSHIFT
    (51) relop -> . LE
    (52) relop -> . LT
    (53) relop -> . GE
    (54) relop -> . GT

    EQ              reduce using rule 46 (exprEQ -> exprEQ EQ exprRELOP .)
    NE              reduce using rule 46 (exprEQ -> exprEQ EQ exprRELOP .)
    BIT_AND         reduce using rule 46 (exprEQ -> exprEQ EQ exprRELOP .)
    BIT_XOR         reduce using rule 46 (exprEQ -> exprEQ EQ exprRELOP .)
    BIT_OR          reduce using rule 46 (exprEQ -> exprEQ EQ exprRELOP .)
    AND             reduce using rule 46 (exprEQ -> exprEQ EQ exprRELOP .)
    OR              reduce using rule 46 (exprEQ -> exprEQ EQ exprRELOP .)
    SEMICOLON       reduce using rule 46 (exprEQ -> exprEQ EQ exprRELOP .)
    ASSIGN          reduce using rule 46 (exprEQ -> exprEQ EQ exprRELOP .)
    PLUS_ASSIGN     reduce using rule 46 (exprEQ -> exprEQ EQ exprRELOP .)
    MINUS_ASSIGN    reduce using rule 46 (exprEQ -> exprEQ EQ exprRELOP .)
    MUL_ASSIGN      reduce using rule 46 (exprEQ -> exprEQ EQ exprRELOP .)
    DIV_ASSIGN      reduce using rule 46 (exprEQ -> exprEQ EQ exprRELOP .)
    AND_ASSIGN      reduce using rule 46 (exprEQ -> exprEQ EQ exprRELOP .)
    OR_ASSIGN       reduce using rule 46 (exprEQ -> exprEQ EQ exprRELOP .)
    XOR_ASSIGN      reduce using rule 46 (exprEQ -> exprEQ EQ exprRELOP .)
    MOD_ASSIGN      reduce using rule 46 (exprEQ -> exprEQ EQ exprRELOP .)
    L_SHIFT_ASSIGN  reduce using rule 46 (exprEQ -> exprEQ EQ exprRELOP .)
    R_SHIFT_ASSIGN  reduce using rule 46 (exprEQ -> exprEQ EQ exprRELOP .)
    R_PAREN         reduce using rule 46 (exprEQ -> exprEQ EQ exprRELOP .)
    LE              shift and go to state 66
    LT              shift and go to state 67
    GE              shift and go to state 68
    GT              shift and go to state 69

    relop                          shift and go to state 65

state 106

    (47) exprEQ -> exprEQ NE exprRELOP .
    (49) exprRELOP -> exprRELOP . relop exprSHIFT
    (51) relop -> . LE
    (52) relop -> . LT
    (53) relop -> . GE
    (54) relop -> . GT

    EQ              reduce using rule 47 (exprEQ -> exprEQ NE exprRELOP .)
    NE              reduce using rule 47 (exprEQ -> exprEQ NE exprRELOP .)
    BIT_AND         reduce using rule 47 (exprEQ -> exprEQ NE exprRELOP .)
    BIT_XOR         reduce using rule 47 (exprEQ -> exprEQ NE exprRELOP .)
    BIT_OR          reduce using rule 47 (exprEQ -> exprEQ NE exprRELOP .)
    AND             reduce using rule 47 (exprEQ -> exprEQ NE exprRELOP .)
    OR              reduce using rule 47 (exprEQ -> exprEQ NE exprRELOP .)
    SEMICOLON       reduce using rule 47 (exprEQ -> exprEQ NE exprRELOP .)
    ASSIGN          reduce using rule 47 (exprEQ -> exprEQ NE exprRELOP .)
    PLUS_ASSIGN     reduce using rule 47 (exprEQ -> exprEQ NE exprRELOP .)
    MINUS_ASSIGN    reduce using rule 47 (exprEQ -> exprEQ NE exprRELOP .)
    MUL_ASSIGN      reduce using rule 47 (exprEQ -> exprEQ NE exprRELOP .)
    DIV_ASSIGN      reduce using rule 47 (exprEQ -> exprEQ NE exprRELOP .)
    AND_ASSIGN      reduce using rule 47 (exprEQ -> exprEQ NE exprRELOP .)
    OR_ASSIGN       reduce using rule 47 (exprEQ -> exprEQ NE exprRELOP .)
    XOR_ASSIGN      reduce using rule 47 (exprEQ -> exprEQ NE exprRELOP .)
    MOD_ASSIGN      reduce using rule 47 (exprEQ -> exprEQ NE exprRELOP .)
    L_SHIFT_ASSIGN  reduce using rule 47 (exprEQ -> exprEQ NE exprRELOP .)
    R_SHIFT_ASSIGN  reduce using rule 47 (exprEQ -> exprEQ NE exprRELOP .)
    R_PAREN         reduce using rule 47 (exprEQ -> exprEQ NE exprRELOP .)
    LE              shift and go to state 66
    LT              shift and go to state 67
    GE              shift and go to state 68
    GT              shift and go to state 69

    relop                          shift and go to state 65

state 107

    (49) exprRELOP -> exprRELOP relop exprSHIFT .
    (55) exprSHIFT -> exprSHIFT . L_SHIFT exprOP
    (56) exprSHIFT -> exprSHIFT . R_SHIFT exprOP

    LE              reduce using rule 49 (exprRELOP -> exprRELOP relop exprSHIFT .)
    LT              reduce using rule 49 (exprRELOP -> exprRELOP relop exprSHIFT .)
    GE              reduce using rule 49 (exprRELOP -> exprRELOP relop exprSHIFT .)
    GT              reduce using rule 49 (exprRELOP -> exprRELOP relop exprSHIFT .)
    EQ              reduce using rule 49 (exprRELOP -> exprRELOP relop exprSHIFT .)
    NE              reduce using rule 49 (exprRELOP -> exprRELOP relop exprSHIFT .)
    BIT_AND         reduce using rule 49 (exprRELOP -> exprRELOP relop exprSHIFT .)
    BIT_XOR         reduce using rule 49 (exprRELOP -> exprRELOP relop exprSHIFT .)
    BIT_OR          reduce using rule 49 (exprRELOP -> exprRELOP relop exprSHIFT .)
    AND             reduce using rule 49 (exprRELOP -> exprRELOP relop exprSHIFT .)
    OR              reduce using rule 49 (exprRELOP -> exprRELOP relop exprSHIFT .)
    SEMICOLON       reduce using rule 49 (exprRELOP -> exprRELOP relop exprSHIFT .)
    ASSIGN          reduce using rule 49 (exprRELOP -> exprRELOP relop exprSHIFT .)
    PLUS_ASSIGN     reduce using rule 49 (exprRELOP -> exprRELOP relop exprSHIFT .)
    MINUS_ASSIGN    reduce using rule 49 (exprRELOP -> exprRELOP relop exprSHIFT .)
    MUL_ASSIGN      reduce using rule 49 (exprRELOP -> exprRELOP relop exprSHIFT .)
    DIV_ASSIGN      reduce using rule 49 (exprRELOP -> exprRELOP relop exprSHIFT .)
    AND_ASSIGN      reduce using rule 49 (exprRELOP -> exprRELOP relop exprSHIFT .)
    OR_ASSIGN       reduce using rule 49 (exprRELOP -> exprRELOP relop exprSHIFT .)
    XOR_ASSIGN      reduce using rule 49 (exprRELOP -> exprRELOP relop exprSHIFT .)
    MOD_ASSIGN      reduce using rule 49 (exprRELOP -> exprRELOP relop exprSHIFT .)
    L_SHIFT_ASSIGN  reduce using rule 49 (exprRELOP -> exprRELOP relop exprSHIFT .)
    R_SHIFT_ASSIGN  reduce using rule 49 (exprRELOP -> exprRELOP relop exprSHIFT .)
    R_PAREN         reduce using rule 49 (exprRELOP -> exprRELOP relop exprSHIFT .)
    L_SHIFT         shift and go to state 70
    R_SHIFT         shift and go to state 71


state 108

    (55) exprSHIFT -> exprSHIFT L_SHIFT exprOP .
    (58) exprOP -> exprOP . PLUS term
    (59) exprOP -> exprOP . MINUS term

    L_SHIFT         reduce using rule 55 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    R_SHIFT         reduce using rule 55 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    LE              reduce using rule 55 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    LT              reduce using rule 55 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    GE              reduce using rule 55 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    GT              reduce using rule 55 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    EQ              reduce using rule 55 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    NE              reduce using rule 55 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    BIT_AND         reduce using rule 55 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    BIT_XOR         reduce using rule 55 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    BIT_OR          reduce using rule 55 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    AND             reduce using rule 55 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    OR              reduce using rule 55 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    SEMICOLON       reduce using rule 55 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    ASSIGN          reduce using rule 55 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    PLUS_ASSIGN     reduce using rule 55 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    MINUS_ASSIGN    reduce using rule 55 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    MUL_ASSIGN      reduce using rule 55 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    DIV_ASSIGN      reduce using rule 55 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    AND_ASSIGN      reduce using rule 55 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    OR_ASSIGN       reduce using rule 55 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    XOR_ASSIGN      reduce using rule 55 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    MOD_ASSIGN      reduce using rule 55 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    L_SHIFT_ASSIGN  reduce using rule 55 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    R_SHIFT_ASSIGN  reduce using rule 55 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    R_PAREN         reduce using rule 55 (exprSHIFT -> exprSHIFT L_SHIFT exprOP .)
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73


state 109

    (56) exprSHIFT -> exprSHIFT R_SHIFT exprOP .
    (58) exprOP -> exprOP . PLUS term
    (59) exprOP -> exprOP . MINUS term

    L_SHIFT         reduce using rule 56 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    R_SHIFT         reduce using rule 56 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    LE              reduce using rule 56 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    LT              reduce using rule 56 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    GE              reduce using rule 56 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    GT              reduce using rule 56 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    EQ              reduce using rule 56 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    NE              reduce using rule 56 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    BIT_AND         reduce using rule 56 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    BIT_XOR         reduce using rule 56 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    BIT_OR          reduce using rule 56 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    AND             reduce using rule 56 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    OR              reduce using rule 56 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    SEMICOLON       reduce using rule 56 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    ASSIGN          reduce using rule 56 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    PLUS_ASSIGN     reduce using rule 56 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    MINUS_ASSIGN    reduce using rule 56 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    MUL_ASSIGN      reduce using rule 56 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    DIV_ASSIGN      reduce using rule 56 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    AND_ASSIGN      reduce using rule 56 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    OR_ASSIGN       reduce using rule 56 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    XOR_ASSIGN      reduce using rule 56 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    MOD_ASSIGN      reduce using rule 56 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    L_SHIFT_ASSIGN  reduce using rule 56 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    R_SHIFT_ASSIGN  reduce using rule 56 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    R_PAREN         reduce using rule 56 (exprSHIFT -> exprSHIFT R_SHIFT exprOP .)
    PLUS            shift and go to state 72
    MINUS           shift and go to state 73


state 110

    (58) exprOP -> exprOP PLUS term .
    (61) term -> term . MULTIPLY factor
    (62) term -> term . DIVIDE factor
    (63) term -> term . MOD factor

    PLUS            reduce using rule 58 (exprOP -> exprOP PLUS term .)
    MINUS           reduce using rule 58 (exprOP -> exprOP PLUS term .)
    L_SHIFT         reduce using rule 58 (exprOP -> exprOP PLUS term .)
    R_SHIFT         reduce using rule 58 (exprOP -> exprOP PLUS term .)
    LE              reduce using rule 58 (exprOP -> exprOP PLUS term .)
    LT              reduce using rule 58 (exprOP -> exprOP PLUS term .)
    GE              reduce using rule 58 (exprOP -> exprOP PLUS term .)
    GT              reduce using rule 58 (exprOP -> exprOP PLUS term .)
    EQ              reduce using rule 58 (exprOP -> exprOP PLUS term .)
    NE              reduce using rule 58 (exprOP -> exprOP PLUS term .)
    BIT_AND         reduce using rule 58 (exprOP -> exprOP PLUS term .)
    BIT_XOR         reduce using rule 58 (exprOP -> exprOP PLUS term .)
    BIT_OR          reduce using rule 58 (exprOP -> exprOP PLUS term .)
    AND             reduce using rule 58 (exprOP -> exprOP PLUS term .)
    OR              reduce using rule 58 (exprOP -> exprOP PLUS term .)
    SEMICOLON       reduce using rule 58 (exprOP -> exprOP PLUS term .)
    ASSIGN          reduce using rule 58 (exprOP -> exprOP PLUS term .)
    PLUS_ASSIGN     reduce using rule 58 (exprOP -> exprOP PLUS term .)
    MINUS_ASSIGN    reduce using rule 58 (exprOP -> exprOP PLUS term .)
    MUL_ASSIGN      reduce using rule 58 (exprOP -> exprOP PLUS term .)
    DIV_ASSIGN      reduce using rule 58 (exprOP -> exprOP PLUS term .)
    AND_ASSIGN      reduce using rule 58 (exprOP -> exprOP PLUS term .)
    OR_ASSIGN       reduce using rule 58 (exprOP -> exprOP PLUS term .)
    XOR_ASSIGN      reduce using rule 58 (exprOP -> exprOP PLUS term .)
    MOD_ASSIGN      reduce using rule 58 (exprOP -> exprOP PLUS term .)
    L_SHIFT_ASSIGN  reduce using rule 58 (exprOP -> exprOP PLUS term .)
    R_SHIFT_ASSIGN  reduce using rule 58 (exprOP -> exprOP PLUS term .)
    R_PAREN         reduce using rule 58 (exprOP -> exprOP PLUS term .)
    MULTIPLY        shift and go to state 75
    DIVIDE          shift and go to state 76
    MOD             shift and go to state 77


state 111

    (59) exprOP -> exprOP MINUS term .
    (61) term -> term . MULTIPLY factor
    (62) term -> term . DIVIDE factor
    (63) term -> term . MOD factor

    PLUS            reduce using rule 59 (exprOP -> exprOP MINUS term .)
    MINUS           reduce using rule 59 (exprOP -> exprOP MINUS term .)
    L_SHIFT         reduce using rule 59 (exprOP -> exprOP MINUS term .)
    R_SHIFT         reduce using rule 59 (exprOP -> exprOP MINUS term .)
    LE              reduce using rule 59 (exprOP -> exprOP MINUS term .)
    LT              reduce using rule 59 (exprOP -> exprOP MINUS term .)
    GE              reduce using rule 59 (exprOP -> exprOP MINUS term .)
    GT              reduce using rule 59 (exprOP -> exprOP MINUS term .)
    EQ              reduce using rule 59 (exprOP -> exprOP MINUS term .)
    NE              reduce using rule 59 (exprOP -> exprOP MINUS term .)
    BIT_AND         reduce using rule 59 (exprOP -> exprOP MINUS term .)
    BIT_XOR         reduce using rule 59 (exprOP -> exprOP MINUS term .)
    BIT_OR          reduce using rule 59 (exprOP -> exprOP MINUS term .)
    AND             reduce using rule 59 (exprOP -> exprOP MINUS term .)
    OR              reduce using rule 59 (exprOP -> exprOP MINUS term .)
    SEMICOLON       reduce using rule 59 (exprOP -> exprOP MINUS term .)
    ASSIGN          reduce using rule 59 (exprOP -> exprOP MINUS term .)
    PLUS_ASSIGN     reduce using rule 59 (exprOP -> exprOP MINUS term .)
    MINUS_ASSIGN    reduce using rule 59 (exprOP -> exprOP MINUS term .)
    MUL_ASSIGN      reduce using rule 59 (exprOP -> exprOP MINUS term .)
    DIV_ASSIGN      reduce using rule 59 (exprOP -> exprOP MINUS term .)
    AND_ASSIGN      reduce using rule 59 (exprOP -> exprOP MINUS term .)
    OR_ASSIGN       reduce using rule 59 (exprOP -> exprOP MINUS term .)
    XOR_ASSIGN      reduce using rule 59 (exprOP -> exprOP MINUS term .)
    MOD_ASSIGN      reduce using rule 59 (exprOP -> exprOP MINUS term .)
    L_SHIFT_ASSIGN  reduce using rule 59 (exprOP -> exprOP MINUS term .)
    R_SHIFT_ASSIGN  reduce using rule 59 (exprOP -> exprOP MINUS term .)
    R_PAREN         reduce using rule 59 (exprOP -> exprOP MINUS term .)
    MULTIPLY        shift and go to state 75
    DIVIDE          shift and go to state 76
    MOD             shift and go to state 77


state 112

    (61) term -> term MULTIPLY factor .

    MULTIPLY        reduce using rule 61 (term -> term MULTIPLY factor .)
    DIVIDE          reduce using rule 61 (term -> term MULTIPLY factor .)
    MOD             reduce using rule 61 (term -> term MULTIPLY factor .)
    PLUS            reduce using rule 61 (term -> term MULTIPLY factor .)
    MINUS           reduce using rule 61 (term -> term MULTIPLY factor .)
    L_SHIFT         reduce using rule 61 (term -> term MULTIPLY factor .)
    R_SHIFT         reduce using rule 61 (term -> term MULTIPLY factor .)
    LE              reduce using rule 61 (term -> term MULTIPLY factor .)
    LT              reduce using rule 61 (term -> term MULTIPLY factor .)
    GE              reduce using rule 61 (term -> term MULTIPLY factor .)
    GT              reduce using rule 61 (term -> term MULTIPLY factor .)
    EQ              reduce using rule 61 (term -> term MULTIPLY factor .)
    NE              reduce using rule 61 (term -> term MULTIPLY factor .)
    BIT_AND         reduce using rule 61 (term -> term MULTIPLY factor .)
    BIT_XOR         reduce using rule 61 (term -> term MULTIPLY factor .)
    BIT_OR          reduce using rule 61 (term -> term MULTIPLY factor .)
    AND             reduce using rule 61 (term -> term MULTIPLY factor .)
    OR              reduce using rule 61 (term -> term MULTIPLY factor .)
    SEMICOLON       reduce using rule 61 (term -> term MULTIPLY factor .)
    ASSIGN          reduce using rule 61 (term -> term MULTIPLY factor .)
    PLUS_ASSIGN     reduce using rule 61 (term -> term MULTIPLY factor .)
    MINUS_ASSIGN    reduce using rule 61 (term -> term MULTIPLY factor .)
    MUL_ASSIGN      reduce using rule 61 (term -> term MULTIPLY factor .)
    DIV_ASSIGN      reduce using rule 61 (term -> term MULTIPLY factor .)
    AND_ASSIGN      reduce using rule 61 (term -> term MULTIPLY factor .)
    OR_ASSIGN       reduce using rule 61 (term -> term MULTIPLY factor .)
    XOR_ASSIGN      reduce using rule 61 (term -> term MULTIPLY factor .)
    MOD_ASSIGN      reduce using rule 61 (term -> term MULTIPLY factor .)
    L_SHIFT_ASSIGN  reduce using rule 61 (term -> term MULTIPLY factor .)
    R_SHIFT_ASSIGN  reduce using rule 61 (term -> term MULTIPLY factor .)
    R_PAREN         reduce using rule 61 (term -> term MULTIPLY factor .)


state 113

    (62) term -> term DIVIDE factor .

    MULTIPLY        reduce using rule 62 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 62 (term -> term DIVIDE factor .)
    MOD             reduce using rule 62 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 62 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 62 (term -> term DIVIDE factor .)
    L_SHIFT         reduce using rule 62 (term -> term DIVIDE factor .)
    R_SHIFT         reduce using rule 62 (term -> term DIVIDE factor .)
    LE              reduce using rule 62 (term -> term DIVIDE factor .)
    LT              reduce using rule 62 (term -> term DIVIDE factor .)
    GE              reduce using rule 62 (term -> term DIVIDE factor .)
    GT              reduce using rule 62 (term -> term DIVIDE factor .)
    EQ              reduce using rule 62 (term -> term DIVIDE factor .)
    NE              reduce using rule 62 (term -> term DIVIDE factor .)
    BIT_AND         reduce using rule 62 (term -> term DIVIDE factor .)
    BIT_XOR         reduce using rule 62 (term -> term DIVIDE factor .)
    BIT_OR          reduce using rule 62 (term -> term DIVIDE factor .)
    AND             reduce using rule 62 (term -> term DIVIDE factor .)
    OR              reduce using rule 62 (term -> term DIVIDE factor .)
    SEMICOLON       reduce using rule 62 (term -> term DIVIDE factor .)
    ASSIGN          reduce using rule 62 (term -> term DIVIDE factor .)
    PLUS_ASSIGN     reduce using rule 62 (term -> term DIVIDE factor .)
    MINUS_ASSIGN    reduce using rule 62 (term -> term DIVIDE factor .)
    MUL_ASSIGN      reduce using rule 62 (term -> term DIVIDE factor .)
    DIV_ASSIGN      reduce using rule 62 (term -> term DIVIDE factor .)
    AND_ASSIGN      reduce using rule 62 (term -> term DIVIDE factor .)
    OR_ASSIGN       reduce using rule 62 (term -> term DIVIDE factor .)
    XOR_ASSIGN      reduce using rule 62 (term -> term DIVIDE factor .)
    MOD_ASSIGN      reduce using rule 62 (term -> term DIVIDE factor .)
    L_SHIFT_ASSIGN  reduce using rule 62 (term -> term DIVIDE factor .)
    R_SHIFT_ASSIGN  reduce using rule 62 (term -> term DIVIDE factor .)
    R_PAREN         reduce using rule 62 (term -> term DIVIDE factor .)


state 114

    (63) term -> term MOD factor .

    MULTIPLY        reduce using rule 63 (term -> term MOD factor .)
    DIVIDE          reduce using rule 63 (term -> term MOD factor .)
    MOD             reduce using rule 63 (term -> term MOD factor .)
    PLUS            reduce using rule 63 (term -> term MOD factor .)
    MINUS           reduce using rule 63 (term -> term MOD factor .)
    L_SHIFT         reduce using rule 63 (term -> term MOD factor .)
    R_SHIFT         reduce using rule 63 (term -> term MOD factor .)
    LE              reduce using rule 63 (term -> term MOD factor .)
    LT              reduce using rule 63 (term -> term MOD factor .)
    GE              reduce using rule 63 (term -> term MOD factor .)
    GT              reduce using rule 63 (term -> term MOD factor .)
    EQ              reduce using rule 63 (term -> term MOD factor .)
    NE              reduce using rule 63 (term -> term MOD factor .)
    BIT_AND         reduce using rule 63 (term -> term MOD factor .)
    BIT_XOR         reduce using rule 63 (term -> term MOD factor .)
    BIT_OR          reduce using rule 63 (term -> term MOD factor .)
    AND             reduce using rule 63 (term -> term MOD factor .)
    OR              reduce using rule 63 (term -> term MOD factor .)
    SEMICOLON       reduce using rule 63 (term -> term MOD factor .)
    ASSIGN          reduce using rule 63 (term -> term MOD factor .)
    PLUS_ASSIGN     reduce using rule 63 (term -> term MOD factor .)
    MINUS_ASSIGN    reduce using rule 63 (term -> term MOD factor .)
    MUL_ASSIGN      reduce using rule 63 (term -> term MOD factor .)
    DIV_ASSIGN      reduce using rule 63 (term -> term MOD factor .)
    AND_ASSIGN      reduce using rule 63 (term -> term MOD factor .)
    OR_ASSIGN       reduce using rule 63 (term -> term MOD factor .)
    XOR_ASSIGN      reduce using rule 63 (term -> term MOD factor .)
    MOD_ASSIGN      reduce using rule 63 (term -> term MOD factor .)
    L_SHIFT_ASSIGN  reduce using rule 63 (term -> term MOD factor .)
    R_SHIFT_ASSIGN  reduce using rule 63 (term -> term MOD factor .)
    R_PAREN         reduce using rule 63 (term -> term MOD factor .)


state 115

    (71) brace -> L_PAREN expr R_PAREN .

    PLUS_PLUS       reduce using rule 71 (brace -> L_PAREN expr R_PAREN .)
    MINUS_MINUS     reduce using rule 71 (brace -> L_PAREN expr R_PAREN .)
    MULTIPLY        reduce using rule 71 (brace -> L_PAREN expr R_PAREN .)
    DIVIDE          reduce using rule 71 (brace -> L_PAREN expr R_PAREN .)
    MOD             reduce using rule 71 (brace -> L_PAREN expr R_PAREN .)
    PLUS            reduce using rule 71 (brace -> L_PAREN expr R_PAREN .)
    MINUS           reduce using rule 71 (brace -> L_PAREN expr R_PAREN .)
    L_SHIFT         reduce using rule 71 (brace -> L_PAREN expr R_PAREN .)
    R_SHIFT         reduce using rule 71 (brace -> L_PAREN expr R_PAREN .)
    LE              reduce using rule 71 (brace -> L_PAREN expr R_PAREN .)
    LT              reduce using rule 71 (brace -> L_PAREN expr R_PAREN .)
    GE              reduce using rule 71 (brace -> L_PAREN expr R_PAREN .)
    GT              reduce using rule 71 (brace -> L_PAREN expr R_PAREN .)
    EQ              reduce using rule 71 (brace -> L_PAREN expr R_PAREN .)
    NE              reduce using rule 71 (brace -> L_PAREN expr R_PAREN .)
    BIT_AND         reduce using rule 71 (brace -> L_PAREN expr R_PAREN .)
    BIT_XOR         reduce using rule 71 (brace -> L_PAREN expr R_PAREN .)
    BIT_OR          reduce using rule 71 (brace -> L_PAREN expr R_PAREN .)
    AND             reduce using rule 71 (brace -> L_PAREN expr R_PAREN .)
    OR              reduce using rule 71 (brace -> L_PAREN expr R_PAREN .)
    SEMICOLON       reduce using rule 71 (brace -> L_PAREN expr R_PAREN .)
    ASSIGN          reduce using rule 71 (brace -> L_PAREN expr R_PAREN .)
    PLUS_ASSIGN     reduce using rule 71 (brace -> L_PAREN expr R_PAREN .)
    MINUS_ASSIGN    reduce using rule 71 (brace -> L_PAREN expr R_PAREN .)
    MUL_ASSIGN      reduce using rule 71 (brace -> L_PAREN expr R_PAREN .)
    DIV_ASSIGN      reduce using rule 71 (brace -> L_PAREN expr R_PAREN .)
    AND_ASSIGN      reduce using rule 71 (brace -> L_PAREN expr R_PAREN .)
    OR_ASSIGN       reduce using rule 71 (brace -> L_PAREN expr R_PAREN .)
    XOR_ASSIGN      reduce using rule 71 (brace -> L_PAREN expr R_PAREN .)
    MOD_ASSIGN      reduce using rule 71 (brace -> L_PAREN expr R_PAREN .)
    L_SHIFT_ASSIGN  reduce using rule 71 (brace -> L_PAREN expr R_PAREN .)
    R_SHIFT_ASSIGN  reduce using rule 71 (brace -> L_PAREN expr R_PAREN .)
    R_PAREN         reduce using rule 71 (brace -> L_PAREN expr R_PAREN .)


state 116

    (12) closed -> IF condition . closed ELSE closed
    (6) open -> IF condition . statement
    (7) open -> IF condition . closed ELSE open
    (10) closed -> . simple
    (11) closed -> . block
    (12) closed -> . IF condition closed ELSE closed
    (13) closed -> . WHILE condition closed
    (14) closed -> . FOR for_condition closed
    (4) statement -> . open
    (5) statement -> . closed
    (20) simple -> . expr SEMICOLON
    (21) simple -> . declaration
    (22) simple -> . SEMICOLON
    (19) block -> . L_FLOWBRACE multiple_statements R_FLOWBRACE
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) open -> . FOR for_condition open
    (23) expr -> . expr assignment exprOR
    (24) expr -> . exprOR
    (17) declaration -> . TYPE ID SEMICOLON
    (18) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (36) exprOR -> . exprOR OR exprAND
    (37) exprOR -> . exprAND
    (38) exprAND -> . exprAND AND exprBITOR
    (39) exprAND -> . exprBITOR
    (40) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (41) exprBITOR -> . exprBITXOR
    (42) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (43) exprBITXOR -> . exprBITAND
    (44) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (45) exprBITAND -> . exprEQ
    (46) exprEQ -> . exprEQ EQ exprRELOP
    (47) exprEQ -> . exprEQ NE exprRELOP
    (48) exprEQ -> . exprRELOP
    (49) exprRELOP -> . exprRELOP relop exprSHIFT
    (50) exprRELOP -> . exprSHIFT
    (55) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (56) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (57) exprSHIFT -> . exprOP
    (58) exprOP -> . exprOP PLUS term
    (59) exprOP -> . exprOP MINUS term
    (60) exprOP -> . term
    (61) term -> . term MULTIPLY factor
    (62) term -> . term DIVIDE factor
    (63) term -> . term MOD factor
    (64) term -> . factor
    (65) factor -> . NOT factor
    (66) factor -> . PLUS factor
    (67) factor -> . MINUS factor
    (68) factor -> . PLUS_PLUS factor
    (69) factor -> . MINUS_MINUS factor
    (70) factor -> . brace
    (71) brace -> . L_PAREN expr R_PAREN
    (72) brace -> . brace PLUS_PLUS
    (73) brace -> . brace MINUS_MINUS
    (74) brace -> . INT_NUM
    (75) brace -> . FLOAT_NUM
    (76) brace -> . ID

    IF              shift and go to state 85
    WHILE           shift and go to state 88
    FOR             shift and go to state 89
    SEMICOLON       shift and go to state 12
    L_FLOWBRACE     shift and go to state 14
    TYPE            shift and go to state 16
    NOT             shift and go to state 30
    PLUS            shift and go to state 26
    MINUS           shift and go to state 28
    PLUS_PLUS       shift and go to state 31
    MINUS_MINUS     shift and go to state 32
    L_PAREN         shift and go to state 34
    INT_NUM         shift and go to state 35
    FLOAT_NUM       shift and go to state 36
    ID              shift and go to state 17

    closed                         shift and go to state 123
    statement                      shift and go to state 86
    open                           shift and go to state 4
    simple                         shift and go to state 9
    block                          shift and go to state 10
    expr                           shift and go to state 11
    declaration                    shift and go to state 13
    exprOR                         shift and go to state 15
    exprAND                        shift and go to state 18
    exprBITOR                      shift and go to state 19
    exprBITXOR                     shift and go to state 20
    exprBITAND                     shift and go to state 21
    exprEQ                         shift and go to state 22
    exprRELOP                      shift and go to state 23
    exprSHIFT                      shift and go to state 24
    exprOP                         shift and go to state 25
    term                           shift and go to state 27
    factor                         shift and go to state 29
    brace                          shift and go to state 33

state 117

    (7) open -> IF condition closed ELSE . open
    (12) closed -> IF condition closed ELSE . closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) open -> . FOR for_condition open
    (10) closed -> . simple
    (11) closed -> . block
    (12) closed -> . IF condition closed ELSE closed
    (13) closed -> . WHILE condition closed
    (14) closed -> . FOR for_condition closed
    (20) simple -> . expr SEMICOLON
    (21) simple -> . declaration
    (22) simple -> . SEMICOLON
    (19) block -> . L_FLOWBRACE multiple_statements R_FLOWBRACE
    (23) expr -> . expr assignment exprOR
    (24) expr -> . exprOR
    (17) declaration -> . TYPE ID SEMICOLON
    (18) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (36) exprOR -> . exprOR OR exprAND
    (37) exprOR -> . exprAND
    (38) exprAND -> . exprAND AND exprBITOR
    (39) exprAND -> . exprBITOR
    (40) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (41) exprBITOR -> . exprBITXOR
    (42) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (43) exprBITXOR -> . exprBITAND
    (44) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (45) exprBITAND -> . exprEQ
    (46) exprEQ -> . exprEQ EQ exprRELOP
    (47) exprEQ -> . exprEQ NE exprRELOP
    (48) exprEQ -> . exprRELOP
    (49) exprRELOP -> . exprRELOP relop exprSHIFT
    (50) exprRELOP -> . exprSHIFT
    (55) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (56) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (57) exprSHIFT -> . exprOP
    (58) exprOP -> . exprOP PLUS term
    (59) exprOP -> . exprOP MINUS term
    (60) exprOP -> . term
    (61) term -> . term MULTIPLY factor
    (62) term -> . term DIVIDE factor
    (63) term -> . term MOD factor
    (64) term -> . factor
    (65) factor -> . NOT factor
    (66) factor -> . PLUS factor
    (67) factor -> . MINUS factor
    (68) factor -> . PLUS_PLUS factor
    (69) factor -> . MINUS_MINUS factor
    (70) factor -> . brace
    (71) brace -> . L_PAREN expr R_PAREN
    (72) brace -> . brace PLUS_PLUS
    (73) brace -> . brace MINUS_MINUS
    (74) brace -> . INT_NUM
    (75) brace -> . FLOAT_NUM
    (76) brace -> . ID

    IF              shift and go to state 6
    WHILE           shift and go to state 7
    FOR             shift and go to state 8
    SEMICOLON       shift and go to state 12
    L_FLOWBRACE     shift and go to state 14
    TYPE            shift and go to state 16
    NOT             shift and go to state 30
    PLUS            shift and go to state 26
    MINUS           shift and go to state 28
    PLUS_PLUS       shift and go to state 31
    MINUS_MINUS     shift and go to state 32
    L_PAREN         shift and go to state 34
    INT_NUM         shift and go to state 35
    FLOAT_NUM       shift and go to state 36
    ID              shift and go to state 17

    closed                         shift and go to state 124
    open                           shift and go to state 125
    simple                         shift and go to state 9
    block                          shift and go to state 10
    expr                           shift and go to state 11
    declaration                    shift and go to state 13
    exprOR                         shift and go to state 15
    exprAND                        shift and go to state 18
    exprBITOR                      shift and go to state 19
    exprBITXOR                     shift and go to state 20
    exprBITAND                     shift and go to state 21
    exprEQ                         shift and go to state 22
    exprRELOP                      shift and go to state 23
    exprSHIFT                      shift and go to state 24
    exprOP                         shift and go to state 25
    term                           shift and go to state 27
    factor                         shift and go to state 29
    brace                          shift and go to state 33

state 118

    (13) closed -> WHILE condition . closed
    (8) open -> WHILE condition . open
    (10) closed -> . simple
    (11) closed -> . block
    (12) closed -> . IF condition closed ELSE closed
    (13) closed -> . WHILE condition closed
    (14) closed -> . FOR for_condition closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) open -> . FOR for_condition open
    (20) simple -> . expr SEMICOLON
    (21) simple -> . declaration
    (22) simple -> . SEMICOLON
    (19) block -> . L_FLOWBRACE multiple_statements R_FLOWBRACE
    (23) expr -> . expr assignment exprOR
    (24) expr -> . exprOR
    (17) declaration -> . TYPE ID SEMICOLON
    (18) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (36) exprOR -> . exprOR OR exprAND
    (37) exprOR -> . exprAND
    (38) exprAND -> . exprAND AND exprBITOR
    (39) exprAND -> . exprBITOR
    (40) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (41) exprBITOR -> . exprBITXOR
    (42) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (43) exprBITXOR -> . exprBITAND
    (44) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (45) exprBITAND -> . exprEQ
    (46) exprEQ -> . exprEQ EQ exprRELOP
    (47) exprEQ -> . exprEQ NE exprRELOP
    (48) exprEQ -> . exprRELOP
    (49) exprRELOP -> . exprRELOP relop exprSHIFT
    (50) exprRELOP -> . exprSHIFT
    (55) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (56) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (57) exprSHIFT -> . exprOP
    (58) exprOP -> . exprOP PLUS term
    (59) exprOP -> . exprOP MINUS term
    (60) exprOP -> . term
    (61) term -> . term MULTIPLY factor
    (62) term -> . term DIVIDE factor
    (63) term -> . term MOD factor
    (64) term -> . factor
    (65) factor -> . NOT factor
    (66) factor -> . PLUS factor
    (67) factor -> . MINUS factor
    (68) factor -> . PLUS_PLUS factor
    (69) factor -> . MINUS_MINUS factor
    (70) factor -> . brace
    (71) brace -> . L_PAREN expr R_PAREN
    (72) brace -> . brace PLUS_PLUS
    (73) brace -> . brace MINUS_MINUS
    (74) brace -> . INT_NUM
    (75) brace -> . FLOAT_NUM
    (76) brace -> . ID

    IF              shift and go to state 85
    WHILE           shift and go to state 88
    FOR             shift and go to state 89
    SEMICOLON       shift and go to state 12
    L_FLOWBRACE     shift and go to state 14
    TYPE            shift and go to state 16
    NOT             shift and go to state 30
    PLUS            shift and go to state 26
    MINUS           shift and go to state 28
    PLUS_PLUS       shift and go to state 31
    MINUS_MINUS     shift and go to state 32
    L_PAREN         shift and go to state 34
    INT_NUM         shift and go to state 35
    FLOAT_NUM       shift and go to state 36
    ID              shift and go to state 17

    closed                         shift and go to state 92
    open                           shift and go to state 91
    simple                         shift and go to state 9
    block                          shift and go to state 10
    expr                           shift and go to state 11
    declaration                    shift and go to state 13
    exprOR                         shift and go to state 15
    exprAND                        shift and go to state 18
    exprBITOR                      shift and go to state 19
    exprBITXOR                     shift and go to state 20
    exprBITAND                     shift and go to state 21
    exprEQ                         shift and go to state 22
    exprRELOP                      shift and go to state 23
    exprSHIFT                      shift and go to state 24
    exprOP                         shift and go to state 25
    term                           shift and go to state 27
    factor                         shift and go to state 29
    brace                          shift and go to state 33

state 119

    (14) closed -> FOR for_condition . closed
    (9) open -> FOR for_condition . open
    (10) closed -> . simple
    (11) closed -> . block
    (12) closed -> . IF condition closed ELSE closed
    (13) closed -> . WHILE condition closed
    (14) closed -> . FOR for_condition closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) open -> . FOR for_condition open
    (20) simple -> . expr SEMICOLON
    (21) simple -> . declaration
    (22) simple -> . SEMICOLON
    (19) block -> . L_FLOWBRACE multiple_statements R_FLOWBRACE
    (23) expr -> . expr assignment exprOR
    (24) expr -> . exprOR
    (17) declaration -> . TYPE ID SEMICOLON
    (18) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (36) exprOR -> . exprOR OR exprAND
    (37) exprOR -> . exprAND
    (38) exprAND -> . exprAND AND exprBITOR
    (39) exprAND -> . exprBITOR
    (40) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (41) exprBITOR -> . exprBITXOR
    (42) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (43) exprBITXOR -> . exprBITAND
    (44) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (45) exprBITAND -> . exprEQ
    (46) exprEQ -> . exprEQ EQ exprRELOP
    (47) exprEQ -> . exprEQ NE exprRELOP
    (48) exprEQ -> . exprRELOP
    (49) exprRELOP -> . exprRELOP relop exprSHIFT
    (50) exprRELOP -> . exprSHIFT
    (55) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (56) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (57) exprSHIFT -> . exprOP
    (58) exprOP -> . exprOP PLUS term
    (59) exprOP -> . exprOP MINUS term
    (60) exprOP -> . term
    (61) term -> . term MULTIPLY factor
    (62) term -> . term DIVIDE factor
    (63) term -> . term MOD factor
    (64) term -> . factor
    (65) factor -> . NOT factor
    (66) factor -> . PLUS factor
    (67) factor -> . MINUS factor
    (68) factor -> . PLUS_PLUS factor
    (69) factor -> . MINUS_MINUS factor
    (70) factor -> . brace
    (71) brace -> . L_PAREN expr R_PAREN
    (72) brace -> . brace PLUS_PLUS
    (73) brace -> . brace MINUS_MINUS
    (74) brace -> . INT_NUM
    (75) brace -> . FLOAT_NUM
    (76) brace -> . ID

    IF              shift and go to state 85
    WHILE           shift and go to state 88
    FOR             shift and go to state 89
    SEMICOLON       shift and go to state 12
    L_FLOWBRACE     shift and go to state 14
    TYPE            shift and go to state 16
    NOT             shift and go to state 30
    PLUS            shift and go to state 26
    MINUS           shift and go to state 28
    PLUS_PLUS       shift and go to state 31
    MINUS_MINUS     shift and go to state 32
    L_PAREN         shift and go to state 34
    INT_NUM         shift and go to state 35
    FLOAT_NUM       shift and go to state 36
    ID              shift and go to state 17

    closed                         shift and go to state 94
    open                           shift and go to state 93
    simple                         shift and go to state 9
    block                          shift and go to state 10
    expr                           shift and go to state 11
    declaration                    shift and go to state 13
    exprOR                         shift and go to state 15
    exprAND                        shift and go to state 18
    exprBITOR                      shift and go to state 19
    exprBITXOR                     shift and go to state 20
    exprBITAND                     shift and go to state 21
    exprEQ                         shift and go to state 22
    exprRELOP                      shift and go to state 23
    exprSHIFT                      shift and go to state 24
    exprOP                         shift and go to state 25
    term                           shift and go to state 27
    factor                         shift and go to state 29
    brace                          shift and go to state 33

state 120

    (15) condition -> L_PAREN expr R_PAREN .

    IF              reduce using rule 15 (condition -> L_PAREN expr R_PAREN .)
    WHILE           reduce using rule 15 (condition -> L_PAREN expr R_PAREN .)
    FOR             reduce using rule 15 (condition -> L_PAREN expr R_PAREN .)
    SEMICOLON       reduce using rule 15 (condition -> L_PAREN expr R_PAREN .)
    L_FLOWBRACE     reduce using rule 15 (condition -> L_PAREN expr R_PAREN .)
    TYPE            reduce using rule 15 (condition -> L_PAREN expr R_PAREN .)
    NOT             reduce using rule 15 (condition -> L_PAREN expr R_PAREN .)
    PLUS            reduce using rule 15 (condition -> L_PAREN expr R_PAREN .)
    MINUS           reduce using rule 15 (condition -> L_PAREN expr R_PAREN .)
    PLUS_PLUS       reduce using rule 15 (condition -> L_PAREN expr R_PAREN .)
    MINUS_MINUS     reduce using rule 15 (condition -> L_PAREN expr R_PAREN .)
    L_PAREN         reduce using rule 15 (condition -> L_PAREN expr R_PAREN .)
    INT_NUM         reduce using rule 15 (condition -> L_PAREN expr R_PAREN .)
    FLOAT_NUM       reduce using rule 15 (condition -> L_PAREN expr R_PAREN .)
    ID              reduce using rule 15 (condition -> L_PAREN expr R_PAREN .)


state 121

    (16) for_condition -> L_PAREN declaration expr . SEMICOLON expr R_PAREN
    (23) expr -> expr . assignment exprOR
    (25) assignment -> . ASSIGN
    (26) assignment -> . PLUS_ASSIGN
    (27) assignment -> . MINUS_ASSIGN
    (28) assignment -> . MUL_ASSIGN
    (29) assignment -> . DIV_ASSIGN
    (30) assignment -> . AND_ASSIGN
    (31) assignment -> . OR_ASSIGN
    (32) assignment -> . XOR_ASSIGN
    (33) assignment -> . MOD_ASSIGN
    (34) assignment -> . L_SHIFT_ASSIGN
    (35) assignment -> . R_SHIFT_ASSIGN

    SEMICOLON       shift and go to state 126
    ASSIGN          shift and go to state 45
    PLUS_ASSIGN     shift and go to state 46
    MINUS_ASSIGN    shift and go to state 47
    MUL_ASSIGN      shift and go to state 48
    DIV_ASSIGN      shift and go to state 49
    AND_ASSIGN      shift and go to state 50
    OR_ASSIGN       shift and go to state 51
    XOR_ASSIGN      shift and go to state 52
    MOD_ASSIGN      shift and go to state 53
    L_SHIFT_ASSIGN  shift and go to state 54
    R_SHIFT_ASSIGN  shift and go to state 55

    assignment                     shift and go to state 44

state 122

    (18) declaration -> TYPE ID ASSIGN expr . SEMICOLON
    (23) expr -> expr . assignment exprOR
    (25) assignment -> . ASSIGN
    (26) assignment -> . PLUS_ASSIGN
    (27) assignment -> . MINUS_ASSIGN
    (28) assignment -> . MUL_ASSIGN
    (29) assignment -> . DIV_ASSIGN
    (30) assignment -> . AND_ASSIGN
    (31) assignment -> . OR_ASSIGN
    (32) assignment -> . XOR_ASSIGN
    (33) assignment -> . MOD_ASSIGN
    (34) assignment -> . L_SHIFT_ASSIGN
    (35) assignment -> . R_SHIFT_ASSIGN

    SEMICOLON       shift and go to state 127
    ASSIGN          shift and go to state 45
    PLUS_ASSIGN     shift and go to state 46
    MINUS_ASSIGN    shift and go to state 47
    MUL_ASSIGN      shift and go to state 48
    DIV_ASSIGN      shift and go to state 49
    AND_ASSIGN      shift and go to state 50
    OR_ASSIGN       shift and go to state 51
    XOR_ASSIGN      shift and go to state 52
    MOD_ASSIGN      shift and go to state 53
    L_SHIFT_ASSIGN  shift and go to state 54
    R_SHIFT_ASSIGN  shift and go to state 55

    assignment                     shift and go to state 44

state 123

    (12) closed -> IF condition closed . ELSE closed
    (7) open -> IF condition closed . ELSE open
    (5) statement -> closed .

    ELSE            shift and go to state 128
    IF              reduce using rule 5 (statement -> closed .)
    WHILE           reduce using rule 5 (statement -> closed .)
    FOR             reduce using rule 5 (statement -> closed .)
    SEMICOLON       reduce using rule 5 (statement -> closed .)
    L_FLOWBRACE     reduce using rule 5 (statement -> closed .)
    TYPE            reduce using rule 5 (statement -> closed .)
    NOT             reduce using rule 5 (statement -> closed .)
    PLUS            reduce using rule 5 (statement -> closed .)
    MINUS           reduce using rule 5 (statement -> closed .)
    PLUS_PLUS       reduce using rule 5 (statement -> closed .)
    MINUS_MINUS     reduce using rule 5 (statement -> closed .)
    L_PAREN         reduce using rule 5 (statement -> closed .)
    INT_NUM         reduce using rule 5 (statement -> closed .)
    FLOAT_NUM       reduce using rule 5 (statement -> closed .)
    ID              reduce using rule 5 (statement -> closed .)
    $end            reduce using rule 5 (statement -> closed .)
    R_FLOWBRACE     reduce using rule 5 (statement -> closed .)


state 124

    (12) closed -> IF condition closed ELSE closed .

    IF              reduce using rule 12 (closed -> IF condition closed ELSE closed .)
    WHILE           reduce using rule 12 (closed -> IF condition closed ELSE closed .)
    FOR             reduce using rule 12 (closed -> IF condition closed ELSE closed .)
    SEMICOLON       reduce using rule 12 (closed -> IF condition closed ELSE closed .)
    L_FLOWBRACE     reduce using rule 12 (closed -> IF condition closed ELSE closed .)
    TYPE            reduce using rule 12 (closed -> IF condition closed ELSE closed .)
    NOT             reduce using rule 12 (closed -> IF condition closed ELSE closed .)
    PLUS            reduce using rule 12 (closed -> IF condition closed ELSE closed .)
    MINUS           reduce using rule 12 (closed -> IF condition closed ELSE closed .)
    PLUS_PLUS       reduce using rule 12 (closed -> IF condition closed ELSE closed .)
    MINUS_MINUS     reduce using rule 12 (closed -> IF condition closed ELSE closed .)
    L_PAREN         reduce using rule 12 (closed -> IF condition closed ELSE closed .)
    INT_NUM         reduce using rule 12 (closed -> IF condition closed ELSE closed .)
    FLOAT_NUM       reduce using rule 12 (closed -> IF condition closed ELSE closed .)
    ID              reduce using rule 12 (closed -> IF condition closed ELSE closed .)
    $end            reduce using rule 12 (closed -> IF condition closed ELSE closed .)
    R_FLOWBRACE     reduce using rule 12 (closed -> IF condition closed ELSE closed .)
    ELSE            reduce using rule 12 (closed -> IF condition closed ELSE closed .)


state 125

    (7) open -> IF condition closed ELSE open .

    IF              reduce using rule 7 (open -> IF condition closed ELSE open .)
    WHILE           reduce using rule 7 (open -> IF condition closed ELSE open .)
    FOR             reduce using rule 7 (open -> IF condition closed ELSE open .)
    SEMICOLON       reduce using rule 7 (open -> IF condition closed ELSE open .)
    L_FLOWBRACE     reduce using rule 7 (open -> IF condition closed ELSE open .)
    TYPE            reduce using rule 7 (open -> IF condition closed ELSE open .)
    NOT             reduce using rule 7 (open -> IF condition closed ELSE open .)
    PLUS            reduce using rule 7 (open -> IF condition closed ELSE open .)
    MINUS           reduce using rule 7 (open -> IF condition closed ELSE open .)
    PLUS_PLUS       reduce using rule 7 (open -> IF condition closed ELSE open .)
    MINUS_MINUS     reduce using rule 7 (open -> IF condition closed ELSE open .)
    L_PAREN         reduce using rule 7 (open -> IF condition closed ELSE open .)
    INT_NUM         reduce using rule 7 (open -> IF condition closed ELSE open .)
    FLOAT_NUM       reduce using rule 7 (open -> IF condition closed ELSE open .)
    ID              reduce using rule 7 (open -> IF condition closed ELSE open .)
    $end            reduce using rule 7 (open -> IF condition closed ELSE open .)
    R_FLOWBRACE     reduce using rule 7 (open -> IF condition closed ELSE open .)


state 126

    (16) for_condition -> L_PAREN declaration expr SEMICOLON . expr R_PAREN
    (23) expr -> . expr assignment exprOR
    (24) expr -> . exprOR
    (36) exprOR -> . exprOR OR exprAND
    (37) exprOR -> . exprAND
    (38) exprAND -> . exprAND AND exprBITOR
    (39) exprAND -> . exprBITOR
    (40) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (41) exprBITOR -> . exprBITXOR
    (42) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (43) exprBITXOR -> . exprBITAND
    (44) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (45) exprBITAND -> . exprEQ
    (46) exprEQ -> . exprEQ EQ exprRELOP
    (47) exprEQ -> . exprEQ NE exprRELOP
    (48) exprEQ -> . exprRELOP
    (49) exprRELOP -> . exprRELOP relop exprSHIFT
    (50) exprRELOP -> . exprSHIFT
    (55) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (56) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (57) exprSHIFT -> . exprOP
    (58) exprOP -> . exprOP PLUS term
    (59) exprOP -> . exprOP MINUS term
    (60) exprOP -> . term
    (61) term -> . term MULTIPLY factor
    (62) term -> . term DIVIDE factor
    (63) term -> . term MOD factor
    (64) term -> . factor
    (65) factor -> . NOT factor
    (66) factor -> . PLUS factor
    (67) factor -> . MINUS factor
    (68) factor -> . PLUS_PLUS factor
    (69) factor -> . MINUS_MINUS factor
    (70) factor -> . brace
    (71) brace -> . L_PAREN expr R_PAREN
    (72) brace -> . brace PLUS_PLUS
    (73) brace -> . brace MINUS_MINUS
    (74) brace -> . INT_NUM
    (75) brace -> . FLOAT_NUM
    (76) brace -> . ID

    NOT             shift and go to state 30
    PLUS            shift and go to state 26
    MINUS           shift and go to state 28
    PLUS_PLUS       shift and go to state 31
    MINUS_MINUS     shift and go to state 32
    L_PAREN         shift and go to state 34
    INT_NUM         shift and go to state 35
    FLOAT_NUM       shift and go to state 36
    ID              shift and go to state 17

    expr                           shift and go to state 129
    exprOR                         shift and go to state 15
    exprAND                        shift and go to state 18
    exprBITOR                      shift and go to state 19
    exprBITXOR                     shift and go to state 20
    exprBITAND                     shift and go to state 21
    exprEQ                         shift and go to state 22
    exprRELOP                      shift and go to state 23
    exprSHIFT                      shift and go to state 24
    exprOP                         shift and go to state 25
    term                           shift and go to state 27
    factor                         shift and go to state 29
    brace                          shift and go to state 33

state 127

    (18) declaration -> TYPE ID ASSIGN expr SEMICOLON .

    IF              reduce using rule 18 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    WHILE           reduce using rule 18 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    FOR             reduce using rule 18 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    SEMICOLON       reduce using rule 18 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    L_FLOWBRACE     reduce using rule 18 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    TYPE            reduce using rule 18 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    NOT             reduce using rule 18 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    PLUS            reduce using rule 18 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    MINUS           reduce using rule 18 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    PLUS_PLUS       reduce using rule 18 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    MINUS_MINUS     reduce using rule 18 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    L_PAREN         reduce using rule 18 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    INT_NUM         reduce using rule 18 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    FLOAT_NUM       reduce using rule 18 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    ID              reduce using rule 18 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    $end            reduce using rule 18 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    R_FLOWBRACE     reduce using rule 18 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)
    ELSE            reduce using rule 18 (declaration -> TYPE ID ASSIGN expr SEMICOLON .)


state 128

    (12) closed -> IF condition closed ELSE . closed
    (7) open -> IF condition closed ELSE . open
    (10) closed -> . simple
    (11) closed -> . block
    (12) closed -> . IF condition closed ELSE closed
    (13) closed -> . WHILE condition closed
    (14) closed -> . FOR for_condition closed
    (6) open -> . IF condition statement
    (7) open -> . IF condition closed ELSE open
    (8) open -> . WHILE condition open
    (9) open -> . FOR for_condition open
    (20) simple -> . expr SEMICOLON
    (21) simple -> . declaration
    (22) simple -> . SEMICOLON
    (19) block -> . L_FLOWBRACE multiple_statements R_FLOWBRACE
    (23) expr -> . expr assignment exprOR
    (24) expr -> . exprOR
    (17) declaration -> . TYPE ID SEMICOLON
    (18) declaration -> . TYPE ID ASSIGN expr SEMICOLON
    (36) exprOR -> . exprOR OR exprAND
    (37) exprOR -> . exprAND
    (38) exprAND -> . exprAND AND exprBITOR
    (39) exprAND -> . exprBITOR
    (40) exprBITOR -> . exprBITOR BIT_OR exprBITXOR
    (41) exprBITOR -> . exprBITXOR
    (42) exprBITXOR -> . exprBITXOR BIT_XOR exprBITAND
    (43) exprBITXOR -> . exprBITAND
    (44) exprBITAND -> . exprBITAND BIT_AND exprEQ
    (45) exprBITAND -> . exprEQ
    (46) exprEQ -> . exprEQ EQ exprRELOP
    (47) exprEQ -> . exprEQ NE exprRELOP
    (48) exprEQ -> . exprRELOP
    (49) exprRELOP -> . exprRELOP relop exprSHIFT
    (50) exprRELOP -> . exprSHIFT
    (55) exprSHIFT -> . exprSHIFT L_SHIFT exprOP
    (56) exprSHIFT -> . exprSHIFT R_SHIFT exprOP
    (57) exprSHIFT -> . exprOP
    (58) exprOP -> . exprOP PLUS term
    (59) exprOP -> . exprOP MINUS term
    (60) exprOP -> . term
    (61) term -> . term MULTIPLY factor
    (62) term -> . term DIVIDE factor
    (63) term -> . term MOD factor
    (64) term -> . factor
    (65) factor -> . NOT factor
    (66) factor -> . PLUS factor
    (67) factor -> . MINUS factor
    (68) factor -> . PLUS_PLUS factor
    (69) factor -> . MINUS_MINUS factor
    (70) factor -> . brace
    (71) brace -> . L_PAREN expr R_PAREN
    (72) brace -> . brace PLUS_PLUS
    (73) brace -> . brace MINUS_MINUS
    (74) brace -> . INT_NUM
    (75) brace -> . FLOAT_NUM
    (76) brace -> . ID

    IF              shift and go to state 85
    WHILE           shift and go to state 88
    FOR             shift and go to state 89
    SEMICOLON       shift and go to state 12
    L_FLOWBRACE     shift and go to state 14
    TYPE            shift and go to state 16
    NOT             shift and go to state 30
    PLUS            shift and go to state 26
    MINUS           shift and go to state 28
    PLUS_PLUS       shift and go to state 31
    MINUS_MINUS     shift and go to state 32
    L_PAREN         shift and go to state 34
    INT_NUM         shift and go to state 35
    FLOAT_NUM       shift and go to state 36
    ID              shift and go to state 17

    closed                         shift and go to state 124
    open                           shift and go to state 125
    simple                         shift and go to state 9
    block                          shift and go to state 10
    expr                           shift and go to state 11
    declaration                    shift and go to state 13
    exprOR                         shift and go to state 15
    exprAND                        shift and go to state 18
    exprBITOR                      shift and go to state 19
    exprBITXOR                     shift and go to state 20
    exprBITAND                     shift and go to state 21
    exprEQ                         shift and go to state 22
    exprRELOP                      shift and go to state 23
    exprSHIFT                      shift and go to state 24
    exprOP                         shift and go to state 25
    term                           shift and go to state 27
    factor                         shift and go to state 29
    brace                          shift and go to state 33

state 129

    (16) for_condition -> L_PAREN declaration expr SEMICOLON expr . R_PAREN
    (23) expr -> expr . assignment exprOR
    (25) assignment -> . ASSIGN
    (26) assignment -> . PLUS_ASSIGN
    (27) assignment -> . MINUS_ASSIGN
    (28) assignment -> . MUL_ASSIGN
    (29) assignment -> . DIV_ASSIGN
    (30) assignment -> . AND_ASSIGN
    (31) assignment -> . OR_ASSIGN
    (32) assignment -> . XOR_ASSIGN
    (33) assignment -> . MOD_ASSIGN
    (34) assignment -> . L_SHIFT_ASSIGN
    (35) assignment -> . R_SHIFT_ASSIGN

    R_PAREN         shift and go to state 130
    ASSIGN          shift and go to state 45
    PLUS_ASSIGN     shift and go to state 46
    MINUS_ASSIGN    shift and go to state 47
    MUL_ASSIGN      shift and go to state 48
    DIV_ASSIGN      shift and go to state 49
    AND_ASSIGN      shift and go to state 50
    OR_ASSIGN       shift and go to state 51
    XOR_ASSIGN      shift and go to state 52
    MOD_ASSIGN      shift and go to state 53
    L_SHIFT_ASSIGN  shift and go to state 54
    R_SHIFT_ASSIGN  shift and go to state 55

    assignment                     shift and go to state 44

state 130

    (16) for_condition -> L_PAREN declaration expr SEMICOLON expr R_PAREN .

    IF              reduce using rule 16 (for_condition -> L_PAREN declaration expr SEMICOLON expr R_PAREN .)
    WHILE           reduce using rule 16 (for_condition -> L_PAREN declaration expr SEMICOLON expr R_PAREN .)
    FOR             reduce using rule 16 (for_condition -> L_PAREN declaration expr SEMICOLON expr R_PAREN .)
    SEMICOLON       reduce using rule 16 (for_condition -> L_PAREN declaration expr SEMICOLON expr R_PAREN .)
    L_FLOWBRACE     reduce using rule 16 (for_condition -> L_PAREN declaration expr SEMICOLON expr R_PAREN .)
    TYPE            reduce using rule 16 (for_condition -> L_PAREN declaration expr SEMICOLON expr R_PAREN .)
    NOT             reduce using rule 16 (for_condition -> L_PAREN declaration expr SEMICOLON expr R_PAREN .)
    PLUS            reduce using rule 16 (for_condition -> L_PAREN declaration expr SEMICOLON expr R_PAREN .)
    MINUS           reduce using rule 16 (for_condition -> L_PAREN declaration expr SEMICOLON expr R_PAREN .)
    PLUS_PLUS       reduce using rule 16 (for_condition -> L_PAREN declaration expr SEMICOLON expr R_PAREN .)
    MINUS_MINUS     reduce using rule 16 (for_condition -> L_PAREN declaration expr SEMICOLON expr R_PAREN .)
    L_PAREN         reduce using rule 16 (for_condition -> L_PAREN declaration expr SEMICOLON expr R_PAREN .)
    INT_NUM         reduce using rule 16 (for_condition -> L_PAREN declaration expr SEMICOLON expr R_PAREN .)
    FLOAT_NUM       reduce using rule 16 (for_condition -> L_PAREN declaration expr SEMICOLON expr R_PAREN .)
    ID              reduce using rule 16 (for_condition -> L_PAREN declaration expr SEMICOLON expr R_PAREN .)

